/***
*  * WHAT
*  *    Code genararor auxiliary functions
*  * FILE
*  *    $Source: /home/vdmtools/cvsroot/toolbox/code/lib/cg.cc,v $
*  * VERSION
*  *    $Revision: 1.10 $
*  * DATE
*  *    $Date: 2005/01/21 03:16:06 $
*  * STATUS
*  *    $State: Exp $
*  * PROJECT
*  *    Afrodite - ESPRIT III programme, project no. 6500.
*  * AUTHOR
*  *    Henrik Voss + $Author: vdmtools $
*  * COPYRIGHT
*  *    (C) Kyushu University
***/

#include <fstream>
#include <stdlib.h>
#include "metaiv.h"
#include "cg.h"
#include "random.h"

Stack CGUTIL::file_stack, CGUTIL::pos_stack;
long CGUTIL::rseed = -1;
Random CGUTIL::r;

void CGUTIL::RunTime(wstring mess)
{
  CGUTIL::PrintPosition();

  if (mess.find(L"Run-Time Error:") == std::string::npos)
    wcout << L"Run-Time Error:";

  wcout << mess << endl;

  VDMErrorHandle(VDM_ERR_LIB, 0); 
}

void CGUTIL::NotSupported(wstring mess)
{
  PrintPosition();

  if (mess.find(L"The construct is not supported: ") == std::string::npos)
    wcout << L"The construct is not supported: ";

  wcout << mess << endl;

  VDMErrorHandle(VDM_ERR_LIB, 0); 
}

void CGUTIL::PushPosInfo(int line, int col)
{
  CGUTIL::pos_stack.Push(mk_(Int(line), Int(col)));
}

void CGUTIL::PopPosInfo()
{
  CGUTIL::pos_stack.Pop();
}

void CGUTIL::PushFile(wstring file)
{
  CGUTIL::file_stack.Push(SEQ<Char>(file));
}

void CGUTIL::PopFile()
{
  CGUTIL::file_stack.Pop();
}

void CGUTIL::SetRandomSeed(long s)
{
  CGUTIL::rseed = s;
  CGUTIL::r.set_seed(rseed);
}

Sequence CGUTIL::GetRandomSequence(const Int & n)
{
  Sequence l;
  for (int i = 1; i <= n.GetValue(); i++)
    l.ImpAppend(Int(i));

  if ((rseed < 0) || (l.Length() <= 1))
    return l;

  Sequence res;
  while(l.Length() > 1)
  {
    size_t idx = r.get_random(l.Length()) + 1;
    res.ImpAppend(l[idx]);
    l.RemElem(idx);
  }
  res.ImpAppend(l[1]);
  return res;
}

/**************************************************************************
*  When run-time errors are detected in the VDM C++ library or in
*  code generated by the VDM code generator, the last recorded position 
*  in the code generated VDM specification is printed.
**************************************************************************/

void CGUTIL::PrintPosition()
{
  if (!CGUTIL::pos_stack.IsEmpty())
  {
    wcout << L"Last recorded position:" << endl;
    if (!CGUTIL::file_stack.IsEmpty())
      wcout << L"In: " << CGUTIL::file_stack.Head().ascii() << L". ";
    Tuple t (CGUTIL::pos_stack.Head());
    wcout << L"At line: " << t.GetInt(1).ascii() << L" column: " << t.GetInt(2).ascii() << endl;
  }
}

void PrintPosition()
{
  CGUTIL::PrintPosition();
}

void RunTime(wstring str)
{
  CGUTIL::RunTime(str);
}

void NotSupported(wstring str)
{
  CGUTIL::NotSupported(str);
}

void PushPosInfo(int line, int col)
{
  CGUTIL::PushPosInfo(line, col);
}

void PopPosInfo()
{
  CGUTIL::PopPosInfo();
}

void PushFile(wstring fnm)
{
  CGUTIL::PushFile(fnm);
}

void PopFile()
{
  CGUTIL::PopFile();
}

void AddRecordTag(const wstring & nm, const int & tag)
{
  CGUTIL::AddRecordTag(nm, tag);
}

bool ParseVDMValue(const wstring & filename, Generic& res)
{
  return CGUTIL::ParseVDMValue(filename, res);
}

bool ParseVDMValueString(const wstring & str, Generic& res)
{
  return CGUTIL::ParseVDMValueString(str, res);
}


