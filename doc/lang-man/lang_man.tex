%%
%% Toolbox Language Manual
%% $Id: lang_man.tex,v 1.81 2005/10/24 01:48:38 vdmtools Exp $
%% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF compatibility code. 

\makeatletter
\newif\ifpdflatex@
\ifx\pdftexversion\@undefined
\pdflatex@false
%\message{Not using pdf}
\else
\pdflatex@true
%\message{Using pdf}
\fi

\newcommand{\latexpdf}[2]{
  \ifpdflatex@ #1
  \else #2
  \fi
}

\newcommand{\latexorpdf}[2]{
  \ifpdflatex@ #2
  \else #1
  \fi
}

#ifdef A4Format
\newcommand{\pformat}{a4paper}
#endif A4Format
#ifdef LetterFormat
\newcommand{\pformat}{letterpaper}
#endif LetterFormat

\makeatother

\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\latexorpdf{
\documentclass[\pformat,12pt]{article}
}{
% pdftex option is used by graphic[sx],hyperref,toolbox.sty
\documentclass[\pformat,pdftex,12pt]{article}
}

\usepackage{toolbox}
\usepackage{vdmsl-2e}
\usepackage{makeidx}
\usepackage{alltt}
%\usepackage{epsfig}
\usepackage{here}
\usepackage{array}
\usepackage{longtable}
\usepackage{ifthen}
% plainpages=false: avoid warning
%   destination with the same identifier already exists
%   but it do not seem to work a the first pages
% Ueki change start
\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}
% Ueki change end

% Ueki delete start
%\latexorpdf{
%\usepackage[plainpages=true,colorlinks,linkcolor=black,citecolor=black,pagecolor=black, urlcolor=black]{hyperref}
%}{
%\usepackage[plainpages=true,colorlinks]{hyperref}
%}
% Ueki delete end

#ifdef VDMPP
\usepackage{vpp}
#endif VDMPP

\newcommand{\vdmslpp}[2]{%
#ifdef VDMSL
#1
#endif VDMSL
#ifdef VDMPP
#2
#endif VDMPP
}

\newcommand{\vdmsl}{VDM-SL}
\newcommand{\vdmpp}{VDM++}
\newcommand{\Index}[1]{#1\index{#1}}
#ifdef VDMPP
%\usepackage{latexsym}
%\usepackage{epsf}
\newcommand{\vppsmall}{\small\tt}
\newcommand{\tr}[1]{{\bf\underline{#1}}}



\newcommand{\insertfig}[4]{ % Filename, epsheight, epswidth, caption,  label
\begin{figure}[H]
\begin{center}
\includegraphics[width=#2]{#1} 
\end{center}
\caption{{\em #3}} #4
\end{figure}
}

\newcommand{\insertfignw}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\includegraphics{#1} 
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

\newcommand{\insertfignwrot}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\scalebox{1}%
{\rotatebox{270}{%
\includegraphics{#1}}}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

\makeindex
#endif VDMPP

% The use of VDMSL/VDMPP ifdef's have basicly been exchanged with the
% use of LaTeX ifthenelse's.  For this two LaTeX boolean value VDMSL and
% VDMpp have been defined  (Lowercase p's are used to avoid conflict with
% the VDMPP environment variable.  The typical use are:
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{vdmpp-text}
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{}
%   \ifthenelse{\boolean{VDMpp}}{vdmpp-text}{}
% The advantage of this as opposed to ifdef's is that within a general
% paragraph specific VDM-SL and VDM++ parts can be distinguished without
% problematic empty lines.
% 
% The values are initialised such that exactly one of the values is true
% and the other is false.  This should hopefully avoid strange behaviour
% due to possible preprossing errors.  The default case is VDM-SL.
\newboolean{VDMsl}
\setboolean{VDMsl}{true}
\newboolean{VDMpp}
\setboolean{VDMpp}{false}
#ifdef VDMSL
\setboolean{VDMsl}{true}
\setboolean{VDMpp}{false}
#endif VDMSL
#ifdef VDMPP
\setboolean{VDMpp}{true}
\setboolean{VDMsl}{false}
#endif VDMPP

%\latexpdf{\usepackage[pdftex,colorlinks=true,bookmarks=true]{hyperref}}{}

#ifdef VICEMAN
\newcommand{\vdmtoolsver}{v9.0.6 beta}
#else
\newcommand{\vdmtoolsver}{v9.0.6}
#endif VICEMAN

\newcommand{\MYEQUIV}{$\equiv$}
\newlength{\nonstandlen}
\newcommand{\nonstandard}[1]{%
#ifdef VDMSL
\setlength{\nonstandlen}{#1\baselineskip}%
  \marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{\fbox{{\footnotesize Non standard}}}}%
#endif VDMSL
}
\newenvironment{TypeSemantics}{\begin{longtable}[r]{|p{3.5cm}|p{9cm}|}\hline%
  Operator Name & Semantics Description \\ \hline\hline \endhead}% 
  {\hline\end{longtable}}
  
%\renewcommand{\vdmpp}{{\small VDM}$^{++}$}

\makeatletter
% ------------- TOC manipulation ------------
\def\docglbldepth{1}
%\setcounter{secnumdepth}{\docglbldepth}
%\setcounter{tocdepth}{\docglbldepth}
\def\@pnumwidth{3.0em}
% more space for for >10 subsections
%\def\l@section{\@dottedtocline{1}{1.5em}{3.1em}}
\def\l@subsection{\@dottedtocline{2}{1.5em}{2.8em}}
%\def\l@subsubsection{\@dottedtocline{3}{4.3em}{3.6em}}
%\def\l@paragraph{\@dottedtocline{4}{7.9em}{4.1em}}
%\def\l@subparagraph{\@dottedtocline{5}{10em}{5em}}
\makeatother

\makeindex
%\latexpdf{\pdfinfo{
% /Title (The  VDM-SL Language)
% /Author (The VDM Tool Group, The Institute of Applied Computer Science)
%}}{}


\begin{document}
%\latexpdf{\pdfcatalog{/PageMode /UseOutlines} openaction goto page 1 {/Fit}}{}

#ifdef VDMSL
%\vdmtoolsmanual{The  VDM-SL Language}
\vdmtoolsmanualscsk{The VDM-SL Language Manual}{2.0}
#endif //VDMSL
#ifdef VDMPP
%\vdmtoolsmanual{The  VDM++ Language %
\vdmtoolsmanualscsk{The VDM++ Language Manual %
#ifdef VICEMAN
  For VICE
#endif VICEMAN
}
#ifdef VICEMAN
        {2.0 beta}
#else
        {2.0}
#endif // VICEMAN
#endif //VDMPP


\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index
    
  \end{tabbing}\end{quote}
  }
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\sf #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt #1}\makebox[\kwlen][l]{\sf
    #1}}
\newcommand{\keyw}[1]{{\sf #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{alltt}\input{#1}\end{alltt}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\kw{map }#1\kw{ to }#2}
\newcommand{\INMAP}[2]{\kw{inmap }#1\kw{ to }#2}
\newcommand{\SEQ}[1]{\kw{seq of }#1}
\newcommand{\NSEQ}[1]{\kw{seq1 of }#1}
\newcommand{\SET}[1]{\kw{set of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{$#1 \To #2$}
\newcommand{\FUN}[2]{#1 \To #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}


% No line numbering
%\nolinenumbering
%\setindent{outer}{\parindent}
%\setindent{inner}{0.0em}


\section{Introduction}

#ifdef VDMPP

% {\vdmpp} is a formal specification language intended to specify
{\vdmpp} is a formal specification language intended to specify
object oriented systems with parallel 
and real-time 
behaviour,
typically in technical environments~\cite{Fitzgerald&05}.  The language is based on
\vdmsl~\cite{ISOVDM96}, and has been extended with class and object
concepts, which are also present in languages like Smalltalk-80 and
Java.  This combination facilitates the development of object oriented
formal specifications.  
#ifdef VICEMAN
VICE is an acronym for ``VDM++ In Constrained Environments'' so this
variant of VDM is used to appropriately model and analyse real-time
embedded and distributed systems~\cite{Verhoef&06b}.
#endif VICEMAN

\subsection{Purpose of The Document}

This document is the language reference manual for {\vdmpp}.  The
syntax of {\vdmpp} language constructs is defined using grammar rules.
The meaning of each language construct is explained in an informal
manner and some small examples are given. The description is supposed
to be suited for `looking up' information rather than for `sequential
reading'; it is a manual rather than a tutorial.  The reader is
expected be familiar with the concepts of object oriented
programming/design.

We will use the ASCII (also called the interchange)
concrete syntax but we will display all reserved words in a special
keyword font. This is done because the document works as a language
%manual to the  \vdmpp\ Toolbox where the ASCII notation is used as
manual to the \vdmpp\ Toolbox where the ASCII notation is used as
input. The mathematical concrete syntax can be generated automatically
by the Toolbox so a nicer looking syntax can be produced.

\subsection{History of The Language}

{\vdmpp} has been under development since 1992; see \cite{Durr92a} for
its original description. Since then, the language has been further
developed as part of the AFRODITE\footnote{AFRODITE has been sponsored
by the European Union under the ESPRIT programme (EP6500).}
%project.  {\vdmpp} is based on the development in the AFRODITE
project. {\vdmpp} is based on the development in the AFRODITE
project.  In the process of language development, feedback and
evaluation of the language from a number of larger case studies has
been used.

%The  {\vdmpp} language is the language supported by the 
The {\vdmpp} language is the language supported by the
{\vdmpp} Toolbox. This Toolbox contains a
syntax checker, a static semantics checker, an interpreter\footnote{In
addition the Toolbox provides pretty printing facilities, debugging
facilities and support for test coverage, but these are the basic
components.}, a code generator to C++, and a UML link.  Because
ISO/VDM-SL in general is a non-executable language the interpreter
supports only a subset of the language. This document will focus
particularly on the points where the semantics of VDM-SL differs from
the semantics used in the interpreter. In this document we will use
the term ``interpreter'' whenever we refer to the interpreter from the
%  {\vdmpp} Toolbox.
{\vdmpp} Toolbox.

\subsection{Structure of the Document}

Section~\ref{conformance} indicates how the language presented here
%and the corresponding  \vdmpp\ Toolbox conform to the VDM-SL
and the corresponding \vdmpp\ Toolbox conform to the VDM-SL
standard.  Section~\ref{syntax-notation} presents the BNF notation
%used for the description of syntactic constructs.  The  \vdmpp\
used for the description of syntactic constructs.  The \vdmpp\
notation is described in section~\ref{typedef} to
section~\ref{ch:thread}.  Section~\ref{diff} provides a complete list
%of the differences between ISO/VDM-SL and  \vdmpp\ while
of the differences between ISO/VDM-SL and \vdmpp\ while
section~\ref{static} contains a short explanation of the static
semantics of \vdmpp. The complete syntax of the language is described
in Appendix~\ref{app-a}, the lexical specification in
Appendix~\ref{app-b} and the operator precedence in
Appendix~\ref{app-c}. Appendix~\ref{sec:diff} presents a list of the
differences between symbols in the mathematical syntax and the ASCII
concrete syntax. In Appendex~\ref{stdlib} details of the Standard
library and how to use it are given. Finally, an index of the defining
occurrences of all 
the syntax rules in the document is given.
#endif VDMPP

#ifdef VDMSL
This document describes the syntax and semantics of the  VDM-SL
language which is essentially standard ISO/VDM-SL \cite{ISOVDM96}
with a modular extension
\footnote{A few other extensions are also included.}.
Notice that all syntactically correct VDM-SL specifications are also correct in
 VDM-SL. 
Even though we have tried to present the language in a
clear and understandable way the document is not a complete VDM-SL
reference manual. 
For a more thorough presentation of the language we refer to the
existing literature\footnote{A more tutorial like
presentation is given in \cite{Fitzgerald&98} whereas proofs in VDM-SL
are treated best in \cite{Jones90a} and \cite{Bicarregui&94}.}.
Wherever the  VDM-SL notation differs from
the VDM-SL standard notation the semantics will of course be carefully
explained.

The  VDM-SL language is the language supported by the  VDM-SL
Toolbox (see \cite{UserMan-SCSK}). This Toolbox contains a syntax checker,
a static semantics checker, an interpreter\footnote{In addition the
Toolbox provides pretty printing facilities, debugging facilities and
support for test coverage, but these are the basic components.} and a
code generator to C++. Because ISO/VDM-SL in general is a
non-executable language the interpreter supports only a subset of the
language. This document will focus particularly on the points where
the semantics of VDM-SL differs from the semantics used in the
interpreter. In this document we will use the term ``the interpreter"
whenever we refer to the interpreter from the  VDM-SL Toolbox, and
we will refer to ``VDM-SL" whenever the semantics of some language
construct is totally identical to the dynamic semantics for the VDM-SL
standard.

Consequently we will use the ASCII (also called the interchange)
concrete syntax but we will display all reserved words in a special
keyword font. This is done because the document works as a language
manual to the  VDM-SL Toolbox where the ASCII notation is used as
input. The mathematical concrete syntax can be generated automatically
by the Toolbox so a nicer looking syntax can be produced.

Section~\ref{conformance} indicates how the language presented here and the
corresponding  VDM-SL Toolbox conform to the VDM-SL standard.
Section~\ref{syntax-notation} presents the BNF notation used
for the description of syntactic constructs.  The  VDM-SL
notation is described in section~\ref{typedef} to
section~\ref{top-level}.
Section~\ref{diff} provides a complete list of the differences between
ISO/VDM-SL and  VDM-SL while section~\ref{static} contains a
short explanation of the static semantics of VDM-SL.
The complete syntax of the language is described in Appendix~\ref{app-a}, the
lexical specification in Appendix~\ref{app-b} and the operator precedence
in Appendix~\ref{app-c}. Appendix~\ref{sec:diff} presents a list of the
differences between symbols in the mathematical syntax and the ASCII
concrete syntax. In Appendex~\ref{stdlib} details of the Standard
library and how to use it are given. Finally, an index of the defining
occurrences of 
all the syntax rules in the document is given. 
#endif VDMSL

\section{Conformance Issues}
\label{conformance}

The VDM-SL standard has a conformance clause which specifies a number
of levels of conformity. The lowest level of conformity deals with
syntax conformance. The  \vdmslpp{\vdmsl}{\vdmpp} Toolbox accepts
specifications which follow the syntax description in the
\vdmslpp{standard.}{standard with the exceptions described in section
\ref{diff}.}

In addition it accepts a number of extensions (see section \ref{diff})
which should be rejected according to the conformance clause.

Level one in the conformance clause deals with the static semantics
for possible correctness (see section~\ref{static}). 
In this part we have chosen to reject more
specifications than the standard prescribes as being possibly
well-formed\footnote{For example with a set comprehension where a
  predicate is present the standard does not check the element
  expression at all (in the possibly well-formedness check) because
  the predicate could yield false (and thus the whole expression would
  just be another way to write an empty set). We believe that a user
  will be interested in getting such parts tested as well.}.

Level two and the following levels (except the last one) deal with the
definite well-formedness static semantics check and a number of
possible extended checks which can be added to the static semantics.
The definitely well-formedness check is present in the
Toolbox. However, we do not consider it to be of major value for real
examples because almost no ``real'' specifications will be able to
pass this test.

The last conformance level deals with the dynamic semantics. Here it
is required that an accompanying document provides details about the
deviations from the standard dynamic semantics (which is not
executable). This is actually done in this document by explaining
which constructs can be interpreted by the Toolbox and what the
deviations are for a few constructs. Thus, this level of conformance
is satisfied by the  \vdmslpp{VDM-SL}{\vdmpp} Toolbox.

To sum up, we can say that  \vdmslpp{VDM-SL}{\vdmpp} (and its
supporting Toolbox) is quite close conforming to the standard, but we
have not yet invested the time in ensuring this.

\section{Concrete Syntax Notation}
\label{syntax-notation}


Wherever the syntax for parts of the language is presented in the
document it will be described in a BNF dialect. The BNF notation
used employs the following special symbols:

\newcommand{\singleQuote}{\texttt{\symbol{34}}}
\begin{tabular}{l@{\hspace{1cm}}p{10cm}}
  , &  the concatenate symbol \\
  = & the define symbol \\
  \dsepl & the definition separator symbol (alternatives)\\
  \OptPt{} & enclose optional syntactic items \\
  \SeqPt{} & enclose syntactic items which may occur zero or more times \\
  \Lit{ } & single quotes are used to enclose terminal symbols \\
    meta identifier & non-terminal symbols are written in lower-case letters
    (possibly including spaces) \\
  ;  & terminator symbol to denote the end of a rule \\
  (\ ) & used for grouping, e.g. ``a, (b\dsepl c)'' is equivalent to
    ``a, b\dsepl a, c''. \\
  -- & denotes subtraction from a set of terminal symbols 
    (e.g. ``character -- (\Lit{\singleQuote})'' denotes all characters
    excepting the double quote character.)
\end{tabular}

\section{Data Type Definitions}
\label{typedef}

As in traditional programming languages it is possible to define data
types in \vdmslpp{\vdmsl}{\vdmpp}\ and give them appropriate names.
Such an equation might look like:

\begin{alltt}
  Amount = \keyw{nat}
\end{alltt}
Here we have defined a data type with the name ``{\tt Amount}'' and
stated that the values which belong to this type are natural numbers
(\keyw{nat} is one of the basic types described below). One general
point about the type system of \vdmslpp{\vdmsl}{\vdmpp}\ which is
worth mentioning at this point is that equality and inequality can be
used between any value. In programming languages it is often required
that the operands have the same type. Because of a 
construct called a union type (described below) this is not the case
for \vdmslpp{\vdmsl.}{\vdmpp.}

In this section we will present the syntax of data type
definitions. In addition, we will show how values belonging to a type
can be constructed and manipulated (by means of built-in operators).
We will present the basic data types first and then we will proceed
with the compound types.

\subsection{Basic Data Types}

In the following a number of basic types will be presented. Each of
them will contain:

\begin{itemize}
\item Name of the construct.
\item Symbol for the construct.
\item Special values belonging to the data type.
\item Built-in operators for values belonging to the type.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.%
  \footnote{In these examples the Meta symbol `$\equiv$' will be used
    to indicate what the given example is equivalent to.}
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt a}, {\tt b}, {\tt x}, {\tt y}
etc.

The basic types are the types defined by the language with distinct
values that cannot be analysed into simpler values. There are five
fundamental basic types: booleans, numeric types,
characters, tokens and quote types. The basic types will be explained one by
one in the following.

\subsubsection{The Boolean Type}\label{bool}

In general \vdmslpp{\vdmsl}{\vdmpp} allows one to specify systems in
which computations may fail to terminate or to deliver a result. To
deal with such potential undefinedness, 
\vdmslpp{\vdmsl}{\vdmpp} employs a three valued logic: values may be
true, false or bottom (undefined). 
The semantics of the interpreter differs from \vdmsl\ in that it does
not have an LPF (Logic of Partial Functions) three valued logic where
the order of the operands is  
unimportant (see \cite{Jones90a}).  The \keyw{and} operator, the
\keyw{or} operator and the imply operator, though, have a conditional
semantics meaning that if the first operand is sufficient to determine
the final result, the second operand will not be evaluated. In a sense
the semantics of the logic in the interpreter can still be considered
to be three-valued as for VDM-SL. However, bottom values may
either result in infinite computation or a run-time error in the
interpreter.

\begin{description}
\item[Name:] \Index{Boolean}
\item[Symbol:] \Index{\keyw{bool}}
\item[Values:] \Index{\keyw{true}}, \Index{\keyw{false}}
\item[Operators:] Assume that {\tt a} and {\tt b} in the following
  denote arbitrary boolean expressions:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name       & Type                       \\ \hline
    {\tt \keyw{not} b}& Negation   & \TO{\keyw{bool}}{\keyw{bool}} \\
    {\tt a \keyw{and} b}& Conjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a \keyw{or} b}& Disjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a => b}& Implication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <=> b}& Biimplication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a = b} & Equality   & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <> b}& Inequality & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{not}}\index{Negation}\index{\keyw{and}}\index{Conjunction}%
\index{\keyw{or}}\index{Disjunction}%
\index{\texttt{=>}}\index{Implication}\index{\texttt{<=>}}\index{Biimplication}%
\index{\texttt{=}!boolean equality}\index{Equality!boolean type}\index{\texttt{<>}!boolean inequality}\index{Inequality!boolean type}


\item[Semantics of Operators:] Semantically {\tt <=>} and {\tt =} are
  equivalent when we deal with boolean values. There is a conditional
  semantics for \keyw{and}, \keyw{or} and {\tt=>}.

  We denote undefined terms (e.g. \ applying a map with a key outside
  its domain)  by $\perp$. The truth tables for the boolean operators
  are then%
  \footnote{Notice that in standard VDM-SL all these truth tables
  (except {\tt =>}) would be symmetric.}:
     
  \begin{tabular}{ll}
    Negation {\tt \keyw{not} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      {\tt \keyw{not} b}  & \keyw{false}  & \keyw{true} & $\perp$ \\ \hline
    \end{tabular}\\
    \mbox{} & \\
    Conjunction {\tt a \keyw{and} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{false} & \keyw{false} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Disjunction {\tt a \keyw{or} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{true} & \keyw{true} \\
      \keyw{false} & \keyw{true} & \keyw{false} & $\perp$ \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Implication {\tt a => b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{true} & \keyw{true} & \keyw{true} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Biimplication {\tt a <=> b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ a \backslash b$    & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{true}  & $\perp$ \\
      $\perp$&$\perp$ &$\perp$ & $\perp$ \\ \hline
    \end{tabular}\\
  \end{tabular}     

\item[Examples:] 
  Let {\tt a = \keyw{true}} and {\tt b = \keyw{false}} then:
  
  \begin{tabular}{lcl}
    {\tt \keyw{not} a} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{and} b} & $\equiv$ & \keyw{false} \\
    {\tt b \keyw{and} $\perp$} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{or} b} & $\equiv$ & \keyw{true} \\
    {\tt a \keyw{or} $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a => b} & $\equiv$ & \keyw{false} \\
    {\tt b => b} & $\equiv$ & \keyw{true} \\
    {\tt b => $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a <=> b} & $\equiv$ & \keyw{false} \\
    {\tt a = b} & $\equiv$ & \keyw{false} \\
    {\tt a <> b} & $\equiv$ & \keyw{true} \\
    {\tt $\perp$ \keyw{or} \keyw{not} $\perp$} & $\equiv$ & $\perp$\\
    {\tt (b \keyw{and} $\perp$) \keyw{or} ($\perp$ \keyw{and}
    \keyw{false})} & $\equiv$ & $\perp$
  \end{tabular}
\end{description}

\subsubsection{The Numeric Types}\label{numeric}

There are five basic numeric types: positive naturals, naturals,
integers, rationals and reals.  Except for three, all the
numerical operators can have mixed operands of the three types. The
exceptions are integer division, modulo and the remainder operation.

The five numeric types denote a hierarchy where \Index{\keyw{real}} is
the most general type followed by \Index{\keyw{rat}}\footnote{From the
   \vdmslpp{\vdmsl}{\vdmpp}\ Toolbox's point of view there is no
  difference between \keyw{real} and \keyw{rat} because only rational
  numbers can be represented in a computer.}, \Index{\keyw{int}},
\Index{\keyw{nat}} and \Index{\keyw{nat1}}.

\vspace{1ex}
\begin{tabular}{|l|l|} \hline
  Type & Values \\ \hline
  \keyw{nat1}& {\tt 1, 2, 3, \ldots}\\
  \keyw{nat} & {\tt 0, 1, 2, \ldots}\\
  \keyw{int} & {\tt \ldots, -2, -1, 0, 1, \ldots}\\
  \keyw{real} & {\tt \ldots, -12.78356, \ldots, 0, \ldots, 3, \ldots, 1726.34, \ldots}\\ \hline
\end{tabular}

\mbox{}\\
This means that any number of type \keyw{int} is also automatically of type
\keyw{real} but not necessarily of type \keyw{nat}.  Another way to
illustrate this is to say that the positive natural numbers are a subset of
the natural numbers which again are a subset of the integers which again
are a subset of the rational numbers which finally are a subset of the real
numbers. The following table shows some numbers and their associated
type:

\vspace{1ex}
\begin{tabular}{|c|l|} \hline
  Number & Type \\ \hline
  {\tt 3}      & \keyw{real, rat, int, nat, nat1} \\
  {\tt 3.0}    & \keyw{real, rat, int, nat, nat1} \\
  {\tt 0}      & \keyw{real, rat, int, nat} \\
  {\tt -1}     & \keyw{real, rat, int}\\
  {\tt 3.1415} & \keyw{real, rat} \\ \hline
\end{tabular}

\mbox{}\\
Note that all numbers are necessarily of type \keyw{real} (and
\keyw{rat}).

\begin{description}
\item[Names:] real, rational, integer, natural and positive natural
  numbers.
\item[Symbols:] \keyw{real}, \keyw{rat}, \keyw{int}, \keyw{nat},
  \keyw{nat1}
\item[Values:] {\tt \ldots, -3.89, \ldots, -2, \ldots, 0, \ldots, 4,
    \ldots, 1074.345, \ldots}
\item[Operators:] Assume in the following that {\tt x} and {\tt y} denote
  numeric expressions. No assumptions are made regarding their type.

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name & Type \\ \hline
    {\tt -x}& Unary minus & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{abs} x}& Absolute value & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{floor} x}& Floor  & \TO{\keyw{real}}{\keyw{int}} \\
    {\tt x + y}& Sum    & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x - y}& Difference & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x * y}& Product  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x / y}& Division & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x \keyw{div} y}& Integer division & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{rem} y}& Remainder & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{mod} y}& Modulus   & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x**y}& Power & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x < y}& Less than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x > y}& Greater than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <= y}& Less or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x >= y}& Greater or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x = y}& Equal  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <> y}& Not equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    \hline     
  \end{tabular}%
\index{\texttt{-}}\index{Unary minus}\index{\keyw{abs}}\index{Absolute value}%
\index{\keyw{floor}}\index{Floor}\index{\texttt{+}}\index{Sum}\index{Difference!numeric}%
\index{\texttt{*}}\index{Product}\index{\texttt{/}}\index{Division}%
\index{\keyw{div}}\index{Integer division}\index{\keyw{mod}}\index{Remainder}%
\index{\keyw{mod}}\index{Modulus}\index{\texttt{**}!numeric power}\index{Power}%
\index{\texttt{<}}\index{Less than}\index{\texttt{>}}\index{Greater than}%
\index{\texttt{<=}}\index{Less or equal}\index{\texttt{>=}}\index{Greater or equal}%
\index{\texttt{=}!numeric equality}\index{Equality!numeric type}\index{\texttt{<>}!numeric inequality}\index{Inequality!numeric type}

  The types stated for operands are the most general types allowed.  This
  means for instance that unary minus works for operands of all five types
  (\keyw{nat1}, \keyw{nat}, \keyw{int} \keyw{rat} and \keyw{real}).
     
\input{sem-numtypes}

\item[Examples:] Let {\tt a = 7, b = 3.5, c = 3.1415, d = -3, e = 2} then:

  \begin{longtable}{lcl}
    {\tt - a}&$\equiv$& -7                     \\
    {\tt \keyw{abs} a}&$\equiv$& 7                    \\
    {\tt \keyw{abs} d}&$\equiv$& 3                    \\
    {\tt \keyw{floor} a <= a}&$\equiv$& \keyw{true}   \\
    {\tt a + d}&$\equiv$& $4$                  \\
    {\tt a * b}&$\equiv$& $24.5$               \\
    {\tt a / b}&$\equiv$& $2$                \\
    {\tt a \keyw{div} e}&$\equiv$& $3$                \\
    {\tt a \keyw{div} d}&$\equiv$& $-2$               \\
    {\tt a \keyw{mod} e}&$\equiv$& $1$                \\
    {\tt a \keyw{mod} d}&$\equiv$& $-2$               \\
    {\tt -a \keyw{mod} d}&$\equiv$& $-1$               \\
    {\tt a \keyw{rem} e}&$\equiv$& $1$                \\
    {\tt a \keyw{rem} d}&$\equiv$& $1$                \\
    {\tt -a \keyw{rem} d}&$\equiv$& $-1$              \\
    {\tt 3**2 + 4**2 = 5**2} &$\equiv$ &\keyw{true}   \\
    {\tt b < c}&$\equiv$& \keyw{false}                \\
    {\tt b > c}&$\equiv$& \keyw{true}                 \\
    {\tt a <= d}&$\equiv$& \keyw{false}               \\
    {\tt b >= e}&$\equiv$& \keyw{true}                \\
    {\tt a = e}&$\equiv$& \keyw{false}                \\
    {\tt a = 7.0}&$\equiv$& \keyw{true}               \\
    {\tt c <> d}&$\equiv$& \keyw{true}                \\
    {\tt \keyw{abs} c < 0} & $\equiv$ & \keyw{false}  \\
    {\tt (a \keyw{div} e) * e} & $\equiv$ & 6       
  \end{longtable}
\end{description}

\subsubsection{The Character Type}

The character type contains all the single character
elements of the VDM character set
(see Table~\ref{charSetTable} on page~\pageref{charSetTable}).

\begin{description}
\item[Name:] \Index{Char}
\item[Symbol:] \Index{\keyw{char}}
\item[Values:] {\tt 'a', 'b',} \ldots, {\tt '1', '2',} \ldots {\tt
                '+', '-'} \ldots
\item[Operators:] Assume that {\tt c1} and {\tt c2} in the following denote arbitrary
  characters:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name      & Type \\ \hline
    {\tt c1 = c2}  & Equal     & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    {\tt c1 <> c2} & Not equal & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!char equality}\index{Equality!char}\index{\texttt{<>}!char inequality}\index{Inequality!char}


\item[Examples:] \mbox{}

  \begin{tabular}{lcl}
    {\tt 'a' = 'b'} &$\equiv$& \keyw{false}\\
    {\tt '1' = 'c'} &$\equiv$& \keyw{false}\\
    {\tt 'd' <> '7'} &$\equiv$& \keyw{true}\\
    {\tt 'e' = 'e'} &$\equiv$& \keyw{true}\\
  \end{tabular}
\end{description}

\subsubsection{The Quote Type}

The quote type corresponds to enumerated types in a programming
language like Pascal. However, instead of writing the different quote
literals between curly brackets in \vdmslpp{\vdmsl}{\vdmpp}\ it is done
by letting a quote type consist of a single quote literal and
then let them be a part of a union type.
%Quote literals are recognized
%by being a sequence of $\const{distinguished letters}$ (which cannot be
%used for any other purpose).

\begin{description}
\item[Name:] \Index{Quote}
\item[Symbol:] e.g. {\tt <QuoteLit>}\index{\texttt{<>}!quote value}
\item[Values:] {\tt <RED>, <CAR>, <QuoteLit>,} \ldots
\item[Operators:] Assume that \texttt{q} and \texttt{r} in the
  following denote arbitrary quote values belonging to an enumerated
  type {\tt T}: 

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt q = r}  & Equal     & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt q <> r} & Not equal & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!quote equality}\index{Equality!quote type}\index{\texttt{<>}!quote inequality}\index{Inequality!quote}


\item[Examples:] Let \texttt{T} be the type defined as:

  \begin{tabular}{l}
    {\tt T = <France> | <Denmark> | <SouthAfrica> | <SaudiArabia>} \\
  \end{tabular}

  If for example {\tt a = <France>}
  then:

  \begin{tabular}{lcl}
     {\tt <France> = <Denmark>} & $\equiv$ & \keyw{false}\\
     {\tt <SaudiArabia> <> <SouthAfrica>} & $\equiv$ & \keyw{true}\\
     {\tt a <> <France>} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsubsection{The Token Type}

The token type consists of a countably infinite set of distinct
values, called tokens. The only operations that can be carried out on
tokens are equality and inequality. In \vdmslpp{\vdmsl,}{\vdmpp,}
tokens cannot be individually represented whereas they can be written
with a \keyw{mk\_token} around an arbitrary expression. This is a way
of enabling testing of specifications which contain token
types. However, in order to resemble the \vdmsl\ standard these token
values cannot be decomposed by means of any pattern matching and they
cannot be used for anything other than equality and inequality
comparisons.

\begin{description}
\item[Name:] \Index{Token}
\item[Symbol:] \Index{\keyw{token}}
\item[Values:] \index{\keyw{mk\_}!token value}{\tt \keyw{mk\_token}(5)},
  {\tt \keyw{mk\_token}(\{9, 3\})}, {\tt
    \keyw{mk\_token}([\keyw{true}, \{\}])}, \ldots%\index
\item[Operators:] Assume that {\tt s} and {\tt  t} in the following denote arbitrary
  token values:

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt s = t}  & Equal     & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    {\tt s <> t} & Not equal & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!token equality}\index{Equality!token type}\index{\texttt{<>}!token inequality}\index{Inequality!token type}

\item[Examples:] Let for example {\tt s = \keyw{mk\_token}(6)} and let {\tt t
    = \keyw{mk\_token}(1)} in:

  \begin{tabular}{lcl}
    {\tt s = t} &$\equiv$& \keyw{false} \\
    {\tt s <> t} &$\equiv$& \keyw{true} \\
    {\tt s = \keyw{mk\_token}(6)} & $\equiv$& \keyw{true} \\
  \end{tabular}
\end{description}

\subsection{Compound Types}

In the following compound types will be presented. Each of
them will contain:
\begin{itemize}
\item The syntax for the compound type definition.
\item An equation illustrating how to use the construct.
\item Examples of how to construct values belonging to the type. In
  most cases there will also be given a forward reference to the
  section where the syntax of the basic constructor expressions is given.
\item Built-in operators for values belonging to the
  type \footnote{These operators are used in either unary or binary
    expressions which are given with all the operators in
    section~\ref{unandbin}.}.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt m}, {\tt m1}, {\tt s}, {\tt
  s1} etc.

\subsubsection{Set Types}
\label{sets}

A set is an unordered collection of values, all of the same
type\footnote{Note however that it is always possible to find a common
  type for two values by the use of a union type (see
  section~\ref{unions}.)}, which is treated as a whole. All sets in 
\vdmslpp{\vdmsl}{\vdmpp}\ are finite, i.e.\ they contain only a finite
number of elements. The elements of a set type can be arbitrarily
complex, they could for example be sets themselves.

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt S} is a set type, {\tt s}, {\tt s1}, {\tt s2} are set
values, {\tt ss} is a set of set values, {\tt e}, {\tt e1}, {\tt e2}
and {\tt en} are elements from the sets, {\tt bd1,} {\tt bd2}, \ldots,
{\tt bdm} are bindings of identifiers to sets or types, and {\tt P} is
a logical predicate.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
   \Ruleref{set type} \dsep
    \ldots
    }
  
  \Rule{set type}{\Lop{set of}, \Ruleref{type}}

\item[Equation:] {\tt S = \keyw{set of} A}\index{\keyw{set of}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Set enumeration:] \verb|{e1, e2, ..., en}| constructs a set of the
    enumerated elements. The empty set is denoted by {\tt \{\}}.
  
  \item[Set comprehension:] \verb+{e | bd1, bd2, ..., bdm & P}+
    constructs a set by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}.
    A binding is either a set binding or a type
    binding\footnote{Notice that type bindings cannot be executed by
      the interpreter because in general
      they are not executable (see section~\ref{bind} for further
      information about this).}.  A set bind {\tt bdn} has the form
    {\tt pat1, \ldots, patp \keyw{in set} s}, where {\tt pati} is a
    pattern (normally simply an identifier), and {\tt s} is a set
    constructed by an expression. A type binding is similar, in the
    sense that \keyw{in set} is replaced by a colon and {\tt s} is
    replaced with a type expression.
  \end{description}
  The syntax and semantics for all set expressions are given in
  section~\ref{setexpr}.%
\index{\texttt{\{\}}!set enumeration}\index{\texttt{\{"|\}}!set comprehension}\index{\texttt{\&}!set comprehension}
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline 
    {\tt e \keyw{in set} s1} & Membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt e \keyw{not in set} s1} & Not membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{union} s2}& Union & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{inter} s2}& Intersection & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 {\tt \char'134} s2}& Difference & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{subset} s2}& Subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{psubset} s2} & Proper subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 = s2}& Equality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 <> s2}& Inequality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt \keyw{card} s1}& Cardinality & \TO{\SET{A}}{\keyw{nat}} \\
    {\tt \keyw{dunion} ss}& Distributed union& \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{dinter} ss}&Distributed intersection & \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{power} s1}&Finite power set & \TO{\SET{A}}{\SET{\SET{A}}} \\
    \hline
  \end{tabular}%
\index{\keyw{in set}}\index{Membership}\index{\keyw{not in set}}\index{Not membership}%
\index{\keyw{union}}\index{Union}\index{\keyw{inter}}\index{Intersection}%
\index{\texttt{\char'134}}\index{Difference!set}\index{\keyw{subset}}\index{Subset}%
\index{\keyw{psubset}}\index{Proper subset}\index{\texttt{=}!set equality}\index{Equality!set type}%
\index{\texttt{<>}!set inequality}\index{Inequality!set type}\index{\keyw{card}}\index{Cardinality}%
\index{\keyw{dunion}}\index{Distributed union}\index{\keyw{dinter}}\index{Distributed intersection}%
\index{\keyw{power}}\index{Finite power set}

  Note that the types {\tt A, \SET{A}} and {\tt \SET{\SET{A}}} are only 
  meant to illustrate the structure of the type. For instance it is
  possible to make
  a union between two arbitrary sets {\tt s1} and {\tt s2} and the type of
  the resultant set is the union type of the two set types. Examples
  of this will be given in section \ref{unions}.
      
\input{sem-settypes}

\item[Examples:]%
 Let {\tt s1 = \{<France>,<Denmark>,<SouthAfrica>,<SaudiArabia>\}}, 
{\tt s2 = \{2, 4, 6, 8, 11\}} and {\tt s3 = \{\}} then: 

  \begin{longtable}{lcl}
    {\tt <England> \keyw{in set} s1} & $\equiv$ & \keyw{false}\\
    {\tt 10 \keyw{not in set} s2}    & $\equiv$ & \keyw{true}\\
    {\tt s2 \keyw{union} s3}         & $\equiv$ & \texttt{\{2, 4, 6, 8, 11\}}\\
    \texttt{s1 \keyw{inter} s3}      & $\equiv$ & \texttt{\{\}}\\
    \texttt{(s2 \char'134 \ \{2,4,8,10\}) union \{2,4,8,10\} = s2} &
    $\equiv$ & \keyw{false}\\
    \texttt{s1 \keyw{subset} s3} & $\equiv$ & \keyw{false}\\
    \texttt{s3 \keyw{subset} s1} & $\equiv$ & \keyw{true}\\
    \texttt{s2 \keyw{psubset} s2} & $\equiv$ & \keyw{false}\\
    \texttt{s2 <> s2 \keyw{union} \{2, 4\}} & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{card} s2 \keyw{union} \{2, 4\}} & $\equiv$ & \texttt{5}\\
    \texttt{\keyw{dunion} \{s2, \{2,4\}, \{4,5,6\}, \{0,12\}\}} &
    $\equiv$ & \texttt{\{0,2,4,5,6,8,11,12\}}\\
    \texttt{\keyw{dinter} \{s2, \{2,4\}, \{4,5,6\}\}} & $\equiv$ &
    \texttt{\{4\}}\\
    \texttt{\keyw{dunion} \keyw{power} \{2,4\}} & $\equiv$ &
    \texttt{\{2,4\}}\\
    \texttt{\keyw{dinter} \keyw{power} \{2,4\}} & $\equiv$ & \texttt{\{\}}
  \end{longtable}
\end{description}

\subsubsection{Sequence Types}
\label{sequences}

A sequence value is an ordered collection of elements of some type
indexed by {\tt 1, 2, \ldots, n}; where {\tt n} is the length of the
sequence. A sequence type is the type of finite sequences of elements
of a type, either including the empty sequence (seq0 type) or
excluding it (seq1 type). The elements of a sequence type can be
arbitrarily complex; they could e.g.\ be sequences themselves.

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt L} is a sequence type, {\tt S} is a set type, {\tt l}, {\tt
  l1}, {\tt l2} are sequence values, {\tt ll} is a sequence of
sequence values.  {\tt e1}, {\tt e2} and {\tt en} are elements in
these sequences, {\tt i} will be a natural number, {\tt P} is a
predicate and {\tt e} is an arbitrary expression.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{seq type} \dsep
    \ldots
    }

  \Rule{seq type}{\Ruleref{seq0 type} \dsep
    \Ruleref{seq1 type}}

  \Rule{seq0 type}{\Lop{seq of}, \Ruleref{type}}
  
  \Rule{seq1 type}{\Lop{seq1 of}, \Ruleref{type}}
\item[Equation:] {\tt L = \keyw{seq of} A} or {\tt L = \keyw{seq1 of} A}%
\index{\keyw{seq of}}\index{\keyw{seq1 of}}

%                 $L = \seqof*{A}$ or
%                 $L = \seqof+{A}$ where the notation has been adopted
%                 from regular expressions. Thus $\seqof*{A}$ means the type 
%                 containing sequences of $A$ elements (also the empty
%                 sequence), while $\seqof+{A}$ means the type containing
%                 non-empty sequences of $A$ elements. 

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Sequence enumeration:] \verb+[e1, e2,..., en]+ constructs a
    sequence of the enumerated elements. The empty sequence will be written
    as \verb+[]+.  A text literal is a shorthand for enumerating a sequence
    of characters (e.g.\ {\tt "ifad" = ['i','f','a','d']}).

  \item[Sequence comprehension:] {\tt [e | id \keyw{in set} S \& P]}
    constructs a sequence by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}. The
    expression {\tt e} will use the identifier {\tt id}. {\tt S} is a set
    of numbers and {\tt id} will be matched to the numbers in the
    normal order (the smallest number first).
  \end{description}
  The syntax and semantics of all sequence expressions are given in
  section~\ref{seqexpr}.%
\index{\texttt{[]}!sequence enumeration}\index{\texttt{["|]}!sequence comprehension}\index{\texttt{\&}!sequence comprehension}

      
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline 
    {\tt \keyw{hd} l} & Head & \TO{\NSEQ{A}}{A} \\
    {\tt \keyw{tl} l} & Tail & \TO{\NSEQ{A}}{\SEQ{A}} \\
    {\tt \keyw{len} l} & Length & \TO{\SEQ{A}}{\keyw{nat}} \\
    {\tt \keyw{elems} l} & Elements & \TO{\SEQ{A}}{\SET{A}} \\
    {\tt \keyw{inds} l} & Indexes & \TO{\SEQ{A}}{\SET{\keyw{nat1}}} \\
    {\tt l1 \char'136\ l2} & Concatenation & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\SEQ{A}} \\
    {\tt \keyw{conc} ll} & Distributed concatenation & \TO{\SEQ{\SEQ{A}}}{\SEQ{A}}\\
    {\tt l ++ m} & Sequence modification & \TO{\PROD{\SEQ{A}}{\MAP{\keyw{nat1}}{A}}}{\SEQ{A}}\\
    {\tt l(i)} & Sequence application & \TO{\PROD{\SEQ{A}}{\keyw{nat1}}}{A} \\
    {\tt l1 = l2} & Equality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    {\tt l1 <> l2} & Inequality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{hd}}\index{Head}\index{\keyw{tl}}\index{Tail}%
\index{\keyw{len}}\index{Length}\index{\keyw{elems}}\index{Elements}%
\index{\keyw{inds}}\index{Indexes}\index{\texttt{\char'136}}\index{Concatenation}%
\index{\keyw{conc}}\index{Distributed concatenation}%
\index{\texttt{++}!sequence modification}\index{Sequence modification}%
\index{\texttt{()}!sequence apply}\index{Sequence application}%
\index{\texttt{=}!sequence equality}\index{Equality!sequence type}\index{\texttt{<>}!sequence inequality}\index{Inequality!sequence type}%


  The type {\tt A} is an arbitrary type and the operands for the
  concatenation and distributed concatenation operators do not have
  to be of the same ({\tt A}) type. The type of the resultant sequence
  will be the union type of the types of the operands. Examples will
  be given in section \ref{unions}.

\input{sem-seqtypes}

\item[Examples:] Let \texttt{l1 = [3,1,4,1,5,9,2]}, \texttt{ l2 =
    [2,7,1,8]}, \newline
    \texttt{ l3 = [<England>, <Rumania>, <Colombia>,
    <Tunisia>]} then: 

  \begin{longtable}{lcl}
    \texttt{\keyw{len} l1}        & $\equiv$ & \texttt{7}\\
    \texttt{\keyw{hd} (l1\char'136 l2)}    & $\equiv$ & \texttt{3}\\
    \texttt{\keyw{tl} (l1\char'136 l2)}    & $\equiv$ &
      \texttt{[1,4,1,5,9,2,2,7,1,8]}\\
    \texttt{l3(\keyw{len} l3)}    & $\equiv$ & \texttt{<Tunisia>}\\
    \texttt{"England"(2)}       & $\equiv$ & \texttt{'n'}\\
    \texttt{\keyw{conc} [l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{conc} [l1,l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{elems} l3}      & $\equiv$ & \{
      \parbox[t]{5cm}{\texttt{<England>, <Rumania>, }\\
                      \texttt{<Colombia>,<Tunisia>\}}}\\
    \texttt{(\keyw{elems} l1) \keyw{inter} (\keyw{elems} l2)} 
                                  & $\equiv$ & \texttt{\{1,2\}}\\
    \texttt{\keyw{inds} l1}       & $\equiv$ & \texttt{\{1,2,3,4,5,6,7\}}\\
    \texttt{(\keyw{inds} l1) \keyw{inter} (\keyw{inds} l2)}
                                  & $\equiv$ & \texttt{\{1,2,3,4\}}\\
    \texttt{l3 ++ \{2 |-> <Germany>,4 |-> <Nigeria>\}}
                                  & $\equiv$ & [
      \parbox[t]{5cm}{\texttt{<England>, <Germany>, }\\
                      \texttt{<Colombia>, <Nigeria>]}}
  \end{longtable}
\end{description}

\subsubsection{Map Types}\label{maps}

A map type from a type {\tt A} to a type {\tt B} is a type that
associates with each element of {\tt A} (or a subset of {\tt A}) an
element of {\tt B}.  A map value can be thought of as an unordered
collection of pairs.  The first element in each pair is called a key,
because it can be used as a key to get the second element (called the
information part) in that pair. All key elements in a map must therefore
be unique. The set of all key elements is called the domain of the map,
while the set of all information values is called the range of the map.
All maps in \vdmslpp{\vdmsl}{\vdmpp}\ are finite. The domain and range
elements of a map type can be arbitrarily complex, they could e.g. be
maps themselves.

A special kind of map is the injective map. An injective map is one
for which no element of the range is associated with more than one
element of the domain. For an injective map it is possible to invert
the map.

In the following this convention will be used: {\tt m}, {\tt m1} and {\tt
  m2} are maps from an arbitrary type {\tt A} to another arbitrary type
{\tt B}, {\tt ms} is a set of map values, {\tt a}, {\tt a1}, {\tt a2} and
{\tt an} are elements from {\tt A} while {\tt b}, {\tt b1}, {\tt b2} and
{\tt bn} are elements from {\tt B} and {\tt P} is a logic predicate. {\tt
  e1} and {\tt e2} are arbitrary expressions and {\tt s} is an arbitrary
set.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{map type} \dsep
    \ldots
    }
  
  \Rule{map type}{\Ruleref{general map type} \dsep
    \Ruleref{injective map type}}
  
  \Rule{general map type}{\Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}
  
  \Rule{injective map type}{\Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}

\item[Equation:] {\tt M = \keyw{map} A \keyw{to} B} or {\tt M =
    \keyw{inmap} A \keyw{to} B}\index{\keyw{map to}}\index{\keyw{inmap to}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Map enumeration:] {\tt \{a1 |-> b1, a2 |-> b2, \ldots, an |-> bn\}}
    con\-structs a mapping of the enumerated maplets. The empty map will be
    written as {\tt \{|->\}}.

  \item[Map comprehension:] {\tt \{ed |-> er | bd1, \ldots, bdn \& P\}}
    constructs a mapping by evaluating the expressions {\tt ed} and {\tt
      er} on all the possible bindings for which the predicate {\tt P}
    evaluates to \keyw{true}. {\tt bd1, \ldots, bdn} are bindings of
    free identifiers from the expressions {\tt ed} and {\tt er} to sets or types.
  \end{description}
  The syntax and semantics of all map expressions are given in
  section~\ref{mapexpr}.%
\index{\texttt{\{\}}!map enumeration}\index{\texttt{\{"|\}}!map comprehension}\index{\texttt{\&}!map comprehension}


\item[Operators:]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline 
    {\tt \keyw{dom} m} & Domain & \TO{(\MAP{A}{B})}{\SET{A}} \\
    {\tt \keyw{rng} m} & Range & \TO{(\MAP{A}{B})}{\SET{B}} \\
    {\tt m1 \keyw{munion} m2} & Merge & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m1 ++ m2} & Override & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt \keyw{merge} ms} & Distributed merge & \TO{\SET{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <: m} & Domain restrict to & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <-: m} & Domain restrict by & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m :> s} & Range restrict to & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m :-> s} & Range restrict by & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m(d)} & Map apply & \TO{\PROD{(\MAP{A}{B})}{A}}{B} \\
    {\tt m1 \keyw{comp} m2} & Map composition & \TO{\PROD{(\MAP{B}{C})}{(\MAP{A}{B})}}{\MAP{A}{C}} \\
    {\tt m ** n} & Map iteration & \TO{\PROD{(\MAP{A}{A})}{\keyw{nat}}}{\MAP{A}{A}} \\
    {\tt m1 = m2} & Equality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt m1 <> m2} & Inequality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt \keyw{inverse} m} & Map inverse & \TO{\INMAP{A}{B}}{\INMAP{B}{A}} \\
    \hline
  \end{tabular}%
\index{\keyw{dom}}\index{Domain}\index{\keyw{rng}}\index{Range}%
\index{\keyw{munion}}\index{Merge}\index{\texttt{++}!map override}\index{Override}%
\index{\keyw{merge}}\index{Distribute merge}\index{\texttt{<:}}\index{Domain restrict to}%
\index{\texttt{<-:}}\index{Domain restrict by}\index{\texttt{:>}}\index{Range restrict to}%
\index{\texttt{:->}}\index{Range restrict by}\index{\texttt{()}!map apply}\index{Map apply}%
\index{\keyw{comp}!map composition}\index{Map composition}\index{\texttt{**}}\index{Map iteration}%
\index{\texttt{=}!map equality}\index{Equality!map type}\index{\texttt{<>}!map inequality}\index{Inequality!map type}%
\index{\keyw{inverse}}\index{Map inverse}

\input{sem-maptypes}

\item[Examples:] Let 

  {\ttfamily\selectfont
  \begin{tabular}{l}
    m1 = \{ <France> |-> 9, <Denmark> |-> 4, \\
          \mbox{\hspace{3em}}  <SouthAfrica> |-> 2, <SaudiArabia> |-> 1\}, \\
    m2 = \{ 1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1 \}, \\
    Europe = \{ <France>, <England>, <Denmark>, <Spain> \}
  \end{tabular}}

  then:

  \begin{longtable}{lcl}
    \texttt{\keyw{dom} m1}           & $\equiv$ & 
       \texttt{\{}\parbox[t]{5.3cm}{%
           \texttt{<France>, <Denmark>,}\\
           \texttt{<SouthAfrica>, <SaudiArabia>\}}}\\
    \\
    \texttt{\keyw{rng} m1}           & $\equiv$ & \texttt{\{1,2,4,9\}}\\
    \\
    \texttt{m1 \keyw{munion} \{<England> |-> 3\}}
                                     & $\equiv$ & 
       \texttt{\{}%
       \parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4,\\
          <England> |-> 3, \\ 
          <SaudiArabia> |-> 1,\\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 ++ \{\parbox[t]{4cm}{\ttfamily\selectfont
       <France> |-> 8,\\ <England> |-> 4\}}}
                                     & $\equiv$ &
       \texttt{\{}%
           \parbox[t]{5.3cm}{\ttfamily\selectfont
              <France> |-> 8, \\
              <Denmark> |-> 4,\\
              <SouthAfrica> |-> 2, 
              <SaudiArabia> |-> 1,\\
              <England> |-> 4\}}\\
    \\
    
    \texttt{\keyw{merge}\{}
         \parbox[t]{5.7cm}{\ttfamily\selectfont
                 \{<France> |-> 9, \\
                   \mbox{\hspace{0.0cm}} <Spain> |-> 4\} \\
                 \{<France> |-> 9, \\
                    \mbox{\hspace{0.0cm}} <England> |-> 3, \\
                    \mbox{\hspace{0.0cm}} <UnitedStates> |-> 1\}\}}
                                     & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont%
         <France> |-> 9, \\
         <England> |-> 3, \\
         <Spain> |-> 4,\\
         <UnitedStates> |-> 1\}}\\ \\
    \\
    \texttt{Europe <: m1}            & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4\}}\\
    \\
    \texttt{Europe <-: m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <SouthAfrica> |-> 2,\\
          <SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 :> \{2,...,10\}}      & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4, \\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 :-> \{2,...,10\}}     & $\equiv$ &
       \texttt{\{<SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 \keyw{comp} (\{"France" |-> <France>\})}
                                     & $\equiv$ & 
       \texttt{\{"France" |-> 9\}}\\
    \\
    \texttt{m2 ** 3}                 & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 4, 2 |-> 1, \\
            3 |-> 2, 4 |-> 3 \}}\\
    \\
    \texttt{\keyw{inverse} m2}       & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            2 |-> 1, 3 |-> 2, \\
            4 |-> 3, 1 |-> 4 \}}\\
    \\
    \texttt{m2 \keyw{comp} (\keyw{inverse} m2)} & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 1, 2 |-> 2,\\
            3 |-> 3, 4 |-> 4 \}}
  \end{longtable}
\end{description}



\subsubsection{Product Types}\label{tuples}

The values of a product type are called tuples. A tuple is a fixed
length list where the i'th element of the tuple must belong to the
i'th element of the product type.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{product type} \dsep
    \ldots
    }

  \Rule{product type}{
    \Ruleref{type}, \Lop{{\tt *}}, \Ruleref{type}, \SeqPt{\Lop{{\tt *}}, \Ruleref{type}}
    }

  A product type consists of at least two subtypes.

\item[Equation:] {\tt T = A1 * A2 * \ldots\ * An}\index{\texttt{*}!tuple type}

\item[Constructors:] The tuple constructor: {\tt \keyw{mk\_}(a1, a2,
    \ldots, an)}\index{\keyw{mk\_}!tuple constructor}

    The syntax and semantics for the tuple constructor are given in
    section~\ref{tupexpr}. 
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    \texttt{t.\#n}   & Select     & \TO{\PROD{T}{\keyw{nat}}}{Ti}\\
    {\tt t1 = t2}  & Equality   & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!tuple equality}\index{Equality!tuple}\index{\texttt{<>}!tuple inequality}\index{Inequality!tuple}


  The only operators working on tuples are component select, equality
  and inequality. Tuple components may be accessed using the select
  operator or by matching against a tuple pattern. Details of the
  semantics of the tuple select operator and an example of its use are
  given in section \ref{app-expr}. 

\item[Examples:] Let {\tt a = \keyw{mk\_}(1, 4, 8)}, {\tt b =
    \keyw{mk\_}(2, 4, 8)} then:

  \begin{tabular}{lcl}
    {\tt a = b}     &$\equiv$& \keyw{false}\\
    {\tt a <> b}    &$\equiv$& \keyw{true}\\
    {\tt a = \keyw{mk\_}(2,4)} &$\equiv$& \keyw{false}\\
  \end{tabular}
\end{description}

\subsubsection{Composite Types}\label{records}

Composite types correspond to record types\index{record type} in programming languages.
Thus, elements of this type are somewhat similar to the tuples
described in the section about product types above. The difference
between the record type and the product type is that the different
components of a record can be directly selected by means of
corresponding selector functions. In addition records are tagged with
an identifier which must be used when manipulating the record. The
only way to tag a type is by defining it as a record. It is therefore
common usage to define records with only one field in order to give it
a tag. This is another difference to tuples as a tuple must have at
least two entries whereas records can be empty.

In \vdmslpp{\vdmsl,}{\vdmpp,} \keyw{is\_} is a reserved prefix for names
and it is used in an {\it is expression}. This is a built-in operator
which is used to determine which record type a record value belongs to.
It is often used to discriminate between the subtypes of a union type
and will therefore be explained further in section~\ref{unions}. In
addition to record types the \keyw{is\_} operator can also determine if
a value is of one of the basic types.
 
In the following this convention will be used: {\tt A} is a record
type, {\tt A1, \ldots, Am} are arbitrary types, {\tt r}, {\tt r1}, and
{\tt r2} are record values, {\tt i1, \ldots, im} are selectors from
the {\tt r} record value, {\tt e1, \ldots, em} are arbitrary
expressions.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{composite type} \dsep
    \ldots
    }
  
  \Rule{composite type}{
    \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list},
    \Lop{end}
    }
  
  \Rule{field list}{\SeqPt{\Ruleref{field}}}
  
  \Rule{field}{\OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type}
  \dsep  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }
  
  or the shorthand notation
  
  \Rule{composite type}{
    \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}}
  
  where identifier denotes both the type name and the tag name.

\item[Equation:]\mbox{}\label{a-type}
  \begin{alltt}
    A :: selfirst : A1
         selsec   : A2
  \end{alltt}%
\index{\texttt{::}}

  or

  \begin{alltt}
    A :: selfirst :  A1
         selsec   :- A2
  \end{alltt}%
\index{\texttt{:-}}

  or

  \begin{alltt}
    A :: A1 A2
  \end{alltt}

  In the second notation, an {\it equality abstraction\/} field
  \index{equality abstraction field} is
  used for the second field {\tt selsec}. The minus indicates that
  such a field is ignored when comparing records using the equality
  operator.  In the last notation the fields of {\tt A} can only be
  accessed by pattern matching (like it is done for tuples) as the
  fields have not been named.
  
  In the last notation the fields of {\tt A} can only be accessed by
  pattern matching (as is done for tuples) since the fields have not
  been named.

  The shorthand notation {\tt ::} used in the two previous examples
   where the tag name equals the type
  name, is the notation most used.
  The more general \keyw{compose} notation is typically used if a
  composite type has to be specified directly as a component of a more
  complex type:
  \begin{alltt}
    T = \keyw{map} S \keyw{to compose} A \keyw{of} A1 A2 \keyw{end}
  \end{alltt}
  It should be noted however that composite types can only be used in
  type definitions, and not e.g.\ in signatures to functions or
  operations. 

  Typically composite types are used as alternatives in a union type
  definition (see~\ref{unions}) such as:

  \begin{alltt}
   MasterA = A | B | ...
  \end{alltt}
  where \texttt{A} and \texttt{B} are defined as composite types
  themselves. In this situation the \keyw{is\_} predicate can be used
  to distingush the alternatives.

\item[Constructors:] The record constructor: {\tt \keyw{mk\_}A(a, b)} where
  {\tt a} belongs to the type {\tt A1} and {\tt b} belongs to the type {\tt
    A2}.

  The syntax and semantics for all record expressions are given in
  section~\ref{recexpr}.%
\index{\keyw{mk\_}!record constructor}

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt r.i} & Field select & \TO{\PROD{A}{Id}}{Ai} \\
    {\tt r1 = r2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt r1 <> r2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt \keyw{is\_}A(r1)} & Is & \TO{\PROD{Id}{MasterA}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{.}!record field selector}\index{Field select}%
\index{\texttt{=}!record equality}\index{Equality!record}\index{\texttt{<>}!record inequality}\index{Inequality!record}

\input{sem-comtypes}

\item[Examples:] Let \texttt{Score} be defined as
\begin{alltt}\label{scoredef}
   Score :: team : Team
            won : \keyw{nat}
            drawn : \keyw{nat}
            lost : \keyw{nat}
            points : \keyw{nat};
   Team = <Brazil> | <France> | ...
\end{alltt}
and let 

\begin{tabular}{l}
\texttt{sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9)}, \\
\texttt{sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4)},\\
\texttt{sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2)} and \\
\texttt{sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1)}.
\end{tabular}

\noindent%
Then

  \begin{tabular}{lcl}
    \texttt{sc1.team}            & $\equiv$ & \texttt{<France>}\\
    \texttt{sc4.points}          & $\equiv$ & \texttt{1}\\
    \texttt{sc2.points > sc3.points} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_}Score(sc4)} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(sc3)}
                                 & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_int}(sc1.won)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{sc4 = sc1}           & $\equiv$ & \keyw{false}\\
    \texttt{sc4 <> sc2}          & $\equiv$ & \keyw{true}  
  \end{tabular}

  The equality abstraction field, written using `{\tt :-}' instead of
  `{\tt :}', may be useful, for example, when working with lower level
  models of an abstract syntax of a programming language. For example,
  one may wish to add a position information field to a type of
  identifiers without affecting the true identity of identifiers:

\begin{alltt}
  Id :: name :  seq of char
        pos  :- nat
\end{alltt}

The effect of this will be that the {\tt pos} field is
ignored in equality comparisons, e.g.\
the following would evaluate to true:

\begin{alltt}
  mk_Id("x",7) = mk_Id("x",9)
\end{alltt}

In particular this can be useful when looking up in an environment
which is typically modelled as a map of the following form:

\begin{alltt}
  Env = map Id to Val
\end{alltt}

Such a map will contain at most one index for a specific identifier,
and a map lookup will be independent of the {\tt pos} field.

Moreover, the equality abstraction field will affect set expressions.
For example, 
\begin{alltt}
  \{mk_Id("x",7),mk_Id("y",8),mk_Id("x",9)\}
\end{alltt}

will be equal to

\begin{alltt}
  \{mk_Id("x",?),mk_Id("y",8)\}
\end{alltt}

where the question mark stands for 7 or 9.

Finally, note that for equality abstraction fields valid patterns are
limited to don't care and identifier patterns. Since equality
abstraction fields are ignored when comparing two values, it does not
make sense to use more complicated patterns.
\end{description}

\subsubsection{Union and Optional Types}\label{unions}

The union type corresponds to a set-theoretic union, i.e.\ the type
defined by means of a union type will contain all the elements from
each of the components of the union type. It is possible to use types
that are not disjoint in the union type, even though such usage
would be bad practice.  However, the union type is normally used when
something belongs to one type from a set of possible types.  The
types which constitute the union type are often composite types.  This
makes it possible, using the \keyw{is\_} operator, to decide which of
these types a given value of the union type belongs to.

The optional type {\tt [T]} is a kind of shorthand for a union type {\tt T |
  \keyw{nil}}, where \keyw{nil} is used to denote the absence of a
value. However, it is not possible to use the set {\tt \{\keyw{nil}\}}
as a type so the only types \keyw{nil} will belong to will be optional
types. 


\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{union type} \dsep
    \Ruleref{optional type} \dsep
    \ldots
    }
  
  \Rule{union type}{
    \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
    }
  
  \Rule{optional type}{\Lit{[}, \Ruleref{type}, \Lit{]}}

\item[Equation:] {\tt B = A1 | A2 | \ldots\ | An}%
\index{\texttt{|}!union type}\index{\texttt{[]}!optional type}

\item[Constructors:] None.

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!union equality}\index{Equality!union type}%
\index{\texttt{<>}!union inequality}\index{Inequality!union type}%
\index{\texttt{=}!optional equality}\index{Equality!optional type}%
\index{\texttt{<>}!optional inequality}\index{Inequality!optional type}


\item[Examples:] In this example {\tt Expr} is a union type whereas
  {\tt Const}, {\tt Var}, {\tt Infix} and {\tt Cond} are composite
  types defined using the shorthand {\tt ::} notation.

  \begin{alltt}\label{exprdef}
    Expr  = Const | Var | Infix | Cond;
    Const :: \keyw{nat} | \keyw{bool};
    Var   :: id:Id
             tp: [<Bool> | <Nat>];
    Infix :: Expr * Op * Expr;
    Cond  :: test : Expr
             cons : Expr
             altn : Expr
  \end{alltt}    
  and let {\tt expr = \keyw{mk\_}Cond(\keyw{mk\_}Var("b",<Bool>),%
    \keyw{mk\_}Const(3),}\\ {\tt \keyw{mk\_}Var("v",\keyw{nil}))} then:

  \begin{tabular}{lcl}\label{exprIsExs}
    {\tt \keyw{is\_}Cond(expr)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Const(expr.cons)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Var(expr.altn)}   &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Infix(expr.test)}  &$\equiv$& \keyw{false}\\
  \end{tabular}

  Using union types we can extend the use of previously defined
    operators. For instance, interpreting \texttt{=} as a test over
    \texttt{\keyw{bool} | \keyw{nat}} we have
 
 \begin{tabular}{lcl}
    \texttt{1 = \keyw{false}}    & $\equiv$ & \keyw{false}
  \end{tabular}

  Similarly we can take use union types for taking unions of sets and
    concatenating sequences:
  
  \begin{tabular}{lcl}
     \texttt{ \{1,2\} \keyw{union} \{\keyw{false},\keyw{true}\}}
                                 & $\equiv$ & 
        \texttt{\{1,2, \keyw{false},\keyw{true}\}}\\
     \texttt{ ['a','b']\char'136 [<c>,<d>]}
                                 & $\equiv$ &
        \texttt{['a','b', <c>,<d>]}
  \end{tabular}

  In the set union, we take the union over sets of type
    \texttt{\keyw{nat} | \keyw{bool}}; for the sequence concatenation
    we are manipulating sequences of type \texttt{\keyw{char} | <c> |
    <d>}. 
\end{description}

#ifdef VDMPP
\subsubsection{The Object Reference Type}

The object reference type has been added as part of the standard
\vdmsl\ types. Therefore there is no direct way of restricting the use
of object reference types (and thus of objects) in a way that conforms
to pure object oriented principles; no additional structuring
mechanisms than classes are foreseen. From these principles it follows
that the use of an object reference type in combination with a type
constructor (record, map, set, etc.) should be treated with caution.

A value of the object reference type can be regarded as a {\em
reference} to an object.  If, for example, an instance variable (see
section \ref{sec:ivars}) is defined to be of this type, this makes the
class in which that instance variable is defined, a `client' of the
class in the object reference type; a {\em clientship relation} is
established between the two classes.

An object reference type is denoted by a class name.  The class name
in the object reference type must be the name of a class defined in
the specification.

The only operators defined for values of this type is the test for
equality (\Lit{=}) and inequality (\Lit{<>}). Equality is based on references rather than
values. That is, if \texttt{o1} and \texttt{o2} are two distinct
objects which happen to have the same contents, \texttt{o1 = o2} will
yield false.

\begin{description}
\item[Constructors] Object references are constructed using the new
expression (see section \ref{sec:creation}).

\item[Operators]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}

\item[Examples]
An example of the use of object references is in the definition of the
class of binary trees:
\begin{alltt}\label{TreeDef}
class Tree

  types

    \PROTECTED tree = <Empty> | node;
    
    \PUBLIC node :: lt: Tree
                   nval : int
                   rt : Tree

 instance variables
    \PROTECTED root: tree := <Empty>;
end Tree
\end{alltt}
Here we define the type of nodes, which consist of a node value, and
references to left and right tree objects.
#ifdef VDMPP
Details of access specifiers may be found in section
\ref{ch:interface}.
#endif VDMPP
\end{description}

#endif VDMPP

\subsubsection{Function Types}

In \vdmslpp{\vdmsl}{\vdmpp} function types can also be used in type
definitions.  A function type from a type {\tt A} (actually a list of
types) to a type {\tt B} is a type that associates with each element
of {\tt A} an element of {\tt B}. A function value can be thought of
as a function in a programming language which has no side-effects
(i.e.\ it does not use any global variables).

Such usage can be considered advanced in the sense
that functions are used as values (thus this section
may be skipped during the first reading). Function values may be created by
lambda expressions (see below), or by function definitions, which are
described in section~\ref{functiondef}.  Function values can be of
higher order in the sense that they can take functions as arguments or
return functions as results. In this way functions can be Curried such
that a new function is returned when the first set of parameters are
supplied (see the examples below).

%Type definitions may not be recursive {\it through} function types, though
%they may be recursive {\it over} them. That is, no chain of
%definitions derived from a set of recursive type definitions from a
%type back to itself may pass through a function type operator (see the
%next subsection for more information about recursive type
%definitions). Thus, a type definition like {\tt A = A -> A |
%\keyw{bool}} is illegal while a type definition like: {\tt A = A * A |
%(\keyw{nat} -> \keyw{nat})} is legal.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{partial function type} \dsep
    \ldots
    }
  
  \Rule{function type}{
    \Ruleref{partial function type} \dsep
    \Ruleref{total function type}
    }

  \Rule{partial function type}{
    \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}}
  
  \Rule{total function type}{
    \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}}
  
  \Rule{discretionary type}{\Ruleref{type} \dsepl \Lit{(},\Lit{)}} 
  
\item[Equation:] {\tt F = A +> B}\footnote{Note that the total
function arrow can only be used in signatures of totally defined
functions and thus not in a type definition.} or {\tt F = A -> B}%
\index{\texttt{->}}\index{\texttt{+>}}

\item[Constructors:] In addition to the traditional function
  definitions the only way to construct functions is by the lambda
  expression: {\tt \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& body}
  where the {\tt patj} are patterns, the {\tt Tj} are type expressions, and
  {\tt body} is the body expression which may use the pattern
  identifiers from all the patterns.

  The syntax and semantics for the lambda expression are given in
  section~\ref{lambda}.
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt f(a1,\ldots,an)} & Function apply & \TO{A1 * \cdots * An}{B} \\
    {\tt f1 \keyw{comp} f2}& Function composition & \TO{\PROD{(\FUN{B}{C})}{(\FUN{A}{B})}}{(\FUN{A}{C})} \\
    {\tt f ** n} & Function iteration & \TO{\PROD{(\FUN{A}{A})}{\keyw{nat}}}{(\FUN{A}{A})} \\
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!function equality}\index{Equality!function type}\index{\texttt{<>}!function inequality}\index{Inequality!function type}%
\index{\keyw{comp}!function composition}\index{Function composition}%
\index{\texttt{**}!function iteration}\index{Function iteration}%
\index{\texttt{()}!function apply}\index{Function apply}
  
  Note that equality and inequality between type values should be used
  with great care. In \vdmslpp{\vdmsl}{\vdmpp}\ this corresponds to the
  mathematical equality (and inequality) which is not computable for
  infinite values like general functions. Thus, in the
  interpreter the
  equality is on the abstract syntax of the function value (see {\tt
    inc1} and {\tt inc2} below).

\input{sem-functypes}

\item[Examples:] Let the following function values be defined:
  \begin{alltt}
    f1 = \keyw{lambda} x : \keyw{nat} \& \keyw{lambda} y : \keyw{nat} \& x + y
    f2 = \keyw{lambda} x : \keyw{nat} \& x + 2
    inc1 = \keyw{lambda} x : \keyw{nat} \& x + 1
    inc2 = \keyw{lambda} y : \keyw{nat} \& y + 1
  \end{alltt}
  then the following holds:
  
  \begin{tabular}{lcl}
    {\tt f1(5)} &$\equiv$& {\tt \keyw{lambda} y :\keyw{nat} \& 5 + y}\\
    {\tt f2(4)} &$\equiv$& {\tt 6}\\
    {\tt f1 \keyw{comp} f2}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \&
      \keyw{lambda} y :\keyw{nat} \& (x + 2) + y}\\
    {\tt f2 ** 4}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \& x + 8}\\
    {\tt inc1 = inc2}&$\equiv$& \keyw{false}\\
  \end{tabular}
  
  Notice that the equality test does not yield the expected result with
  respect to the semantics of \vdmslpp{\vdmsl}{\vdmpp}. Thus, one should
  be {\bf very} careful with the usage of equality for infinite values
  like functions.
\end{description}

%\subsection{Recursive Types}
%
%In the data type equations given so far we have only used the equations in
%a hierarchical manner (the data type identifiers occurring on the
%right-hand-side in the equations have already been defined).  However,
%there are occasions when it is appropriate to use a collection of
%equations which are mutually recursive. 
%
%Without going into the mathematical details about how such recursive
%equations are solved, it will shortly be explained what they denote and how
%their usage must be restricted. We define that the semantics of such a
%collection of mutually recursive equations is that the data types become
%the set of all those values which can be constructed by using the equations
%a finite number of times. Thus, types containing infinite values cannot be
%constructed by means of recursive definitions.
%
%In order to achieve this, the recursive equations need to fulfill two
%requirements:
%\begin{enumerate}
%\item There must exist at least one alternative in a union type which is
%  fully defined elsewhere (a so-called base case).
%
%\item It must not be possible for a data value to belong to two different
%  alternatives in a union type. Thus, for recursive equations the
%  alternatives in union types must be disjunct.
%\end{enumerate}
%If these two requirements are fulfilled then the recursive type definitions
%are interpreted as the collection of finite values which are constructed by
%a finite number of steps in this process.
%
%To illustrate the use of recursive type definitions here is an example
%modelling a forest using recursive type definitions.
%
%\begin{alltt}
%  Forest = Forest * Node * Forest;
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent It is clear that the first requirement (1) cannot be fulfilled,
%because there is no base case for the forest type. Thus, these type
%definitions only specify infinite forests, and thus are not valid in
%\vdmslpp{\vdmsl}{\vdmpp}.
%
%Let us try to repair this by letting a node be the base case in the
%first definition:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent However, these two definitions do not fulfill the second
%requirement. This can be seen from the fact that a forest can be a node, and that
%node in turn can be a forest, etc. In this case it is not possible to say
%which alternative a given value belongs to. Thus, these definitions are
% not valid in \vdmslpp{\vdmsl}{\vdmpp}\ either.
%
%Now let us try to repair it by letting the base case be empty (i.e.\ 
%a nil value):
%
%\begin{alltt}
%  Forest = [Forest * Node * Forest];
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent These definitions are valid, but they specify something slightly
%different than the intention behind the definitions above. With these
%definitions an empty forest exists, and this is not the case for the
%definitions above.
%
%Finally we try to repair it by means of tagging:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node :: \keyw{nat} | Forest
%\end{alltt}
%
%\noindent By making {\tt Node} a composite type, the definitions are valid,
%because the second requirement is also fulfilled here, due to tagging of
%the node. With these definitions an empty forest will not exist.
%
\subsection{Invariants}

If the data types specified by means of equations as described above
contain values which should not be allowed, then it is possible to restrict
the values in a type by means of an invariant. The result is that the type
is restricted to a subset of its original values. Thus, by means of a
predicate the acceptable values of the defined type are limited to those
where this expression is true.

The general scheme for using invariants looks like this:

\begin{alltt}
  Id = Type
  \keyw{inv} pat == expr
\end{alltt}

\noindent where {\tt pat} is a pattern matching the values belonging to the type
{\tt Id}, and {\tt expr} is a truth-valued expression, involving some or
all of the identifiers from the pattern {\tt pat}.

If an invariant is defined, a new (total) function is implicitly
created with the signature:
\begin{alltt}
  \keyw{inv\_}Id : Type +> \keyw{bool}
\end{alltt}
This function can be used within other invariant, function or operation
definitions.

For instance, recall the record type \texttt{Score} defined on page
\pageref{scoredef}. We can ensure that the number of points awarded
is consistent with the number of games won and drawn using an invariant:
\begin{alltt}
  Score :: team : Team
           won : nat
           drawn : nat
           lost : nat
           points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn;
\end{alltt}
The invariant function implicitly created for this type is:
\begin{alltt}
  \keyw{inv\_}Score : Score +> \keyw{bool}
  \keyw{inv\_}Score (sc) == 
    sc.points = 3 * sc.won + sc.drawn;
\end{alltt}

\section{Algorithm Definitions}
\label{algorithm}


In \vdmslpp{\vdmsl}{\vdmpp} algorithms can be defined by both
functions and operations.  However, they do not directly correspond to
functions in traditional programming languages. What separates
functions from operations in \vdmslpp{\vdmsl}{\vdmpp} is the use of
local and global variables. Operations can manipulate both the global
variables and any local variables.  Both
local and global variables will be described later. Functions are pure in
the sense that they cannot access global variables and they are not
allowed to define local variables. Thus, functions are purely
applicative while operations are imperative.

Functions and operations can be defined both explicitly (by means of
an explicit algorithm definition) or implicitly (by means of a
pre-condition and/or a post condition).  An explicit algorithm
definition for a function is called an expression while for an
operation it is called a statement.  A pre-condition is a truth-valued
expression which specifies what must hold before the
function/operation is evaluated. A pre-condition can only refer to
parameter values and global variables (if it is an operation).  A
post-condition is also a truth valued expression which specifies what
must hold after the function/operation is evaluated. A post-condition
can refer to the result identifier, the parameter values, the current
values of global variables and the old values of global variables. The
old values of global variables are the values of the variables as they
were before the operation was evaluated.  Only operations can refer to
the old values of global variables in a post-condition as functions
are not allowed to change the global variables.

However, in order to be able to execute both functions and operations
by the interpreter they must be defined explicitly\footnote{Implicitly
specified functions and operations cannot in general be executed
because their post-condition does not need to directly relate the
output to the input. Often it is done by specifying the properties the
output must satisfy.}. In \vdmslpp{ VDM-SL}{\vdmpp} it is also
possible for explicit function and operation definitions to specify an
additional pre- and a post-condition.  In the post-condition of 
explicit function and operation definitions the result value must be
referred to by the reserved word \keyw{RESULT}.
 
\section{Function Definitions}\label{functiondef}

In \vdmslpp{ VDM-SL}{\vdmpp} we can define first order and higher order
functions. A higher order function is either a Curried function
(a function that returns a function as result), or a function that takes
functions as arguments. Furthermore, both first order and higher order
functions can be polymorphic. In general, the syntax for the definition of a
function is:

\Rule{function definitions}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}}, 
         \OptPt{\Lit{;}}
        }
  }

\ifthenelse{\boolean{VDMpp}}{
  \Rule{access function definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{function definition}
  }}{}


\ifthenelse{\boolean{VDMpp}}{
  \Rule{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Rule{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }

\Rule{explicit function definition}{
  \Ruleref{identifier}, 
\lfeed
  \OptPt{\Ruleref{type variable list}}, 
  \Lit{:}, \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \Lit{$==$}, \lfeed
  \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{name}}
  }                                 

\Rule{implicit function definition}{
  \Ruleref{identifier}, 
  \OptPt{\Ruleref{type variable list}},\lfeed
  \Ruleref{parameter types}, \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
}

\Rule{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types},\lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}

\Rule{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }

\Rule{identifier type pair list}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{identifier}, \Lit{:}, \Ruleref{type}}
}

\Rule{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Rule{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Rule{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Rule{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Rule{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{(},\Lit{)}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern},\SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{function body}{
  \Ruleref{expression} \dsep 
#ifdef VDMPP
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!functions}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
#endif VDMSL
  }

Here \keyw{is not yet specified} may be used as the function body
during development of a model%
#ifdef VDMSL
.
#endif VDMSL
#ifdef VDMPP
; \keyw{is subclass responsibility} indicates that implementation of
this body must be undertaken by any subclasses.
#endif VDMPP

#ifdef VDMPP
Details of the access and \keyw{static} specifiers can be found in
section \ref{ch:interface}. Note that a static function may not call
non-static operations or functions, and self expressions cannot be
used in the definition of a static function.
#endif VDMPP

A simple example of an explicit function definition is the function
\texttt{map\_inter} which takes two compatible maps over natural
numbers and returns those maplets common to both
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
Note that we could also use the optional post condition to allow
assertions about the result of the function:
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} \keyw{RESULT} = \keyw{dom} m1 \keyw{inter} \keyw{dom} m2
\end{alltt}

The same function can also be defined implicitly:
\begin{alltt}
  map_inter2 (m1,m2: \keyw{map nat to nat}) m: \keyw{map nat to nat}
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} m = \keyw{dom} m1 \keyw{inter dom} m2 and
       \keyw{forall} d \keyw{in set dom} m & m(d) = m1(d);
\end{alltt}

A simple example of an extended explicit function definition
(non-standard) is the function \texttt{map\_disj} which takes a pair of
compatible maps over natural numbers and returns the map consisting of
those maplets unique to one or other of the given maps:

\begin{alltt}\label{mapdisj}
  map_disj (m1:\keyw{map nat to nat},m2:\keyw{map nat to nat}) res : \keyw{map nat to nat} ==
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m1 \keyw{munion}
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} res = (\keyw{dom} m1 \keyw{union dom} m2) \verb+\+ (\keyw{dom} m1 \keyw{inter dom} m2) 
       and
       \keyw{forall} d \keyw{in set dom} res & res(d) = m1(d) or res(d) = m2(d)
\end{alltt}
(Note here that an attempt to interpret the post-condition could
potentially result in a run-time error since \texttt{m1(d)} and
\texttt{m2(d)} need not both be defined simultaneously.)

The functions {\tt map\_inter} and {\tt map\_disj} can be evaluated by the
interpreter, but the implicit function {\tt map\_inter2} cannot be evaluated.
However, in all three cases the pre- and post-conditions can be used
in other functions; for instance from the definition of
\texttt{map\_inter2} we get functions \texttt{\keyw{pre\_}map\_inter2}
and \texttt{\keyw{post\_}map\_inter2} with the following signatures:

\begin{alltt}
  \keyw{pre\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) +> \keyw{bool}
  \keyw{post\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) *
                   (\keyw{map nat to nat}) +> \keyw{bool}
\end{alltt}
These kinds of functions are automatically created by the
interpreter and they can be used in other definitions (this technique
is called quoting). In general, for a function \texttt{f} with
signature
\begin{alltt}
  f : T1 * ... * Tn -> Tr
\end{alltt}
defining a pre-condition for the function causes creation of a
function \texttt{\keyw{pre\_}f} with signature
\begin{alltt}
  \keyw{pre\_}f : T1 * ... * Tn +> bool
\end{alltt}
and defining a post-condition for the function causes creation of a
function \texttt{\keyw{post\_}f} with signature
\begin{alltt}
  \keyw{post\_}f : T1 * ... * Tn * Tr +> bool
\end{alltt}

Functions can also be defined using recursion (i.e.\ by calling
themselves). When this is done one is recommended to add
a \Lop{measure} function that can be used in the proof obligations
generated from the model such that termination proofs can be carried
out. A simple example here could be the traditional factorial function
defined as:
\begin{alltt}
functions

fac: nat +> nat
fac(n) ==
  if n = 0
  then 1
  else n * fac(n - 1)
measure id
\end{alltt}
where \texttt{id} would be defined as:
\begin{alltt}
id: nat +> nat
id(n) == n
\end{alltt}

\subsection{Polymorphic Functions}

Functions can also be polymorphic. This means that we can create
generic functions that can be used on values of several different
types. For this purpose type parameters (or type variables which are
written like normal identifiers prefixed with a {\tt @} sign) are
used. Consider the polymorphic function to create an empty
bag:\footnote{The examples for polymorphic functions are taken from
\cite{Dawes91}. Bags are modelled as maps from the elements to their
multiplicity in the bag. The multiplicity is at least 1, i.e.\ a
non-element is not part of the map, rather than being mapped to 0.}
\begin{alltt}
  empty_bag[@elem] : () +> (\keyw{map} @elem \keyw{to nat1})
  empty_bag() ==
    \{ |-> \}
\end{alltt}
Before we can use the above function, we have to instantiate the
function {\tt empty\_bag} with a type, for example integers (see also
section~\ref{app-expr}):
\begin{alltt}
  emptyInt = empty_bag[int]
\end{alltt}
Now we can use the function {\tt emptyInt} to create a new bag to store
integers. More examples of polymorphic functions are:
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    \keyw{if} e \keyw{in set dom} m
    \Keyw{then} m(e)
    \Keyw{else} 0;

  plus_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> (\keyw{map} @elem \keyw{to nat1})
  plus_bag(e, m) ==
    m ++ \{ e |-> num_bag[@elem](e, m) + 1 \}
\end{alltt} 
If pre- and or post-conditions are defined for polymorphic functions, the
corresponding predicate functions are also polymorphic. For instance
if \texttt{num\_bag} was defined as
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    m(e)
  \Keyw{pre} e \keyw{in set dom} m
\end{alltt}
then the pre-condition function would be
\begin{alltt}
  \keyw{pre\_}num_bag[@elem] :@elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{bool}
\end{alltt}

In case functions are defined polymorphic a \keyw{measure} should also be
used.

\subsection{Higher Order Functions}

Functions are allowed to receive other functions as arguments. A
simple example of this is the function \texttt{nat\_filter} which
takes a sequence of natural numbers, and a predicate, and returns the
subsequence that satisfies this predicate:
\begin{alltt}
  nat_filter : (\keyw{nat} -> \keyw{bool}) * \keyw{seq of nat} -> \keyw{seq of nat}
  nat_filter (p,ns) ==
    [ns(i) | i \keyw{in set inds} ns & p(ns(i))];
\end{alltt}
Then 
  \texttt{nat\_filter (\keyw{lambda} x:\keyw{nat} \& x \keyw{mod} 2 = 0, [1,2,3,4,5])} $\equiv$ \texttt{[2,4]}.
In fact, this algorithm is not specific to natural numbers, so we may
define a polymorphic version of this function:
\begin{alltt}\label{filterdef}
  filter[@elem]: (@elem -> \keyw{bool}) * \keyw{seq of} @elem -> \keyw{seq of} @elem
  filter (p,l) ==
    [l(i) | i \keyw{in set inds} l & p(l(i))];
\end{alltt}
so \texttt{filter[\keyw{real}](\keyw{lambda} x:\keyw{real} \&
  \keyw{floor} x = x, [2.3,0.7,-2.1,3])} $\equiv$  \texttt{[3]}.


Functions may also return functions as results. An example of this is
the function \texttt{fmap}:
\begin{alltt}
  fmap[@elem]: (@elem -> @elem) -> \keyw{seq} of @elem -> \keyw{seq} of @elem
  fmap (f)(l) ==
    \keyw{if} l = []
    \keyw{then} []
    else [f(\keyw{hd} l)]\verb+^+(fmap[@elem] (f)(\keyw{tl} l));
\end{alltt}
So \texttt{fmap[\keyw{nat}](\keyw{lambda} x:\keyw{nat} \& x * x)([1,2,3,4,5])} $\equiv$ 
\texttt{[ 1,4,9,16,25 ]}

\section{Expressions}

In this subsection we will describe the different kinds of expressions
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\subsection{Let Expressions}\label{let-exp}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \Ruleref{let expression} \dsep
    \Ruleref{let be expression} \dsep
    \ldots
    }

  \Rule{let expression}{
    \Lop{let}, 
    \Ruleref{local definition}
    \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{expression}
    }

  \Rule{let be expression}{ 
    \Lop{let}, \Ruleref{bind},
    \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
    \Ruleref{expression}
    } 

  \Rule{local definition}{
    \Ruleref{value definition} \dsep
    \Ruleref{function definition}
    }

  \Rule{value definition}{ 
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  \noindent where the ``function definition'' component is described in
  section~\ref{functiondef}.

\item[Semantics:] A simple {\it let expression} has the form:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} e
  \end{alltt}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding pattern {\tt pi}, and
  {\tt e} is an expression, of any type, involving the pattern
  identifiers of {\tt p1, \ldots, pn}. It denotes the value of the
  expression {\tt e} in the context in which the patterns {\tt p1,
    \ldots, pn} are matched against the corresponding expressions {\tt
    e1, \ldots, en}.

  More advanced let expressions can also be made by using local
  function definitions. The semantics of doing so is simply that the
  scope of such locally defined functions is restricted to the body of
  the let expression.

  In standard \vdmsl\ the collection of definitions may be mutually
  recursive.  However, in  \vdmslpp{\vdmsl}{\vdmpp} this is not
  supported by the interpreter.  Furthermore, the definitions must be
  ordered such that all constructs are defined before they are used.
     
  A {\it let-be-such-that expression} has the form:
  \begin{alltt}
    \keyw{let} b \keyw{be st} e1 \keyw{in} e2
  \end{alltt}%
  where {\tt b} is a binding of a pattern to a set value (or a type),
  {\tt e1} is a boolean expression, and {\tt e2} is an expression, of
  any type, involving the pattern identifiers of the pattern in {\tt
    b}. The {\tt \keyw{be st} e1} part is optional. The expression
  denotes the value of the expression {\tt e2} in the context in which
  the pattern from {\tt b} has been matched against either an element
  in the set from {\tt b} or against a value from the type in {\tt b}%
  \footnote{Remember that only the set bindings can be executed by
    means of the interpreter.}.
  If the {\tt \keyw{st} e1} expression is present, only such bindings
  where {\tt e1} evaluates to true in the matching context are used.

\item[Examples:] {\it Let expressions} are useful for improving
  readability especially by contracting complicated expressions used
  more than once. For instance, we can improve the function
  \texttt{map\_disj} from page \pageref{mapdisj}:
\begin{alltt}
  map_disj : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_disj (m1,m2) ==
    \keyw{let} inter_dom = \keyw{dom} m1 \keyw{inter dom} m2
    \keyw{in}
      inter_dom <-: m1 \keyw{munion}
      inter_dom <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
  They are also convenient for decomposing complex
  structures into their components. For instance, using the previously
  defined record type \texttt{Score} (page \pageref{scoredef}) we can
  test whether one score is greater than another:
  \begin{alltt}
    \keyw{let} \keyw{mk\_}Score(-,w1,-,-,p1) = sc1,
       \keyw{mk\_}Score(-,w2,-,-,p2) = sc2
    \keyw{in} (p1 > p2) \keyw{or} (p1 = p2 \keyw{and} w1 > w2)
  \end{alltt}
  In this
  particular example we extract the second and fifth components of the
  two scores. Note that don't care
  patterns (page \pageref{patterns}) are used to indicate that the
  remaining components are irrelevant 
  for the processing done in the body of this expression.
  
  {\it Let-be-such-that expressions} are useful for abstracting away
  the non-essential choice of an element from a set, in particular in
  formulating recursive definitions over sets. An example of this is a
  version of the sequence filter function (page \pageref{filterdef})
  over sets:\label{setfilterdef}
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \keyw{if} s = \{\}
      \keyw{then} \{\}
      \keyw{else let} x \keyw{in set} s
          \keyw{in} (\keyw{if} p(x) \keyw{then} \{x\} \keyw{else} \{\}) \keyw{union}
             set_filter[@elem](p)(s \verb+\+ \{x\});
   \end{alltt}
   We could alternatively have defined this function using a set
  comprehension (described in section \ref{setexpr}):
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \{ x | x \keyw{in set} s & p(x)\};
  \end{alltt} 

   The last example shows how the optional ``be such that'' part
   (\keyw{be st}) can be used. This part is especially useful when it
   is known that an element with some property exists but an explicit
   expression for such an element is not known or difficult to
  write. For instance we can exploit this expression to write a
  selection sort algorithm:
   \begin{alltt}\label{selectionSortdef}
   remove : \keyw{nat} * \keyw{seq of nat} -> \keyw{seq of nat}
   remove (x,l) ==
     \keyw{let} i \keyw{in set inds} l \keyw{be st} l(i) = x
     \keyw{in} l(1,...,i-1)\verb+^+l(i+1,...,\keyw{len} l)
   \Keyw{pre} x \keyw{in set elems} l;

   selection_sort : \keyw{seq of nat} -> \keyw{seq of nat}
   selection_sort (l) ==
     \keyw{if} l = []
     \keyw{then} []
     \keyw{else let} m \keyw{in set elems} l \keyw{be st}
         \keyw{forall} x \keyw{in set elems} l & m <= x
         \keyw{in} [m]\verb+^+(selection_sort (remove(m,l)))
   \end{alltt}
   Here the first function removes a given element from the given
   list; the second function repeatedly removes the least element in
   the unsorted portion of the list, and places it at the head of the
   sorted portion of the list.
\end{description}

\subsection{The Define Expression} \label{define-exp}

This expression can only be used inside operations which will be
described in section~\ref{op-def}. In order to deal with global variables
inside the expression part an extra expression construct is available
inside operations.

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{def expression} \dsep
    \ldots
    }

\Rule{def expression}{
  \Lop{def}, 
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  } 

\item[Semantics:] A {\it define expression} has the form:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \Keyw{in}
      e
  \end{alltt}
  The {\it define expression} corresponds to a let expression except
  that the right hand side expressions may depend on the value of the
  local and/or
  global variable and that it may not be mutually recursive.
  It denotes the value of the expression {\tt e} in the
  context in which the patterns (or binds) {\tt pb1, \ldots, pbn} are
  matched against the corresponding expressions {\tt e1, \ldots,
    en}\footnote{If binds are used, it simply means that the values
    which can match the pattern are further constrained by the type or
    set expression as explained in section~\ref{patterns}.}.

\item[Examples:] The {\it define expression} is
  used in a pragmatic way, in order to make the reader aware of the fact that
  the value of the expression depends upon the global variable.

  This can be illustrated by a small example:
  \begin{alltt}
    \Keyw{def} user = lib(copy) \keyw{in}
      \keyw{if} user = <OUT>
      \Keyw{then} \keyw{true}
      \Keyw{else} \keyw{false}
  \end{alltt}      
  where {\tt copy} is defined in the context, {\tt lib} is global
  variable (thus {\tt lib(copy)} can be considered as looking up the
  contents of a part of the variable).

  The operation \texttt{GroupRunnerUp\_expl} in section \ref{letstmt}
  also gives an example of a define expression.
\end{description}

\subsection{Unary and Binary Expressions}\label{unandbin}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{unary expression} \dsep \Ruleref{binary expression} \dsep \ldots
    }

\Rule{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Rule{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

  \Rule{unary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lop{abs} \dsepl
    \Lop{floor} \dsepl \Lop{not} \dsep
    \Lop{card} \dsepl \Lop{power} \dsepl \Lop{dunion} \dsepl
    \Lop{dinter} \dsep
    \Lop{hd} \dsepl \Lop{tl} \dsepl \Lop{len} \dsepl \Lop{elems} \dsepl
    \Lop{inds} \dsepl \Lop{conc} \dsep
    \Lop{dom} \dsepl \Lop{rng} \dsepl \Lop{merge} 
    }

\Rule{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

  \Rule{binary expression}{
    \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}}

  \Rule{binary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lit{*} \dsepl \Lit{/} \dsep
    \Lop{rem} \dsepl \Lop{div} \dsepl \Lop{mod} \dsepl \Lit{**} \dsep
    \Lop{union} \dsepl \Lop{inter} \dsepl \Lit{\char'134} \dsepl
    \Lop{subset} \dsep
    \Lop{psubset} \dsepl \Lop{in set} \dsepl \Lop{not in set} \dsep
    \Lit{\char'136} \dsep
    \Lit{++} \dsepl \Lop{munion} \dsepl \Lit{<:} \dsepl \Lit{<-:} \dsepl \Lit{:>} \dsepl \Lit{:->} \dsep
    \Lop{and} \dsepl \Lop{or} \dsep
    \Lit{=>} \dsepl \Lit{<=>} \dsepl \Lit{=} \dsepl \Lit{<>} \dsep
    \Lit{<} \dsepl \Lit{<=} \dsepl \Lit{>} \dsepl \Lit{>=} \dsep
    \Lop{comp}
    }

\item[Semantics:] Unary and binary expressions are a combination of
  operands and operators denoting a value of a specific type. The
  signature of all these operators is already given in
  section~\ref{typedef}, so no further explanation will be provided
  here. The map inverse unary operator is treated separately because
  it is written with postfix notation in the mathematical syntax.

\item[Examples:] Examples using these operators were given in
  section~\ref{typedef}, so none will be provided here.
\end{description}

\subsection{Conditional Expressions}
\label{if-exp} \label{cases-exp}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{if expression} \dsep \Ruleref{cases expression} \dsep \ldots
    }

  \Rule{if expression}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
    \SeqPt{\Ruleref{elseif expression}}, \Lop{else}, \Ruleref{expression}
    }

  \Rule{elseif expression}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
    }
                     
  \Rule{cases expression}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases expression alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
    }

  \Rule{cases expression alternatives}{
    \Ruleref{cases expression alternative},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
    }

  \Rule{cases expression alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
    } 

  \Rule{others expression}{
    \Lop{others}, \Lit{->}, \Ruleref{expression}
    }

\item[Semantics:] {\it If expressions} and {\it cases expressions}
  allow the choice of one from a number of expressions on the basis of
  the value of a particular expression.

  The {\it if expression} has the form:
  \begin{alltt}
    \keyw{if} e1
    \Keyw{then} e2
    \Keyw{else} e3
  \end{alltt}
  where {\tt e1} is a boolean expression, while {\tt e2} and {\tt e3}
  are expressions of any type. The if expression denotes the value of
  {\tt e2} evaluated in the given context if {\tt e1} evaluates to
  true in the given context. Otherwise the if expression denotes the
  value of {\tt e3} evaluated in the given context. The use of an
  \keyw{elseif} expression is simply a shorthand for a nested if then
  else expression in the \keyw{else} part of the expression.

  The {\it cases expression} has the form
  \begin{alltt}
    \keyw{cases} e :
      p11, p12, ..., p1n -> e1,
      ...                -> ...,
      pm1, pm2, ..., pmk -> em,
      \Keyw{others}             -> emplus1
    \keyw{end}
  \end{alltt}
  where {\tt e} is an expression of any type, all {\tt pij}'s are patterns
  which are matched one by one against the expression {\tt e}.  The {\tt
    ei}'s are expressions of any type, and the keyword \keyw{others} and
  the corresponding expression {\tt emplus1} are optional. The cases
  expression denotes the value of the {\tt ei} expression evaluated in the
  context in which one of the {\tt pij} patterns has been matched against
  {\tt e}. The chosen {\tt ei} is the first entry where it has been
  possible to match the expression {\tt e} against one of the patterns. If
  none of the patterns match {\tt e} an \keyw{others} clause must be
  present, and then the cases expression denotes the value of {\tt emplus1}
  evaluated in the given context.
     
\item[Examples:] The if expression in \vdmslpp{\vdmsl}{\vdmpp}\ 
  corresponds to what is used in most programming languages, while the
  cases expression in \vdmslpp{\vdmsl}{\vdmpp}\ is more general than
  most programming languages. This is shown by the fact that real
  pattern matching is taking place, but also because the patterns do not
  have to be constants as in most programming languages.

  An example of the use of conditional expressions is provided by the
  specification of the mergesort algorithm:
  \begin{alltt}
  lmerge : \keyw{seq of nat} * \keyw{seq of nat} -> \keyw{seq of nat}
  lmerge (s1,s2) ==
    \keyw{if} s1 = [] \keyw{then} s2
    \keyw{elseif} s2 = [] \keyw{then} s1
    \keyw{elseif} (\keyw{hd} s1) < (\keyw{hd} s2)
    \keyw{then} [\keyw{hd} s1]\verb+^+(lmerge (\keyw{tl} s1, s2))
    \keyw{else} [\keyw{hd} s2]\verb+^+(lmerge (s1, \keyw{tl} s2));

  mergesort : \keyw{seq of nat} -> \keyw{seq of nat}
  mergesort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      l1\verb+^+l2 -> lmerge (mergesort(l1), mergesort(l2))
    \keyw{end}
  \end{alltt}
The pattern matching provided by cases expressions is useful for
  manipulating members of type unions. For instance, using the type
  definition \texttt{Expr} from page \pageref{exprdef} we have:
  \begin{alltt}\label{printExprDef}
  print_Expr : Expr -> \keyw{seq1 of char}
  print_Expr (e) ==
    \keyw{cases} e:
      \keyw{mk\_}Const(-) -> "Const of"\verb+^+(print_Const(e)),
      \keyw{mk\_}Var(id,-) -> "Var of"\verb+^+id,
      \keyw{mk\_}Infix(\keyw{mk\_}(e1,op,e2)) -> "Infix of"\verb+^+print_Expr(e1)^","
                                      \verb+^+print_Op(op)\verb+^+","
                                      \verb+^+print_Expr(e2),
      \keyw{mk\_}Cond(t,c,a) -> "Cond of"\verb+^+print_Expr(t)\verb+^+","
                                 \verb+^+print_Expr(c)\verb+^+","
                                 \verb+^+print_Expr(a)
    end;

  print_Const : Const -> \keyw{seq1 of char}
  print_Const(\keyw{mk\_}Const(c)) ==
    \keyw{if} \keyw{is\_nat}(c)
    \keyw{then} "nat"
    \keyw{else} -- must be bool
         "bool";
  \end{alltt}
  The function \texttt{print\_Op} would be defined similarly.
\end{description}

\subsection{Quantified Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{quantified expression} 
    \dsep \ldots
    }

  \Rule{quantified expression}{
    \Ruleref{all expression} \dsep
    \Ruleref{exists expression} \dsep
    \Ruleref{exists unique expression}
    } 

  \Rule{all expression}{
    \Lop{forall}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }
    
  \Rule{exists expression}{
      \Lop{exists}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{exists unique expression}{
    \Lop{exists1}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] There are three forms of quantified expressions:
  {\it universal} (written as \keyw{forall}), {\it existential} (written
  as \keyw{exists}), and {\it unique existential} (written as
  \keyw{exists1}). Each yields a boolean value \keyw{true} or \keyw{false}, as
  explained in the following.

  The {\it universal quantification} has the form:
  \begin{alltt}
    \keyw{forall} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  where each {\tt mbdi} is a multiple bind {\tt pi \keyw{in set} s} (or
  if it is a type bind {\tt pi : type}), and {\tt e} is a boolean
  expression involving the pattern identifiers of the {\tt mbdi}'s. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of every choice of bindings from {\tt mbd1, mbd2, \ldots,
    mbdn} and \keyw{false} otherwise.

  The {\it existential quantification} has the form:
  \begin{alltt}
    \keyw{exists} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  where the {\tt mbdi}'s and the {\tt e} are as for a universal
  quantification. It has the value \keyw{true} if {\tt e} is \keyw{true} when
  evaluated in the context of at least one choice of bindings from
  {\tt mbd1, mbd2, \ldots, mbdn}, and \keyw{false} otherwise.

  The {\it unique existential quantification} has the form:
  \begin{alltt}
    \keyw{exists1} bd \& e
  \end{alltt}
  where {\tt bd} is either a set bind or a type bind and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of exactly one choice of bindings, and \keyw{false} otherwise.

  All quantified expressions have the lowest possible precedence. This
  means that the longest possible constituent expression is taken. The
  expression is continued to the right as far as it is syntactically
  possible. 
  

\item[Examples:] 
  An example of an existential quantification is given in the function
  shown below, \texttt{QualificationOk}. This function, taken from the
  specification of a nuclear tracking system in \cite{Fitzgerald&98},
  checks whether a set of experts has a required qualification.
  \begin{alltt}
  types

  ExpertId = \keyw{token};
  Expert :: expertid : ExpertId
            quali : \keyw{set of} Qualification
  \keyw{inv} ex == ex.quali <> {};
  Qualification = <Elec> | <Mech> | <Bio> | <Chem>

  functions

  QualificationOK: \keyw{set of} Expert * Qualification -> \keyw{bool}
  QualificationOK(exs,reqquali) ==
      \keyw{exists} ex \keyw{in set} exs & reqquali \keyw{in set} ex.quali
  \end{alltt}
  The function \texttt{min} gives us an example of a universal
  quantification: 
  \begin{alltt}
  min(s:\keyw{set of nat}) x:\keyw{nat}
  \Keyw{pre} s <> \{\} 
  \Keyw{post} x \keyw{in set} s \keyw{and}
       \keyw{forall} y \keyw{in set} s \verb+\+ \{x\} & y < x
  \end{alltt}
  We can use unique existential quantification to state the functional
  property satisfied by all maps \texttt{m}:
  \begin{alltt}
  \keyw{forall} d \keyw{in set dom} m &
    \keyw{exists1} r \keyw{in set rng} m & m(d) = r
  \end{alltt}


\end{description}

\subsection{The Iota Expression}\label{iotaexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{iota expression} \dsep
    \ldots
    }

  \Rule{iota expression}{
    \Lop{iota}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] An {\it iota expression} has the form:
  \begin{alltt}
    \keyw{iota} bd \& e
  \end{alltt}
  where {\tt bd} is either a set bind or a type bind, and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}.
  The \keyw{iota} operator can only be used if a unique value exists
  which matches the bind and makes the body expression {\tt e} yield
  \keyw{true} (i.e.\ {\tt \keyw{exists1} bd \& e} must be \keyw{true}). The
  semantics of the iota expression is such that it returns the unique
  value which satisfies the body expression ({\tt e}).

\item[Examples:]
  Using the values \texttt{sc1,...,sc4} defined by
  \begin{alltt}
    sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9);
    sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4);
    sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2);
    sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1);
  \end{alltt}
  we have
  
  \begin{tabular}{lcl}
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.team = <France>} & $\equiv$ & \texttt{sc1}\\
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.points > 3} & $\equiv$ & $\perp$\\
    \texttt{ \keyw{iota} x : Score \& x.points < x.won} & $\equiv$ &
  $\perp$
  \end{tabular}

  \noindent Notice that the last example cannot be executed and that
  the last two expressions are undefined - in the former case because
  there is more than value satisfying the expression, and in the
  latter because no value satisfies the expression.
\end{description}

\subsection{Set Expressions}\label{setexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{set enumeration} \dsep \Ruleref{set comprehension} \dsep
    \Ruleref{set range expression} \dsep \ldots
    }
  
  \Rule{set enumeration}{
    \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
    }

  \Rule{expression list}{
    \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
    }

  \Rule{set comprehension}{
    \Lit{\{}, \Ruleref{expression}, \Lit{$|$}, \Ruleref{bind list}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

  \Rule{set range expression}{
    \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{expression}, \Lit{\}}
    }

\item[Semantics:] A {\it Set enumeration} has the form:
  \begin{alltt}
    \{e1, e2, e3, \ldots, en\}
  \end{alltt}
  where {\tt e1} up to {\tt en} are general expressions. It constructs
  a set of the values of the enumerated expressions. The empty set
  must be written as \verb+{}+.

  The {\it set comprehension} expression has the form:
  \begin{alltt}
    \{e | mbd1, mbd2, \ldots, mbdn \& P\}
  \end{alltt}
  It constructs a set by evaluating the expression {\tt e} on all the
  bindings for which the predicate {\tt P} evaluates to \keyw{true}. A
  multiple binding can contain both set bindings and type bindings.
  Thus {\tt mbdn} will look like {\tt pat1 \keyw{in set} s1, pat2 : tp1,
    \ldots \keyw{in set} s2}, where {\tt pati} is a pattern (normally
  simply an identifier), and {\tt s1} and {\tt s2} are sets
  constructed by expressions (whereas {\tt tp1} is used to illustrate
  that type binds can also be used). Notice however that type binds
  cannot be executed by the interpreter.

  The {\it set range expression} is a special case of a set
  comprehension. It has the form
  \begin{alltt}
    \{e1, \ldots, e2\}
  \end{alltt}
  where {\tt e1} and {\tt e2} are numeric expressions. The set range
  expression denotes the set of integers from {\tt e1} to {\tt e2}
  inclusive. If {\tt e2} is smaller than {\tt e1} the set range
  expression denotes the empty set. 

\item[Examples:]
  Using  the values \texttt{Europe=\{<France>,<England>,<Denmark>,%
  <Spain>\}} and \texttt{GroupC = \{sc1,sc2,sc3,sc4\}} (where
  \texttt{sc1,...,sc4} are as defined in the preceding example) we have

  \begin{tabular}{lcl}
    \texttt{\{<France>, <Spain>\} \keyw{subset} Europe} & $\equiv$ &
      \keyw{true}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<Brazil>, <Chile>, <England>\}}\\
      \mbox{\hspace{3em}}\texttt{\keyw{subset} Europe} }
      & $\equiv$ &  \keyw{false}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<France>, <Spain>, {\char'042}France{\char'042}\}} \\
      \mbox{\hspace{3em}}\keyw{subset} \texttt{Europe}} &
      $\equiv$ & \keyw{false}\\
    \parbox[t]{7cm}{\raggedright\texttt{\{sc.team | sc \keyw{in set} GroupC }\\
                    \mbox{\hspace{3em}}\texttt{\& sc.points > 2\}}} &
      $\equiv$ & \texttt{\{\parbox[t]{4cm}{<France>,\\ <Denmark>\}}}\\
    \parbox[t]{7cm}{\raggedright
        \texttt{\{sc.team | sc \keyw{in set} GroupC }\\
        \mbox{\hspace{3em}}\texttt{\& sc.lost > sc.won \}}}
      & $\equiv$ & \texttt{\{\parbox[t]{4cm}{<SouthAfrica>, \\<SaudiArabia>\}}}\\
    \texttt{\{2.718,...,3.141\}} & $\equiv$ & \texttt{\{3\}}\\
    \texttt{\{3.141,...,2.718\}} & $\equiv$ & \texttt{\{\}}\\
    \texttt{\{1,...,5\}} & $\equiv$ & \texttt{\{1,2,3,4,5\}}\\
    \texttt{\{ x | x:\keyw{nat} \& x < 10 \keyw{and} x \keyw{mod} 2 = 0\}}
      & $\equiv$ & \texttt{\{0,2,4,6,8\}}
  \end{tabular}
\end{description}

\subsection{Sequence Expressions} \label{seqexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{sequence enumeration} \dsep \Ruleref{sequence comprehension} \dsep
    \Ruleref{subsequence} \dsep \ldots
    }

  \Rule{sequence enumeration}{
    \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
    }

  \Rule{sequence comprehension}{
    \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{set bind}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{]}
    }

  \Rule{subsequence}{
    \Ruleref{expression}, \lfeed
    \Lit{(}, \Ruleref{expression},
    \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{expression}, \Lit{)}
    }

\item[Semantics:] A {\it sequence enumeration} has the form:
  \begin{alltt}
    [e1, e2, \ldots, en]
  \end{alltt}
  where {\tt e1} through {\tt en} are general expressions. It constructs a
  sequence of the enumerated elements. The empty sequence must be written
  as {\tt []}.

  A {\it sequence comprehension} has the form:
  \begin{alltt}
    [e | pat \keyw{in set} S \& P]
  \end{alltt}
  where the expression {\tt e} will use the identifiers from the
  pattern {\tt pat} (normally this pattern will simply be an
  identifier, but the only real requirement is that exactly one pattern
  identifier must be present in the pattern). {\tt S} is
  a set of values (normally natural numbers). The bindings of the
  pattern identifier must be to some kind of numeric values which then
  are used to indicate the ordering of the elements in
  the resulting sequence. It constructs a sequence by evaluating the
  expression {\tt e} on all the bindings for which the predicate {\tt P}
  evaluates to \keyw{true}.

  A {\it subsequence} of a sequence {\tt l} is a sequence formed from
  consecutive elements of {\tt l}; from index {\tt n1} up to and including
  index {\tt n2}. It has the form:
  \begin{alltt}
    l(n1, ..., n2)
  \end{alltt}
  where {\tt n1} and {\tt n2} are positive integer expressions.
  If the lower bound {\tt n1} is smaller than
  1 (the first index in a non-empty sequence) the subsequence
  expression will start from the first element of the sequence.
  If the upper bound {\tt n2} is larger
  than the length of the sequence (the largest index which can be used
  for a non-empty sequence) the subsequence expression will end at the
  last element of the sequence.

%  A {\it sequence modifier} has the form:
%  \begin{alltt}
%    l ++ \{n1 |-> e1, n2 |-> e2, \ldots, nm |-> em\}
%  \end{alltt}
%  where {\tt l} is an expression denoting a sequence (which is going to be
%  modified), {\tt n1, n2, \ldots, nm} are positive integer expressions
%  (less than the length of {\tt l}) and {\tt e1, e2, \ldots, em} are
%  expressions of any type. The sequence modifier expression denotes the
%  sequence {\tt l} modified in a way so that element {\tt ni} has been
%  replaced by {\tt ei}.

\item[Examples:] Given that \texttt{GroupA} is equal to the sequence 
  \begin{alltt}\label{GroupAdef}
    [ \keyw{mk\_}Score(<Brazil>,2,0,1,6), 
      \keyw{mk\_}Score(<Norway>,1,2,0,5),
      \keyw{mk\_}Score(<Morocco>,1,1,1,4),
      \keyw{mk\_}Score(<Scotland>,0,1,2,1) ]
  \end{alltt} then:

  \begin{tabular}{lcl}
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i).team \\
            | i \keyw{in set inds} GroupA \\
                  \mbox{\hspace{1em}} \& GroupA(i).won <> 0]}
    &$\equiv$ & 
        \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
                                 <Brazil>, \\
                                 <Norway>, \\
                                 <Morocco>]}\\
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA\\
            \mbox{\hspace{1em}} \& GroupA(i).won = 0]}
    &$\equiv$ & \texttt{[\keyw{mk\_}Score(<Scotland>,0,1,2,1)]}\\
  \texttt{GroupA(1,...,2)} 
    &$\equiv$ & 
    \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
         \keyw{mk\_}Score(<Brazil>,2,0,1,6), \\
         \keyw{mk\_}Score(<Norway>,1,2,0,5)]}\\
  \parbox[t]{5.65cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA \\
            \mbox{\hspace{1em}} \& GroupA(i).points = 9]}
    &$\equiv$ & \texttt{[]}
  \end{tabular}
\end{description}

\subsection{Map Expressions} \label{mapexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{map enumeration} \dsep \Ruleref{map comprehension} \dsep \ldots
    }

  \Rule{map enumeration}{
    \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    } 
  
  \Rule{maplet}{
    \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
    }
  
  \Rule{map comprehension}{
    \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list},\lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

\item[Semantics:] A {\it map enumeration} has the form:
  \begin{alltt}
    \{d1 |-> r1, d2 |-> r2, \ldots, dn |-> rn\}
  \end{alltt}
  where all the domain expressions {\tt di} and range expressions {\tt ri}
  are general expressions. The empty map
  must be written as {\tt \{|->\}}.
      
  A {\it map comprehension} has the form:
  \begin{alltt}
    \{ed |-> er | mbd1, \ldots, mbdn \& P\}
  \end{alltt}
  where constructs {\tt mbd1, \ldots, mbdn} are multiple bindings of
  variables from the expressions {\tt ed} and {\tt er} to sets (or types).
  The {\it map comprehension} constructs a mapping by evaluating the
  expressions {\tt ed} and {\tt er} on all the possible bindings for which
  the predicate {\tt P} evaluates to \keyw{true}.

\item[Examples:] Given that \texttt{GroupG} is equal to the map 
  \begin{alltt}\label{GroupGdef}
    \{ <Romania> |-> mk_(2,1,0), <England> |-> mk_(2,0,1),
      <Colombia> |-> mk_(1,0,2), <Tunisia> |-> mk_(0,1,2) \}
  \end{alltt}
  then:

  \begin{tabular}{lcl}
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> \keyw{let} \keyw{mk\_}(w,d,-) = GroupG(t)\\
             \mbox{\hspace{4em}}\keyw{in} w * 3 + d \\
             | t \keyw{in set dom} GroupG\}}
    & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6,\\
                   <Colombia> |-> 3,\\
                   <Tunisia> |-> 1\}}\\
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> w * 3 + d \\
    | t \keyw{in set dom} GroupG, w,d,l:\keyw{nat} \\
    \ \& \keyw{mk\_}(w,d,l) = GroupG(t) \\
    \mbox{\hspace{.7em}}\keyw{and} w > l\}}
   & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6\}}
  \end{tabular}
\end{description}

\subsection{Tuple Constructor Expressions} \label{tupexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{tuple constructor} \dsep \ldots
    }

  \Rule{tuple constructor}{
    \Lop{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
    }

\item[Semantics:] The {\it tuple constructor expression}  has the form:
  \begin{alltt}
    \keyw{mk\_}(e1, e2, \ldots, en)
  \end{alltt}
  where {\tt ei} is a general expression. It can only be used by the
  equality and inequality operators.
     
\item[Examples:] Using the map \texttt{GroupG} defined in the preceding 
example, we have:

  \begin{tabular}{lcl}
  \texttt{\keyw{mk\_}(2,1,0) \keyw{in set rng} GroupG} & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}({\char'042}Romania{\char'042},2,1,0) \keyw{not in set rng} GroupG} 
       & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}(<Romania>,2,1,0) <> \keyw{mk\_}({\char'042}Romania{\char'042},2,1,0)}
       & $\equiv$ \keyw{true}
  \end{tabular}
\end{description}

\subsection{Record Expressions} \label{recexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{record constructor} \dsep
    \Ruleref{record modifier} \dsep \ldots
    }

  \Rule{record constructor}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(}, 
    \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{record modifier}{
    \Lop{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,}, 
    \Ruleref{record modification}, \lfeed \SeqPt{\Lit{,}, \Ruleref{record modification}}
    \Lit{)}
    }

  \Rule{record modification}{
    \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
    }

\item[Semantics:] The {\it record constructor} has the form:
  \begin{alltt}
    \keyw{mk\_}T(e1, e2, \ldots, en)
  \end{alltt}
  where the type of the expressions {\tt (e1, e2, \ldots, en)} matches the
  type of the corresponding entrances in the composite type {\tt T}.

  The {\it record modification} has the form:
  \begin{alltt}
    \keyw{mu} (e, id1 |-> e1, id2 |-> e2, \ldots, idn |-> en)
  \end{alltt}
  where the evaluation of the expression {\tt e} returns the record value
  to be modified. All the identifiers {\tt idi} must be distinct named
  entrances in the record type of {\tt e}.
     
\item[Examples:] If \texttt{sc} is the value \texttt{\keyw{mk\_}Score(<France>,3,0,0,9)} then
  \begin{alltt}
    \keyw{mu}(sc, drawn |-> sc.drawn + 1, points |-> sc.points + 1)
    \MYEQUIV \keyw{mk\_}Score(<France>,3,1,0,10)
  \end{alltt}
  Further examples are demonstrated in the function \texttt{win}. This
  function takes two teams and a set of scores. From the set of scores
  it locates the scores corresponding to the given teams (\texttt{wsc}
  and \texttt{lsc} for the winning and losing team respectively), then
  updates these using the \keyw{mu} operator. The set of teams is then
  updated with the new scores replacing the original ones.
  \begin{alltt}
  win : Team * Team * \keyw{set of} Score -> \keyw{set of} Score
  win (wt,lt,gp) ==
    \keyw{let} wsc = \keyw{iota} sc \keyw{in set} gp & sc.team = wt,
       lsc = \keyw{iota} sc \keyw{in set} gp & sc.team = lt
    \keyw{in let} new_wsc = \keyw{mu}(wsc, won |-> wsc.won + 1,
                            points |-> wsc.points + 3),
         new_lsc = \keyw{mu}(lsc, lost |-> lsc.lost + 1)
      \keyw{in} (gp \verb+\+ \{wsc,lsc\}) \keyw{union} \{new_wsc, new_lsc\}
  \Keyw{pre} \keyw{forall} sc1, sc2 \keyw{in set} gp &
          sc1 <> sc2 <=> sc1.team <> sc2.team
          \keyw{and} \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gp\}
  \end{alltt}

\end{description}

\subsection{Apply Expressions}\label{app-expr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{apply} \dsep
    \Ruleref{field select} \dsep
    \Ruleref{tuple select} \dsep
    \Ruleref{function type instantiation} \dsep
    \ldots
    }

  \Rule{apply}{
    \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{field select}{
    \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
    }

  \Rule{tuple select}{
    \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
    }

  \Rule{function type instantiation}{
    \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
    }
    
\item[Semantics:] The {\it field select expression} can be used for records
  and it has already been explained in section~\ref{records} so no further
  explanation will be given here.
     
  The {\it apply} is used for looking up in a map, indexing in a
  sequence, and finally for calling a function. In section~\ref{maps} it
  has already been shown what it means to look up in a map. Similarly in
  section~\ref{sequences} it is illustrated how indexing in a sequence is
  performed.

  In  \vdmslpp{VDM-SL}{\vdmpp} an operation can also be called 
  here. This is not allowed in standard VDM-SL and because this kind of
  operation call can modify the state such usage should be done with
  care in complex expressions. Note however that such operation calls
  are not allowed to throw exceptions.

  With such operation calls the order of evaluation can become
  important. Therefore the type checker will allow the user to enable
  or disable operation calls inside expressions.

  The tuple select expression is used to extract a particular
  component from a tuple. The meaning of the expression is if
  \texttt{e} evaluates to some tuple
  \keyw{mk\_}\texttt{(v1,...,vN)} and \texttt{M} is an integer in the
  range \verb+{1,...,N}+ then \texttt{e.\#M} yields \texttt{vM}. If
  \texttt{M} lies outside \verb+{1,...,N}+ the expression is undefined.

  The {\it function type instantiation\/} is used for instantiating
  polymorphic functions with the proper types. It has the form:
  \begin{alltt}
    pf [ t1, ..., tn ]
  \end{alltt}
  where {\tt pf} is the name of a polymorphic function, and {\tt t1,
    \ldots, tn} are types. The resulting function uses the types {\tt
    t1, \ldots, tn} instead of the variable type names given in the
  function definition.

\item[Examples:] Recall that \texttt{GroupA} is a sequence (page 
  \pageref{GroupAdef}), \texttt{GroupG} is a map (page \pageref{GroupGdef}) 
  and \texttt{selection\_sort} is a function (page \pageref{selectionSortdef}):

  \begin{tabular}{lcl}
  \texttt{GroupA(1)} & $\equiv$ & 
                           \texttt{\keyw{mk\_}Score(<Brazil>,2,0,1,6)}\\
  \texttt{GroupG(<Romania>)} & $\equiv$ &
                           \texttt{\keyw{mk\_}(2,1,0)}\\
  \texttt{GroupG(<Romania>).\#2} & $\equiv$ &
                           \texttt{1}\\
  \texttt{selection\_sort([3,2,9,1,3])} & $\equiv$ &
                           \texttt{[1,2,3,3,9]}
  \end{tabular}

  As an example of the use of polymorphic functions and function type
  instantiation, we use the example functions from
  section~\ref{functiondef}:
  \begin{alltt}
    \keyw{let} emptyInt = empty_bag[int] \keyw{in}
      plus_bag[int](-1, emptyInt())

  \MYEQUIV

    \{ -1 |-> 1 \}
  \end{alltt}

\end{description}

#ifdef VDMPP
\subsection{The New Expression}
\label{sec:creation}

\begin{description}
\item[Syntax:] 
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{new expression} 
    }
  \Rule{new expression}{
    \Lop{new}, \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\item[Semantics:] The {\it new expression} has the form:

  \begin{alltt}
    \keyw{new} classname(e1, e2, ..., en)
  \end{alltt}
  An object can be created (also called {\em instantiated}) from its
  class description using a {\it new expression}. The effect of a
  {\it new expression} is that a `new', unique object as described in
  class {\tt classname} is created. The value of the {\it new
  expression} is a reference to the new object.

  If the {\it new expression} is invoked with no parameters, an
  object is created in which all instance variables take their
  ``default'' values (i.e.\ the values defined by their initialisation
  conditions). With parameters, the {\it new expression} represents a
  \emph{constructor}~(see Section~\ref{constructors}) and creates
  customised instances (i.e.\ where the instance variables may take
  values which are different from their default values).


\item[Examples:] Suppose we have a class called \texttt{Queue} and
  that default instances of \texttt{Queue} are empty. Suppose also
  that this class contains a constructor (which will also be called
  \texttt{Queue}) which takes a single parameter which is a list of
  values representing an arbitrary starting queue. Then we can 
  create default  instances of \texttt{Queue} in which the actual
  queue is empty using the expression
\begin{alltt}
  \keyw{new} Queue()
\end{alltt}
and an instance of \texttt{Queue} in which the actual
  queue is, say, \texttt{e1, e2, e3} using the expression
\begin{alltt}
  \keyw{new} Queue([e1, e2, e3])
\end{alltt}

Using the class \texttt{Tree} defined on page \pageref{TreeDef} we create
new \texttt{Tree} instances to construct \texttt{node}s:
\begin{alltt}
\keyw{mk\_}node(\keyw{new} Tree(), x, \keyw{new} Tree())
\end{alltt}
    

\end{description}

\subsection{The Self Expression}
\label{sec:self}

\begin{description}
\item[Syntax:] 
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{self expression} 
    }
  \Rule{self expression}{
    \Lop{self}
  }
  
\item[Semantics:] The {\it self expression} has the form:

  \begin{alltt}
    \keyw{self}
  \end{alltt}
  The self expression returns a reference to the object currently
    being executed. It can be used to simplify the name space in
    chains of inheritance.

\item[Examples:] Using the class \texttt{Tree} defined on page
\pageref{TreeDef} we can specify a subclass called \texttt{BST} which
stores data using the binary search tree approach.
We can then specify an operation which performs a binary search tree 
insertion:
\begin{alltt}
    Insert : \keyw{int} ==> ()
    Insert (x) ==
      (\keyw{dcl} curr_node : Tree := \keyw{self};

       \keyw{while not} curr_node.isEmpty() \keyw{do}
         \keyw{if} curr_node.rootval() < x
         \keyw{then} curr_node := curr_node.rightBranch()
         \keyw{else} curr_node := curr_node.leftBranch();
       curr_node.addRoot(x);
       )
\end{alltt}
This operation uses a self expression to find the root at which to
being traversal prior to insertion. Further examples are given in
section \ref{call-stmt}.
\end{description}

\subsection{The Threadid Expression}
\label{sec:threadid}

\begin{description}
\item[Syntax:] 
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{threadid expression} 
    }
  \Rule{threadid expression}{
    \Lop{threadid}
  }
  
\item[Semantics:] The {\it threadid expression} has the form:

  \begin{alltt}
    \keyw{threadid}
  \end{alltt}
  The threadid expression returns a natural number which uniquely
  identifies the thread in which the expression is executed.
#ifdef VICEMAN
  Note that periodic threads gets a new threadid at the start of each period.
#endif

\item[Examples:] 
Using threadids it is possible to provide a VDM++ base class that
implements a Java-style wait-notify in VDM++ using permission
predicates. Any object that should be available for the wait-notify
mechanism must derive from this base class.  
\begin{alltt}
\keyw{class} WaitNotify

  \keyw{instance variables}
    waitset : \keyw{set of nat} := \{\};

  \keyw{operations}
    \PROTECTED wait: () ==> ()
    wait() == 
      \keyw{let} p = \keyw{threadid}
      \keyw{in} (
        AddToWaitSet( p );
        Awake();
       );

    AddToWaitSet : \keyw{nat} ==> ()
    AddToWaitSet( p ) ==
      waitset := waitset \keyw{union} \{ p \};
      
    Awake: () ==> ()
    Awake() == 
      \keyw{skip};
  
    \PROTECTED notify: () ==> ()
    notify() == 
        \keyw{if} waitset <> \{\} \keyw{then}
          \keyw{let} arbitrary_process \keyw{in set} waitset
          \keyw{in}  waitset := waitset \verb+\+ \{arbitrary_process\};

    \PROTECTED notifyAll: () ==> ()
    notifyAll() ==
         waitset := \{\};

  \keyw{sync}
    \keyw{mutex}(notifyAll, AddToWaitSet, notify);
    \keyw{per} Awake => \keyw{threadid not in set} waitset;

\keyw{end} WaitNotify
\end{alltt}
In this example the threadid expression is used in two places:
\begin{itemize}
\item In the \texttt{Wait} operation for threads to register interest
  in this object.
\item In the permission predicate for \texttt{Awake}. An interested
  thread should call \texttt{Awake} following registration using
  \texttt{Wait}. It will then be blocked until its threadid is removed
  from the waitset following another thread's call to \texttt{notify}.
\end{itemize}

#ifdef VICEMAN
Note also that one needs to be careful about the use of the wait-notify
mechanism when having periodic threads (because they change their threadid 
for each new period).
#endif

\end{description}
#endif VDMPP

\subsection{The Lambda Expression}\label{lambda}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{lambda expression} \dsep \ldots
    }

  \Rule{lambda expression}{
    \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
    }

\Rule{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }
        
\item[Semantics:] A {\it lambda expression} is of the form:
  \begin{alltt}
    \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& e
  \end{alltt}
  where the {\tt pati} are patterns, the {\tt Ti} are type expressions, and
  {\tt e} is the body expression. The scope of the pattern identifiers in
  the patterns {\tt pati} is the body expression. A lambda expression
  cannot be polymorphic, but apart from that, it corresponds semantically
  to an explicit function definition as explained in
  section~\ref{functiondef}. A function defined by a lambda expression can
  be Curried by using a new lambda expression in the body of it in a nested
  way. When lambda expressions are bound to an identifier they can also
  define a recursive function.

\item[Examples:] An increment function can be defined by means of a lambda
  expression like:
  \begin{alltt}
    Inc = \keyw{lambda} n : \keyw{nat} \& n + 1
  \end{alltt}
  and an addition function can be Curried by:
  \begin{alltt}
    Add = \keyw{lambda} a : \keyw{nat} \& \keyw{lambda} b : \keyw{nat} \& a + b
  \end{alltt}
  which will return a new lambda expression if it is applied to only one
  argument:
  \begin{alltt}
    Add(5) \(\equiv\) \keyw{lambda} b : \keyw{nat} \& 5 + b
  \end{alltt}
  Lambda expression can be useful when used in conjunction with higher-order 
  functions. For instance using the function \texttt{set\_filter}
  defined on page \pageref{setfilterdef}:
  \begin{alltt}
  set_filter[nat](lambda n:nat & n mod 2 = 0)(\{1,...,10\})
  \MYEQUIV \{2,4,6,8,10\}
  \end{alltt}
\end{description}

\subsection{Narrow Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{narrow expression} \dsep
    \ldots
    }

  \Rule{narrow expression}{
    \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)} 
    }

    \item[Semantics:] The {\it narrow expression} convert the given {\tt expression} value into given {\tt type}.
	Downcasting in class inheritance, and narrowing Union type are permit.
	However, conversions between unrelated types become type errors.
    
    \item[Examples:] In following examples, there is no difference in the results of running the Test() and Test'(), 
	But, there is a type error (DEF) in Test().

#ifdef VDMPP
      \begin{alltt}
class S
end S

class C1 is subclass of S

instance variables
public a : nat := 1;

end C1

class C2 is subclass of S

instance variables
public b : nat := 2;

end C2

class A

operations
public
Test: () ==>  seq of nat
Test() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> e.a,
                (isofclass(C2, e)) -> e.b
               end | i in set inds list ];

public
Test': () ==>  seq of nat
Test'() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> narrow_(e, C1).a,
                (isofclass(C2, e)) -> narrow_(e, C2).b
               end | i in set inds list ];
end A
      \end{alltt}
#endif VDMPP
 
      \begin{alltt}
class A

types
public C1 :: a : nat;
public C2 :: b : nat;
public S = C1 | C2;

operations
public
Test: () ==> nat
Test() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = s
   in
     return c.a;

public
Test': () ==> nat
Test'() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = narrow_(s, C1)
   in
     return c.a;
end A
      \end{alltt}

\end{description}


\subsection{Is Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{general is expression} \dsep
    \ldots
    }

  \Rule{general is expression}{
    \Ruleref{is expression} \dsep
    \Ruleref{type judgement}
    }


  \Rule{is expression}{
    \Lop{is\_}, \Ruleref{name}, \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
    \Ruleref{is basic type}, \Lit{(}, \Ruleref{expression}, \Lit{)}
    }

  \Rule{is basic type}{
    \Lop{is\_}, 
    \Brack{%
      \Lop{bool} \dsepl
      \Lop{nat} \dsepl 
      \Lop{nat1} \dsepl 
      \Lop{int} \dsep 
      \Lop{rat} \dsepl 
      \Lop{real} \dsep
      \Lop{char} \dsepl
      \Lop{token}
      }
    }

  \Rule{type judgement}{
    \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\item[Semantics:] The {\it is expression} can be used with values
     that are either basic or record values (tagged values belonging
     to some composite type). The is expression yields true if the
     given value belongs to the basic type indicated or if the value
     has the indicated  tag. Otherwise it yields false.

     A type judgement is a more general form which can be used for
     expressions whose types can not be statically determined. The
     expression \texttt{\keyw{is}\_(e,t)} is equal to true if and only
     if \texttt{e} is of type \texttt{t}.
     
\item[Examples:] Using the record type \texttt{Score} defined on page 
  \pageref{scoredef} we have:
     
  \begin{tabular}{lcl}
    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{true}\\
% Ueki mod start (Kagemai#54)
%    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,8))}
%      & $\equiv$ & \keyw{false}\\
% Ueki mod end
    \texttt{\keyw{is\_bool}(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_real}(0)} & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_nat1}(0)} & $\equiv$ & \keyw{false}
  \end{tabular}

  An example of a type judgement:
  \begin{alltt}
    Domain : \keyw{map nat to nat} | \keyw{seq of (nat*nat)} -> \keyw{set of nat}
    Domain(m) ==
      \keyw{if is}\_(m, \keyw{map nat to nat})
      \keyw{then dom} m
      \keyw{else} \{d | \keyw{mk}\_(d,-) \keyw{in set elems} m\}
  \end{alltt}
     In addition there are examples on page \pageref{exprIsExs}.
\end{description}
#ifdef VDMPP

\subsection{Base Class Membership}\index{base class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{isofbaseclass expression} \dsep
    \ldots
    }

  \Rule{isofbaseclass expression}{
    \Lop{isofbaseclass},
    \Lit{(}, \Ruleref{identifier}, \Ruleref{expression}, \Lit{)}}
  
\item[Semantic:] The function {\vppsmall isofbaseclass} when applied to an
  object reference {\vppsmall expression} and a class name {\vppsmall identifier}
  yields the boolean value $\True$ if and only if {\vppsmall identifier} is a
  root superclass in the inheritance chain of the object referenced to
  by {\vppsmall expression}, and $\False$ otherwise.
  
\item[Examples:] \label{treeExDef}
  Suppose that \texttt{BinarySearchTree} is a subclass of
  \texttt{Tree}, \texttt{Tree} is not a subclass of any other class and
  \texttt{Queue} is not related by inheritance to either \texttt{Tree}
  or \texttt{BinarySearchTree}. Let \texttt{t} be an instance of \texttt{Tree},
  \texttt{b} is an instance of \texttt{BinarySearchTree}
  and \texttt{q} is an instance of \texttt{Queue}. Then:
  
  \begin{tabular}{lcl}
    \keyw{isofbaseclass}\texttt{(Tree, t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(BinarySearchTree, b)} & $\equiv$ & \keyw{false}\\
    \keyw{isofbaseclass}\texttt{(Queue, q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, q)} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsection{Class Membership}\index{class membership expression}
\begin{description}
\item[Syntax] 
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{isofclass expression} \dsep
    \ldots
    }
  \Rule{isofclass expression}{
    \Lop{isofclass}, \Lit{(}, \Ruleref{identifier}, \Ruleref{expression}, \Lit{)}
  }

\item[Semantics:] The function {\vppsmall isofclass} when applied to an
  object reference {\vppsmall expression} and a class name {\vppsmall identifier}
  yields the boolean value $\True$ if and only if {\vppsmall expression}
  refers to an object of class name {\vppsmall identifier} or to an object of any of
  the subclasses of {\vppsmall identifier}, and $\False$ otherwise.

\item[Examples:] Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} as in the previous example, we have:
  
  \begin{tabular}{lcl}
    \keyw{isofclass}\texttt{(Tree,t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,q)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(Queue,q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,t)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,b)} & $\equiv$ & \keyw{true}
  \end{tabular}

\end{description}

\subsection{Same Base Class Membership}%
\index{same base class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
     \Ruleref{samebaseclass expression} \dsep
    \ldots
    }
  \Rule{samebaseclass expression}{\Lop{samebaseclass}, \lfeed
  \Lit{(},
        \Ruleref{expression}, \Ruleref{expression}, \Lit{)}
    }
  
\item[Semantics:] The function {\vppsmall samebaseclass} when applied to
  object references \texttt{ex\-pression1} and {\vppsmall expression2} yields
  the boolean value $\True$ if and only if the objects denoted by
  \texttt{expres\-sion1} and {\vppsmall expression2} are instances of classes
  that can be derived from the same root superclass, and $\False$
  otherwise.
  
\item[Examples:] Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} as in the previous example, suppose that
\texttt{AVLTree} is another subclass of \texttt{Tree},
\texttt{BalancedBST} is a subclass of \texttt{BinarySearchTree}, \texttt{a}
is an instance of \texttt{AVLTree} and \texttt{bb} is an instance of
\texttt{BalancedBST} :

  \begin{tabular}{lcl}
  \keyw{samebaseclass}\texttt{(a,b)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(a,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(b,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(t,bb)} & $\equiv$ & \keyw{false}\\
  \keyw{samebaseclass}\texttt{(q,a)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\subsection{Same Class Membership}%
\index{same class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
     \Ruleref{sameclass expression} \dsep
    \ldots
    }

  \Rule{sameclass expression}{\Lop{sameclass}, \lfeed
  \Lit{(}, \Ruleref{expression},
        \Ruleref{expression}, \Lit{)}
   }
   
\item[Semantics:] The function {\vppsmall sameclass} when applied to object
  references \texttt{expressi\-on1} and {\vppsmall expression2} yields the
  boolean value $\True$ if and only if the objects denoted by
  \texttt{expression1} and {\vppsmall expression2} are instances of the same
  class, and $\False$ otherwise.

\item[Examples:] 
Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} from section \ref{treeExDef}, and assuming
\texttt{b'} is another instance of \texttt{BinarySearchTree} we have:

  \begin{tabular}{lcl}
  \keyw{sameclass}\texttt{(b,t)} & $\equiv$ & \keyw{false}\\
  \keyw{sameclass}\texttt{(b,b')} & $\equiv$ & \keyw{true}\\
  \keyw{sameclass}\texttt{(q,t)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\subsection{History Expressions}\index{history expressions}
\label{sec:historyexpr}

\begin{description}
\item[Syntax:] 
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{act expression} \dsep
    \Ruleref{fin expression} \dsep
    \Ruleref{active expression} \dsep
    \Ruleref{req expression} \dsep
    \Ruleref{waiting expression} \dsep 
    \ldots
  }
  \Rule{act expression}{
    \Lit{\#act}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#act}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{fin expression}{
    \Lit{\#fin}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#fin}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{active expression}{
    \Lit{\#active}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#active}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{req expression}{
    \Lit{\#req}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#req}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{waiting expression}{
    \Lit{\#waiting}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#waiting}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }

\item[Semantics:] History expressions can only be used in
permission predicates (see section \ref{sec:permissionpred}). History
expressions may contain one or more of the following expressions:
  
\begin{itemize}
\item {\tt \#act (}{\em operation name}{\tt )}. The number of times
  that {\em operation name} operation has been activated.
\item {\tt \#fin(}{\em operation name}{\tt )}. The number of times that
  the {\em operation name} operation has been completed.
\item {\tt \#active(}{\em operation name}{\tt )}. The number of {\em operation
  name} operations that are currently active.  Thus: {\tt \#active(}{\em
    operation name}{\tt )} $=$ {\tt \#act(}{\em operation name}{\tt )}
  $-$ {\tt \#fin(}{\em operation name}{\tt )}.
\item {\tt \#req(}{\em operation name}{\tt )}. The number of requests
  that has been issued for the {\em operation name} operation.
\item {\tt \#waiting(}{\em operation name}{\tt )}. The number of
  outstanding requests for the {\em operation name} operation. Thus: {\tt
    \#waiting(}{\em operation name}{\tt )} $=$ {\tt \#req(}{\em operation
    name}{\tt )} $-$ {\tt \#act(}{\em operation name}{\tt )}.
\end{itemize}
For all of these operators, the name list version
\texttt{\#}\textit{history op(op1,$\ldots$,opN)} is simply shorthand
for \texttt{\#}\textit{history op(op1)} \texttt{+} $\mathtt{\cdots}$
\texttt{+\#}\textit{history op(opN)}.

\item[Examples:]Suppose at a point in the execution of a particular
thread, three operations, \texttt{A}, \texttt{B} and \texttt{C} may be
executed. A sequence of requests, activations and completions occur
during this thread. This is shown graphically in figure \ref{historyfig}.

\insertfig{history}{14cm}{History Expressions}{\label{historyfig}}

Here we use the notation \textit{rA} to indicate a request for an
execution of operation \texttt{A}, \textit{aA} indicates an activation
of \texttt{A}, \textit{fA} indicates completion of an execution of
operation \texttt{A}, and likewise for operations \texttt{B} and
\texttt{C}. The respective history expressions have the following
values for the interval [\textbf{S},\textbf{T}]:
\end{description}

\begin{center}\small
\begin{tabular}{llll}
\texttt{\#act(A) = 1} & \texttt{\#act(B) = 1} & \texttt{\#act(C) = 1}
& \texttt{\#act(A,B,C) = 3}\\
\texttt{\#fin(A) = 1} & \texttt{\#fin(B) = 1} & \texttt{\#fin(C) = 0}
& \texttt{\#fin(A,B,C) = 2}\\
\texttt{\#active(A) = 0} & \texttt{\#active(B) = 0} & 
\texttt{\#active(C) = 1} & \texttt{\#active(A,B,C) = 1}\\
\texttt{\#req(A) = 2} & \texttt{\#req(B) = 1} & \texttt{\#req(C) = 3}
& \texttt{\#req(A,B,C) = 6}\\
\texttt{\#waiting(A) = 1} & \texttt{\#waiting(B) = 0} & 
\texttt{\#waiting(C) = 2} & \texttt{\#waiting(A,B,C) = 3}\\
\end{tabular}
\end{center}


#endif VDMPP

#ifdef VICEMAN
\subsection{The Time Expression}\index{time expression}\label{sec:time}

\begin{description}
\item[Syntax:] 
 \Rule{time expression}{\Lop{time}}

\item[Semantics:] This is simply an easy way to refer to the current time on 
     a given CPU. The time is provided as a natural number.
\item[Examples:] If for example one would like to log when a certain operation takes place one can create an operation such as \texttt{logEnvToSys} below.
\begin{alltt}
  \keyw{public} logEnvToSys: \keyw{nat} ==> ()
  logEnvToSys (pev) == e2s := e2s \keyw{munion} \{pev |-> \keyw{time}\};
\end{alltt}
\end{description}

#endif VICEMAN

\subsection{Literals and Names}

\begin{description}
\item[Syntax:]
  \Rule{expression}{    \ldots \dsep
    \Ruleref{name} \dsep
    \Ruleref{old name} \dsep
    \Ruleref{symbolic literal} \dsep
    \ldots
    }

  \Rule{name}{
    \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
    }

  \Rule{name list}{
    \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
    }

  \Rule{old name}{
    \Ruleref{identifier}, \Lit{\char'176}
    }

\item[Semantics:] {\it Names\/} and {\it old names\/} are used to access
  definitions of functions, operations, values and state components. A {\it
    name\/} has the form:
  \begin{alltt}
    id1`id2
  \end{alltt}
  where {\tt id1} and {\tt id2} are simple identifiers. If a name consists
  of only one identifier, the identifier is defined within scope, i.e.\ it
  is defined either locally as a pattern identifier or variable,
  or globally within the current module as a function, operation,
  value or global variable. 
  Otherwise, the identifier {\tt id1} indicates the
#ifdef VDMSL
module name
#endif VDMSL
#ifdef VDMPP
class name
#endif VDMPP
where the
  construct is defined (see also
#ifdef VDMSL
  section~\ref{modules}
#endif VDMSL
#ifdef VDMPP
  section~\ref{sec:classdep}
#endif VDMPP
and appendix \ref{ap:lexis}.)

  An {\it old name\/} is used to access the old value of global
  variables in the post condition of an operation definition (see
  section~\ref{op-def}) and in the post condition of specification
  statements (see section~\ref{se:specification}).  It has the form:

  \begin{alltt} 
    id~ 
  \end{alltt} 
  where {\tt id} is a state component.

  {\it Symbolic literals\/} are constant values of some basic type.

\item[Examples:] {\it Names} and {\it symbolic literals\/} are used
  throughout all examples in this document (see appendix~\ref{Symbols}).

#ifdef VDMSL
  For an example of the use of {\it old names}, consider the state defined
  as:
  \begin{alltt}
    \keyw{state} sigma \keyw{of}
      numbers : \keyw{seq of nat}
      index   : \keyw{nat}
    \Keyw{inv}  \keyw{mk\_}sigma(numbers, index) == index \keyw{not in set elems} numbers
    \Keyw{init} s == s = \keyw{mk\_}sigma([], 1)
    \keyw{end}
  \end{alltt}
#endif VDMSL
#ifdef VDMPP
  For an example of the use of {\it old names}, consider the instance 
  variables defined as:
  \begin{alltt}
    \keyw{instance variables}
      numbers: \keyw{seq of nat} := [];
      index  : \keyw{nat} := 1;
    \Keyw{inv} index \keyw{not in set elems} numbers;
  \end{alltt}
#endif VDMPP

  We can define an operation that increases the variable {\tt index} in
  an implicit manner:
  \begin{alltt}
    IncIndex()
    \keyw{ext wr} index : \keyw{nat}
    \keyw{post} index = index~ + 1
  \end{alltt}
  The operation {\tt IncIndex} manipulates the variable {\tt index},
  indicated with the \keyw{ext wr} clause. In the post condition, the new
  value of {\tt index} is equal to the old value of {\tt index} plus
  \texttt{1}. (See more about operations in section~\ref{op-def}).

  For a simple example of 
#ifdef VDMSL
module 
#endif VDMSL
#ifdef VDMPP
class
#endif VDMPP
  names, suppose that a function called 
  \texttt{build\_rel} is defined (and exported) in a 
#ifdef VDMSL
module 
#endif VDMSL
#ifdef VDMPP
class
#endif VDMPP
  called 
  \texttt{CGRel} as follows:
\begin{alltt}
  \keyw{types}

    Cg = <A> | <B> | <C> | <D> | <E> | <F> | 
         <G> | <H> | <J> | <K> | <L> | <S>;
    CompatRel = \keyw{map} Cg \keyw{to set of} Cg

  \keyw{functions}

    build_rel : \keyw{set of} (Cg * Cg) -> CompatRel
    build_rel (s) == \{|->\}
\end{alltt}
In another 
#ifdef VDMSL
module 
#endif VDMSL
#ifdef VDMPP
class
#endif VDMPP
  we can access this function by 
#ifdef VDMSL
first importing the module \texttt{CGRel} then by 
#endif VDMSL
  using the following call 
  \begin{alltt}
  CGRel`build_rel({mk_(<A>, <B>)})
  \end{alltt}


\end{description}

\subsection{The Undefined Expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{undefined expression}
    }

  \Rule{undefined expression}{
    \Lop{undefined}
    }
  
\item[Semantics:] The {\it undefined expression} is used to state
  explicitly that the result of an expression is undefined. This could
  for instance be used if it has not been decided what the result of
  evaluating the else-branch of an if-then-else expression should be.
  When an {\it undefined expression} is evaluated the
  interpreter will terminate the execution
  and report that an undefined expression was evaluated.

  Pragmatically use of undefined expressions differs from
  pre-conditions: use of a pre-condition means it is the caller's
  responsibility to ensure that the pre-condition is satisfied when
  the function is called; if an undefined expression is used it is the
  called function's responsibility to deal with error handling.

\item[Examples:] We can check that the type invariant holds before building 
  \texttt{Score} values:
  \begin{alltt}
  build_score : Team * \keyw{nat} * \keyw{nat} * \keyw{nat} * \keyw{nat} -> Score
  build_score (t,w,d,l,p) ==
    \keyw{if} 3 * w + d = p
    \keyw{then} \keyw{mk\_}Score(t,w,d,l,p)
    \keyw{else undefined}
  \end{alltt}
\end{description}

\subsection{The Precondition Expression}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{precondition expression}
    }
  \Rule{precondition expression}{
    \Lop{pre\_}, \Lit{(}, \Ruleref{expression}, \lfeed
                          \OptPt{\SeqPt{\Lit{,}, \Ruleref{expression}}},
                 \Lit{)}
    }
  
\item[Semantics:] 
  Assuming \texttt{e} is of function type the expression
  \keyw{pre\_}\texttt{(e,e1,...,en)} is true if and only if the
  pre-condition of \texttt{e} is true for arguments \texttt{e1,...,em}
  where \texttt{m} is the arity of the pre-condition of \texttt{e}. If
  \texttt{e} is not a function or \texttt{m} $>$ \texttt{n} then the
  result is \texttt{true}. If \texttt{e} has no pre-condition then the
  expression equals true.
\item[Examples:] 
  Consider the functions \texttt{f} and \texttt{g} defined below
  \begin{alltt}
  f : \keyw{nat} * \keyw{nat} -> \keyw{nat}
  f(m,n) == m \keyw{div} n
  \keyw{pre} n <> 0;

  g (n: \keyw{nat}) sqrt:\keyw{nat}
  \keyw{pre} n >= 0
  \keyw{post} sqrt * sqrt <= n \keyw{and}
       (sqrt+1) * (sqrt+1) > n
  \end{alltt}
  Then the expression
  \begin{alltt}
  \keyw{pre}\_(\keyw{let} h \keyw{in set} \{f,g, \keyw{lambda mk}\_(x,y):\keyw{nat} * \keyw{nat} & x \keyw{div} y\} 
       \keyw{in} h, 1,0,-1)
  \end{alltt}  
  is equal to 
  \begin{itemize}
  \item false if \texttt{h} is bound to \texttt{f} since this equates
        to \texttt{\keyw{pre}\_f(1,0)};
  \item true if \texttt{h} is bound to \texttt{g} since this equates
        to \texttt{\keyw{pre}\_g(1)};
  \item true if \texttt{h} is bound to 
        \texttt{\keyw{lambda} \keyw{mk}\_(x,y):\keyw{nat} * \keyw{nat} \& x \keyw{div} y} since there is no
        pre-condition defined for this function.
  \end{itemize}
  Note that however \texttt{h} is bound, the last argument
  (\texttt{-1}) is never used.
\end{description}


\section{Patterns}\label{patterns}

\begin{description}
\item[Syntax:]
  \Rule{pattern bind}{
    \Ruleref{pattern} \dsepl
    \Ruleref{bind}
    }

  \Rule{pattern}{
    \Ruleref{pattern identifier} \dsep
    \Ruleref{match value} \dsep
    \Ruleref{set enum pattern} \dsep
    \Ruleref{set union pattern} \dsep
    \Ruleref{seq enum pattern} \dsep
    \Ruleref{seq conc pattern} \dsep
    \Ruleref{map enumeration pattern} \dsep
    \Ruleref{map muinon pattern} \dsep
    \Ruleref{tuple pattern} \dsep
    \Ruleref{record pattern}
    }

  \Rule{pattern identifier}{
    \Ruleref{identifier} \dsepl \Lit{-}
    }

  \Rule{match value}{
    \Ruleref{symbolic literal} \dsep \Lit{(}, \Ruleref{expression}, \Lit{)}
    }

  \Rule{set enum pattern}{
    \Lit{\{}, [\Ruleref{pattern list}], \Lit{\}}
    }

  \Rule{set union pattern}{
    \Ruleref{pattern}, \Lit{\keyw{union}}, \Ruleref{pattern}
    }

  \Rule{seq enum pattern}{
    \Lit{[}, [\Ruleref{pattern list}], \Lit{]}
    }

  \Rule{seq conc pattern}{
    \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
    }


  \Rule{map enumeration pattern}{
    \Lit{\{}, [\Ruleref{maplet pattern list}], \Lit{\}}
    }

  \Rule{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

  \Rule{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

   \Rule{map muinon pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

  \Rule{tuple pattern}{
    \Lop{mk\_(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
    }
 
  \Rule{record pattern}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(}, [\Ruleref{pattern list}], \Lit{)}
    }

  \Rule{pattern list}{
    \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
    }

\item[Semantics:] A pattern is always used in a context where it is matched
  to a value of a particular type. Matching consists of checking that the
  pattern can be matched to the value, and binding any pattern identifiers
  in the pattern to the corresponding values, i.e.\ making the identifiers
  denote those values throughout their scope. In some cases where a pattern
  can be used, a bind can be used as well (see next section). If a bind is
  used it simply means that additional information (a type or a set
  expression) is used to constrain the possible values which can match the
  given pattern.

  Matching is defined as follows
  \begin{enumerate}
  \item A {\it pattern identifier} fits any type and can be matched to any
    value. If it is an identifier, that identifier is bound to the value;
    if it is the don't-care symbol \Lit{-}, no binding occurs.

  \item A {\it match value} can only be matched against the value of
    itself; no binding occurs. If a match value is not a literal like e.g.
    {\tt 7} or {\tt <RED>} it must be an expression enclosed in parentheses in order to
    discriminate it to a pattern identifier.

  \item A {\it set enumeration pattern} fits only set values. The patterns
    are matched to distinct elements of a set; all elements must be
    matched.

  \item A {\it set union pattern} fits only set values. The two patterns
    are matched to a partition of two subsets of a set. In the Toolbox
    the two subsets will always be chosen such that they are non-empty
    and disjoint.

  \item A {\it sequence enumeration pattern} fits only sequence values.
    Each pattern is matched against its corresponding element in the
    sequence value; the length of the sequence value and the number of
    patterns must be equal.

  \item A {\it sequence concatenation pattern} fits only sequence values.
    The two patterns are matched against two subsequences which together
    can be concatenated to form the original sequence value. In the
    Toolbox the two subsequences will always be chosen so that they
    are non-empty.

  \item A {\it map enumeration pattern} fits only map values. 

  \item A {\it maplet pattern list} are matched to distinct elements of a map; 
   all elements must be matched.

  \item A {\it map munion pattern} fits only map values. 
   The two patterns are matched to a partition of two sub maps of a map.
   In the VDM interpreters the two sub maps will always be chosen such that they are non-empty and disjoint.

  \item A {\it tuple pattern} fits only tuples with the same number of
    elements. Each of the patterns are matched against the corresponding
    element in the tuple value.

  \item A {\it record pattern} fits only record values with the same tag.
    Each of the patterns are matched against the field of the record value.
    All the fields of the record must be matched.
  \end{enumerate}

\item[Examples:] The simplest kind of pattern is the pattern
identifier. An example of this is given in the following let
expression:
\begin{alltt}
  \keyw{let} top = GroupA(1)
  \keyw{in} top.sc
\end{alltt}
Here the identifier \texttt{top} is bound to the head of the sequence
\texttt{GroupA} and the identifier may then be used in the body of the
let expression.

In the following examples we use match values:
\begin{alltt}
  \keyw{let} a = <France>
  \keyw{in} \keyw{cases} GroupA(1).team:
             <Brazil> -> "Brazil are winners",
             (a)      -> "France are winners",
             \keyw{others}    -> "Neither France nor Brazil are winners"
     \keyw{end;}
\end{alltt}
Match values can only match against their own values, so here if the
team at the head of \texttt{GroupA} is \texttt{<Brazil>} then the
first clause is matched; if the team at the head of \texttt{GroupA} is
\texttt{<France>} then the second clause is matched. Otherwise the
\keyw{others} clause is matched. Note here that the use of brackets
around \texttt{a} forces \texttt{a} to be considered as a match value.

Set enumerations match patterns to elements of a set. For instance in
\begin{alltt}
  \keyw{let} \{sc1, sc2, sc3, sc4\} = \keyw{elems} GroupA
  \keyw{in} sc1.points + sc2.points + sc3.points + sc4.points;
\end{alltt}
the identifiers \texttt{sc1}, \texttt{sc2}, \texttt{sc3} and
\texttt{sc4} are bound to the four elements of \texttt{GroupA}. Note
that the choice of binding is loose - for instance
\texttt{sc1} may be bound to [any] element of \texttt{\keyw{elems}
GroupA}. In this case if \texttt{\keyw{elems} GroupA} does not contain
precisely four elements, then the expression is not well-formed.

A set union pattern can be used to decompose a set for recursive
function calls. An example of this is the function \texttt{set2seq}
which converts a set into a sequence (with arbitrary order):
\begin{alltt}
  set2seq[@elem] : \keyw{set of} @elem -> \keyw{seq of} @elem
  set2seq(s) ==
    \keyw{cases} s:
      \{\} -> [],
      \{x\} -> [x],
      s1 \keyw{union} s2 -> (set2seq[@elem](s1))^(set2seq[@elem](s2))
    \keyw{end}
\end{alltt}
In the third cases alternative we see the use of a set union pattern. This
binds \texttt{s1} and \texttt{s2} to arbitrary subsets of \texttt{s}
such that they partition \texttt{s}. The Toolbox interpreter always
ensures a disjoint partition.

Sequence enumeration patterns can be used to extract specific elements
from a sequence. An example of this is the function \texttt{promoted}
which extracts the first two elements of a seqnce of scores and
returns the corresponding pair of teams:
\begin{alltt}
  promoted : \keyw{seq of} Score -> Team * Team
  promoted([sc1,sc2]^-) == \keyw{mk\_}(sc1.team,sc2.team);
\end{alltt}
Here \texttt{sc1} is bound to the head of the argument sequence, and
\texttt{sc2} is bound to the second element of the sequence. If
\texttt{promoted} is called with a sequence with fewer than two
elements then a runtime error occurs. Note that as we are not
interested in the remaining elements of the list we use a don't care
pattern for the remainder. 

The preceding example also demonstrated the use of sequence
concatenation patterns. Another example of this is the function
\texttt{quicksort} which implements a standard quicksort algorithm:
\begin{alltt}
  quicksort : \keyw{seq of nat} -> \keyw{seq of nat}
  quicksort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      [x,y] -> \keyw{if} x < y \keyw{then} [x,y] \keyw{else} [y,x],
      -^[x]^- -> quicksort ([y | y \keyw{in set elems} l & y < x]) ^ 
                 [x] ^ quicksort ([y | y \keyw{in set elems} l & y > x])
    \keyw{end}
\end{alltt}
Here, in the second cases clause a sequence concatenation pattern is
used to decompose \texttt{l} into an arbitrary pivot element and two
subsequences. The pivot is used to partition the list into those
values less than the pivot and those values greater, and these two
partitions are recursively sorted.


Maplet pattern match patterns to elements of a maplet.
\begin{alltt}
\keyw{let} \{a |-> b\} = \{1 |-> 2\} \keyw{in} \keyw{mk\_}(a,b) = \keyw{mk\_}(1,2)
\end{alltt}

Maplet pattern list match patterns to elements of each maplet in a map.
\begin{alltt}
\keyw{let} \{1 |-> a,a |-> b,b |-> c\} = \{1 |-> 4,2 |-> 3,4 |-> 2\} \keyw{in}
c = 3
\end{alltt}

Map munion pattern can be used to decompose a map for recursive function calls.
Following \texttt{map2seq} function converts a map to a seq of maplet.
\begin{alltt}
map2seq[@T1, @T2] : map @T1 to @T2 -> seq of (map @T1 to @T2)
map2seq(m) ==
  \keyw{cases} m:
    (\{|->\})	-> [],
    \{- |-> -\}	-> [m],
    m1 \keyw{munion} m2 -> map2seq[@T1, @T2] (m1) ^  map2seq[@T1, @T2] (m2)
  \keyw{end};
\end{alltt}
Here, in the third cases clause a map munion pattern is used to decompose \texttt{m} 
into two maps.


Tuple patterns can be used to bind tuple components to
identifiers. For instance since the function \texttt{promoted} defined
above returns a pair, the following value definition binds the winning
team of \texttt{GroupA} to the identifier \texttt{Awinner}:
\begin{alltt}
  \keyw{values}

    \keyw{mk\_}(Awinner,-) = promoted(GroupA);
\end{alltt}

Record patterns are useful when several fields of a record are used in
the same expression. For instance the following expression constructs
a map from team names to points score:
\begin{alltt}
  \{ t |-> w * 3 + l | \keyw{mk\_}Score(t,w,l,-,-) \keyw{in set elems} GroupA\}
\end{alltt}
The function \texttt{print\_Expr} on page \pageref{printExprDef} also gives
several examples of record patterns.




\end{description}

\section{Bindings}\label{bind}

\begin{description}
\item[Syntax:]
  \Rule{bind}{
    \Ruleref{set bind} \dsepl \Ruleref{type bind}
    }

  \Rule{set bind}{
    \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{multiple bind}{
    \Ruleref{multiple set bind} \dsep
    \Ruleref{multiple type bind}
    }

  \Rule{multiple set bind}{
    \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{multiple type bind}{
    \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
    }

\item[Semantics:] A {\it bind} matches a pattern to a value. In a {\it
    set bind} the value is chosen from the set defined by the set
    expression of the bind. In a {\it type bind} the value is chosen
    from the type defined by the type expression.  {\it Multiple bind}
    is the same as {\it bind} except that several patterns are bound
    to the same set or type.  Notice that type binds {\bf cannot} be
    executed by the interpreter.  This would require the interpreter
    to search through infinite domains like the natural numbers.

\item[Examples:] Bindings are mainly used in quantified expressions and
  comprehensions which can be seen from these examples:
  \begin{alltt}
    \keyw{forall} i, j \keyw{in set inds} list \& i < j => list(i) <= list(j)
      
    \{ y | y \keyw{in set} S & y > 2 \}

    \{ y | y: nat & y > 3 \}

    occurs : \keyw{seq1 of char} * \keyw{seq1 of char} -> \keyw{bool}
    occurs (substr,str) ==
      \keyw{exists} i,j \keyw{in set inds} str & substr = str(i,...,j);

  \end{alltt}
\end{description}

\section{Value (Constant) Definitions} \label{valuedef}

\vdmslpp{\vdmsl}{\vdmpp}\ supports the definition of constant
values. A value definition corresponds to a constant definition in
traditional programming languages.

\begin{description}
\item[Syntax:]
  \Rule{value definitions}{
    \Lop{values}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                       {\Ruleref{value definition}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                              {\Ruleref{value definition}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed 
         \Ruleref{value definition}
    }}{}


  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

\item[Semantics:] The value definition has the form:
  \begin{alltt}
    \keyw{values}
      \ifthenelse{\boolean{VDMpp}}{access}{} pat1 = e1;
      \ldots
      \ifthenelse{\boolean{VDMpp}}{access}{} patn = en
  \end{alltt}

  
  The global values (defined in a value definition) can be referenced
  at all levels in a \vdmslpp{\vdmsl}{\vdmpp} specification.  However,
  in order to be able to execute a specification these 
  values must be defined before they are used in the sequence of value
  definitions. This ``declaration before use'' principle is only used
  by the interpreter for value definitions.
  Thus for instance functions can be used before they are declared. In
  standard VDM-SL there are not any restrictions on the order of the
  definitions at all. It is possible to provide a type restriction as
  well, and this can be useful in order to obtain more exact type
  information.

#ifdef VDMPP
Details of the access and \keyw{static} specifiers can be found in
section \ref{ch:interface}. 
#endif VDMPP

\item[Examples:] The example below, taken from \cite{Fitzgerald&98}
  assigns token values to identifiers  
  \texttt{p1} and \texttt{eid2}, an \texttt{Expert} record value to 
  \texttt{e3} and an \texttt{Alarm} record value to \texttt{a1}.
\begin{alltt}
     \keyw{types}

     Period = \keyw{token};
     ExpertId = \keyw{token};
     Expert :: expertid : ExpertId
               quali : \keyw{set of} Qualification
     \keyw{inv} ex == ex.quali <> \{\};
     Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
     Alarm :: alarmtext : \keyw{seq of} char
              quali : Qualification

     \keyw{values}
 
     \PUBLIC p1: Period = mk_token("Monday day");
     \PRIVATE eid2 : ExpertId = mk_token(145);
     \PROTECTED e3 : Expert = mk_Expert(eid2, { <Mech>, <Chem> });
     \mbox{} a1 : Alarm = mk_Alarm("CO2 detected", <Chem>)
\end{alltt}
  As this example shows, a value can depend on other values which are
  defined previous to itself.
#ifdef VDMSL
  A top-level specification can consist of
  specifications from a number of files or modules (see
  section~\ref{top-level}).  It is good practice not to let a value depend
  on values defined in other modules as the ordering is important.
#endif VDMSL
\end{description}

#ifdef VDMPP
\section{Instance Variables}
\label{sec:ivars}

Both an object instantiated from a class description and the class
itself can have an internal state, also called the \emph{instance
  variables} of the object or class. In the case of objects, we also
refer to this state as the global state of the object.

\begin{description}
\item[Syntax:]
  \Rule{instance variable definitions}{
    \Lop{instance}, \Lop{variables}, \lfeed
    \OptPt{\Ruleref{instance variable definition}, \lfeed
           \SeqPt{\Lit{;}, 
               \Ruleref{instance variable definition}
                 }
          }
  }
  

  \Rule{instance variable definition}{
    \Ruleref{access assignment definition} \dsep
    \Ruleref{invariant definition}
  }

  \Rule{access assignment definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
    \Ruleref{assignment definition}
  }

\Rule{assignment definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
  \Ruleref{expression}}
  }
\Rule{invariant definition}{
  \Lop{inv}, \Ruleref{expression}
  }

%\Rule{init statement}{
%  \Lop{init}, \Ruleref{statement}
%  }

\item[Semantics:] The section describing the internal state is
preceded by the keyword {\tt instance variables}.  A list of instance
variable definitions and/or invariant definitions follows.  Each
instance variable definition consists of an instance variable name
with its corresponding type indication and may also include an
initial value and access and \keyw{static} specifiers. Details of the
access and \keyw{static} specifiers can be found in section
\ref{ch:interface}. 

It is possible to restrict the values of the instance variables by
means of invariant definitions. Each invariant definition, involving
one or more instance variables, may be defined over the values of the
instance variables of objects of a class. All instance variables in
the class including those inherited from superclasses are visible in
the invariant expression. Each invariant definition must be a 
boolean expression that limits the values of the instance variables to
those where the expression is true. All invariant expressions must be
true during the entire lifetime of each object of the class.

The overall invariant expression of a class is all the invariant
definitions of the class and its superclasses combined by logical
\keyw{and} in the order that they are defined in 1) the superclasses
and 2) the class itself.

%If a class contains one or more invariant definitions, an operation named
%{\tt inv\_classname} is implicitly constructed in the class.%
%\footnote{Not yet supported by the interpreter.}
% *****Check this for next version
This operation is private, has no parameters and returns a boolean
corresponding to the execution of the invariant expression.

\item[Example:]

The following examples show instance variable definitions. The first
class specifies one instance variable: 
  \begin{alltt}
  \keyw{class} GroupPhase

  \keyw{types}

    GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>;
    Team = ... -- as on page \pageref{scoredef}
    Score::team : Team
           won : \keyw{nat}
           drawn : \keyw{nat}
           lost : \keyw{nat}
           points : \keyw{nat};


  \keyw{instance variables}
    gps : \keyw{map} GroupName \keyw{to set of} Score;
  \keyw{inv forall} gp \keyw{in set rng} gps & 
        (\keyw{card} gp = 4 \keyw{and}
         \keyw{forall} sc \keyw{in set} gp & sc.won + sc.lost + sc.drawn <= 3)

  \keyw{end} GroupPhase
  \end{alltt}

% ***** Put this back in in the future if access to invariant can be
% ***** modified from private to public or protected
%The second example demonstrates inheritance.
%  \begin{alltt}
%  \keyw{class} BankAccount
%
%    \keyw{types}
%
%    \PUBLIC digit = \keyw{nat}
%    \keyw{inv} d == d < 10
%
%    \keyw{instance variables}
%      holder : \keyw{seq1 of char};
%      number : \keyw{seq1 of digit};
%      branchcode : \keyw{seq1 of digit};
%    \keyw{inv len} number = 8 \keyw{and len} branchcode = 6
%
%  \keyw{end} BankAccount
%  \end{alltt}
%
%In this example three instance variables are defined: \texttt{holder}
%- a string representing the name of the account holder,
%\texttt{number} - a sequence of digits representing the account
%number, and \texttt{branchcode} - a sequence of digits representing
%the code number of the bank branch holding the account.
%The invariant ensures that at all times the account number has 8
%digits and the branch code has 6 digits.
%
%As the class {\tt BankAccount} contains an invariant definition
%the invariant operation below is implicitly constructed:
%
%  \begin{alltt}
%    \keyw{inv\_}BankAccount: () ==> \keyw{bool}
%    \keyw{inv\_}BankAccount() ==
%      \keyw{return len} number = 8 \keyw{and len} branchcode = 6;
%  \end{alltt}
%
%The effect of inheritance is demonstrated by the class
%\texttt{ATMCard}:
%\begin{alltt}\label{ATMCardDef}
%  \keyw{class} ATMCard \keyw{is subclass of} BankAccount
%
%    \keyw{instance variables}
%      cardnumber : \keyw{seq of} digit;
%      expiry : digit * digit * digit * digit;
%    \keyw{inv} (\keyw{let mk\_}(m1,m2,y1,y2) = expiry
%        in m1 * 10 + m2 <= 12) and
%        \keyw{len} cardnumber >= 8
%
%  \keyw{end} ATMCard
%\end{alltt}
%This is a subclass of \texttt{BankAccount} so it inherits the type
%\texttt{digit}. In this case the implicitly created invariant
%operation is:
%
%  \begin{alltt}
%    \keyw{inv\_}ATMCard: () ==> \keyw{bool}
%    \keyw{inv\_}ATMCard() ==
%      \keyw{return} \keyw{len} number = 8 \keyw{and len} branchcode = 6 \keyw{and}
%            (\keyw{let} mk_(m1,m2,y1,y2) = expiry
%             \keyw{in} m1 * 10 + m2 <= 12) \keyw{and}
%             \keyw{len} cardnumber >= 8;
%  \end{alltt}

\end{description}
#endif VDMPP

#ifdef VDMSL
\section{The State Definition}\label{statedef}

If global variables are desired in a specification, it is possible to make
a state definition. The components of the state definition can be
considered the collection of global variables which can be referenced
inside operations. A state in a module is initialised before any of the
operation definitions (using that state) in a module can be used by
the interpreter.

\begin{description}
\item[Syntax:]
  \Rule{state definition}{
    \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
    \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
    }

  \Rule{invariant}{
    \Lop{inv}, \Ruleref{invariant initial function}
    }

  \Rule{initialisation}{
    \Lop{init}, \Ruleref{invariant initial function}
    }

  \Rule{invariant initial function}{
    \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}}

\item[Semantics:] The state definition has the form:
  \begin{alltt}
    \keyw{state} ident \keyw{of}
      id1 : type1
      \ldots
      idn : typen
    \Keyw{inv}  pat1 == inv
    \Keyw{init} pat2 == init
    \keyw{end}
  \end{alltt}
  A state identifier {\tt idn} is declared of a specific type {\tt typen}.
  The invariant {\tt inv} is a boolean expression denoting a
  property which must hold for the state {\tt ident} at all
  times. {\tt init} denotes a condition which must hold initially.
  It should be noticed that in order to use the
  interpreter, it is
  necessary to have an initialisation predicate (if any of the
  operations using the state are to be executed). In addition the body of
  this initialisation predicate must be a binary equality expression with
  the name (which also must be used as the pattern) of the entire state on
  the left-hand side of the equality and the right-hand side must evaluate
  to a record value of the correct type. This enables the interpreter
  to evaluate the {\tt init} condition. A simple example of an
  initialisation predicate is shown below:

  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{init} s == s = \keyw{mk\_}St(0,0,[1])
  \keyw{end}
  \end{alltt}

  In the specification of both the invariant and the initial value the
  state must be manipulated as a whole, and this is done by referring to it
  as a record tagged with the state name (see the example). When a field in
  the state is manipulated in some operation, the field must however be
  referenced to directly by the field name without pre-fixing it with the
  state name.

\item[Examples:] In the following example we create one state variable:
  \begin{alltt}
  \keyw{types }

  GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>

  \keyw{state} GroupPhase \keyw{of}
    gps : \keyw{map} GroupName \keyw{to set of} Score
  \keyw{inv mk\_}GroupPhase(gps) ==
    \keyw{forall} gp \keyw{in set rng gps} & 
      (\keyw{card} gp = 4 \keyw{and}
       \keyw{forall} sc \keyw{in set} gp & sc.won + sc.lost + sc.drawn <= 3)
  \keyw{init} gp ==
    gp = \keyw{mk\_}GroupPhase ({ <A> |-> 
                                init_sc ({<Brazil>, <Norway>, 
                                    <Morocco>, <Scotland>}),
                         ...})
  \keyw{end}

  \keyw{functions}

  init_sc : \keyw{set of} Team -> \keyw{set of} Score
  init_sc (ts) ==
    \{ \keyw{mk\_}Score (t,0,0,0,0) | t \keyw{in set ts} \}
  \end{alltt}
  In the invariant we state that each group has four teams, and no team 
  plays more than three games. Initially no team has played any games.

\end{description}
#endif VDMSL

\section{Operation Definitions} \label{op-def}

Operations have already been mentioned in section~\ref{algorithm}. The
general form is described
\ifthenelse{\boolean{VDMsl}}{here.}{immediately below, and special
  operations called \emph{constructors} which are used for
  constructing instances of a class are described in
  section~\ref{constructors}.} 

\begin{description}
\item[Syntax:]
  \Rule{operation definitions}{
    \Lop{operations}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                       {\Ruleref{operation definition}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                       {\Ruleref{operation definition}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access operation definition}{(
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep\  
     (
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{operation definition}
    }}{}


\Rule{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }

\Rule{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \lfeed  \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
#ifdef VDMPP
  %, \lfeed
  %\OptPt{\Lop{time}, \Lop{post}, expression}
#endif VDMPP
  }

\Rule{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Rule{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
#ifdef VDMPP
  %\OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{exceptions}}
  }

\Rule{extended explicit operation definition}{
  \Ruleref{identifier}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
#ifdef VDMPP
  %\OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{exceptions}}
}

\Rule{operation type}{
  \Ruleref{discretionary type}, \Lit{{\tt ==>}}, \Ruleref{discretionary type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{()}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{operation body}{
  \Ruleref{statement} \dsep 
#ifdef VDMPP
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!operations}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!operations}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!operations}
#endif VDMSL
  }

\Rule{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Rule{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Rule{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Rule{name list}{
  \Ruleref{identifier}, \SeqPt{\Lit{,}, \Ruleref{identifier}}
  }

\Rule{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Rule{error list}{
  \Ruleref{error}, \SeqPt{\Ruleref{error}}
  }

\Rule{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }

\item[Semantics:]
#ifdef VICEMAN
Operations in VDM are per default synchronous but if the keyword 
``\keyw{async}'' is used in front of an operation definition it means that
that operation will be treated as an asynchronous operation. This means
that the operation cannot have a return type and the thread calling an
asynchronous operation will continue its own execution after having 
requested the invocation of the asynchronous operation. Note that
constructors cannot be declared asynchronous.
#endif VICEMAN
#ifdef VDMPP
Details of the access and \keyw{static} specifiers can be found in
section \ref{ch:interface}. Note that a static operation may not call
non-static operations or functions, and self expressions cannot be
used in the definition of a static operation.
#endif VDMPP

The following example of an explicit operation updates the 
#ifdef VDMSL
state \texttt{GroupPhase} 
#endif VDMSL
#ifdef VDMPP
instance variables of class \texttt{GroupPhase}
#endif VDMPP
when one team beats another.
\begin{alltt}\label{winDef}
  Win : Team * Team ==> ()
  Win (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps := gps ++ \{ gp |-> 
                        \{\keyw{if} sc.team = wt
                         \keyw{then mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                         \keyw{else if} sc.team = lt
                         \keyw{then mu}(sc, lost |-> sc.lost + 1)
                         \keyw{else} sc 
                    | sc \keyw{in set} gps(gp)\}\}
    \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\};
\end{alltt}
An explicit operation consists of a statement (or several composed
using a block statement), as described in section \ref{sec:stmt}. The 
statement may access any 
#ifdef VDMSL
state
#endif
#ifdef VDMPP
instance
#endif
variables it wishes, reading and writing to them as it sees fit.

An implicit operation is specified using an optional pre-condition,
and a mandatory post-condition. For example we could specify the
\texttt{Win} operation implicitly:
\begin{alltt}
  Win (wt,lt: Team)
  \Keyw{ext wr} gps : \keyw{map} GroupName \keyw{to set of} Score
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \Keyw{post} \keyw{exists} gp \keyw{in set dom} gps &
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
         \keyw{and} gps = gps~ ++ 
                       \{ gp |-> 
                         \{\keyw{if} sc.team = wt
                          \keyw{then} \keyw{mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                          \keyw{else if} sc.team = lt
                          \keyw{then mu}(sc, lost |-> sc.lost + 1)
                          \keyw{else} sc 
                     | sc \keyw{in set} gps(gp)\}\};
\end{alltt}

The externals field lists the 
#ifdef VDMSL
state
#endif
#ifdef VDMPP
instance
#endif
variables that the
operation will manipulate. The 
#ifdef VDMSL
state
#endif
#ifdef VDMPP
instance
#endif
variables listed after the reserved
word \keyw{rd} can only be read whereas the operation can both read and
write the variables listed after \keyw{wr}. 
 
#ifdef VDMSL
For these pre- and post-conditions the interpreter also
creates new functions as with the pre- and post-conditions of operation
definitions.  However, if a specification contains a global state, the
state is also part of the newly created functions. Thus, functions
with the following signatures are created for operations with pre-
and/or post-conditions\footnote{However, you should remember that
these pre and post condition predicates for an operation are simply
boolean functions and the state components are thus not changed by
calling such a predicate.}:
\begin{alltt}
  \keyw{pre\_}Op : InType * State +> \keyw{bool}

  \keyw{post\_}Op : InType * OutType * State * State +> \keyw{bool}
\end{alltt}
with the following exceptions:
\begin{itemize}
\item If the operation does not take any arguments, the {\tt InType} part
  of the signature is left out in both the {\tt \keyw{pre\_}Op} and {\tt
    \keyw{post\_}Op} signatures.

\item If the operation does not return a value, the {\tt OutType} part is
  left out in the {\tt \keyw{post\_}Op} signature.

\item If the specification does not define a state, the {\tt State} part(s)
  of both signatures are left out.
\end{itemize}

In the {\tt \keyw{post\_}Op} signature, the first {\tt State} part is for
the old state, whereas the second {\tt State} part is for the 
state after the operation call.

For instance, consider the following specifications:

\begin{quotation}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} A

\keyw{definitions}

\keyw{state} St \keyw{of}
  n : \keyw{nat}
\keyw{end}

\keyw{operations}

Op1 (a : \keyw{nat}) b :\keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} A

\end{alltt}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} B

\keyw{definitions}

\keyw{operations}

Op1 (a : \keyw{nat}) b : \keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} B
\end{alltt}
\end{minipage}
\end{quotation}

For \textbf{module A} we could then quote the pre and post conditions
defined in this specification as illustrated below

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1,\keyw{mk}\_St(2))              
  & \texttt{a} bound to 1 in state \texttt{St} with \texttt{n}  bound to 2 \\
\keyw{post}\_Op1(1,2,\keyw{mk}\_St(1), \keyw{mk}\_St(2)) 
  & \texttt{a} bound to 1, \texttt{b} bound to 2, state before with
    \texttt{n} bound to 1, state after with \texttt{n} bound to 2 \\
\keyw{post}\_Op2(2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))   
  & \texttt{b} bound to 2, state before with \texttt{n} bound to 1, state
    after with \texttt{n} bound to 2 \\
\keyw{post}\_Op3(\keyw{mk}\_St(1), \keyw{mk}\_St(2))     
  & state before with \texttt{n} bound to 1, state after with
    \texttt{n} bound to 2 \\
\hline
\end{tabular}

For \textbf{module B} we can quote the pre and post conditions defined
in this specification as illustrated below

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1)     & \texttt{a} bound to 1 \\
\keyw{post}\_Op1(1,2)  & \texttt{a} bound to 1, \texttt{b} bound to 2\\
\keyw{post}\_Op2(2)    & \texttt{b} bound to 2\\
\keyw{post}\_Op3()     & No binding at all\\
\hline
\end{tabular}

\vspace{2ex}

#endif VDMSL

The exceptions clause can be used to describe how an operation should
deal with error situations. The rationale for having the exception
clause is to give the user the ability to separate the exceptional
cases from the normal cases. The specification using exceptions does
not give any commitment as to how exceptions are to be signalled, but
it gives the means to show under which circumstances an error
situation can occur and what the consequences are for the result of
calling the operation.

The exception clause has the form:
\begin{alltt}
   \keyw{errs} COND1: c1 -> r1
       \ldots
       CONDn: cn -> rn
\end{alltt}
The condition names {\tt COND1}, \ldots, {\tt CONDn} are identifiers
which describe the kind of error which can be raised\footnote{Notice
that these names are purely of mnemonic value, i.e.\ semantically they
are not important.}. The condition expressions {\tt c1}, \ldots, {\tt
cn} can be considered as pre-conditions for the different kinds of
errors. Thus, in these expressions the identifiers from the arguments
list and the variables from the externals list can be used (they have
the same scope as the pre-condition). The result expressions {\tt r1},
\ldots, {\tt rn} can correspondingly be considered as post-conditions
for the different kinds of errors. In these expressions the result
identifier and old values of global variables (which can be written
to) can also be used. Thus, the scope corresponds to the scope of the
post-condition.

Superficially there appears to be some redundancy between exceptions
and pre-conditions here. However there is a conceptual distinction
between them which dictates which should be used and when. The
pre-condition specifies what callers  to the operation must ensure for
correct behaviour; the exception clauses indicate that the operation
being specified takes responsibility for error handling when an
exception condition is satisfied. Hence normally exception clauses and
pre-conditions do not overlap.

#ifdef VDMSL
The next example of an operation uses the following state definition:
\begin{alltt}
  \keyw{state} qsys \keyw{of}
    q : Queue
  \keyw{end}
\end{alltt}    
#endif
#ifdef VDMPP
The next example of an operation uses the following instance variable definition:
\begin{alltt}
  \keyw{instance variables}
    q : Queue
  \keyw{end}
\end{alltt}    
#endif
This example shows how exceptions with an implicit definition can be used:
\begin{alltt}
  DEQUEUE() e: [Elem]
  \keyw{ext} \keyw{wr} q : Queue
  \keyw{post} q~ = [e] ^ q
  \keyw{errs} QUEUE_EMPTY: q = [] -> q = q~ \keyw{and} e = \keyw{nil}
\end{alltt}

This is a dequeue operation which uses a global variable {\tt q} of
type {\tt Queue} to get an element {\tt e} of type {\tt Elem} out of
the queue. The exceptional case here is that the queue in
which the exception clause specifies how the operation should
behave is empty.

#ifdef VDMSL
Note that the Toolbox creates a function here:
\begin{alltt}
  \keyw{post\_}DEQUEUE: [Elem] * qsys * qsys +> \keyw{bool}
\end{alltt}
#endif

#ifdef VDMPP

%The time post-condition has the same scope as the post-condition and
%deals with the duration of the operation from the invocation moment
%until the moment it finishes. Thus describing for explicitly specified
%operations, the duration of the statement.
%
%The following two extra concepts are
%introduced: {\tt now\verb+~+}, representing the time the operation is
%invoked (moment of incrementing {\tt \#act}) and {\tt now},
%representing the time the operation is completely finished (moment of
%incrementing {\tt \#fin}). The expression:
%\begin{alltt}
%  now - now\verb+~+
%\end{alltt}
%represents the duration of the operation. 
%
%For instance, consider the specification of a system for controlling a
%set of traffic lights. We might have the following instance variables:
%\begin{alltt}
%  \keyw{instance variables}
%    red: \keyw{bool};
%    green: \keyw{bool};
%    amber: \keyw{bool};
%  \keyw{inv} (red => (\keyw{not} green \keyw{and not} amber)) \keyw{and}
%     (green => (\keyw{not} amber \keyw{and not} red)) \keyw{and}
%     (amber => (\keyw{not} red \keyw{and not} green))
%\end{alltt}
%Then the following operation specifies that on execution the light
%must change from red to green within 20 time units:
%\begin{alltt}
%    RedToGreen()
%    \keyw{ext wr} red: \keyw{bool}
%       \keyw{wr} green: \keyw{bool}
%    \keyw{pre} red
%    \keyw{post} green
%    \keyw{time post now} - \keyw{now}~ < 20
%\end{alltt}

#endif VDMPP

\end{description}

#ifdef VDMPP
\subsection{Constructors}\label{constructors}

Constructors are operations which have the same name as the class in
which they are defined and which create new instances of that
class. Their return type must therefore be the same class
name, and if a return value is specified this should be \keyw{self}
though this can optionally be omitted.

Multiple constructors can be defined in a single class using
operation overloading as described in section~\ref{sec:classdep}. 

#endif VDMPP

\section{Statements}\label{sec:stmt}

In this section the different kind of statements will be described
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\subsection{Let Statements}\label{letstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \Ruleref{let statement} \dsep
    \Ruleref{let be statement} \dsep
    \ldots
    }

  \Rule{let statement}{
    \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{statement}
    }

  \Rule{let be statement}{
    \Lop{let}, \Ruleref{bind}, \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{local definition}{
    \Ruleref{value definition} \dsep \Ruleref{function definition}
    }

  \Rule{value definition}{ 
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  where the ``function definition'' component is described in
  section~\ref{functiondef}.

\item[Semantics:] The {\it let statement} and the {\it let-be-such-that
    statement} are similar to the corresponding {\it let} and {\it
    let-be-such-that expressions} except that the {\it in} part is a
  statement instead of an expression. Thus it can be explained as follows:

  A simple {\it let statement} has the form:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} s
  \end{alltt}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding patterns {\tt pi}, and {\tt s}
  is a statement, of any type, involving the pattern identifiers of {\tt
    p1, \ldots, pn}. It denotes the evaluation of the statement {\tt s} in
  the context in which the patterns {\tt p1, \ldots, pn} are matched
  against the corresponding expressions {\tt e1, \ldots, en}.

  More advanced let statements can also be made by using local function
  definitions. The semantics of doing that is simply that the scope of such
  locally defined functions is restricted to the body of the let statement.

#ifdef VDMSL
  In VDM-SL the collection of definitions may be mutually recursive.
  However, this is not supported by the interpreter in  VDM-SL.
  Furthermore, the definitions must be ordered such that
  all constructs are defined before they are used.
#endif VDMSL

  A {\it let-be-such-that statement} has the form
  \begin{alltt}
    \keyw{let} b \keyw{be st} e \keyw{in} s
  \end{alltt}
  where {\tt b} is a binding of a pattern to a set value (or a type), {\tt
    e} is a boolean expression, and {\tt s} is a statement, involving the
  pattern identifiers of the pattern in {\tt b}. The {\tt \keyw{be st} e}
  part is optional. The expression denotes the evaluation of the statement
  {\tt s} in the context where the pattern from {\tt b} has been matched
  against an element in the set (or type) from {\tt b}\footnote{Remember
    that only the set bindings can be executed by means of the
    interpreter.}. 
  If the \keyw{be st}
  expression {\tt e} is present, only such bindings where {\tt e} evaluates
  to true in the matching context are used.
     
\item[Examples:] An example of a \keyw{let be st} statement is provided in the
  operation \texttt{GroupWinner} 
#ifdef VDMPP
from the class \texttt{GroupPhase}
#endif VDMPP
  which returns the winning team in a given group: 
  \begin{alltt}
  GroupWinner : GroupName ==> Team
  GroupWinner (gp) ==
    \keyw{let} sc \keyw{in set} gps(gp) \keyw{be st}
       \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} & 
          (sc.points > sc'.points) \keyw{or}
          (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
    \keyw{in return} sc.team
  \end{alltt}
  The companion operation \texttt{GroupRunnerUp} gives an example of a simple 
  let statement as well:
  \begin{alltt}
  GroupRunnerUp_expl : GroupName ==> Team
  GroupRunnerUp_expl (gp) ==
    \keyw{def} t = GroupWinner(gp)
    \keyw{in let} sct = \keyw{iota} sc \keyw{in set} gps(gp) & sc.team = t
      \keyw{in}
         \keyw{let} sc \keyw{in set} gps(gp) \verb+\+ \{sct\} \keyw{be st}
           \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc,sct\} & 
             (sc.points > sc'.points) \keyw{or}
             (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
         \keyw{in return} sc.team
  \end{alltt}
  Note the use of the \texttt{def} statement (section \ref{defstmt})
  here; this is used rather than a \texttt{let} statement since the
  right-hand side is an operation call, and therefore is not an
  expression. 

\end{description}

\subsection{The Define Statement}\label{defstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{def statement} \dsep \ldots
    }

  \Rule{def statement}{
    \Lop{def}, 
    \Ruleref{equals definition}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{equals definition}},\OptPt{\Lit{;}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    } 

  \Rule{equals definition}{
    \Ruleref{pattern bind}, \Lit{=},
    \Ruleref{expression}}

\item[Semantics:] A {\it define statement} has the form:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \keyw{in}
      s
  \end{alltt}
  The {\it define statement} corresponds to a {\it define expression}
  except that it is also allowed to use operation calls on the right-hand
  sides. Thus, operations that change the state can also be used here, and
  if there are more than one definition they are evaluated in the order in
  which they are presented.  It denotes the evaluation of the statement
  {\tt s} in the context in which the patterns (or binds) {\tt pb1, \ldots,
    pbn} are matched against the values returned by the corresponding
  expressions or operation calls {\tt e1, \ldots, en}\footnote{If binds are
    used it simply means that the values which can match the pattern are
    further constrained by the type or set expression as it is explained in
    section~\ref{patterns}.}.

\item[Examples:] Given the following sequences:
  \begin{alltt}
  secondRoundWinners = [<A>,<B>,<C>,<D>,<E>,<F>,<G>,<H>];
  secondRoundRunnersUp = [<B>,<A>,<D>,<C>,<F>,<E>,<H>,<G>]
  \end{alltt}
  The operation \texttt{SecondRound}%
#ifdef VDMPP
, from class \texttt{GroupPhase}
#endif VDMPP
  returns the sequence of pairs 
  representing the second round games gives an example of a \keyw{def} 
  statement:
  \begin{alltt}
  SecondRound : () ==> \keyw{seq of} (Team * Team)
  SecondRound () ==
  \keyw{def} winners = \{ gp |-> GroupWinner(gp) | gp \keyw{in set dom} gps \};
     runners_up = \{ gp |-> GroupRunnerUp(gp) | gp \keyw{in set dom} gps\}
  \keyw{in return} ([mk_(winners(secondRoundWinners(i)),
                runners_up(secondRoundRunnersUp(i))) 
           | i \keyw{in set} \{1,...,8\}])
  \end{alltt}

\end{description}

\subsection{The Block Statement} \label{dcl-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{block statement} \dsep \ldots
    }

  \Rule{block statement}{
    \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
    \Ruleref{statement}, \SeqPt{\Lit{;}, \Ruleref{statement}}, \OptPt{\Lit{;}}, \Lit{)}
    }

  \Rule{dcl statement}{
    \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
    }

  \Rule{assignment definition}{
    \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
    \Ruleref{expression}}}

\item[Semantics:] The {\it block statement} corresponds to block statements
  from traditional high-level programming languages.  It enables the use of
  locally defined variables (by means of the declare statement) which can
  be modified inside the body of the block statement. It simply denotes the
  ordered execution of what the individual statements prescribe. The first
  statement in the sequence that returns a value causes the evaluation of
  the sequence statement to terminate. This value is returned as the
  value of the block statement. If none of the statements in the block
  returns a value, the evaluation of the block statement is terminated when
  the last statement in the block has been evaluated. When the block
  statement is left the values of the local variables are discharged. Thus,
  the scope of these variables is simply inside the block statement.
      
\item[Examples:] In the context of 
#ifdef VDMSL
state definition
  \begin{alltt}\label{stdef}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
#endif VDMSL
#ifdef VDMPP
instance variables
  \begin{alltt}\label{stdef}
  \keyw{instance variables}
    x:\keyw{nat};
    y:\keyw{nat};
    l:\keyw{seq1 of nat};
  \end{alltt}
#endif VDMPP
  the operation \texttt{Swap} uses a block statement to swap the values of 
  variables \texttt{x} and \texttt{y}:
  \begin{alltt}
  Swap : () ==> ()
  Swap () ==
    (\keyw{dcl} temp: \keyw{nat} := x;
     x := y;
     y := temp
    )
  \end{alltt}

\end{description}

\subsection{The Assignment Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \ifthenelse{\boolean{VDMpp}}{\Ruleref{general assign statement}}%
                                {\Ruleref{assign statement}} \dsep
    \ldots
    }

\ifthenelse{\boolean{VDMpp}}{%
  \Rule{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
}%
{}

\Rule{assign statement}{
  \Ruleref{state designator}, \Lit{:=}, 
    \Ruleref{expression}
  }

  \Rule{state designator}{
    \Ruleref{name} \dsep
    \Ruleref{field reference} \dsep
    \Ruleref{map or sequence reference}
    }

  \Rule{field reference}{
    \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
    }

%koizumi change_start
%  \Rule{map reference}{
%    \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
%    }

%  \Rule{sequence reference}{
%    \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
%    }

   \Rule{map or sequence reference}{
     \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
     }
%koizumi change_end

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{multiple assign statement}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \SeqPt{\Lit{;},\Ruleref{assign statement}}
    \Lit{)}
    }
%  }%
%{}

\item[Semantics:] The {\it assignment statement} corresponds to a
  generalisation of assignment statements from traditional high level
  programming languages. It is used to change the value of the global or
  local state. Thus, the assignment statement has side-effects on the
  state. However, in order to be able to simply change a part of the state,
  the left-hand side of the assignment can be a state designator. A state
  designator is either simply the name of a global variable, a reference to
  a field of a variable, a map reference of a variable, or a sequence
  reference of a variable. In this way it is possible to change the value
  of a small component of the state. For example, if a state component is a
  map, it is possible to change a single entry in the map.

  An assignment statement has the form:
  \begin{alltt}
    sd := ec
  \end{alltt}
  where {\tt sd} is a state designator, and {\tt ec} is either an
  expression or a call of an operation. The assignment statement denotes the
  change to the given state component described at the right-hand side
  (expression or operation call). If the right-hand side is a state
  changing operation then that operation is executed (with the
  corresponding side effect) before the assignment is made.


  Multiple assignment is also possible. This has the form:
  \begin{alltt}
    \keyw{atomic} (sd1 := ec1;
\           ...;
\           sdN := ecN
           )
  \end{alltt}
  All of the expressions or operation calls on the right hand sides are
  executed or evaluated, and then the results are bound to the
  corresponding state designators. The right-hand sides are executed
  atomically with respect to invariant evaluation. 
#ifdef VDMPP
 However in the case
  of a multi-threaded concurrent model, execution is not necessarily
  atomic with respect to task switching.
#endif VDMPP

\item[Examples:] The operation in the previous example (\texttt{Swap}) 
  illustrated normal assignment. The operation \texttt{Win\_sd}, a 
  refinement of \texttt{Win} on page \pageref{winDef} illustrates the use of 
  state designators to assign to a specific map key:
  \begin{alltt}
  Win_sd : Team * Team ==> ()
  Win_sd (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
        \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps(gp) := \{ \keyw{if} sc.team = wt
                   \keyw{then mu}(sc, won |-> sc.won + 1,
                               points |-> sc.points + 3)
                   \keyw{else if} sc.team = lt
                   \keyw{then mu}(sc, lost |-> sc.lost + 1)
                   \keyw{else} sc 
                 | sc \keyw{in set} gps(gp)\}
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
                 \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \end{alltt}
  The operation \texttt{SelectionSort} is a state based version of the 
  function \texttt{selection\_sort} on page \pageref{selectionSortdef}. It 
  demonstrates the use of state designators to modify the contents of a 
  specific sequence index, using the 
#ifdef VDMSL
state \texttt{St}
#endif VDMSL
#ifdef VDMPP
instance variables
#endif VDMPP
 defined on page~\pageref{stdef}. 
  \begin{alltt}
  \keyw{functions}
 
  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
  \keyw{if len} l = 1 \keyw{then} 1
  \keyw{else let} mi = min_index(\keyw{tl} l)
     \keyw{in if} l(mi+1) < \keyw{hd} l
       \keyw{then} mi+1
       \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    \keyw{if} i < \keyw{len} l
    \keyw{then} (\keyw{dcl} temp: \keyw{nat};
         \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         temp := l(mi);
         l(mi) := l(i);
         l(i) := temp;
         SelectionSort(i+1)
        );
  \end{alltt}
#ifdef VDMPP
  The following example illustrates multiple assignment.
  \begin{alltt}
  \keyw{class} C

    \keyw{instance variables}
      size : \keyw{nat};
      l : \keyw{seq of nat};
    \keyw{inv} size = \keyw{len} l

    \keyw{operations}
      add1 : \keyw{nat} ==> ()
      add1 (x) ==
         ( l := [x] ^ l;
           size := size + 1);

      add2 : \keyw{nat} ==> ()
      add2 (x) ==
         atomic (l := [x] ^ l;
                 size := size + 1)

  \keyw{end} C
  \end{alltt}
Here, in \texttt{add1} the invariant on the class's instance variables
is broken, whereas in \texttt{add2} using the multiple assignment, the
invariant is preserved.
#endif VDMPP

\end{description}

\subsection{Conditional Statements}\label{condstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{if statement} \dsep
    \Ruleref{cases statement} \dsep \ldots
    }

  \Rule{if statement}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
    \SeqPt{\Ruleref{elseif statement}}, \OptPt{\Lop{else}, \Ruleref{statement}}
    }

  \Rule{elseif statement}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
    }

  \Rule{cases statement}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases statement alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
    }

  \Rule{cases statement alternatives}{
    \Ruleref{cases statement alternative}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
    }

  \Rule{cases statement alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
    }

  \Rule{others statement}{
    \Lop{others}, \Lit{->}, \Ruleref{statement}
    }

\item[Semantics:] The semantics of the {\it if statement} corresponds to
  the {\it if expression} described in section~\ref{if-exp} except for the
  alternatives which are statements (and that the \keyw{else} part is
  optional)\footnote{If the \keyw{else} part is omitted
  semantically it is like using \keyw{else skip}.}.
  
  The semantics for the {\it cases statement} corresponds
  to the {\it cases expression} described in section~\ref{cases-exp} except
  for the alternatives which are statements.

\item[Examples:] Assuming functions \texttt{clear\_winner} and 
  \texttt{winner\_by\_more\_wins} and operation \texttt{RandomElement} 
  with the following signatures:
  \begin{alltt}
    clear_winner : \keyw{set of} Score -> \keyw{bool}
    winner_by_more_wins : \keyw{set of} Score -> \keyw{bool}
    RandomElement : \keyw{set of} Team ==> Team
  \end{alltt}
  then the operation \texttt{GroupWinner\_if} demonstrates the use of a 
  nested if statement (the iota expression is presented on page 
  \pageref{iotaexpr}):
  \begin{alltt}
  GroupWinner_if : GroupName ==> Team
  GroupWinner_if (gp) ==
    \keyw{if} clear_winner(gps(gp))
     -- return unique score in gps(gp) which has more points
     -- than any other score
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                   \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                     sc.points > sc'.points).team)
    \keyw{else if} winner_by_more_wins(gps(gp))
     -- return unique score in gps(gp) with maximal points
     -- & has won more than other scores with maximal points
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
              \keyw{forall} sc' \keyw{in set} gps(gp) \verb+f+\ \{sc\} &
                (sc.points > sc'.points) \keyw{or}
                (sc.points = sc'.points \keyw{and} 
                 sc.won > sc'.won)).team)
     -- no outright winner, so choose random score 
     -- from joint top scores
    \keyw{else} RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                           \keyw{forall} sc' \keyw{in set} gps(gp) &
                            sc'.points <= sc.points\} );
  \end{alltt}
  Alternatively, we could use a cases statement with match value patterns for
  this operation: 
  \begin{alltt}
  GroupWinner_cases : GroupName ==> Team
  GroupWinner_cases (gp) ==
    \keyw{cases true}:
      (clear_winner(gps(gp))) -> 
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                      sc.points > sc'.points).team),

      (winner_by_more_wins(gps(gp))) ->
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                       (sc.points > sc'.points) \keyw{or}
                       (sc.points = sc'.points \keyw{and} 
                          sc.won > sc'.won)).team),

      \keyw{others} -> RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                                  \keyw{forall} sc' \keyw{in set} gps(gp) &
                                   sc'.points <= sc.points\} )
    end
  \end{alltt}

\end{description}

\subsection{For-Loop Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{sequence for loop} \dsep
    \Ruleref{set for loop} \dsep
    \Ruleref{index for loop} \dsep \ldots
    }

  \Rule{sequence for loop}{
    \Lop{for}, \Ruleref{pattern bind}, \Lop{in}, 
    \OptPt{\Lop{reverse}}, \Ruleref{expression}, \lfeed
    \Lop{do}, \Ruleref{statement}
    }\index{for loop}

  \Rule{set for loop}{
    \Lop{for}, \Lop{all}, \Ruleref{pattern},
    \Lit{\keyw{in set}}, \Ruleref{expression},\lfeed
    \Lop{do}, \Ruleref{statement}
    }

  \Rule{index for loop}{
    \Lop{for}, \Ruleref{identifier}, \Lit{$=$}, \Ruleref{expression},
    \Lop{to}, \Ruleref{expression}, \lfeed
    \OptPt{\Lop{by}, \Ruleref{expression}}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] There are three kinds of {\it for-loop statements}. The
  for-loop using an index is known from most high-level programming
  languages. In addition, there are two for-loops for traversing sets and
  sequences. These are especially useful if access to all
  elements from a set (or sequence) is needed one by one.

  An {\it index for-loop statement} has the form:
  \begin{alltt}
    \keyw{for} id = e1 \keyw{to} e2 \keyw{by} e3 \keyw{do}
    s
  \end{alltt}
  where {\tt id} is an identifier, {\tt e1} and {\tt e2} are integer
  expressions indicating the lower and upper bounds for the loop, {\tt e3}
  is an integer expression indicating the step size, and {\tt s} is a
  statement where the identifier {\tt id} can be used. It denotes the
  evaluation of the statement {\tt s} as a sequence statement where the
  current context is extended with a binding of {\tt id}. Thus, the first
  time {\tt s} is evaluated {\tt id} is bound to the value returned from
  the evaluation of the lower bound {\tt e1} and so forth until the upper
  bound is reached ie. until \texttt{s} $>$ \texttt{e2} . Note that
  {\tt e1, e2} and {\tt e3} are evaluated before entering the loop.

  A {\it set for-loop statement\/} has the form:
  \begin{alltt}
    \keyw{for all} e \keyw{in set} S \keyw{do}
    s
  \end{alltt}
  where {\tt S} is a set expression. The statement {\tt s} is evaluated in
  the current environment extended with a binding of e to subsequent values
  from the set {\tt S}.

  A {\it sequence for-loop statement\/} has the form:
  \begin{alltt}
    \keyw{for} e \keyw{in} l \keyw{do}
    s
  \end{alltt}
  where {\tt l} is a sequence expression. The statement {\tt s} is
  evaluated in the current environment extended with a binding of e to
  subsequent values from the sequence {\tt l}. If the keyword
  \keyw{reverse} is used the elements of the sequence {\tt l} will be
  taken in reverse order.

\item[Examples:] The operation \texttt{Remove} demonstrates the use of a 
  \textit{sequence-for} loop to remove all occurences of a given number from a 
  sequence of numbers:
  \begin{alltt}\label{removeDef}
  Remove : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove (k,z) ==
  (\keyw{dcl} nk : \keyw{seq of nat} := [];
   \keyw{for} elem \keyw{in} k \keyw{do}
     \keyw{if} elem <> z
     \keyw{then} nk := nk^[elem];
   \keyw{return} nk
  );
  \end{alltt}
  A \textit{set-for} loop can be exploited to return the set of winners of 
  all groups:
  \begin{alltt}
  GroupWinners: () ==> \keyw{set of} Team
  GroupWinners () ==
  (\keyw{dcl} winners : \keyw{set of} Team := \{\};
   \keyw{for all} gp \keyw{in set dom} gps \keyw{do}
     (\keyw{dcl} winner: Team := GroupWinner(gp);
      winners := winners \keyw{union} \{winner\}
     );
   \keyw{return} winners
   );
  \end{alltt}
  An example of a \textit{index-for} loop is the classic bubblesort 
  algorithm:
  \begin{alltt}
  BubbleSort : \keyw{seq of nat} ==> \keyw{seq of nat}
  BubbleSort (k) ==
    (\keyw{dcl} sorted_list : \keyw{seq of nat} := k;
     \keyw{for} i = \keyw{len} k \keyw{to} 1 \keyw{by} -1 \keyw{do}
       \keyw{for} j = 1 to i-1 \keyw{do}
         \keyw{if} sorted_list(j) > sorted_list(j+1)
         \keyw{then} (\keyw{dcl} temp:\keyw{nat} := sorted_list(j);
               sorted_list(j) := sorted_list(j+1);
               sorted_list(j+1) := temp
              );
     \keyw{return} sorted_list
     )
\end{alltt}
\end{description}

\subsection{The While-Loop Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{while loop} \dsep \ldots
    }
  
  \Rule{while loop}{
    \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] The semantics for the {\it while statement} corresponds
  to the while statement from traditional programming languages. The form
  of a {\it while loop\/} is:
  \begin{alltt}
    \keyw{while} e \keyw{do}
      s
  \end{alltt}
  where {\tt e} is a boolean expression and {\tt s} a statement. As long as
  the expression {\tt e} evaluates to \keyw{true} the body statement {\tt
    s} is evaluated.

\item[Examples:] The {\it while loop} can be illustrated by the following
  example which uses Newton's method to approximate the square root of
  a real number \texttt{r} within relative error \texttt{e}.
  \begin{alltt}\label{squarerootDef}
  SquareRoot : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRoot (r,e) ==
    (\keyw{dcl} x:\keyw{real} := 1,
        nextx:\keyw{real} := r;
     \keyw{while} \keyw{abs} (x - nextx) >= e * x \keyw{do}
       ( x := nextx;
         nextx := ((r / x) + x) / 2;
       );
     \keyw{return} nextx
    );
  \end{alltt}
\end{description}

\subsection{The Nondeterministic Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{nondeterministic statement} \dsep \ldots
    }
  
  \Rule{nondeterministic statement}{
    \Lit{||}, \Lit{(}, \Ruleref{statement},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
    }

\item[Semantics:] The {\it nondeterministic statement} has the form:
  \begin{alltt}
    || (stmt1, stmt2, \ldots, stmtn)
  \end{alltt}
  and it represents the execution of the component statements {\tt
    stmti} in an arbitrary (non-deterministic)
  order. However, it
  should be noted that the component statements are not executed
  simultaneously. Notice that the interpreter will use an
  underdetermined\footnote{Even though the
    user of the interpreter does not know
    the order in which these statements are executed they are always
    executed in the same order unless the seed option is used.} semantics even though this construct
  is called a non-deterministic statement.

\item[Examples:] Using the 
#ifdef VDMSL
state definition
  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
#endif VDMSL
#ifdef VDMPP
instance variables
  \begin{alltt}
  \keyw{instance variables}
    x:\keyw{nat};
    y:\keyw{nat};
    l:\keyw{seq1 of nat};
  \end{alltt}
#endif VDMPP
  we can use the non-deterministic statement to effect a bubble sort:
  \begin{alltt}\label{sortDef}
  Sort: () ==> ()
  Sort () ==
    \keyw{while} x < y \keyw{do}
      ||(BubbleMin(), BubbleMax());
  \end{alltt}
  Here \texttt{BubbleMin} ``bubbles'' the minimum value in the
  subsequence \texttt{l(x,...,y)} to the head of the subsequence and
  \texttt{BubbleMax} ``bubbles'' the maximum value in the subsequence
  \texttt{l(x,...,y)} to the last index in the
  subsequence. \texttt{BubbleMin} works by first iterating through the
  subsequence to find the index of the minimum value. The contents of
  this index are then swapped with the contents of the head of the
  list, \texttt{l(x)}.
  \begin{alltt}
  BubbleMin : () ==> ()
  BubbleMin () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find min val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) < m
       \keyw{then} ( m := l(i);
              z := i);
     -- move min val to index x
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(x);
      l(x) := l(z);
      l(z) := temp;
      x := x+1));
\end{alltt}
\texttt{BubbleMax} operates in a similar fashion. It iterates through the
  subsequence to find the index of the maximum value, then swaps the
  contents of this index with the contents of the last element of the
  subsequence. 
\begin{alltt}
  BubbleMax : () ==> ()
  BubbleMax () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find max val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) > m
       \keyw{then} ( m := l(i);
              z := i);
     -- move max val to index y
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(y);
      l(y) := l(z);
      l(z) := temp;
      y := y-1));
  \end{alltt}
\end{description}

\subsection{The Call Statement}
\label{call-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{call statement} \dsep \ldots
    }
#ifdef VDMSL
  \Rule{call statement}{
    \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }
#endif VDMSL
#ifdef VDMPP
  \Rule{call statement}{
    \OptPt{\Ruleref{object designator}, \Lit{.}},
    name, \lfeed
    \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)},
    }
  \Rule{object designator}{
    \Ruleref{name} \dsep
    \Ruleref{self expression} \dsep
    \Ruleref{new expression} \dsep
   \Ruleref{object field reference} \dsep
    \Ruleref{object apply}
  }

  \Rule{object field reference}{
    \Ruleref{object designator}, \Lit{.}, \Ruleref{identifier}
  }

  \Rule{object apply}{
    \Ruleref{object designator}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
#endif VDMPP

\item[Semantics:] The {\it call statement} has the form:
#ifdef VDMSL
  \begin{alltt}
    opname(param1, param2, \ldots, paramn)
  \end{alltt}
#endif VDMSL

#ifdef VDMPP
  \begin{alltt}
    object.opname(param1, param2, \ldots, paramn)
  \end{alltt}
#endif VDMPP

  The {\it call statement} calls an operation, {\tt opname}, %
#ifdef VDMPP in an object, {\tt expression},
#endif VDMPP
and returns the result of
  evaluating the operation. Because operations can manipulate global
  variables a {\it call statement} does not necessarily have to return
  a value as function calls do.

#ifdef VDMPP 
  If an {\vppsmall object designator} is specified it must yield an
  object reference to an object of a class in which the operation
  {\tt opname} is defined, and then the operation must be specified as
  public. If no {\tt object designator} is specified the
  operation will be called in the current object. If the operation is
  defined in a superclass, it must have been defined as public or
  protected. 
#endif VDMPP

\item[Examples:] \mbox{} 
#ifdef VDMSL
  The operation {\tt ResetStack} given below does not
  have any parameter and does not return a value whereas the operation {\tt
    PopStack} returns the top element of the stack.
  \begin{alltt}
    ResetStack();
    ...
    top := PopStack();
  \end{alltt}
  where {\tt PopStack} could be defined as:
  \begin{alltt}
    PopStack: () ==> Elem
    PopStack() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack
  \end{alltt}
  where {\tt stack} is a global variable.

#endif VDMSL
#ifdef VDMPP

  Consider the following simple specification of a {\tt Stack}:

  \begin{alltt}
  class Stack

  instance variables
    stack: seq of Elem := [];

  operations

    \PUBLIC Reset: () ==> ()
    Reset() ==
      stack := []; 

    \PUBLIC Pop: () ==> Elem
    Pop() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack

  end Stack
  \end{alltt}

  In the example the operation {\tt Reset} does not have any parameters
  and does not return a value whereas the operation {\tt Pop} returns
  the top element of the stack. The stack could be used as follows:
  \begin{alltt}
    ( dcl stack := new Stack();
      stack.Reset();
      ....
      top := stack.Pop();
    )
  \end{alltt}
 
  Inside class {\tt Stack} the operations can be called as shown below:   
  \begin{alltt}
    Reset();
    ....
    top := Pop();
  \end{alltt}
  
  Or using the \keyw{self}\index{self expressions} reference:
  \begin{alltt}
    \keyw{self}.Reset();
    top := \keyw{self}.Pop();
  \end{alltt}

#endif VDMPP
\end{description}

\subsection{The Return Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{return statement} \dsep \ldots
    }

  \Rule{return statement}{
    \Lop{return}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The {\it return statement} returns the value of an
  expression inside an operation. The value is evaluated in the given
  context. If an operation does not return a value, the expression must be
  omitted. A {\it return statement\/} has the form:
  \begin{alltt}
    return e
  \end{alltt}
  or
  \begin{alltt}
    return
  \end{alltt}
  where expression {\tt e} is the return value of the operation.

\item[Examples:] In the following example {\tt OpCall} is an operation call
  whereas {\tt FunCall} is a function call. As the {\it if statement\/}
  only accepts statements in the two branches {\tt FunCall} is
  ``converted'' to a statement by using the {\it return statement}.
  \begin{alltt}
    \keyw{if} test
    \Keyw{then} OpCall()
    \Keyw{else} \keyw{return} FunCall()
  \end{alltt}
#ifdef VDMPP
  For instance, we can extend the \texttt{stack} class from the
  previous section with an operation which examines the top of the
  stack:
\begin{alltt}
  \PUBLIC Top : () ==> Elem
  Top() ==
    \keyw{return} (\keyw{hd} stack);
\end{alltt}
#endif

\end{description}

\subsection{Exception Handling Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{always statement} \dsep
    \Ruleref{trap statement} \dsep
    \Ruleref{recursive trap statement} \dsep
    \Ruleref{exit statement} \dsep \ldots
    }

  \Rule{always statement}{
    \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{trap statement}{
    \Lop{trap}, \Ruleref{pattern bind}, \Lop{with},
    \Ruleref{statement}, \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{recursive trap statement}{
    \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{traps}{
    \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
    \SeqPt{ \Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement} },
    \Lit{\}}
    }

  \Rule{exit statement}{
    \Lop{exit}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The exception handling statements are used to control
  exception errors in a specification. This means that we have to be
  able to signal an exception within a specification. This can be done with
  the {\it exit statement}, and has the form:
  \begin{alltt}
    \keyw{exit} e
  \end{alltt}
  or
  \begin{alltt}
    \keyw{exit}
  \end{alltt}
  where {\tt e} is an expression which is optional. The expression {\tt e}
  can be used to signal what kind of exception is raised.

  The {\it always statement\/} has the form:
  \begin{alltt}
    \keyw{always} s1 \keyw{in}
    s2
  \end{alltt}
  where {\tt s1} and {\tt s2} are statements. First statement {\tt s2} is
  evaluated, and regardless of any exceptions raised, statement {\tt s1} is
  also evaluated. The result value of the complete {\it always statement\/}
  is determined by the evaluation of statement {\tt s1}: if this raises an
  exception, this value is returned, otherwise the result of the evaluation
  of statement {\tt s2} is returned.

  The {\it trap statement\/} only evaluates the handler statement,
{\tt s1}, when certain conditions are fulfilled. It has the form:
\begin{alltt} 
    \keyw{trap} pat \keyw{with} s1 \keyw{in} s2 
\end{alltt}
where {\tt pat} is a pattern or bind used to select certain
exceptions, {\tt s1} and {\tt s2} are statements. First, we evaluate
statement {\tt s2}, and if no exception is raised, the result value of
the complete {\it trap statement\/} is the result of the evaluation of
{\tt s2}. If an exception is raised, the value of {\tt s2} is matched
against the pattern {\tt pat}. If there is no matching, the exception
is returned as result of the complete {\it trap statement}, otherwise,
statement {\tt s1} is evaluated and the result of this evaluation is
also the result of the complete {\it trap statement}.

  The {\it recursive trap statement\/} has the form:
  \begin{alltt}
    \keyw{tixe} \{
      pat1 |-> s1,
      ...
      patn |-> sn
    \} \keyw{in} s
  \end{alltt}
  where {\tt pat1, \ldots, patn} are patterns or binds, {\tt s, s1, \ldots,
    sn} are statements. First, statement {\tt s} is evaluated, and if no
  exception is raised, the result is returned as the result of the complete
  {\it recursive trap statement}. Otherwise, the value is matched in order
  against each of the patterns {\tt pati}. When a match cannot be found,
  the exception is returned as the result of the {\it recursive trap
    statement}. If a match is found, the corresponding statement {\tt
    si} is evaluated. If this does not raise an exception, the result value
  of the evaluation of {\tt si} is returned as the result of the {\it
    recursive trap statement}. Otherwise, the matching starts again, now
  with the new exception value (the result of the evaluation of {\tt si}).

\item[Examples:] In many programs, we need to allocate memory for a
  single operation. After the operation is completed, the memory is not
  needed anymore. This can be done with the {\it always statement}:
  \begin{alltt}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
  In the above example, we cannot act upon a possible exception raised
  within the body statement of the {\it always statement}. By using the
  {\it trap statement\/} we can catch these exceptions:
  \begin{alltt}
    \keyw{trap} pat \keyw{with} ErrorAction(pat) \keyw{in}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
  Now all exceptions raised within the {\it always statement\/} are
  captured by the {\it trap statement}. If we want to distinguish between
  several exception values, we can use either nested {\it trap
    statements\/} or the {\it recursive trap statement}:
  \begin{alltt}
    DoCommand : () ==> int
    DoCommand () ==
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    );

    Example : () ==> int
    Example () ==
    \keyw{tixe}
    \{ <NOMEM> |-> \keyw{return} -1,
      <BUSY>  |-> DoCommand(),
      err     |-> \keyw{return} -2 \}
    \keyw{in}
      DoCommand()
  \end{alltt}
  In operation {\tt DoCommand} we use the {\it always statement\/} in the
  allocation of memory, and all exceptions raised are captured by the {\it
    recursive trap statement\/} in operation {\tt Example}. An exception
  with value {\tt <NOMEM>} results in a return value of {\tt -1} and no
  exception raised. If the value of the exception is {\tt <BUSY>} we try to
  perform the operation {\tt DoCommand} again. If this raises an exception,
  this is also handled by the {\it recursive trap statement}. All other
  exceptions result in the return of the value {\tt -2}.  
\end{description}

\subsection{The Error Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{error statement} \dsep
    \ldots
    }

  \Rule{error statement}{
    \Lop{error}
    }

\item[Semantics:] The {\it error statement} corresponds to the
undefined expression. It is used to state explicitly that the result
of a statement is undefined and because of this an error has occurred.
When an {\it error statement} is evaluated the
interpreter will
terminate the execution of the specification and report that an {\it
error statement} was evaluated.

  Pragmatically use of error statements differs from
  pre-conditions as was the case with undefined expressions: use of a
  pre-condition means it is the caller's 
  responsibility to ensure that the pre-condition is satisfied when
  the operation is called; if an error statement is used it is the
  called operation's responsibility to deal with error handling.


\item[Examples:] The operation \texttt{SquareRoot} on page
  \pageref{squarerootDef} does not exclude
  the possibility that the number to be square rooted might be
  negative. We remedy this in the operation \texttt{SquareRootErr}:
  \begin{alltt}
  SquareRootErr : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRootErr (r,e) ==
    \keyw{if} r < 0
    \keyw{then error}
    \keyw{else}
      (\keyw{dcl} x:\keyw{real} := 1;
       \keyw{dcl} nextx\keyw:{real} := r;
       \keyw{while abs} (x - nextx) >= e * x \keyw{do}
         ( x := nextx;
           nextx := ((r / x) + x) / 2;
         );
       \keyw{return} nextx
      )
  \end{alltt}
\end{description}

\subsection{The Identity Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{identity statement}
    }

  \Rule{identity statement}{
    \Lop{skip}
    }

\item[Semantics:] The {\it identity statement\/} is used to signal that no
  evaluation takes place.

\item[Examples:] In the operation \texttt{Remove} in section
  \ref{removeDef} the behaviour of the operation within the
  \textsf{for} loop if \texttt{elem=z} is not explicitly
  stated. \texttt{Remove2} below does this.
  \begin{alltt}
  Remove2 : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove2 (k,z) ==
    (\keyw{dcl} nk : \keyw{seq of nat} := [];
     \keyw{for} elem \keyw{in} k \keyw{do}
       \keyw{if} elem <> z \keyw{then} nk := nk^[elem]
       \keyw{else skip};
     \keyw{return} nk
    );
  \end{alltt}
  Here, we explicitly included the \keyw{else}-branch to illustrate the
  {\it identity statement}, however, in most cases the \keyw{else}-branch
  will not be included and the {\it identity statement\/} is implicitly
  assumed.

\end{description}

#ifdef VDMPP
\subsection{Start and Start List Statements}\label{sec:start}
\label{sc:startstmt}

\begin{description}
\item[Syntax:] 
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{start statement} \dsep
    \Ruleref{start list statement}
    }

  \Rule{start statement}{
    \Lop{start}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

  \Rule{start list statement}{
    \Lop{startlist}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }
    
\item[Semantics:] The {\it start} and {\it start list} statements have
the form:
  \begin{alltt}
    \keyw{start}(aRef)
    \keyw{startlist}(aRef_s)
  \end{alltt}

If a class description includes a thread (see
section~\ref{ch:thread}), each object created from this class will
have the ability to operate as a stand-alone virtual machine, or in
other terms: the object has its own processing capability.  In this
situation, a {\it new expression} creates the `process' leaving it in
a waiting state.  For such objects {\vdmpp} has a mechanism to change
the waiting state into an active state\footnote{When an object is in
an active state, its behaviour can be described using a thread (see
section~\ref{ch:thread}).}  in terms of a predefined operation, which
can be invoked through a {\it start statement}.

The explicit separation of object creation and start provides the
possibility to complete the initialisation of a (concurrent) system
{\it before} the objects start exhibiting their described behaviour,
in this way avoiding problems that may arise when objects are referred
to that are not yet created and/or connected.

A syntactic variant of the start statement is available to start up a
number of active objects in arbitrary order: the {\it start list
statement}. The parameter {\tt aRef\_s} to \keyw{startlist} must be a
set of object references to objects instantiated from classes
containing a thread.

\item[Examples:] 
Consider the specification of an operating system. A component of this
would be the daemons and other processes started up during the boot
sequence. From this perspective, the following definitions are
relevant:
\begin{alltt}
  \keyw{types}

    runLevel = \keyw{nat};

    Process = Kerneld | Ftpd | Syslogd | Lpd | Httpd

  \keyw{instance variables}
    pInit : \keyw{map} runLevel \keyw{to set of} Process
\end{alltt}
where \texttt{Kerneld} is an object reference type specified
elsewhere, and similarly for the other processes listed. 

We can then model the boot sequence as an operation:
\begin{alltt}
    bootSequence : runLevel ==> ()
    bootSequence(rl) ==
      \keyw{for all} p \keyw{in set} pInit(rl) \keyw{do}
        \keyw{start}(p);
\end{alltt}
Alternatively we could use the \texttt{startlist} statement here:
\begin{alltt}
    bootSequenceList : runLevel ==> ()
    bootSequenceList(rl) ==
      \keyw{startlist}(pInit(rl))
\end{alltt}
\end{description}
#endif VDMPP

\subsection{The Specification Statement} \label{se:specification}

\begin{description}
\item[Syntax:] 
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{specification statement}
    }
  \Rule{specification statement}{
    \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }

\item[Semantics:] 

The specification statement can be used to describe a desired effect a
statement in terms of a pre- and a post-condition. Thus, it captures
the abstraction of a statement, permitting it to have an abstract
(implicit) specification without being forced to an operation
definition. The specification statement is equivalent with the body of
an implicitly defined operation (see section~\ref{op-def}). Thus
specification statements can not be executed.

\item[Examples:] We can use a specification statement to specify a
  bubble maximum part of a bubble sort:
  \begin{alltt}
  Sort2 : () ==> ()
  Sort2 () ==
    \keyw{while} x < y \keyw{do}
      || (BubbleMin(),
          [\keyw{ext wr} l : \keyw{seq1 of nat}
              \keyw{wr} y : \keyw{nat}
              \keyw{rd} x : \keyw{nat}
           \keyw{pre} x < y
           \keyw{post} y < y~ \keyw{and}
                permutation (l~(x,...,y~),l(x,...,y~)) \keyw{and}
                \keyw{forall} i \keyw{in set} \{x,...,y\} & l(i) < l(y~)]
         )
  \end{alltt}
  (\texttt{permutation} is an auxiliary function taking two sequences
  which returns true iff one sequence is a permutation of the other.)


\end{description}

#ifdef VICEMAN
\subsection{The Duration Statement}
\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{duration statement}
  }
  \Rule{duration statement}{
    \Lop{duration}, \Lit{(}, \Ruleref{numeral}, \Lit{)},\lfeed
    \Ruleref{statement}
  }

\item[Semantics:]
The duration statement is a runtime directive to the Toolbox
interpreter telling it that when incrementing the internal clock for the
enclosed statement, the value (a natural number)
given in the duration statement should
be used instead of the increment which would normally be computed for that
statement. Thus the duration statement provides a mechanism to
override the Toolbox's default execution time computation.

\item[Example:] First a simple example:
\begin{alltt}
      \keyw{while} n < 10 \keyw{do}
         \keyw{duration}(10) n := n + 1; 
\end{alltt}
In this example, assuming that this loop is not executed in the
context of an enclosing duration statement, on each iteration of the
loop the Toolbox will increment its internal clock by 10 time units,
rather than computing the amount of time required to execute the
statement \texttt{n := n + 1}. 

If duration statements are nested, the outermost one takes precedence
and the remainder are ignored. For instance
\begin{alltt}
      \keyw{duration}(30)(
        n := 1;
        \keyw{while} n < 10 \keyw{do}
           \keyw{duration}(10) n := n + 1; 
        )
\end{alltt}
The outer duration statement takes precedence, so assuming this is not
executed in the context of an enclosing duration statement, the
interpreter would increment its internal clock by 30 time units when
executing this statement.

Note that nesting can occur due to operation calls. Consider the
following example:
\begin{alltt}
      op1 : \keyw{nat} ==> \keyw{nat}
      op1(m) ==
       \keyw{duration} (20) \keyw{return} m + 1;

      op2 : () ==> \keyw{nat}
      op2() ==
      (\keyw{dcl} n : \keyw{nat} := 3;
       \keyw{duration}(10)  n := op1(1);
       \keyw{return} n) 
\end{alltt}
When executing \texttt{op2}, if the call to \texttt{op1} is
executed, the duration statement in \texttt{op1} will be overridden by
the duration statement in the environment of the call. Thus in
\texttt{op2} following execution of the statement 
\texttt{n := op1(1);} the internal clock is incremented by 10 time units
only. 


\end{description}

\subsection{The Cycles Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{cycles statement}
  }
  \Rule{cycles statement}{
    \Lop{cycles}, \Lit{(}, \Ruleref{numeral}, \Lit{)},\lfeed
    \Ruleref{statement}
  }

\item[Semantics:]
The cycles statement is a runtime directive to the Toolbox interpreter
telling it that when incrementing the internal clock for the enclosed
statement, the value (a natural number)
given in the cycles statement should be used as
an indication of how many clock cycles that the enclosed statement
should be incremented by instead of the increment which would normally
be computed for that statement. Thus the cycles statement provides a
mechanism to override the Toolbox's default execution time
computation similar to the duration statement but in a way that is
relative to the speed of the \texttt{CPU} that the computation is carried
out on.

\item[Example:] First a simple example:
\begin{alltt}
      \keyw{while} n < 10 \keyw{do}
         \keyw{cycles}(1000) n := n + 1; 
\end{alltt}
In this example, assuming that this loop is not executed in the
context of an enclosing cycles statement, on each iteration of the
loop the Toolbox will increment its internal clock by the time it will
take to process 1000 instructions on the given \texttt{CPU} (relative
to its capacity), rather than computing the amount of time required to
execute the statement \texttt{n := n + 1}. 

If cycles statements are nested, the outermost one takes precedence
and the remainder are ignored. For instance
\begin{alltt}
      \keyw{cycles}(3000)(
        n := 1;
        \keyw{while} n < 10 \keyw{do}
           \keyw{cycles}(1000) n := n + 1; 
        )
\end{alltt}
The outer cycles statement takes precedence, so assuming this is not
executed in the context of an enclosing cycles statement, the
interpreter would increment its internal clock by the time it takes to
process 3000 instructions on the given \texttt{CPU} when
executing this statement.

Note that nesting can occur due to operation calls. Consider the
following example:
\begin{alltt}
      op1 : \keyw{nat} ==> \keyw{nat}
      op1(m) ==
       \keyw{cycles} (2000) \keyw{return} m + 1;

      op2 : () ==> \keyw{nat}
      op2() ==
      (\keyw{dcl} n : \keyw{nat} := 3;
       \keyw{cycles}(1000)  n := op1(1);
       \keyw{return} n) 
\end{alltt}
When executing \texttt{op2}, if the call to \texttt{op1} is
executed, the cycles statement in \texttt{op1} will be overridden by
the cycles statement in the environment of the call. Thus in
\texttt{op2} following execution of the statement 
\texttt{n := op1(1);} the internal clock is incremented by the time
it takes to process 1000 instructions on the given \texttt{CPU}
only. 
\end{description}

#endif VICEMAN

#ifdef VDMPP
%\subsection{The Delay Statement}
%\begin{description}
%\item[Syntax:] 
%  \Rule{delay statement}{
%    \Lop{delay}, \Lit{(},expression, \Lit{)}
%  }
%
%\item[Semantics:] 
%The delay statement can be used to indicate a required delay in the
%execution of the operation; in Section~\ref{ch:rt} its use is explained
%more extensively.
%
%The {\it expression} denotes the number of system ticks during which the
%execution of the operation in which the delay statement occurs is halted.
%The delay must be a non-zero natural number.
%\end{description}


%\subsection{The Select Statement}
%
%The select statement is described in section \ref{se:proc-thread}.

\newpage
\section{Top-level Specification}

In the previous sections \vdmpp\ constructs such as types,
expressions, statements, functions and operations have been
described. A number of these constructs can constitute the definitions
inside a class definition. A top-level specification, or document, is
composed by one or more class definitions.

\begin{description}
\item[Syntax:]
\Rule{document}{
   \Ruleref{class} 
#ifdef VICEMAN
   \dsepl\ \Ruleref{system}
#endif VICEMAN
   ,\SeqPt{\Ruleref{class}
#ifdef VICEMAN
   \dsepl\ \Ruleref{system}
#endif VICEMAN
         }
  }
\end{description}

#ifdef VICEMAN
\subsection{System}\label{sec:system}

In order to be able to describe distributed systems in \vdmpp\ includes
a notion of a system that describes how different parts of the system 
modelled are deployed to different Core Processing Units (CPUs) and 
communication busses connecting the CPUs together. Syntactically the 
system is described exactly like ordinary classes described below in 
Section~\ref{sec:classdep}, except that the keyword ``\keyw{system}'' 
instead of the keyword ``\keyw{class}''. 

\begin{description}
\item[Syntax:] 
\Rule{system}{
  \Lop{system}, \Ruleref{identifier},  \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}
\Rule{class body}{\Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
}
\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{instance variable definitions} \dsep
%  time variable definitions \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions}
}

\item[Semantics:] Each system description has the following parts:
\begin{itemize}
\item A system header with the system name.
\item An optional {\em system body}.
\item A system tail.
\end{itemize}

The system name as given in the system header is the defining occurrence
of the name of the class. A system name is globally visible, i.e. visible
in all other classes/systems in the specification.

The system name in the class header must be the same as the system
name in the system tail.  Furthermore, defining system names must be unique
throughout the specification.

The special thing about the system is that it can make use of special
implicitly defined classes called \texttt{CPU} and \texttt{BUS}. It is 
not possible to create instances of the system, but instances made of
\texttt{CPU} and \texttt{BUS} will be created at initialisation time. 
Note that \texttt{CPU} and \texttt{BUS} cannot be used outside the
system definition.

The instances of \texttt{CPU} and \texttt{BUS} must be made as instance 
variables and the definition must use constructors. The constructor for the
\texttt{CPU} class takes two parameters: the first one indicate the 
primary scheduling policy used for the \texttt{CPU} whereas the second 
parameter provides the capacity of the \texttt{CPU} (indicated as Million
Instructions Per Second or MIPS). The constructor for the \texttt{BUS}
class takes three parameters. The first one indicates the kind of bus, the
second one the capacity of the bus (its band width) and finally the third 
parameter gives a set of \texttt{CPU} instances connected together by the
given \texttt{BUS} instance.

The currently supported primary scheduling policies for the \texttt{CPU}
are:
\begin{description}
\item[\texttt{<FP>}:] Fixed Priority
\item[\texttt{<FCFS>}:] First Come First Served
\end{description} 

The currently supported primary scheduling policies for the \texttt{BUS}
are:
\begin{description}
%\item[\texttt{<TDMA>}:] Time Division Multiple Access
\item[\texttt{<FCFS>}:] First Come First Served
%\item[\texttt{<CSMACD>}:] Carrier Sense Multiple Access with Collision 
%                          Detection
\end{description} 

The \texttt{CPU} class have member operations called \texttt{deploy} and
\texttt{setPriority}. The \texttt{deploy} operation takes one
significant parameter
which must be an object that is declared as a static instance variable
inside the system \footnote{It is also allowed to take a string as a
second parameter for future extensions but that is ignored at the
moment.}. The semantics of the deploy operation is that execution
of all functionality inside this object will take place on the CPU that it
has been deployed to. The \texttt{setPriority} operation takes two 
parameters where the first must be the name of a public operation that 
has been deployed to the CPU and the second parameter is a natural number.
The semantics of the \texttt{setPriority} operation is that the given 
operation is assigned the given priority (the second parameter). This will
be used when fixed priority scheduling is used on the given CPU. Per
default operations that are not explicitly assigned a priority using
the \texttt{setPriority} operation are assigned a default priority of 1.

The system ``class'' is limited in the way that it can only contain:
\begin{description}
\item[Instance variables:] The only instances that can be declared in the 
system ``class'' is of the special classes \texttt{CPU} and \texttt{BUS} 
as well as static instances of the different system components that one 
wish to allocate to different CPU's.
\item[Constructor:] The actual deployment of instances to CPU's and setting
of priorities for the different operations is set inside the
constructor which is the only operation that can be placed in the
system ``class''. The only kind of statements that can be used inside
this constructor is a block statement with a sequence of invocations
of the special \texttt{deploy} and \texttt{setPriority} operations.
\end{description}

In addition there are limitations with respect to the use of static
declarations for instances that are deployed to different
CPU's. Basically the user should ensure that only one instance is
deployed to a CPU if the class the instance comes from contains any
static operations or functions. In case a static instance variable is
used it is accessed directly (without any communication over the
busses, so this in essence not proper from a distribution
standpoint. Thus, all instance variables of instances to be deployed
should only be accessed through the use of operations.

\item[Example:] The system class could for example be defined as:
\begin{alltt}
\keyw{system} Simple

\keyw{instance variables
  static public} a : A := \keyw{new} A();
  \keyw{static public} b : B := \keyw{new} B();
  -- define the first CPU with fixed priority scheduling 
  -- and 22E6 MIPS
  CPU1 : CPU := \keyw{new} CPU (<FP>, 22E6);

  \keyw{static public} c : C := \keyw{new} C();
  -- define the second CPU with fixed priority scheduling 
  -- and 11E6 MIPS
  CPU2 : CPU := \keyw{new} CPU (<FP>, 11E6);

  -- create a communication bus that links the three 
  -- CPU's together
  BUS1 : BUS := \keyw{new} BUS (<CSMACD>, 72E3, {CPU1, CPU2})

operations
  public Simple: () ==> Simple
  Simple () ==
    ( -- deploy a on CPU1
      CPU1.deploy(a);
      -- deploy b on CPU1
      CPU1.deploy(b);
      -- deploy c on CPU2
      CPU2.deploy(c,"CT"); 
      -- "CT" is a label here which is ignored
    );

end Simple
\end{alltt} 
\noindent where \texttt{A}, \texttt{B} and \texttt{C} all are defined
as classes.
\end{description}
#endif VICEMAN

\subsection{Classes}
\label{sec:classdep}

Compared to the standard \vdmsl\ language,  \vdmpp\ has been
extended with classes. In this section, the use of classes to create
and structure a top-level specification will be described. With the
object oriented facilities offered by \vdmpp\ it is possible to:

\begin{itemize}
\item Define classes and create objects.
\item Define associations and create links between objects.
\item Make generalisation and specialisation through inheritance.
\item Describe the functional behaviour of the objects using functions
  and operations.
\item Describe the dynamic behaviour of the system through threads and
  synchronisation constraints.
\end{itemize}

Before the actual facilities are described, the general layout of a
class is described.

\begin{description}
\item[Syntax:] 
\Rule{class}{
  \Lop{class}, \Ruleref{identifier}, \OptPt{\Ruleref{inheritance clause}}, \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}
\Rule{inheritance clause}{
      \Lop{is subclass of}, \Ruleref{identifier}, \Lit{,}, \SeqPt{\Ruleref{identifier}}
}
\Rule{class body}{\Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
}
\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{instance variable definitions} \dsep
%  time variable definitions \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions}
}

\item[Semantics:] Each class description has the following parts:
\begin{itemize}
\item A class header with the class name and an optional
  {\em inheritance clause}.
\item An optional {\em class body}.
\item A class tail.
\end{itemize}

The class name as given in the class header is the defining occurrence
of the name of the class. A class name is globally visible, i.e. visible
in all other classes in the specification.

The class name in the class header must be the same as the class
name in the class tail.  Furthermore, defining class names must be unique
throughout the specification.

The (optional) class body may consist of:
\begin{itemize}
\item A set of {\it value definitions} (constants).
\item A set of {\it type definitions}.
\item A set of {\it function definitions}.
\item A set of {\it instance variable definitions} describing
  the internal state of an object instantiated from the
  class. State invariant expressions are encouraged but are not mandatory.
%\item A set of {\em time variable definitions} describing
%  the internal state of an object as a function of time.
\item A set of {\it operation definitions} that can act on the internal state.
\item A set of the {\it synchronization definitions}, specified either 
  in terms of permission predicates or using mutex constraints.
% or in terms of traces.
%  Each trace represents an allowed sequence of invocations of the
%  functions and operations by other objects.
\item A set of {\it thread definitions} that describe the thread of control
  for active objects.
\item A set of {\it traces} that are used to indicate the sequences of 
operation calls for which test cases are desired to be produced automatically.
\end{itemize}

In general, all constructs defined within a class must have a unique
name, e.g.\ it is not allowed to define an operation and a type with
the same name. However, it is possible to {\it overload} function and
operation names (i.e.\ it is possible to have two or more functions
with the same name and two or more operations with the same name)
subject to the restriction that the types of their input parameters
should not overlap. That is,  it should be possible using static type
checking alone to determine uniquely and unambiguously which
function/operation definition corresponds to each function/operation
call. Note that this applies not only to functions and operations
defined in the local interface of a class but also to those inherited
from superclasses. Thus, for example, in a design involving multiple
inheritance a class C may inherit a function from a class A and a
function with the same name from a class B and all calls involving
this function name must be resolvable in class C.
\end{description}

\subsection{Inheritance}\label{ch:inherit}

The concept of inheritance is essential to object orientation.  When
one defines a class as a subclass of an already existing class the
definition of the subclass introduces an extended class, which is
composed of the definitions of the superclass together with the
definitions of the newly defined subclass. 

Through inheritance, a subclass inherits from the superclass:
\begin{itemize}
\item Its instance variables. %and time variables. 
  This also includes
  all invariants and their restrictions on the allowed modifications of
  the state.
\item Its operation and function definitions. 
\item Its value and type definitions.
\item Its synchronization definitions as described in
  section \ref{ch:sync-inh}.
%\item Its thread definitions as described in
%  Section \ref{ch:thread-inh}.
\end{itemize}

A name conflict occurs when two constructs of the same kind and with the
same name are inherited from different superclasses.
Name conflicts must be explicitly resolved through {\it name qualification},
i.e. prefixing the construct with the name of the superclass and a
{\vppsmall `}-sign (back-quote) (see also section~\ref{sec:nameconflicts}).

\begin{description}
\item[Example:] In the first example, we see that inheritance can be
exploited to allow a class definition to be used as an abstract
interface which subclasses must implement:
  \begin{alltt}
  \keyw{class} Sort

    \keyw{instance variables}
      \PROTECTED data : \keyw{seq of int}

    \keyw{operations}

      initial_data : seq of \keyw{int} ==> ()
      initial_data (l) == 
        data := l;

      sort_ascending : () ==> ()
      sort_ascending () == \keyw{is subclass responsibility};
    \keyw{end} Sort

  \keyw{class} SelectionSort \keyw{is subclass of} Sort

    \keyw{functions}

      min_index : \keyw{seq1 of nat} -> \keyw{nat}
      min_index(l) ==
        \keyw{if len} l = 1
        \keyw{then} 1
        \keyw{else let} mi = min_index(\keyw{tl} l)
             \keyw{in} \keyw{if} l(mi+1) < \keyw{hd} l
               \keyw{then} mi+1
               \keyw{else} 1

    \keyw{operations}

      sort_ascending : () ==> ()
      sort_ascending () == selectSort(1);

      selectSort : \keyw{nat} ==> ()
      selectSort (i) ==
        \keyw{if} i < \keyw{len} data
        \keyw{then} (dcl temp: \keyw{nat};
              \keyw{dcl} mi: \keyw{nat} := min_index(data(i,...,\keyw{len} data)) + 
                            i - 1;
         
             temp := data(mi);
             data(mi) := data(i);
             data(i) := temp;
             selectSort(i+1)
             )

  \keyw{end} SelectionSort
\end{alltt}
Here the class \texttt{Sort} defines an abstract interface to be
implemented by different sorting algorithms. One implementation is
provided by the \texttt{Selecti\-onSort} class. 

The next example clarifies how name space clashes are resolved.
  \begin{alltt}
    \keyw{class} A
      \keyw{instance variables}
        i: \keyw{int} := 1;
        j: \keyw{int} := 2;
    \keyw{end} A

    \keyw{class} B \keyw{is subclass of} A
    \keyw{end} B

    \keyw{class} C \keyw{is subclass of} A
      \keyw{instance variables}
        i: \keyw{int} := 3;
    \keyw{end} C

    \keyw{class} D \keyw{is subclass of} B,C
      \keyw{operations}
        GetValues: () ==> \keyw{seq of int}
        GetValues() ==
          \keyw{return} [
            A`i, -- equal to 1
            B`i, -- equal to 1 (A`i)
            C`i, -- equal to 3
            j   -- equal to 2 (A`j)
          ]
     \keyw{end} D
  \end{alltt}
\end{description}

In the example objects of class {\tt D} have 3 instance variables:
{\tt A`i}, {\tt A`j} and {\tt C`j}. Note that objects of class {\tt D}
will have only one copy of the instance variables defined in class {\tt
A} even though this class is a common super class of both class {\tt
B} and {\tt C}. Thus, in class {\tt D} the names {\tt B`j}, {\tt C`j},
{\tt D`j} and {\tt j} are all referring to the same variable, {\tt
A`j}. It should also be noticed that the variable name {\tt i} is
ambiguous in class {\tt D} as it refers to different variables in
class {\tt B} and class {\tt C}.

\subsection{Interface and Availability of Class Members}\label{ch:interface}

In \vdmpp\ definitions inside a class are distinguished between:

\begin{description}
\item[Class attribute:] an attribute of a class for which there
  exists exactly one incarnation no matter how many instances
  (possibly zero) of the class may eventually be created. Class
  attributes in \vdmpp\ correspond to {\tt static} class members in
  languages like C++ and Java. Class (static) attributes can be
  referenced by prefixing the name of the attribute with the name of
  the class followed by a {\vppsmall `}-sign (back-quote), so that, for
  example, {\tt ClassName`val} refers to the value {\tt val} defined in
  class {\tt ClassName}.

\item[Instance attribute:] an attribute for which there exists one
  incarnation for each instance of the class. Thus, an instance
  attribute is only available in an object and each object has its own
  copy of its instance attributes. Instance (non-static) attributes
  can be referenced by prefixing the name of the attribute with the name of
  the object followed by a dot, so that, for example, {\tt
    object.op()} invokes the operation {\tt op} in the object denoted
  by {\tt object} (provided that \texttt{op} is visible to
  \texttt{object}).
\end{description}

Functions, operations, instance variables and constants\footnote{In
  practice, constants will generally be static -- a non-static
  constant would represent a constant whose value may vary from one
  instance of the class to another which would be more naturally
  represented by an instance variable.} in a class may 
be either class attributes or instance attributes. This is indicated
by the keyword \keyw{static}: if the declaration is preceded by the
keyword \keyw{static} then it represents a class attribute, otherwise
it denotes an instance attribute. 

Other class components are by default always either class attributes
or instance attributes as follows:

\begin{itemize}
\item Type definitions are always class attributes.
%  Thus, they can be quoted directly in a class. E.g.\ {\tt
%    ClassName`val} refers to the value {\tt val} defined in 
%  class {\tt ClassName}.
% \item Function and operation definitions are instance
%   attributes.  Thus, they are quoted in objects. E.g.\ {\tt
%   object.op()} invokes the operation {\tt op} in the object denoted by
%   {\tt object} (provided that \texttt{op} is visible to \texttt{object}).
% \item Instance variables %and time variables 
%   are instance
%   attributes. Thus, each object has its own copy
%   of the instance %and time 
%   variables.
\item Thread definitions are always instance attributes. Thus, each active
  object has its own thread(s).
\item Synchronization definitions are always instance attributes. Thus, each
  object has its own ``history'' when it has been created.
\end{itemize}

In addition, the interface or accessibility of a class member may be
explicitly defined using an access specifier: one of \keyw{public},
\keyw{private} or \keyw{protected}. The meaning of these specifiers
is:
\begin{description}
\item[\keyw{public}:] Any class may use such members
\item[\keyw{protected}:] Only subclasses of the current class may use
  such members
\item[\keyw{private}:] No other class may use such members - they may
  only be used in the class in which they are specified.
\end{description}

The default access to any class member is \textbf{private}. That is,
if no access specifier is given for a member it is private.

This is summarized in table \ref{table:access}. A few provisos apply
here: 
\begin{itemize}
\item Granting access to instance variables (i.e.\ through
a \keyw{public} or \keyw{protected} access specifier) gives 
both read and write access to these instance variables.
% ***** Change this in the future if o.v := expr is possible
\item Public instance variables may be read (but not written) using
  the dot (for object instance variables) or back-quote (for class
  instance variables) notation e.g.\ a public instance variable
  \texttt{v} of an object \texttt{o} may be accessed as \texttt{o.v}.
\item Access specifiers may only be used with type, value, function,
  operation and instance variable definitions; they cannot be used
  with thread or synchronization definitions.
\item It is not possible to convert a class attribute into an instance
  attribute, or vice-versa.
\item For inherited classes, the interface to the subclass is the same
  as the interface to its superclasses extended with the new
  definitions within the subclass.  
\item Access to an inherited member cannot be made more restrictive
  e.g.\ a public instance variable in a superclass cannot be
  redeclared as a private instance variable in a subclass.
\end{itemize} 

\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|c|}\hline
                 & \keyw{public} & \keyw{protected} & \keyw{private}\\ \hline
Within the class & $\surd$       & $\surd$          & $\surd$ \\
In a subclass    & $\surd$       & $\surd$          & $\times$\\
In an arbitrary 
external class   & $\surd$       & $\times$         & $\times$ \\
\hline
\end{tabular}
\end{center}
\caption{Summary of Access Specifier Semantics}\label{table:access}
\end{table}
\begin{description}
\item[Example] In the example below use of the different access
  specifiers is demonstrated, as well as the default access to class
  members. Explanation is given in the comments within the definitions.
\begin{alltt}
\keyw{class} A

  \keyw{types}
    \PUBLIC Atype = <A> | <B> | <C>

  \keyw{values}
    \PUBLIC Avalue = 10;

  \keyw{functions}
    \PUBLIC compare : \keyw{nat} -> Atype
    compare(x) ==
      \keyw{if} x < Avalue
      \keyw{then} <A>
      \keyw{elseif} x = Avalue
      \keyw{then} <B>
      \keyw{else} <C>
 
  \keyw{instance variables}
    \keyw{public} v1: \keyw{nat};
    \keyw{private} v2: \keyw{bool} := false;
    \keyw{protected} v3: \keyw{real} := 3.14;

  \keyw{operations}
    protected AInit : \keyw{nat} * \keyw{bool} * \keyw{real} ==> ()
    AInit(n,b,r) ==
      (v1 := n;
       v2 := b;
       v3 := r)
\keyw{end} A

\keyw{class} B \keyw{is subclass of} A

  \keyw{instance variables}
    v4 : Atype --inherited from A

  \keyw{operations}

    BInit: () ==> ()
    BInit() ==
      (AInit(1,true,2.718); --OK: can access protected members
                            --in superclass
       v4 := compare(v1);   --OK since v1 is public
       v3 := 3.5;           --OK since v3 protected and this 
                            --is a subclass of A
       v2 := \keyw{false}   --illegal since v2 is private to A
      )

\keyw{end} B

\keyw{class} C

  \keyw{instance variables}
    a: A := \keyw{new} A();
    b: B := \keyw{new} B();


  \keyw{operations}

    CInit: () ==> A`Atype   --types are class attributes
    CInit() ==
      (a.AInit(3,\keyw{false},1.1);  
                            --illegal since AInit is protected
       b.BInit();           --illegal since BInit is (by default) 
                            --private
       let - = a.compare(b.v3) in skip;
                            --illegal since C is not subclass 
                            --of A so b.v3 is not available
       \keyw{return} b.compare(B`Avalue)
                            --OK since compare is a public instance
                            --attribute and Avalue is public class
                            --attribute in B
      )

\keyw{end} C
\end{alltt}
%       b.v1 := 4;           --OK since v1 public in A so is 
%                            --public by inheritance
  


\end{description}

\section{Synchronization Constraints}\label{ch:sync}

In general a complete system contains objects of a passive
nature (which only react when their operations are invoked) and active
objects which `breath life' into the system. These active objects
behave like virtual machines with their own processing thread of
control and after start up they do not need interaction with other
objects to continue their activities.
In another terminology a system could be described as
consisting of a number of active clients requesting services of passive
or active servers.
In such a parallel environment the server objects need
synchronization control to be able to guarantee internal consistency,
to be able to maintain their state invariants.
Therefore, in a parallel world, a passive object needs to
behave like a Hoare monitor with its operations as entries.

If a sequential system is specified (in which only one thread of control
is active at a time) only a special case of the general properties is used
and no extra syntax is needed. However, in the course of development from
specification to implementation more differences are likely to appear.

The following default synchronization rules for each object apply in {\vdmpp}:
\begin{itemize}
\item operations are to be viewed as though they are atomic, from the
point of the caller; 
\item operations which have no corresponding permission predicate are
  subject to no restrictions at all;
\item synchronization constraints apply equally to calls within an
  object (i.e. one operation within an object calls another operation
  within that object) and outside an object (i.e. an operation from
  one object calls an operation in another object);
\item operation invocations have the semantics of a rendez-vous (as in
Ada, see \cite{adalrm}) in case two active objects are involved. Thus if an
object $O_1$ calls an operation $o$ in object $O_2$, if $O_2$ is currently
unable to start operation $o$ then $O_1$ blocks until the operation may be
executed. Thus invocation occurs when both the calling object and the
called object are ready. (Note here a slight difference from the
semantics of Ada: in Ada both parties to the rendez-vous are active
objects; in \vdmpp only the calling party is active)
\end{itemize}
The synchronization definition blocks of the class description provide the
user with ways to override the defaults described above.

\begin{description}
\item[Syntax:] 
  \Rule{synchronization definitions}{
    \Lop{sync}, \OptPt{\Ruleref{synchronization}}
  }
  \Rule{synchronization}{
    \Ruleref{permission predicates}
  }

\item[Semantics:] 

Synchronization is specified in \vdmpp using permission predicates.

\end{description}


\subsection{Permission Predicates}
\label{sec:permissionpred}

The following gives the syntax used to state
rules for accepting the execution of concurrently callable operations.
Some notes are given explaining these features.

\begin{description}
\item[Syntax:] 
  \Rule{permission predicates}{
    \Ruleref{permission predicate}, \SeqPt{\Lit{;}, \lfeed
    \Ruleref{permission predicate}}
  }
\Rule{permission predicate}{
      \Lop{per}, \Ruleref{name},
      \Lop{=$>$}, \Ruleref{expression} \dsep
      \Ruleref{mutex predicate}}

\Rule{mutex predicate}{
       \Lop{mutex}, \Lit{(}, \Lop{all}, \Lit{)}  \dsep
       \Lop{mutex}, \Lit{(}, \Ruleref{name list} \Lit{)}}

\item[Semantics:] Permission to accept execution of a requested
operation depends on a guard condition in a (deontic) permission
predicate of the form:

\begin{quote}
{\vppsmall per} {\em operation name} {\vppsmall =>} {\em guard condition}
\end{quote}

The use of implication to express the permission means that truth of
the guard condition (expression) is a necessary but not sufficient
condition for the invocation. The permission predicate is to be read
as stating that if the guard condition is false then there is
non-permission. Expressing the permission in this way allows further
similar constraints to be added without risk of contradiction through
inheritance for the subclasses. There is a default for all operations:

\begin{quote}
{\vppsmall per} {\em operation name} {\vppsmall => true}
\end{quote}

but when a permission predicate for an operation is specified
this default is overridden.

Guard conditions can be conceptually divided into:
\begin{itemize}
\item
a {\em history guard} defining the dependence on events in the past;
\item
an {\em object state guard}, which depends on the instance variables of the
object, and
\item
a {\em queue condition guard}, which depends on the
states of the queues formed by operation invocations (messages) awaiting
service by the object.
\end{itemize}
These guards can be freely mixed. \textbf{Note} that there is no
\textit{syntactic} distinction between these guards - they are all
expressions. However they may be distinguished at the semantic level.

A mutex predicate allows the user to specify either that all
operations of the class are to be executed mutually exclusive, or that
a list of operations are to be executed mutually exclusive to each
other. Operations that appear in one mutex predicate are allowed to
appear in other mutex predicates as well, and may also be used in the
usual permission predicates. Each mutex predicate will implicitly be
translated to permission predicates using history guards for each
operation mentioned in the name list. For instance,  
\begin{alltt}
\keyw{sync}
  \keyw{mutex}(opA, opB);
  \keyw{mutex}(opB, opC, opD);
  \keyw{per} opD => someVariable > 42;
\end{alltt}
would be translated to the following permission predicates: 
\begin{alltt}
\keyw{sync}
  \keyw{per} opA => #active(opB) = 0;
  \keyw{per} opB => #active(opA) = 0 and
          #active(opC) + #active(opD) = 0;
  \keyw{per} opC => #active(opB) + #active(opD) = 0;
  \keyw{per} opD => #active(opB) + #active(opC) = 0 and
          someVariable > 42;
\end{alltt}

Note that it is only permitted to have one permission predicate for each
operation. The
\texttt{\#active} operator is explained below.

A \keyw{mutex(all)} constraint specifies that all of the operations
specified in that class \textit{and any superclasses} are to be
executed mutually exclusively. 
\end{description}


\subsubsection{History guards}
\begin{description}
\item[Semantics:] A history guard is a guard which depends on the
sequence of earlier invocations of the operations of the object
expressed in terms of history expressions (see section
\ref{sec:historyexpr}). History expressions denotes the number
of activations and completions of the operations, given as functions

{\tt \#act} and {\tt \#fin}, respectively. 
\begin{quote}
{\tt \#act}: operation name $\rightarrow$ $\Nat$ \\
{\tt \#fin}: operation name $\rightarrow$ $\Nat$ 
\end{quote}

Furthermore, a derived function {\tt \#active} is available such that
{\tt \#active(}{\tt A}{\tt )} $=$ {\tt \#act(}{\tt A}{\tt )} $-$
{\tt \#fin(}{\tt A}{\tt )}, giving the number of currently active
instances of {\tt A}. Another history function - \texttt{\#req} - is
defined in section \ref{queuesec}.
\item[Examples:]
Consider a Web server\label{example:webserver} that is capable of
supporting 10 simultaneous 
connections and can buffer a further 100 requests. In this case we
have one instance variable, representing the mapping from URLs to
local filenames:
\begin{alltt}
  \keyw{instance variables}
    site_map : \keyw{map} URL \keyw{to} Filename := \{|->\}
\end{alltt}

The following operations are defined in this class (definitions
omitted for brevity):

\begin{tabular}{lll}
\texttt{ExecuteCGI:} & \texttt{URL ==> File} & Execute a CGI script on the server\\
\texttt{RetrieveURL:} & \texttt{URL ==> File} & Transmit a page of html\\
\texttt{UploadFile:} & \texttt{File * URL ==> ()} & Upload a file onto the server\\
\texttt{ServerBusy:} & \texttt{() ==> File} & Transmit a ``server busy'' page\\
\texttt{DeleteURL:} & \texttt{URL ==> ()} & Remove an obsolete file
\end{tabular}

Since the server can support only 10 simultaneous connects, we can
only permit an execute or retrieve operation to be activated if the
number already active is less than 10:
\begin{alltt}
    per RetrieveURL => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
    per ExecuteCGI  => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
\end{alltt}


\end{description}

\subsubsection{The object state guard}
\begin{description}
\item[Semantics:] 
The object state guard is a boolean expression which depends on the values of
one (or more) instance variable(s) of the object itself. Object state
guards differ from operation pre-conditions in that a call to an an
operation whose permission predicate is false results in the caller
blocking until the predicate is satisfied, whereas a call to an
operation whose pre-condition is false means the operation's behaviour
is unspecified.

\item[Examples:] 
Using the web server example again, we can only allow file removal if
some files already exist:
\begin{alltt}
    per DeleteURL   => dom site_map <> \{\}
\end{alltt}

Constraints for safe execution of the operations {\tt Push} and {\tt Pop}
in a stack object can be expressed using an object state guard as:
\begin{alltt}
    \keyw{per} Push => length < maxsize;\\
    \keyw{per} Pop => length > 0
\end{alltt}
where {\tt maxsize} and {\tt length} are instance variables of
the stack object.

It is often possible to express such constraints as a
consequence of the history,
for example the empty state of the stack:
\begin{alltt}
    length = 0 <=> \keyw{\#fin}(Push) = \keyw{\#fin}(Pop)
\end{alltt}
However, the size is a property which is better regarded as a
property of the particular stack instance, and in such cases it is
more elegant to use available instance variables which store the effects
of history.

%In replacing history expressions by state based ones, however,
%it should be remembered, that the change of a state value which
%results from an action, defined in a post-condition, may not occur as
%the last action of the corresponding operation.
%
%Furthermore, object state guards may only be used if mutual exclusion
%is specified in addition for all operations in order to avoid problems
%with possible simultaneous access to the instance variables.
\end{description}


\subsubsection{Queue condition guards}\label{queuesec}
\begin{description}
\item[Semantics:] 
A queue condition guard acts on requests waiting in the queues for the
execution of the operations.
This requires use of a third history function {\tt \#req} such that
{\tt \#req(A)} counts the number of messages which have been received by the
object requesting execution of operation {\tt A}.
Again it is useful to introduce the function {\tt \#waiting} such that:
{\tt \#waiting(}{\tt A}{\tt )} $=$ {\tt \#req(}{\tt A}{\tt )} $-$ {\tt \#act(}{\tt A}{\tt )},
which counts the number of items in the queue.

\item[Examples:] 
Once again, with the web server we can only activate the
\texttt{ServerBusy} operation if 100 or more connections are waiting:
\begin{alltt}
    \keyw{per} ServerBusy  => #waiting(RetrieveURL) 
                      + #waiting(ExecuteCGI) >= 100;
\end{alltt}

The most important use of such expressions containing queue
state functions is for expressing priority between operations. The
protocol specified by:
%mutex(A,B) $\wedge$ per B \kw{=>} \#req(A) = 0
\begin{alltt}
    \keyw{per} B => \keyw{\#waiting}(A) = 0
\end{alltt}
gives priority to waiting  requests for activation of {\tt A}. There
are, however, many other situations when operation dispatch depends on
the state of waiting requests.  Full description of the queuing
requirements to allow specification of operation selection based on
request arrival times or to describe `shortest job next' behaviour
will be a future development.

Note that \texttt{\#\keyw{req}(A)} have value 1 at the time of evaluation of
the permission predicate for the first invocation of operation
\texttt{A}. That is,
\begin{alltt}
   \keyw{per} A => \keyw{\#req}(A) = 0
\end{alltt}
would always block.

\end{description}

\subsubsection{Evaluation of Guards}

Using the previous example, consider the following situation: the web
server is handling 10 \texttt{RetrieveURL} requests already. While it
is dealing with these requests, two further \texttt{RetrieveURL}
requests (from objects $O_1$ and $O_2$) and one \texttt{ExecuteCGI}
request (from object $O_3$) are received. The permission predicates
for these two operations are false since the number of active
\texttt{RetrieveURL} operations is already 10. Thus these objects
block. 

Then, one of the active \texttt{RetrieveURL} operations reaches
completion. The permission predicate so far blocking $O_1$, $O_2$ and
$O_3$ will become ``true'' simultaneously.
This raises the question: which object is allowed to proceed? Or even
all of them? 

Guard expressions are only reevaluated when an event occurs (in this
case the completion of a \texttt{RetrieveURL} operation). In addition to
that the test of a permission predicate by an object and its (potential)
activation is an atomic operation. This means, that when the first
object evaluates its guard expression, it will find it to be true and
activate the corresponding operation (\texttt{RetrieveURL} or
\texttt{ExecuteCGI} in this case). The other objects evaluating their
guard expressions afterwards will find that 
\texttt{\#active(RetrieveURL) + \#active(ExecuteCGI) = 10}
and thus remain blocked. \textit{Which object is allowed to evaluate the guard
expression first is undefined.}

It is important to understand that the guard expression need only 
evaluate to \textsf{true} at the time of the activation. In the
example as soon as $O_1$, $O_2$ or $O_3$'s request is activated its
guard expression becomes false again. 


\subsection{Inheritance of Synchronization Constraints}
\label{ch:sync-inh}

Synchronization constraints specified in a superclass are inherited by
its subclass(es). 
The manner in which this occurs depends on 
the kind of synchronization.

\subsubsection{Mutex constraints}
Mutex constraints from base classes and derived classes are
simply added. If the base class and derived class have the mutex
definitions {$M_{A}$} and {$M_{B}$}, respectively, then the derived
class simply has both mutex constraints {$M_{A}$}, and
{$M_{B}$}. The binding of operation names to actual operations is
always performed in the class where the constraint is
defined. Therefore a \keyw{mutex(all)} constraint defined in a
superclass and inherited by a subclass only makes the operations from
the base class mutually exclusive and does not affect operations of
the derived class.

Inheritance of mutex constraints is completely analogous to the
inheritance scheme for  permission predicates. Internally mutex
constraints are always expanded into appropriate permission predicates
which are added to the existing permission predicates as a
conjunction. This inheritance scheme ensures that the result (the
final permission predicate) is the same, regardless of whether the mutex
definitions are expanded in the base class and inherited as permission
predicates or are inherited as mutex definitions and only expanded in
the derived class.

The intention for inheriting synchronization constraints in the way
presented is to ensure, that any derived class at least
satisfies the constraints of the base class.  In addition to that it
must be possible to strengthen the synchronization constraints. This
can be necessary if the derived class adds new operations as in the
following example:
\begin{alltt}
  \keyw{class} A 
    \keyw{operations}
    
      writer: () ==> () \keyw{is not yet specified}
    
      reader: () ==> () \keyw{is not yet specified}
    
    \keyw{sync}
       \keyw{per} reader => \keyw{\#active}(writer) = 0; 
       \keyw{per} writer => \keyw{\#active}(reader, writer) = 0; 
  \keyw{end} A

  \keyw{class} B \keyw{is subclass of} A 
    \keyw{operations}

      newWriter: () ==> () \keyw{is not yet specified}

    \keyw{sync}
       \keyw{per} reader => \keyw{#active}(newWriter) = 0; 
       \keyw{per} writer => \keyw{#active}(newWriter) = 0; 
       \keyw{per} newWriter => \keyw{#active}(reader, writer, newWriter) = 0; 

  \keyw{end} B
\end{alltt}

Class \texttt{A} implements reader and writer operations with the permission
predicates specifying the multiple readers-single writer protocol. The
derived class \texttt{B} adds \texttt{newWriter}. In order to ensure
deterministic behaviour \texttt{B} also has to add permission
predicates for the inherited operations.

The actual permission predicates in the derived class
are therefore:
\begin{alltt}
  \keyw{per} reader => \keyw{\#active}(writer)=0 and \keyw{\#active}(newWriter)=0; 
  \keyw{per} writer => \keyw{\#active}(reader, writer)=0 and \keyw{\#active}(newWriter)=0;
  \keyw{per} newWriter => \keyw{\#active}(reader, writer, newWriter)=0;
\end{alltt}

A special situation arises when a subclass overrides an
operation from the base class. The overriding operation is
treated as a new operation.  It has no permission predicate (and in
particular inherits none) unless one is defined in the subclass.

The semantics of inheriting mutex constraints for overridden
operations is completely analogous: newly defined overriding
operations are not restricted by mutex definitions for equally named
operations in the base class. The \keyw{mutex(all)} shorthand makes all
inherited and locally defined operations mutually
exclusive. Overridden operations (defined in a base class) are not
affected. In other words, all operations, that can be called with an
unqualified name (``locally visible operations'') will be mutex to
each other.



\section{Threads}\label{ch:thread}

Objects instantiated from a class with a {\em thread} part are called
{\em active} objects.  The scope of the instance variables and 
operations of the current class is considered to extend to the thread
specification.

\begin{description}
\item[Syntax:]  \Ruledef{thread definitions}{ \Lop{thread},
\OptPt{\Ruleref{thread definition}} } \Rule{thread definition}{
#ifdef VICEMAN
    \Ruleref{periodic thread definition} \dsep 
#endif VICEMAN
    \Ruleref{procedural thread definition} }
\end{description}

Subclasses inherit threads from superclasses. 
If a class inherits from several classes only one of these may declare
its own thread (possibly through inheritance). Furthermore, explicitly
declaring a thread in a subclass will override any inherited thread.  

#ifdef VICEMAN
\subsection{Periodic Thread Definitions}\label{se:periodic-thread}

The periodic thread definition can be regarded as the implicit way
of describing the activities in a thread.

\begin{description}
\item[Syntax:] 
  \Ruledef{periodic thread definition}{
    \Ruleref{periodic obligation}
  }
  \Ruledef{periodic obligation}{
    \Lop{periodic},\Lit{(}, \Ruleref{numeral},
    \Ruleref{numeral}, \Ruleref{numeral}, \lfeed \Ruleref{numeral}, 
    \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
  }

\item[Semantics:] 
For each periodic thread four different numbers are used. They are in order 
of appearance: 

\begin{enumerate}
\item \textbf{period:} This is a non-negative, non-zero value that describes the length of the 
time interval between two adjacent events in a strictly periodic event stream (where jitter = 0)
\item \textbf{jitter:} This is a non-negative value that describes the amount of time variance that is allowed
around a single event. We assume that the interval is balanced [-j, j]. Note that jitter is
allowed to be bigger than the period to characterize so-called event bursts.
\item \textbf{delay:} This is a non-negative value smaller than the period which is used to denote the minimum
inter arrival distance between two adjacent events.
\item \textbf{offset:} This is a non-negative value which is used to denote the absolute time value at which
the first period of the event stream starts. Note that the first event occurs in the interval
[offset, offset+ jitter].
\end{enumerate}

Given a defined time resolution $\Delta$T, a thread with a periodic
obligation invokes the mentioned operation at the beginning of each
time interval with length {\em period}.  This creates the periodic
execution of the operation simulating the discrete equivalent of
continuous relations which have to be maintained between instance
variables, parameter values and possibly other external values
obtained through operation invocations.  It is not possible to dynamically 
change the length of the interval.

Periodic obligations are intended to describe e.g.\
analogue physical relations between values in formulas (e.g.\ transfer
functions) and their discrete event simulation.
It is a requirement on the implementation to
guarantee that the execution time of the operation is at least smaller
than the used periodic time length.
If other operations are present the user has to guarantee that
the fairness criteria for the invocation of these other operations are
maintained by reasoning about the time slices used internally and
available for external invocations.

A periodic thread is \textit{not} created or started when an instance of the
corresponding class is created. Instead, as with procedural threads,
start statements should be used with periodic threads. 


\item[Examples:]
Consider a timer class which periodically increments its  clock in its
own thread. It provides operations for starting, and stopping timing,
and reading the current time. 

\begin{alltt}
  \keyw{class} Timer
\end{alltt}

The Timer has two instance variables the current time and a flag
indicating whether the Timer is active or not (the current time is
only incremented if the Timer is active).
\begin{alltt}
  \keyw{instance variables}
  curTime : \keyw{nat} := 0;
  active  : \keyw{bool} := \keyw{false};
\end{alltt}

The Timer provides straightforward operations which need no further
explanation. 
\begin{alltt}
  \keyw{operations}
  public Start : () ==> ()
  Start() ==
    (active := \keyw{true};
     curTime := 0);

  public Stop : () ==> () 
  Stop() ==
    active := \keyw{false};

  public GetTime : () ==> nat
  GetTime() ==
    \keyw{return} curTime;

  IncTime: () ==> ()
  IncTime() ==
    \keyw{if} active
    \keyw{then} curTime := curTime + 100;
\end{alltt}

The Timer's thread ensures that the current time is incremented. The period 
with which this is done is 1000 time units. The allowed jitter is 10 time units
and the minimal distance between two instances is 200 time units and finally
no offset has been used.
%We take one time unit for the Timer to correspond to 10 system time units.

\begin{alltt}
  \keyw{thread}
  \keyw{periodic}(1000,10,200,0)(IncTime)

\keyw{end} Timer
\end{alltt}

\end{description}
#endif VICEMAN

\subsection{Procedural Thread Definitions}\label{se:proc-thread}

A procedural thread provides a mechanism to explicitly define the
external behaviour of an active object through the use of {\em
statements}, which are executed when the object is started (see
section \ref{sec:start}).  
%Apart from the statements which are allowed
%in operation bodies (as described in  section \ref{sec:stmt}), it is
%also possible to use {\em answer statements} and {\em select
%statements}.
%based on similar constructs in the language {\small
%POOL}~\cite{Boer91}.
%These allow conditional behaviour within the thread depending on the
%environment.  An answer statement explicitly states that the object
%executing it is prepared to execute a (set of) operation(s).  A select
%statement specifies the conditional execution of operations.

\begin{description}
\item[Syntax:]  
  \Ruledef{procedural thread definition}{
    \Ruleref{statement} } 

%  \Rule{select statement}{ 
%    \Lop{sel}, 
%    \Lit{(},
%    \Ruleref{guarded command}, \lfeed 
%    \SeqPt{\Lit{,}, 
%          \Ruleref{guarded command}}, 
%    \Lit{)} 
%  } 

%  \Rule{guarded command}{
%    \OptPt{\Ruleref{expression}}, 
%    \OptPt{\Ruleref{answer statement}}, \lfeed 
%    \OptPt{\Lop{$->$}, 
%    \Ruleref{statement}} 
%  } 

%  \Rule{answer statement}{ 
%    \Lop{answer}, 
%    \Brack{\Ruleref{name} \dsepl 
%    \Lop{all}} 
%  }

\item[Semantics:] \mbox{} 
A procedural thread is scheduled for execution following the
application of a start statement to the object owning the thread. The
statements in the thread are then executed sequentially, and when
execution of the statements is complete, the thread
dies. Synchronization between multiple threads is achieved using
permission predicates on shared objects.
%Select statements and answer statements can
%occur at any place in a thread and allow conditional execution of the
%thread on the basis of operation invocation requests received by the
%thread. Any number of select and answer statements may occur in a
%thread definition, and they may be freely mixed with other
%statements. Note that select and answer statements may only used in
%active objects (threads), though this restriction is presently not
%enforced by the Toolbox.
%
%The following provisos apply:
%\begin{itemize}
%\item {\em guarded command} may not be empty; it must contain one {\em
%expression}, {\em answer statement} or {\em statement} at minimum.
%\item {\em expression} in {\em guarded command} must be boolean (if it
%is absent its default value is $\True$).
%\item {\em name} in the rule for {\em answer statement} must be
%defined in the class or in one of its superclasses.
%\end{itemize}
%Guards without an answer statement can be used to describe the {\em
%else} behaviour of the select statement.
%
%An answer statement \texttt{\keyw{answer} o} waits until the thread
%receives a request for operation \texttt{o}. It then executes this and
%the statement terminates. The \texttt{\keyw{answer all}} statement
%waits until the thread receives a request for any operation defined in
%that class (or superclass), executes that operation and then
%terminates.
%
%The general form of the select statement is
%\begin{alltt}
%  \keyw{sel} 
%     guard1, \keyw{answer} o1 -> s1, 
%       \vdots 
%     guardN, \keyw{answer} oN -> sN;
%\end{alltt}
%Each line after the \texttt{sel} is a guarded command. For each
%guarded command, each of the guard, answer statement,  and statement
%is optional, but at least one of them must appear.
%
%The select statement is then executed as follows:
%\begin{description}
%\item[Step 1:] All conditions of the guarded command \texttt{guard1}
%$\ldots$ \texttt{guardN} are evaluated.  The guards whose conditions
%result in false are discarded.  The remainder are known as {\em open}
%guards.
%\item[Step 2:] The set of operation names occurring in the answer
%statements of the open guards is determined ({\em open operation
%set}).  The set of all invocations of operations within the open
%operation set is determined (the open invocation set).
%
%We then have three choices
%\begin{description}
%\item[Choice 1] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are open guards without an answer statement
%\end{itemize}
%  then an arbitrary open guard without an answer statement is selected
%  and   its associated statement sequence is executed.  The select
%  statement then terminates.
%\item[Choice 2] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are {\em no} open guards without an answer statement
%\end{itemize}
%then the thread waits until an operation in the open operation set is
%invoked by another object. Following completion of this operation the
%corresponding statement is executed. After this the select statement
%terminates.
%\item[Choice 3] If the set of invocations is {\em not} empty then the
%invocation in the open invocation set which was received first is
%selected. An arbitrary guard with an answer statement matching the
%invoked operation is selected. The operation is executed and after
%that the statement sequence associated with that guard is
%executed. Following this the select statement terminates.
%\end{description}
%\end{description}
%
%In addition to the basic mechanism described above a few points are
%worth noting:
%\begin{itemize}
%\item A select statement must always contain at least one {\em open}
%guard.
%\item A calling object will block until its call is answered by the
%select statement.
%\item The calling object and the thread synchronize on the operation
%call. However if a guarded command includes an answer statement and a
%statement to be executed afterwards, synchronization only occurs on
%the operation named in the answer statement. That is, the calling
%object may proceed following completion of the operation, and does not
%wait for execution of the statement listed in the guarded command.
%\end{itemize}
%
\item[Examples:]  \mbox{}
The example below demonstrates procedural threads by using them to
compute the factorial of a given integer concurrently. 

\begin{alltt}
    \keyw{class} Factorial

    \keyw{instance} \keyw{variables}
      result : \keyw{nat} := 5;
    \keyw{operations}

    \keyw{public} factorial : \keyw{nat} ==> \keyw{nat}
    factorial(n) == 
      \keyw{if} n = 0 \keyw{then} \keyw{return} 1
      \keyw{else} (
        \keyw{dcl} m : Multiplier;
        m := \keyw{new} Multiplier();
        m.calculate(1,n);
        \keyw{start}(m);
        result:= m.giveResult();
        \keyw{return} result
      )

    \keyw{end} Factorial

    \keyw{class} Multiplier

    \keyw{instance} \keyw{variables}
      i : \keyw{nat1};
      j : \keyw{nat1}; 
      k : \keyw{nat1};  
      result : \keyw{nat1}

    \keyw{operations}

    \keyw{public} calculate : \keyw{nat1} * \keyw{nat1} ==> ()
    calculate (first, last) ==  
      (i := first; j := last);

    doit : () ==> ()
    doit() ==
      (
       \keyw{if}  i = j \keyw{then} result := i
       \keyw{else} (
         \keyw{dcl} p : Multiplier;
         \keyw{dcl} q : Multiplier;
         p := \keyw{new} Multiplier();  
         q := \keyw{new} Multiplier();  
         \keyw{start}(p);\keyw{start}(q);  
         k := (i + j)  \keyw{div} 2;
         -- division with rounding down
         p.calculate(i,k);  
         q.calculate(k+1,j);  
         result := p.giveResult() *  q.giveResult ()
        )
      );

    \keyw{public} giveResult : () ==> \keyw{nat1}
    giveResult() ==  
      \keyw{return} result;

    \keyw{sync}
    -- cyclic constraints allowing only the 
    -- sequence calculate; doit; giveResult

    \keyw{per} doit => \keyw{#fin} (calculate) > \keyw{#act}(doit);
    \keyw{per} giveResult => \keyw{#fin} (doit) > \keyw{#act} (giveResult);
    \keyw{per} calculate => \keyw{#fin} (giveResult) = \keyw{#act} (calculate)

    \keyw{thread}
      doit();

    \keyw{end} Multiplier
\end{alltt}

        

%First we consider some examples which illustrate the
%basic mechanism of select statements. Suppose we have a thread with
%instance variables \texttt{x:\keyw{nat}}, \texttt{y:\keyw{nat}} and
%\texttt{l:\keyw{seq1 of nat}}, and operations \texttt{o1} and
%\texttt{o2}. Consider the following select statement:
%\begin{alltt}
%  \keyw{sel} ( 
%    x <= 0, \keyw{answer} o1 -> x:= 1,     -- gc1 
%    x >= 0,\mbox{\hspace{0.2em}}          -> y := x,    -- gc2
%            \keyw{answer} o2 -> l := [1]   -- gc3 )
%\end{alltt}
%We consider a number of different scenarios:
%\begin{enumerate}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc1}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set consists of only \texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, \texttt{gc2} is open and has no answer
%statement. Therefore choice 1 is taken. The statement \texttt{y := x}
%is executed then the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & -3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} &
%[1,2,3]\\ \hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc2}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, and there are no open guards without an answer
%statement. Therefore choice 2 is taken and the thread waits. While it
%waits it can only respond to invocations of \texttt{o1} or
%\texttt{o2}. Suppose then that while waiting it receives a call to
%\texttt{o1}: \texttt{o1} is executed, then the statement \texttt{x :=
%1} is executed and the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and invocations have been received for operations \texttt{o1} and
%\texttt{o2} (\texttt{o2} arriving first).
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Now since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc3} is selected because the invocation of
%\texttt{o2} was received first. \texttt{o2} is executed and on
%completion the statement \texttt{l := [y]} is executed. The select
%statement then terminates.
%\end{description}
%
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and an invocation has been received for operation \texttt{o1}.
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains only \texttt{o1}.
%\item[Choice] Again, since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc1} is selected  and \texttt{o1} is
%executed. On completion the statement \texttt{ x:= 1} is executed. The
%select statement then terminates.
%\end{description}
%\end{enumerate}
%
%We now give a more complex example.  Suppose we wish to model the
%behaviour of an ATM machine. We might have the following instance
%variables:
%\begin{alltt}
%  \keyw{instance variables} 
%    status : <InService> | <OutOfService> |  <CardInserted> |  
%             <CardAccepted> := <InService>; 
%    currentCard : [ATMCard] := \keyw{nil}; 
%    pinTries : \keyw{nat} := 0; 
%    balance :  \keyw{nat} := 10000; 
%    keypad : Keypad := \keyw{new} Keypad();
%    accountDB : AccountDB := \keyw{new} AccountDB(); 
%    retained : \keyw{set} of ATMCard := \{\};
%\end{alltt}
%Here \texttt{ATMCard} is a class representing an ATM card,
%\texttt{Keypad} is a simple object that models digit entry by the
%user, and \texttt{AccountDB} is an object modelling the mapping from
%card numbers to account details.
%
%We might wish to perform the following operations on this class (for
%brevity we do not include their definition here):
%
%\begin{tabular}{lll}
%\texttt{EnterCard :} & \texttt{ATMCard ==> ()}  & Enter a card into
%                          the machine\\ 
%\texttt{GetPin :}    & \texttt{() ==> ()}       & Get the PIN digits typed
%                                                  at \\ 
%                     &                          & the keypad\\
%\texttt{VerifyPin:}  & \texttt{\keyw{nat} ==> ()}
%                                                & Check the validity of the PIN \\
%                     &                          & given\\
%\texttt{RetainCard :}& \texttt{() ==> ()}       & Retain the card if three failed\\
%                     &                          & attempts to enter the PIN\\
%\texttt{WithdrawCash :} 
%                     & \texttt{\keyw{nat} ==> ()}
%                                                & Withdraw cash\\
%\texttt{WithdrawCard :} 
%                     & \texttt{() ==> ()}       & Withdraw card from the \\
%                     &                          & machine\\
%\texttt{ReplenishMachine :} 
%                    & \texttt{() ==> ()}        & Refill machine with cash
%\end{tabular}
%
%Then we might specify the thread behaviour of this class as follows:
%\begin{alltt}
%    \keyw{while true do}
%      \keyw{if} status = <InService>
%      \keyw{then} (
%        \keyw{sel} (\keyw{answer} EnterCard);
%        \keyw{while} status <> <InService> \keyw{do}
%          \keyw{sel} ( status = <CardInserted> \keyw{and} pinTries < 3
%                               \keyw{answer} GetPin,
%               status = <CardInserted> \keyw{and} pinTries = 3 
%                               -> RetainCard(),
%               status = <CardAccepted> \keyw{and} balance > 300 
%                               \keyw{answer} WithdrawCash,
%               status = <CardAccepted> \keyw{answer} WithdrawCard
%              );
%        \keyw{if} balance <= 300
%        \keyw{then} status := <OutOfService> )
%      \keyw{else}
%        \keyw{sel} (status = <OutOfService> \keyw{answer} ReplenishMachine);
%\end{alltt}
%This thread repeatedly loops until the object is destroyed. Within
%this loop behaviour diverges according to whether \texttt{status =
%<InService>} or not. Initially the status is \texttt{<InService>} so
%the \texttt{then} clause will be executed. The thread will then wait
%until a card is entered into the machine.
%
%Following this we loop until the status returns to
%\texttt{<InService>}, which only occurs when the operations
%\texttt{WithdrawCard} or \texttt{RetainCard} are executed. Within this
%loop the thread conditionally allows invocations of the operations
%\texttt{GetPin}, \texttt{WithdrawCash} and
%\texttt{WithdrawCard}. Additionally the thread invokes
%\texttt{RetainCard} itself once 3 unsuccessful attempts have been made
%to enter a pin code.
%
%When this loop is exited the status is \texttt{<InService>}. However
%if insufficient cash is left in the machine it goes out of
%service. This terminates the \texttt{then} clause.
%
%In the \texttt{else} clause, it can be seen that the only way this
%clause can be entered is if the status is
%\texttt{<OutOfService>}. Thus the thread waits until the machine is
%replenished. 
%
%Observe that in the second \keyw{sel} statement, if (\texttt{status =
%<CardAccepted> 
%\keyw{and} balance > 300}) then the thread could behave
%non-deterministically, since two guards would be open simultaneously.
%
\end{description}
%
%Note that the two methods of specifying synchronization (permission
%predicates %, trace structures 
%and answer statements) should not be
%mixed in a class specification: only one of these may be used. 
%
%A procedural thread definition has precedence over a
%synchronization specification in a class; when using this way of
%specification, the full external behaviour of an active object has to
%be specified (i.e. for each operation an answer statement must be
%present).  The synchronization definitions can then be derived
%from the procedural thread.  If there is a contradiction between
%synchronization derived from the procedural thread and the specified
%synchronization behaviour then the class is erroneous.

%\subsection{Inheriting from Active Objects}
%\label{ch:thread-inh}
%
%Threads can, in some cases, be inherited in {\vdmpp}; the situations in which
%this is allowed are determined by whether or not there exists
%a sensible interpretation of polymorphism between active objects (see Section
%\ref{sec:polyao}). The different situations in which inheriting from
%active superclasses is allowed is summarized in the following table:
%
%{\small
%\begin{center}
%\begin{tabular}{|c||c|c|c|c|c|}
%\hline
%& & & {\em active,} & {\em active,}\\
%superclass & {\em none} & {\em passive} & {\em declarative} & {\em procedural}\\
%& & & {\em thread} & {\em thread}\\
%\hline
%\hline
%& & behaviour as & inheritance & inheritance\\
%{\em none} & --- & defined by & allowed, see & allowed, see\\
%& & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%& behaviour as & behaviour as & inheritance & inheritance \\
%{\em passive} & defined by & defined by & allowed, see & allowed, see \\
%& the subclass & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em declarative} & allowed, see & allowed, see & allowed, see & {\bf not} \\
%{\em thread} & Section \ref{decinh} & Section \ref{decinh} & Section \ref{decinh} & allowed\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em procedural} & allowed, see & allowed, see & {\bf not} & allowed, see \\
%{\em thread} & Section \ref{procinh} & Section \ref{procinh} & allowed & Section \ref{procinh} \\
%\hline
%\end{tabular}
%\end{center}}
%
%\subsubsection{Polymorphism for Active Objects}\label{sec:polyao}
%
%A basic issue for understanding polymorphism for active objects
%is the notion of risk of interference caused by the thread of such objects.
%A basic understanding to this is provided by the Bernstein rules.
% (see e.g. \cite{bernstein66} or \cite[pages 289--290]{peterson}).
%Bernstein defines the {\em read-set} $R$ for statement $S_i$, $\fnapply{R}{S_i} = \setrange{a_1, a_2}{a_n}$, as:
%\begin{quote}
%the set of all variables referenced in statement $S_i$, such that the value
%of each $a_j$ did not change during the execution of $S_i$.
%\end{quote}
%The {\em write-set} $W$ for statement $S_i$, $\fnapply{W}{S_i}= \setrange{b_1,
%b_2}{b_n}$, is then defined as:
%\begin{quote}
%the set of all variables referenced in 
%statement $S_i$ such that each $b_j$ is
%updated (i.e. gets a new value) in $S_i$.
%\end{quote}
%
%The following three conditions must hold for two successive statements 
%(say: $S_1$ and $S_2$) in order to be executed concurrently and always
%produce the same result as if they were executed sequentially (the 
%Bernstein conditions):
%\begin{enumerate}
%\item
%$\fnapply{R}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\end{enumerate}
%
%As an example, consider two statements $S_1$ and $S_2$. Suppose that
%$S_1$ updates a variable $b$, and that $S_2$ is defined as
%$\ass{c}{a + b}$. Since 
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \set{b}$, concurrent
%execution of $S_1$ and $S_2$ is not allowed.
%
%In a similar fashion, in {\vdmpp} the read- and write-sets can be defined
%for threads in terms of instance variables.
%
%For presentation purposes a distinction is made between active objects with
%a {\em declarative} thread (periodic obligation) and those with a
%{\em procedural} thread (sequence of statements using answer and select
%statements).
%
%\subsubsection{Declarative Threads}\label{decinh}
%
%Consider two classes {\tt A} and {\tt B} with a periodic obligation, 
%for {\tt A}, say, defined as:
%  \begin{alltt}
%    periodic (intervalA)(mA)
%  \end{alltt}
%and for {\tt B}, say, defined as:
%  \begin{alltt}
%    periodic (intervalB)(mB)
%  \end{alltt}
%then a class {\tt C}, defined as subclass of both {\tt A} and {\tt B},
%has a new thread with {\it two} periodic obligations, e.g. graphically
%depicted as follows:
%\ \\
%\ \\
%\insertfig{2periodic}{14cm}{Periodic obligations for class C}{}
%
%
%\subsubsection{Procedural Threads}\label{procinh}
%
%Polymorphism for active objects of which the behaviour is defined using
%procedural threads instead of declarative threads is more complicated.
%In {\vdmpp} it is only considered for classes with a non-terminating
%behaviour\footnote{It is possible to define terminating threads, implying that
%these (initially) {\it active} objects become {\it passive} after some time.},
%e.g. defined using a loop, typically:
%  \begin{alltt}
%    while true do\\
%    sel (
%      condA -> answer mA,
%      condB -> answer mB,
%      ...
%      condN -> answer mN
%    )
%  \end{alltt}
%or
%  \begin{alltt}
%    while true do
%    answer mA;
%    answer mB;
%    ...
%    answer mN
%  \end{alltt}
%
%Procedural threads of these forms define `answer-sets/sequences', i.e.
%sets or sequences defining the possible (orders of) operations these
%objects will answer to.
%Defining a subclass of two classes with such definitions implies that
%the subclass has an answer-sets/sequence composed by taking the union
%or weaving the two answer-sets/sequences of the superclasses into one another.
%So, suppose that objects from class {\tt A} respond to
%
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n}
%\end{expr}
%\end{vdm}
%and that objects from class {\tt B} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_{n+1}, m_{n+2}}{m_p}
%\end{expr}
%\end{vdm}
%and that class {\tt C} is a subclass of both {\tt A} and {\tt B}, then
%objects from class {\tt C} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n, m_{n+1}, m_{n+2}, \ldots, m_p}
%\end{expr}
%\end{vdm}
%
%Because the scope in which the instance variables of
%an object are visible includes the procedural thread, a proof obligation is
%raised to satisfy the Bernstein conditions.
%No problems arise in the simple case where {\tt C} is a subclass of 
%{\tt A} and {\tt B} and no further coupling is made in {\tt C}
%between the instance variables of {\tt A} and {\tt B} -- the threads of
%{\tt A} and {\tt B} in {\tt C} only affect the {\tt A} and {\tt B} part
%of the instance variables in {\tt C},
%respectively, hence the Bernstein conditions are always satisfied.
%If, however, a connection is made in {\tt C} between the two state parts
%through an invariant, then it is no longer guaranteed that the Bernstein
%conditions are satisfied.

%\cleardoublepage
%\section{Real-time Behaviour}\label{ch:rt}
%
%For the description of requirements and the behaviour of a system
%(component) in real time a small number of concepts suffice.  These
%concepts are based on
%references~\cite{Hayes90,Mahony&91a,Mahony&91b,Mahony92,Mahony&92}.
%At first the time continuous functions are defined and introduced as
%{\em time variables}. Existing concepts like pre-conditions,
%post-\-cond\-it\-ions, hooked values etc. are overloaded with their
%time aspects.
%
%For a complete (sub)system a development process starting in the
%continuous time domain is envisaged.  The initial input-output
%relations from the requirements can be decomposed into a topology of
%subcomponents through refinement steps in the continuous time domain.
%The continuous behaviour of the topology of the derived objects can be
%mapped on equivalent objects, which operate themselves sequentially in
%a discrete time domain.  Relations between the continuous and the
%discrete objects are established through inheritance.  The resulting
%objects can follow the more common {\vdmpp} refinement steps with
%additional descriptions and rules for their time behaviour. The
%resulting time behaviour of the lower level objects in the
%specification will give the limitations/requirements for the component
%implementation. 
%
%Time continuous variables appear in classes with a special role
%in the specification. Spreading these functions in arbitrary places is not
%foreseen. 
%
%\subsection{Time continuous Functions}
%\label{sec:timeexpr}
%
%Time continuous functions are those in which time can be assumed to
%increase continuously and implicitly, thus without any influence from
%the specification.
%
%At the input side of a system {\em assumptions} can be made about
%these continuous signals. In many cases these assumptions will
%represent the physical properties of the real-world signals and the
%available sensors in the environment.  Such an assumption is
%functionally equivalent to a {\em pre-condition}.  There is no way of
%enforcing this condition, however, because the environment is in
%principle beyond the scope of control of the system specifier.  The
%consequence of this observation is that the correct behaviour of the
%system can only be guaranteed for those time periods where these
%assumptions are met.  In all other cases the system will react in an
%undefined way or not at all.  In other words: the assumptions on input
%signals are environmental requirements.
%
%The syntactical representation of time continuous variables is
%realised through a syntactic block comparable with the instance
%variables block, beginning with the keyword {\tt time variables}. Then
%the declaration of the names of the time functions follow.  The
%function value changes over time either according to a given formula,
%with the time as an independent variable, or changes as an observation
%value of a physical quantity in the environment.
%
%\begin{description}
%\item[Syntax:] 
%\Rule{time variable definitions}{\Lop{time}, \Lop{variables},
%      time spec, \SeqPt{\Lit{;}, time spec}, \OptPt{\Lop{;}}}
%\Rule{time spec}{time var decl \dsep assumption \dsep effect}
%\Rule{time var decl}{\OptPt{\Lop{input}}, name list, \Lit{:}, type}
%\Rule{assumption}{\Lop{assumption}, name list, \Lit{==}, expression}
%\Rule{effect}{\Lop{effect}, name list, \Lit{==}, expression}
%
%\item[Semantics:] If instances are created from a continuous class
%(and used through clientship by other objects) each object represents
%a distinct time continuous function which has in principle no relation
%with the functions in the other instances, i.e. different
%observations.  The following rules hold:
%
%\begin{itemize}
%\item If different subclasses are inheriting from the same continuous
%  superclass, they share the same function, i.e. the same observation of
%  the environment.
%\item If instances are created from a continuous class (and used
%  through clientship by other objects) each object represents a distinct
%  time continuous function which has in principle no relation with the
%  functions in the other instances, i.e. different observations.
%\item Sharing of the information available in an object as server for
%  more than one client object, has to be realised by referencing through
%  clientship to the same server object.
%\end{itemize}
%
%This interpretation can be used e.g. with a number of sensors for the
%temperature in a room; they measure the local temperature in a certain area
%Sharing of the information available can be achieved by using 
%an object as server form more
%than one client object.
%The local temperature variations are discarded and
%only one room temperature is used in the model.
%
%A special clause can be added to a time continuous functions to denote
%assumptions over their behaviour.  The keywords used are {\tt
%assumptions} for input variables and {\tt effects} for output
%variables.
%
%The use of the operation interface is reserved for the discrete system
%behaviour and provides the specification of a sampling mechanism, when
%used on continuous variables.
%
%\item[Examples:] \mbox{} 
%
%  \begin{alltt}
%  class SensorBehaviour
%  
%    time variables
%      input theta: real;
%      input myinput: real;
%    assumption myinput == myinput (t) = a * sin (w * t)
%
%  end SensorBehaviour
%  \end{alltt}
%
%These functions are in another notation the continuous time functions:
%
%  \begin{alltt}
%    theta (t) = temperature (t)
%  \end{alltt}
%  and
%  \begin{alltt}
%    myinput (t) = a * sin (w * t)
%  \end{alltt}
%
%\end{description}
% 
%\subsection{From Continuous Time to Discrete Time}
%
%\subsubsection{The input side}
%
%To express the way hardware/software based systems handle the continuous time
%problems a next refinement step will practically always mean the discretisizing
%of the continuous time functions. This means that a sampling mechanism has to
%be specified.
%
%The advised steps to specify this translation into the discrete time
%domain is to:
%
%\begin{enumerate}
%\item Inherit into a new {\vdmpp} class from the continuous class the time
%  function.
%\item Specify a sampling operation.
%\item Introduce a thread which regularly invokes this operation,
%  with sample frequency $f_s\;(=\; \frac{1}{\Delta t})$.
%\end{enumerate}
%
%Discrete sampling involves an approximation of the continuous value.
%If the interval length is $\Delta t$ in the interval $<t_1 , t_1 +
%\Delta t>$, a value within $F \ll t_1 \ldots t_1 + \Delta t \gg $ is
%returned as the discrete result. According to the theory of Shannon,
%the sampling frequency should be at least twice the highest frequency
%which is present in the input signal. The error in the approximation
%can be calculated with standard signal processing operations.
%
%The approximation in time is also needed to handle the fact, that discrete
%observations of ideal time continuous functions always include measurement
%errors, rounding off errors, limited accuracy, etc.
%
%\begin{description}
%\item[Examples:] The advised discretisizing operation as first
%  refinement for the continuous class is represented by the following
%  class based on the continuous temperature class:
%
%\begin{alltt}
%  class Sensor is subclass of SensorBehaviour
%
%    values
%      fs: real = undefined
%  
%    instance variables
%      tempvalues: seq of real := [];
%      currvalue: real;
%    inv len tempvalues > 0 => currvalue = tempvalues(len)
%
%    operations
%      gettemp: () ==> ()
%      gettemp() ==
%      ( currvalue := theta(t);
%        tempvalues := tempvalues ^ [currvalue]
%      )
%  
%   thread
%     periodic (1/fs)(gettemp)
%
%end Sensor
%\end{alltt}
%
%The introduced sequence of values now models the history of all
%samples.  In a normal case in which a $2^{nd}$ order differential
%equation can describe the system behaviour, the length can be reduced
%to three values: those at $t$, $t - \Delta t$ and $t - 2 \Delta t$
%will be sufficient.
%
%\end{description}
%
%\subsubsection{The output side}
%
%At the output side a similar approach can be used, although some special
%considerations are needed here.
%If the discrete class is the `producer' of a series of discrete values over
%time, the output of the system itself will be continuous again.
%Therefore, the impossibility for real signals to perform discontinuous behaviour
%has to be build in. 
%
%\begin{description}
%\item[Example:] In class {\tt HeaterController} there is an instance
%variable {\tt controlvalue} which represented at each time the
%discrete value of the output of the controller.  The transformation
%backwards into the continuous domain is again performed with an
%operation which sets at discrete time intervals the value of the
%continuous time variable.  At the times in between these moments the
%effect constraint specifies the maximum rate that can be achieved in
%the continuous domain.
%
%The two classes can be specified as follows:
%  \begin{alltt}
%  class HCBehaviour
%
%    time variables
%      controloutput: real
%
%  end HCBehaviour
%
%  class HeaterController is subclass of HCBehaviour
%
%    instance variables
%      controlvalue: nat
%      
%    operations
%      setheatercontrol: () ==> ()
%      setheatercontrol() ==
%        controloutput(now) := controloutput
%
%    thread
%      periodic (1/fs) (setheatercontrol)
%
%  end HeaterController
%  \end{alltt}
%\end{description}
%
%The relation between the momentary values coming from the discrete world to
%the continuous time functions requires some extra discussion.
%The specific relationship between the discrete value and its continuous
%counterpart requires the concept of controlled register-like variables in the
%continuous domain, which
%do not change in time between two successive updates by the operation.
%Given a sampling distance $\Delta t$ and an interval beginning at $t_i$ with
%a value $F(t_i)$, the step reaction
%of the system will take some time constant say $\tau$ with 
%$\tau \leq \Delta t$ to stabilise the output value. This value $\tau$ can be
%derived from the effect constraint. This gives the following continuous time
%behaviour:
%\begin{itemize}
%\item
%$<t_i,t_i + \tau>$: the rate defined by constraint, 
%value within $F \ll t_{i-1} \ldots t_i \gg$ or equivalently
%$[F(t_{i-1}),F(t_i)]$ excluding possible `overshoot';
%\item
%$<t_i + \tau ,t_i + \Delta t>$: value should have been stabilised on $F(t_i)$;
%\item
%at $t_i + \Delta t$: value is $F(t_i)$.
%\end{itemize}
%
%This time description is of course a kind of macro description of the
%continuous output value. By including the behaviour of more detailed output
%channel components one can refine the above mentioned intervals again.
%The above specification is effectively
%the behaviour of a certain digital-to-analogue converter.

#endif VDMPP
#ifdef VDMSL
\newpage
\section{Top-level Specification}
\label{top-level}\label{modules}

In the previous sections all the  VDM-SL constructs such as types,
expressions, statements, functions and operations have been described. A
number of these constructs can constitute a top-level  VDM-SL
specification. A top-level specification can be created in two ways:
\begin{enumerate}
\item The specification is split into a number of modules which are
  specified separately, but can depend on each other.
\item The specification is specified in a flat manner, i.e.\ no modules are
  used.
\end{enumerate}
Thus, a complete specification, or document, has the following syntax.

\begin{description}
\item[Syntax:]
\Rule{document}{
  \Ruleref{any module}, \SeqPt{\Ruleref{any module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Rule{any module}{
  \Ruleref{module} \dsep
  \Ruleref{dynamic link module}
  }
\end{description}

\subsection{A Flat Specification}\label{flat}

As said, a flat specification does not use modules. This means that all
constructs can be used throughout the specification. In the flat case, a
document has a syntax of:

\Rule{document}{\ldots \dsep
  \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{state definition} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions}
  }

Thus, a flat specification is made up of several {\it definition\/} blocks.
However, only one state definition is allowed. The following is an example
of a flat top-level specification:

\begin{alltt}
  \keyw{values}

    st1 = \keyw{mk\_}St([3,2,-9,11,5,3])

  \keyw{state} St \keyw{of}
    l:\keyw{seq1 of nat}
  \keyw{end}

  \keyw{functions}

  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
    \keyw{if} \keyw{len} l = 1
    \keyw{then} 1
    \keyw{else} \keyw{let} mi = min_index(\keyw{tl} l)
        \keyw{in} \keyw{if} l(mi+1) < \keyw{hd} l
          \keyw{then} mi+1
          \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    if i < len l
    then (\keyw{dcl} temp: \keyw{nat};
          \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         
          temp := l(mi);
          l(mi) := l(i);
          l(i) := temp;
          SelectionSort(i+1)
         )
\end{alltt}





\subsection{A Structured Specification}

As an extension to the standard VDM-SL language, it is possible to
structure an  VDM-SL specification using modules. In this section,
the use of modules to create the top-level specification will be described.
With the structuring facilities offered by  VDM-SL it is possible to:
\begin{itemize}
\item Export constructs from a module.
\item Import constructs from a module.
\item Rename constructs upon import.
\item Define a state in a module.
\end{itemize}

In addition to these kinds of ordinary modules it is possible to use
so-called ``Dynamic Link Modules'' (see section~\ref{sec:DLmodules}).

\subsubsection{The Layout of a Module}

Before the actual facilities are described, the general layout of a
module is described. A module consists of three parts: a {\it module
declaration}, an {\it interface section}, and a {\it definitions
section}. It is possible to leave out the definitions part in the
early development of a module specification.

In the module declaration, the module is named. The name must be a
unique module name within the complete specification. The second
part, the interface section, defines the relation of a module with other
modules and consists of a number of sections. These sections are:
\begin{itemize}

\item An {\it imports section}. In the imports section, all the
  constructs that are going to be used from other modules are
  described. If constructs are going to be renamed it has to be done
  in the imports section. 

\item An {\it exports section}. Here all the constructs that are going
  to be used in other modules are defined.
  If no exports section is present the
  module cannot be used from other modules.
\end{itemize}
The third part of a module declaration, the
definitions section, contains all the definitions of the module.
Thus, in general, the syntax of a module is:


\begin{description}
\item[Syntax:]
\Rule{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

  \Rule{module body}{
    \Lop{definitions}, \Ruleref{definition block}, \SeqPt{definition block}
  }
\end{description}

To illustrate the use of modules, the example flat top-level
specification are rewritten with some minor modifications.  Some
unimportant parts of the flat specification are left out for clarity.

\subsubsection{The Exports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{export definition}{
    \Lop{exports}, \Ruleref{export module signature}
    }

  \Rule{export module signature}{
    \Lop{all} \dsep
    \Ruleref{export signature}, \lfeed
    \SeqPt{\Ruleref{export signature}}
    }
  
  \Rule{export signature}{
    \Ruleref{export types signature} \dsep
    \Ruleref{values signature} \dsep
    \Ruleref{export functions signature} \dsep
    \Ruleref{operations signature}
%    \dsep
%    state signature
    }
  
  \Rule{export types signature}{
    \Lop{types}, \Ruleref{type export}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
    }
  
  \Rule{type export}{
    \OptPt{\Lop{struct}}, \Ruleref{name}
    }
  
  \Rule{values signature}{
    \Lop{values}, \Ruleref{value signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
    }
  
  \Rule{value signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{type}
    }
  
  \Rule{export functions signature}{
    \Lop{functions} \Ruleref{function export}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function export}}
    }

  \Rule{function export}{
    \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:}, \lfeed
    \Ruleref{function type}
    }
  
  \Rule{functions signature}{
    \Lop{functions} \Ruleref{function signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
    }
  
  \Rule{function signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{function type}
    }
  
  \Rule{operations signature}{
    \Lop{operations} \Ruleref{operation signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
    }
  
  \Rule{operation signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
    }
  
%  \Rule{state signature}{
%    \Lop{state}, name, \SeqPt{\Lit{,}, name}
%    }

\item[Semantics:] The exports section must be used to make constructs
  visible to other modules. Some or all of the defined
  constructs from a module can be exported. In the latter case, the keyword
  \keyw{all} is used. However, imported constructs are not exported
  from the module. If only part 
  of the constructs are exported, the visible constructs with
  the appropriate signatures are stated.

  Normally, if a construct is visible to another module,
  that construct can be considered
   to be defined inside the module. However, with types and
  operations there are some exceptions:
  \begin{description}
  \item[Types:] If a type {\tt T} is defined in module {\tt A} and
    this type is also going to be used in module {\tt B}, the type
    from module {\tt A} has to be exported. This can be done in two ways:
    \begin{enumerate}
    \item The name of the type is exported.
    \item The structure of the type is exported.
    \end{enumerate}
    If only the name of the type is exported, the other module cannot create
    values of type {\tt T}. This means that the exporting module ({\tt A})
    must provide functions and/or operations to directly create and manipulate
    values of type {\tt T} by means of the constructors related to the
    representation of {\tt T}. 

    If we export the structure of the type by using the keyword
    \keyw{struct}, the other module can create and manipulate values of
    type {\tt T} (it can also use \keyw{mk\_} keyword and the
    \keyw{is\_} keyword for this type if it is a record type).

    If the type also defines an invariant, the invariant predicate function
    is only exported if the structure of the type is exported.

  \item[Operations:] In a module, a state that is global for
    the module can be defined. All operations within the module can
    manipulate that state. If operations are exported from a module, they
     manipulate the state in the exporting module,
      i.e.\ the state in the module where they are defined.
  \end{description}

  If an exported function or an operation defines a pre- and/or
  post-condition, the corresponding predicate functions (see
  section~\ref{functiondef}) are also exported.

\item[Examples:] Consider a model of a bank account. An account is
characterised by the name of the holder, the account number, the
bank branch at which the account is maintained, the balance, and an
encrypted PIN code for the ATM card. We might model this as follows:
\begin{alltt}
\keyw{module} BankAccount

  \keyw{exports} \keyw{types} digit; account
          \keyw{functions} digval: digit -> \keyw{nat};
                  withdrawal: account * \keyw{real} -> account;
                  isPin: account * \keyw{nat} -> \keyw{bool};
                  requestWithdrawal: account * \keyw{nat} -> \keyw{bool}
  \keyw{definitions}

  \keyw{types}

  digit = \keyw{nat}
  \keyw{inv} d == d < 10;
  
  account::  holder : \keyw{seq1 of char}
             number : \keyw{seq1 of digit}
             branchcode : \keyw{seq1 of digit}
             balance: \keyw{real}
             epin: \keyw{nat}
  \keyw{inv mk\_}account(holder, number, branchcode,-,-) ==
    \keyw{len} number = 8 and \keyw{len} branchcode = 6

  \keyw{functions}

    digval : digit -> \keyw{nat}
    digval(d) == d;

    deposit: account * \keyw{real} -> account
    deposit(acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance + r);

    withdrawal : account * \keyw{real} -> account
    withdrawal (acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance - r);

    isPin : account * \keyw{nat} -> \keyw{bool}
    isPin(acc,ep) ==
      ep = acc.epin;

    requestWithdrawal : account * \keyw{nat} -> \keyw{bool}
    requestWithdrawal (acc,amt) ==
      acc.balance > amt

\keyw{end} BankAccount
\end{alltt}
In this module we export two types and five functions. Note that since
we have enumerated the entities we are exporting, but have not
exported \texttt{digit} or \texttt{account} using the \keyw{struct}
keyword, the internals of \texttt{account} values may not be accessed
by other modules, neither may the invariant for \texttt{digit}. If 
such access is necessary, the types should be exported with the
\keyw{struct} keyword, or all constructs in the module should be
exported using the \keyw{exports all} clause.

The module \texttt{Keypad} given below models the keypad interface of
an ATM machine. The state variable maintains a buffer of data typed at
the keypad by the user.

\begin{alltt}
\keyw{module} Keypad

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit

  \keyw{exports all}

  \keyw{definitions}

  \keyw{state} buffer \keyw{of}
    data : \keyw{seq of} BankAccount`digit
  \keyw{end}

  \keyw{operations}

    DataAvailable : () ==> \keyw{bool}
    DataAvailable () ==
      \keyw{return}(data <> []);

    ReadData : () ==> \keyw{seq of} BankAccount`digit
    ReadData () ==
      \keyw{return}(data);

    WriteData : \keyw{seq of} BankAccount`digit ==> ()
    WriteData (d) ==
      data := data^d

\keyw{end} Keypad
\end{alltt}
In this module all constructs are exported. Since the only entities
defined are the state and operations on it, this means that all of the
operations may be accessed by an importing module. The state is not
accessible to importing modules, but remains private to this
module. However the state constructor
\texttt{\keyw{mk\_}Keypad`buffer} is accessible.


\end{description}

\subsubsection{The Imports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{import definition list}{
    \Lop{imports}, \Ruleref{import definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{import definition}}
    }

  \Rule{import definition}{
    \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
    }

  \Rule{import module signature}{
    \Lop{all} \dsep
    \Ruleref{import signature}, \lfeed
    \SeqPt{\Ruleref{import signature}}
    }

  \Rule{import signature}{
    \Ruleref{import types signature} \dsep
    \Ruleref{import values signature} \dsep
    \Ruleref{import functions signature} \dsep
    \Ruleref{import operations signature}
%    \dsep
%    state signature
    }

  \Rule{import types signature}{
    \Lop{types}, \Ruleref{type import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
    }

  \Rule{type import}{
    \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
    \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import values signature}{
    \Lop{values}, \Ruleref{value import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
    }

  \Rule{value import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import functions signature}{
    \Lop{functions}, \Ruleref{function import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
    }

  \Rule{function import}{
    \Ruleref{name}, \OptPt{\OptPt{\Ruleref{type variable list}},  \lfeed
    \Lit{:}, \Ruleref{function type}},
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import operations signature}{
    \Lop{operations}, \Ruleref{operation import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
    }

  \Rule{operation import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

\item[Semantics:] The imports section is used to state what constructs are
  used from other modules with the restriction that only visible constructs
  can be imported. If all the visible constructs from a
  module are going to be used, the keyword \keyw{all} is used, unless one or
  more constructs are going to be renamed. With renaming, an imported
  construct is given a new name
  which can be used instead of the original name preceded by the
  exporting module name. In general this has the form:
  \begin{alltt}
    name \keyw{renamed} new_name
  \end{alltt}
  where {\tt name} is the name of the imported construct, and {\tt
    new\_name} is the new name for the construct. This way,
  more meaningful names can be given to constructs. Note that in the importing
  module it is not possible to refer to {\tt DefModule`name} (where
  {\tt DefModule} is the name of the defining module) any longer but only to
  {\tt newname}.

  It is possible to include type information in the imports section,
such that
  this information will only be used by the static semantics check of the
  complete module. If no type information is given, the static semantics
  can also find this information in the exporting module (see
  section~\ref{static}).
  
  When a type which has been exported with the \keyw{struct} keyword
  (with its structure) is imported the
  importing module may only make use of this structure if it repeats
  the type definition from the exporting module in its type import. In
  case such a type is a composite type and it is also renamed this has
  the consequence that the tag is renamed as well.
  
\item[Examples:] We can model an ATM card as consisting of a
card number and an expiry date. This requires the \texttt{digit} type
defined in the module \texttt{BankAccount}. It also uses the function
\texttt{digval} from the same module.
\begin{alltt}
\keyw{module} ATMCard

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit 
                     \keyw{functions} digval \keyw{renamed} atmc_digval

  \keyw{exports all}

  \keyw{definitions}

  \keyw{types}

    digit = BankAccount`digit;

    atmc:: cardnumber : \keyw{seq1 of} digit
           expiry : digit * digit * digit * digit
    \keyw{inv mk\_}atmc(cardnumber, \keyw{mk\_}(m1,m2,-,-)) ==
        atmc_digval(m1) * 10 + atmc_digval(m2) <= 12 \keyw{and}
        \keyw{len} cardnumber >= 8

  \keyw{functions}

    getCardnumber : atmc -> \keyw{seq1 of} digit
    getCardnumber (atmc) ==
      atmc.cardnumber

\keyw{end} ATMCard
\end{alltt}
Here the invariant on the type \texttt{atmc} states that expiry dates
must represent valid dates, and card numbers must be at least 8 digits
long. Note that since \texttt{digit} is not exported with the
\keyw{struct} keyword from the module \texttt{BankAccount}, we cannot
access the invariant for \texttt{digit} in module
\texttt{ATMCard}. However this notwithstanding, all values of type
\texttt{digit} manipulated in \texttt{ATMCard} must satisfy the
invariant. 

\end{description}

\section{Dynamic Link Modules}\label{sec:DLmodules}

Dynamic Link modules are used to describe the interface between
modules which are fully specified in VDM-SL and parts of the overall
system which are only available as C++ code. This facility enables
users to make use of existing C++ libraries while a specification is
being interpreted/debugged. The usage of this facility
is described in detail in \cite{DLMan-SCSK}. The general layout of a Dynamic Link
module is similar to an ordinary VDM-SL module. It has three parts: a
\emph{module declaration}, an \emph{interface section}, and an
optional \emph{library reference}. 

\begin{description}
\item[Syntax:]
  
The module declaration of a Dynamic Link module is simply the keywords
\keyw{dlmodule} followed by the name of the module. The interface
section of a Dynamic Link module is simpler than the interface section
for an ordinary module. The only kind of constructs which
can be imported into a Dynamic Link module are types. Such imported types can
be used in the signature of the values, functions and/or operations
which are exported from the module. Finally the library reference
(identified by the \Lop{uselib} keyword) is
used to identify the dynamically linked C++ library which must be
used by the interpreter in case a specification
which makes use of code from such a library is going to be interpreted.

The syntax for Dynamic Link modules is:
 
\Rule{dynamic link module}{
  \Lop{dlmodule}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link interface},\lfeed
  \OptPt{\Ruleref{use signature}},\lfeed
  \Lop{end}, \Ruleref{identifier}
  }

\Rule{dynamic link interface}{
  \OptPt{\Ruleref{dynamic link import definition list}}, \lfeed
  \Ruleref{dynamic link export definition}
  }

\Rule{use signature}{
   \Lop{uselib}, \Ruleref{text literal}
   }

\Rule{dynamic link import definition list}{
  \Lop{imports}, \lfeed
  \Ruleref{dynamic link import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{dynamic link import definition}}
  }

\Rule{dynamic link import definition}{
  \Lop{from}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link import types signatures}
  }

\Rule{dynamic link import types signatures}{
  \Lop{types}, \Ruleref{name}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{name}}, \OptPt{\Lit{;}}
  }
  
\Rule{dynamic link export definition}{
  \Lop{exports}, \lfeed
  \Ruleref{dynamic link export signature}, \lfeed
  \SeqPt{\Ruleref{dynamic link export signature}}
  }

\Rule{dynamic link export signature}{
  \Ruleref{values signature} \dsep
  \Ruleref{functions signature} \dsep
  \Ruleref{operations signature}
  }
  
\item[Semantics:] The semantics of the interface constructs is
     identical to the semantics of these parts for ordinary
     modules. The semantics of the use signature is given by the C++
     compiler which has been used to create the dynamically linked C++
     libraries. Thus, the C++ code referred to in the use signature is
     not provided with semantics directly at the VDM-SL level.
\item[Example:] The example presented here is used in
\cite{DLMan-SCSK}. The first module imports constructs from a {\tt MATH}
module and a {\tt CYLIO} module. Both of these other modules are
presented afterwards and both of them are Dynamic Link modules.

\begin{alltt}
\keyw{module} CYLINDER
  \keyw{imports}
    \keyw{from} MATH
        \keyw{functions}
          ExtSin : \keyw{real} -> \keyw{real}
        \keyw{values} 
          ExtPI : \keyw{real},

    \keyw{from} CYLIO
        \keyw{functions}
          ExtGetCylinder : () -> CircCyl
   
        \keyw{operations}
          ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()

   \keyw{exports}
     \keyw{types}  
         CircCyl  

  \keyw{definitions}
    \keyw{types}
        CircCyl :: rad    : \keyw{real}
                   height : \keyw{real}
                   slope  : \keyw{real}

    \keyw{functions}
        CircCylVol : CircCyl -> \keyw{real}
        CircCylVol(cyl) ==
          MATH`ExtPI * cyl.rad * cyl.rad * cyl.height * 
          MATH`ExtSin(cyl.slope)

    \keyw{operations}
        CircCyl : () ==> ()
        CircCyl() == ( \keyw{let} cyl = CYLIO`ExtGetCylinder() \keyw{in} 
                         \keyw{let} vol = CircCylVol(cyl) \keyw{in}
                            CYLIO`ExtShowCircCylVol(cyl, vol))
\keyw{end} CYLINDER
\end{alltt}

The {\tt MATH} module is defined as:

\begin{alltt}
\keyw{dlmodule} MATH
  \keyw{exports}
    \keyw{functions}
      ExtCos : \keyw{real} -> \keyw{real};
      ExtSin : \keyw{real} -> \keyw{real}  
      
   \keyw{values}   
      ExtPI : \keyw{real}
  
   \keyw{uselib}
      "libmath.so" 

\keyw{end} MATH
\end{alltt}

The {\tt CYLIO} module is defined as:

\begin{alltt}
\keyw{dlmodule} CYLIO
  \keyw{imports}
    \keyw{from} CYLINDER
      \keyw{types}
        CircCyl

   \keyw{exports}
     \keyw{functions}
       ExtGetCylinder : () -> CircCyl
   
     \keyw{operations}
       ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()

   \keyw{uselib}
      "libcylio.so"

\keyw{end} CYLIO
\end{alltt}

The way to use such modules with the VDM-SL Interpreter is described
in \cite{DLMan-SCSK}
\end{description}
#endif VDMSL

#ifdef VDMPP
\section{Trace Definitions}

In order to automate the testing process VDM++ contains a notation
enabling the expression of the traces that one would like to have
tested exhaustively. Such traces are used to express combinations of
sequences of operations that wish to be tested in all possible
combinations. In a sense this is similar to model checking limitations
except that this is done with real and not symbolic values. However,
errors in test cases are filtered away so other test cases with the
same prefix will be skipped automatically. 

\begin{description}
\item[Syntax:]
\Rule{traces definitions}{\Lop{traces},
   \SeqPt{\Ruleref{named trace}}
}

\Rule{named trace}{\Ruleref{identifier},
  \SeqPt{\Lit{/}, \Ruleref{identifier}},
  \Lit{:},\Ruleref{trace definition list}
}

\Rule{trace definition list}{
  \Ruleref{trace definition term}, 
  \SeqPt{\Lit{;}, \Ruleref{trace definition term}}
}

\Rule{trace definition term}{
  \Ruleref{trace definition} \dsep
  \Ruleref{trace definition term}, \Lit{|}, \Ruleref{trace definition}
}

\Rule{trace definition}{
  \Ruleref{trace core definition} \dsep
  \Ruleref{trace bindings}, \Ruleref{trace core definition} \dsep
  \Ruleref{trace core definition}, \Ruleref{trace repeat pattern} \dsep
  \Ruleref{trace bindings}, \Ruleref{trace core definition}, 
  \Ruleref{trace repeat pattern}
}

\Rule{trace core definition}{
  \Ruleref{trace apply expression} \dsep
  \Ruleref{trace bracketed expression}
}

\Rule{trace apply expression}{
  \Ruleref{identifier}, \Lit{.}, \Ruleref{identifier}, 
  \Lit{(}, \Ruleref{expression list}, \Lit{)}
}

\Rule{trace repeat pattern}{
  \Lit{*} \dsep 
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{\}} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{,} 
  \Ruleref{numeric literal}, \Lit{\}}
} 

\Rule{trace bracketed expression}{
  \Lit{(}, \Ruleref{trace definition list}, \Lit{)}
}

\Rule{trace bindings}{
  \Ruleref{trace binding}, \SeqPt{\Ruleref{trace binding}}
}

\Rule{trace binding}{
  \Lop{let}, \Ruleref{local definitions}, 
             \SeqPt{\Lit{,}, \Ruleref{local definition}}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{bind}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{bind}, \Lop{be}, \Lop{st}, \Ruleref{expression}, \Lop{in}
}

\item[Semantics:] Semantically the trace definitions provided in a
             class have no effect. These definitions are simply used
             to enhance testing of a VDM++ model using principles from
             combinatorial testing (also called all-pairs
             testing). So each trace definition can be considered as a
             regular expression describing the test sequences in which
             different operations should be executed to test the VDM++
             model. Inside the trace definitions, bindings may appear
             and for each possible such binding a particular test case
             can be automatically derived. So one trace definition
             expand into a set of test cases. In this sense a test
             case is a sequence of operation calls executed after each
             other. Between each test case the VDM++ model is
             initialised so they become entirely independent. From a
             static semantics perspective it is important to note that
             the expressions used inside trace definitions must be
             executed in the expansion process. This means that it
             cannot directly refer to instance variables, because
             these could be changed during the execution.

The different kinds of repeat patterns have the following meanings:
\begin{itemize}
\item  \Lit{*} means 0 to n occurences (n is tool specific). 
\item  \Lit{+} means 1 to n occurences (n is tool specific). 
\item  \Lit{?} means 0 or 1 occurences. 
\item  \Lit{\{}, n, \Lit{\}} means n occurences.
\item  \Lit{\{}, n, \Lit{,} m \Lit{\}} means between n and m occurences.
\end{itemize}

\item[Examples:] In an example like the one below test cases will be
generated in all possible combination starting with a call
of \texttt{Reset} followed by one to four \texttt{Push}es of values
onto the stack followed again by one to three \texttt{Pop}s from the stack. \\
\begin{alltt}
\keyw{class} Stack

  \keyw{instance variables}
    stack : \keyw{seq of int} := [];

  \keyw{operations}

    \keyw{public} Reset : () ==> ()
    Reset () ==
      stack := [];

    \keyw{public} Pop : () ==> \keyw{int}
    Pop() ==
      \keyw{def} res = \keyw{hd} stack \keyw{in}
        (stack := \keyw{tl} stack;
         \keyw{return} res)
    \keyw{pre} stack <> []
    \keyw{post} stack~ = [\keyw{RESULT}] ^ stack;

    \keyw{public} Push: \keyw{int} ==> ()
    Push(elem) ==
      stack := stack ^ [elem];

    \keyw{public} Top : () ==> \keyw{int}
    Top() ==
      \keyw{return} (\keyw{hd} stack);

\keyw{end} Stack
\keyw{class} UseStack

\keyw{instance variables}

  s : Stack := \keyw{new} Stack();

\keyw{traces}

  PushBeforePop : s.Reset(); (\keyw{let} x \keyw{in set} {1,2} \keyw{in} s.Push(x))\{1,4\}; 
                  s.Pop()\{1,3\}
 
\keyw{end} UseStack
\end{alltt}
\end{description}

#endif VDMPP
#ifdef VDMSL
\section{Differences between  VDM-SL
         and\\      ISO/VDM-SL}\label{diff}
#endif VDMSL
#ifdef VDMPP
\section{Differences between  VDM++
         and ISO /VDM-SL}\label{diff}
#endif VDMPP

This version of  \vdmslpp{\vdmsl}{\vdmpp} is based on 
the ISO/VDM-SL standard, but a few differences exist. These
differences are both syntactical and semantical, and are mainly due to
the extensions of the language and to requirements to make 
\vdmslpp{\vdmsl}{\vdmpp} constructs executable\footnote{The semantics
mentioned here is the semantics of the interpreter.}.

#ifdef VDMSL
The major difference between  {\vdmsl} and
ISO/VDM-SL is the availability of a structuring in  VDM-SL. This
causes some syntactical differences.

For the flat part of  VDM-SL, the following differences with ISO/VDM-SL
exist:
#endif VDMSL

#ifdef VDMPP
The major difference between  {\vdmpp} and ISO/VDM-SL is the
object-oriented and concurrent %and real-time 
extensions available in 
\vdmpp. This cause some syntactical differences.

First of all an  \vdmpp\ specification is composed by a set of
class definitions. Flat ISO/VDM-SL specifications are not
accepted. For the definitions part of  \vdmpp, the following differences
with ISO/VDM-SL exist:
#endif VDMPP

\begin{description}
\item[Syntactical differences:]\mbox{}\\
  \begin{itemize}
  
  \item Semicolon (``;'') is used in the standard as a separator
    between subsequent constructs (e.g., between function
    definitions).  \vdmslpp{\vdmsl}{\vdmpp} adds to this rule that
    an optional semicolon can be put after the last of such a sequence
    of constructs. This change apply to the following syntactic
    definitions (see appendix \ref{app-a}): \vdmslpp{{\em state
    definition},}{} {\em type definitions}, {\em values definitions},
    {\em function definitions}, {\em operation definitions}, {\em def
    expression}, {\em def statement}, and {\em block statement}.

  \item In explicit function and operation definitions it is possible
    to specify an optional post condition in 
    \vdmslpp{VDM-SL}{\vdmpp} (see section~\ref{functiondef} and
    section~\ref{op-def} or section~\ref{functiondef2} or
    section~\ref{op-def2}).

  \item The body of explicit function and operation definitions can be
    specified in a preliminary manner using the \vdmslpp{clause}{clauses
    \keyw{is subclass responsibility} and} \keyw{is not yet specified}.

#ifdef VDMPP
%  \item In function and operation definitions it is possible
%    to specify an optional time post condition in IFAD {\vdmpp}.
#endif VDMPP
    
  \item An extended form for explicit function and operation
    definitions has been included. The extension is to enable the
    function and operation definition to use a heading similar to that
    used for implicit definitions. This makes it easier first to write
    an implicit definition and then add an algorithmic part later
    on. In addition the result identifier type pair has been
    generalised to work with more than one identifier.

#ifdef VDMSL
  \item In a flat specification the keyword \keyw{definitions} is not used.
    This way, a flat specification can be distributed over several files.
    However, in a module, the definitions section must begin with the
    keyword \keyw{definitions} (see Section~\ref{flat}).

  \item  \vdmsl\ has been extended with the {\em specification statement}.
#endif VDMSL

  \item In an {\it if statement\/} the ``else'' part is optional (see
        section~\ref{condstmt} or section~\ref{condstmt2}).
        
  \item An empty set and an empty sequence can be used directly as
        patterns (see section~\ref{patterns} or section~\ref{patterns2}).
  \item ``map domain restrict to'' and ``map domain restrict by'' have
        a right grouping (see section~\ref{grouping}).
  \item The operator precedence ordering for map type constructors is
        different from the standard (see section~\ref{preceedence}).
#ifdef VDMPP
  \item In  \vdmpp\ tuple select, type judgement and
        precondition expressions have been added.
  \item In  \vdmpp\ atomic assignment statements have been added. 
  \item In  \vdmpp\ the {\em definitions} has been extended with
    {\em instance variable definitions}, 
    %{\em time variable definitions}, 
   {\em thread definitions} and {\em synchronization
    definitions}.

  \item In  \vdmpp\ the following expressions have been added:
    {\em new expression}, {\em self expression }, {\em isofbaseclass
    expression}, {\em 
    isofclass expression}, {\em samebaseclass expression}, {\em
    sameclass expression}, {\em act expression}, {\em fin expression},
    {\em active expression}, {\em req expression} and {\em waiting
    expression}.

  \item In  \vdmpp\ the following statements have been added: {\em
    specification statement}, {\em select statement}, {\em start
    statement} and {\em startlist statement}. % and {\em delay statement}.

  \item The \vdmsl\ state definition has been replaced by the \vdmpp\
    instance variables.
#endif VDMPP


  \end{itemize}
  
\item[Semantical differences (wrt.\ the interpreter):]\mbox{}\\[-3mm] 
  \begin{itemize}
  
  \item  \vdmslpp{\vdmsl}{\vdmpp} only operates with a
    conditional logic (see section~\ref{bool}).
    
#ifdef VDMSL
  \item The initialisation of a global state must be written in a
    special constructive way. Note that the state of a module is only
    initialised if at least one operation from that module is used
    (see section~\ref{statedef}).
#endif VDMSL

  \item In  \vdmslpp{\vdmsl}{\vdmpp}, {\it value definitions\/}
    which are mutually recursive cannot be executed and they must be
    ordered such that they are defined before they are used (see
    section~\ref{valuedef}).
    
  \item The local definitions in a {\it let statement\/} and a {\it
    let expression\/} cannot be recursively defined. Furthermore they
    must be ordered such that they are defined before they are used
    (see section~\ref{let-exp} and section~\ref{letstmt}).
    
  \item The numeric type \keyw{rat} in  \vdmslpp{\vdmsl}{\vdmpp}
    denotes the same type as the type \keyw{real} (see
    section~\ref{numeric}).
      
  \item The two forms of interpreting looseness which are used in
    ISO/VDM-SL are `underdeterminedness' and `nondeterminism'. In
    ISO/VDM-SL the looseness in operations is nondeterministic whereas
    it is underdetermined for functions. In 
    \vdmslpp{\vdmsl}{\vdmpp} the looseness in both operations and
    functions is underdetermined. This is, however, also in line with
    the standard because the interpreter simply corresponds to one of
    the possible models for a specification.

  \end{itemize}
\end{description}

\section{Static Semantics}\label{static}

VDM specifications that are syntactically correct according to the
syntax rules do not necessarily obey the
typing and scoping rules of the language.
The well-formedness of a
VDM specification can be checked by the {\em static semantics checker}.
In the Toolbox such a static semantics checker (for programming
languages this is normally referred to as a type checker) is also
present.

In general, it is not statically decidable whether a given VDM
specification is well-formed or not.  The static semantics for
\vdmslpp{\vdmsl}{\vdmpp}\ differs from the static semantics of other
languages in the sense that it only rejects specifications which are
definitely not well-formed, and only accepts specifications which are
definitely well-formed.  Thus, the static semantics for
\vdmslpp{\vdmsl}{\vdmpp}\ attaches a {\em well-formedness grade} to a
VDM specification.  Such a well-formedness grade indicates whether a
specification is definitely well-formed, definitely not-well-formed, or
possibly well-formed.

In the Toolbox this means that the static semantics checker can be
called for either possible correctness or definite correctness.
However, it should be noted that only very simple specifications will
be able to pass the definite well-formed\-ness check. Thus, for
practical use the possible well-formedness is most useful.

The difference between a possibly well-formedness check and a definite
well-formedness check can be illustrated by the following
fragment of a VDM specification:
\begin{alltt}
   \keyw{if} a = \keyw{true} 
   \keyw{then} a + 1 
   \keyw{else} \keyw{not} a
\end{alltt}
where {\tt a} has the type {\tt \keyw{nat} | \keyw{bool}} (the union
type of
\keyw{nat} and
\keyw{bool}). The reader can easily see that this expression is
ill-formed if {\tt a} is equal to \keyw{true} because then it will be
impossible to add one to {\tt a}. However, since such expressions can
be arbitrarily complex this can in general not be checked statically. In
this particular example possible well-formedness will yield
\keyw{true} while definite well-formedness will yield \keyw{false}.

#ifdef VDMPP
\section{Scope Conflicts}
\label{sec:nameconflicts}

A name conflict occurs when two constructs with the same name
(i.e.\ identified by the same {\em identifier}) are visible in the
same scope.  This is also true when two such constructs are not in the
same language category, e.g.\ a type and an operation with the same name.
A specification with a naming conflict is considered to be erroneous.

In case both constructs are defined in the same class, then the conflict can
not be resolved other than by renaming one of the constructs.
If they are defined in different classes, then the conflict can be resolved
through {\em name qualification}, i.e.\ one of the constructs is
preceded by the name of the class in which it is defined and
a \Lit{`} (backquote) separator, so e.g.
  \begin{alltt}
    types
      Queue = seq of ComplexTypes`RealNumber
  \end{alltt}
name qualification is used to define the type {\tt Queue} in terms of a
type {\tt RealNumber} defined in class {\tt ComplexTypes}.

Note that only name qualification in which a {\em class name} is used to
resolve the naming conflict uses the \Lit{`} symbol as a separator; a
\Lit{.} (dot) symbol is used to `qualify' ordinary values and/or objects.
E.g. the notation
  \begin{alltt}
    o.i
  \end{alltt}
may refer to the instance variable {\tt i} of an object, or to the
field {\tt i} of a compound value (record) {\tt o}.
#endif VDMPP


\newpage

\bibliographystyle{iptes}
#ifdef VDMSL
\bibliography{ifad}
#endif
#ifdef VDMPP
\bibliography{ifad}
#endif

\newpage
\appendix

% Do not delete next line:
% Start Of Rules

#ifdef VDMSL
\section{The  VDM-SL Syntax} \label{app-a}
This appendix specifies the complete syntax for 
VDM-SL.
#endif VDMSL
#ifdef VDMPP
\section{The  VDM++ Syntax} \label{app-a}
This appendix specifies the complete syntax for 
\vdmpp.
#endif VDMPP
#ifdef VDMSL
\subsection{Document}

\Ruledef{document}{
  \Ruleref{any module}, \SeqPt{\Ruleref{any module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{any module}{
  \Ruleref{module} \dsep
  \Ruleref{dynamic link module}
  }

\subsection{Modules}

This entire subsection is not present in the current version of the
VDM-SL standard. \marginpar{\hspace*{-3mm}\fbox{{\footnotesize Non standard}}}

\Ruledef{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

\Ruledef{interface}{
  \OptPt{\Ruleref{import definition list}}, \lfeed
  \Ruleref{export definition}
  }

\Ruledef{import definition list}{
  \Lop{imports}, \Ruleref{import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{import definition}}
  }

\Ruledef{import definition}{
  \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
  }

\Ruledef{import module signature}{
  \Lop{all} \dsep
  \Ruleref{import signature}, \SeqPt{\Ruleref{import signature}}
  }

\Ruledef{import signature}{
  \Ruleref{import types signature} \dsep
  \Ruleref{import values signature} \dsep
  \Ruleref{import functions signature} \dsep
  \Ruleref{import operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{import types signature}{
  \Lop{types}, \Ruleref{type import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
  }

\Ruledef{type import}{
  \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
  \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import values signature}{
  \Lop{values}, \Ruleref{value import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
  }

\Ruledef{value import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import functions signature}{
  \Lop{functions}, \Ruleref{function import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
  }

\Ruledef{function import}{
  \Ruleref{name}, \OptPt{\OptPt{type variable list}, 
  \Lit{:}, \Ruleref{function type}}, \lfeed
  \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import operations signature}{
  \Lop{operations}, \Ruleref{operation import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{export definition}{
  \Lop{exports}, \Ruleref{export module signature}
  }

\Ruledef{export module signature}{
  \Lop{all} \dsep
  \Ruleref{export signature}, \lfeed
  \SeqPt{\Ruleref{export signature}}
  }

\Ruledef{export signature}{
  \Ruleref{export types signature} \dsep
  \Ruleref{values signature} \dsep
  \Ruleref{export functions signature} \dsep
  \Ruleref{operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{export types signature}{
  \Lop{types}, \Ruleref{type export}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
  }

\Ruledef{type export}{
  \OptPt{\Lop{struct}}, \Ruleref{name}
  }

\Ruledef{values signature}{
  \Lop{values}, \Ruleref{value signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{value signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{export functions signature}{
  \Lop{functions} \Ruleref{function export}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function export}}
  }

\Ruledef{function export}{
  \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:}, \lfeed
  \Ruleref{function type}
  }
  
\Ruledef{functions signature}{
  \Lop{functions} \Ruleref{function signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{function signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{function type}
  }

\Ruledef{operations signature}{
  \Lop{operations} \Ruleref{operation signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
  }
  
%\Ruledef{state signature}{
%  \Lop{state}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
%  }
 
\Ruledef{dynamic link module}{
  \Lop{dlmodule}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link interface},\lfeed
  \OptPt{\Ruleref{use signature}},\lfeed
  \Lop{end}, \Ruleref{identifier}
  }

\Ruledef{dynamic link interface}{
  \OptPt{\Ruleref{dynamic link import definition list}}, \lfeed
  \Ruleref{dynamic link export definition}
  }

\Ruledef{use signature}{
   \Lop{uselib}, \Ruleref{text literal}
   }

\Ruledef{dynamic link import definition list}{
  \Lop{imports}, \lfeed
  \Ruleref{dynamic link import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{dynamic link import definition}}
  }

\Ruledef{dynamic link import definition}{
  \Lop{from}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link import types signatures}
  }

\Ruledef{dynamic link import types signatures}{
  \Lop{types}, \Ruleref{name}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{name}}, \OptPt{\Lit{;}}
  }

\Ruledef{dynamic link export definition}{
  \Lop{exports}, \lfeed
  \Ruleref{dynamic link export signature}, \lfeed
  \SeqPt{\Ruleref{dynamic link export signature}}
  }

\Ruledef{dynamic link export signature}{
  \Ruleref{values signature} \dsep
  \Ruleref{functions signature} \dsep
  \Ruleref{operations signature}
  }
#endif VDMSL
#ifdef VDMPP
\subsection{Document}

\Ruledef{document}{
   \Ruleref{class}
#ifdef VICEMAN
   \dsepl\ \Ruleref{system}
#endif VICEMAN
   , \SeqPt{\Ruleref{class}
#ifdef VICEMAN
   \dsepl\ \Ruleref{system}
#endif VICEMAN
   }
}

#ifdef VICEMAN
\subsection{System}
\Ruledef{system}{
  \Lop{system}, \Ruleref{identifier},  \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}
#endif VICEMAN

\subsection{Classes}

\Ruledef{class}{
  \Lop{class}, \Ruleref{identifier}, \OptPt{\Ruleref{inheritance clause}}, \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}

\Ruledef{inheritance clause}{
      \Lop{is subclass of}, \Ruleref{identifier}, \Lit{,}, \SeqPt{\Ruleref{identifier}}
      }
#endif VDMPP
\subsection{Definitions}

#ifdef VDMPP
\Ruledef{class body}{
  \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }
#endif VDMPP 

#ifdef VDMSL
\Ruledef{module body}{
  \Lop{definitions}, \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }
#endif VDMSL

\Ruledef{definition block}{
  \Ruleref{type definitions} \dsep
#ifdef VDMSL
  \Ruleref{state definition} \dsep
#endif VDMSL
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions}
#ifdef VDMPP
  \dsep
  \Ruleref{instance variable definitions} \dsep
%  \Ruleref{time variable definitions} \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions} \dsep
  \Ruleref{traces definitions}
#endif VDMPP
  }

\subsubsection{Type Definitions}
\label{mathCSTypeDefs}

\Ruledef{type definitions}{
  \Lop{types}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access type definition}}%
                                     {\Ruleref{type definition}}
         , \lfeed
         \SeqPt{\Lit{;}, 
               \ifthenelse{\boolean{VDMpp}}{\Ruleref{access type definition}}%
                                           {\Ruleref{type definition}}}, 
         \OptPt{\Lit{;}}
        }
  }%
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{access type definition}{
     (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed 
     \Ruleref{type definition}
    }
  }{}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Ruledef{type definition}{
  \Ruleref{identifier}, \Lit{=}, \Ruleref{type}, \OptPt{\Ruleref{invariant}} \dsep
  \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}, \OptPt{\Ruleref{invariant}}
  }

\Ruledef{type}{
  \Ruleref{bracketed type} \dsep
  \Ruleref{basic type} \dsep
  \Ruleref{quote type} \dsep
  \Ruleref{composite type} \dsep
  \Ruleref{union type} \dsep
  \Ruleref{product type} \dsep
  \Ruleref{optional type} \dsep
  \Ruleref{set type} \dsep
  \Ruleref{seq type} \dsep
  \Ruleref{map type} \dsep
  \Ruleref{partial function type} \dsep
  \Ruleref{type name} \dsep
  \Ruleref{type variable}
  }

\Ruledef{bracketed type}{
  \Lit{(}, \Ruleref{type}, \Lit{)}
  }

\Ruledef{basic type}{
  \Lop{bool} \dsepl
  \Lop{nat} \dsepl
  \Lop{nat1} \dsepl
  \Lop{int} \dsepl
  \Lop{rat} \dsep
  \Lop{real} \dsepl
  \Lop{char} \dsepl
  \Lop{token} 
  }

\Ruledef{quote type}{
  \Ruleref{quote literal}
  }

\Ruledef{composite type}{
  \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \Lop{end}
  }

\Ruledef{field list}{
  \SeqPt{\Ruleref{field}}
  }

\Ruledef{field}{
  \OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type} \dsep
  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }

\Ruledef{union type}{
  \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
  }

\Ruledef{product type}{
  \Ruleref{type}, \Lit{*}, \Ruleref{type}, \SeqPt{\Lit{*}, \Ruleref{type}}
  }

\Ruledef{optional type}{
  \Lit{[}, \Ruleref{type}, \Lit{]}
  }

\Ruledef{set type}{
  \Lop{set of}, \Ruleref{type}
  }

\Ruledef{seq type}{
  \Ruleref{seq0 type} \dsep
  \Ruleref{seq1 type}
  }

\Ruledef{seq0 type}{
  \Lop{seq of}, \Ruleref{type}
  }

\Ruledef{seq1 type}{
  \Lop{seq1 of}, \Ruleref{type}
  }

\Ruledef{map type}{
  \Ruleref{general map type} \dsep
  \Ruleref{injective map type}
  }

\Ruledef{general map type}{
  \Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{injective map type}{
  \Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Ruledef{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Ruledef{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Ruledef{discretionary type}{
  \Ruleref{type} \dsep
  \Lit{(}, \Lit{)}
  }

\Ruledef{type name}{
  \Ruleref{name}
  }

\Ruledef{type variable}{
  \Ruleref{type variable identifier}
  }

#ifdef VDMPP
\Ruledef{invariant}{
  \Lop{inv}, \Ruleref{invariant initial function}
  }

\Ruledef{invariant initial function}{
  \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}
  }
#endif VDMPP

#ifdef VDMSL
\subsubsection{The State Definition}

\Ruledef{state definition}{
  \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
  \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
  }\nonstandard{1}
\Ruledef{invariant}{
  \Lop{inv}, \Ruleref{invariant initial function}
  }

\Ruledef{initialisation}{
  \Lop{init}, \Ruleref{invariant initial function}
  }

\Ruledef{invariant initial function}{
  \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}
  }
#endif VDMSL

\subsubsection{Value Definitions}

\Ruledef{value definitions}{
  \Lop{values}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                     {\Ruleref{value definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                            {\Ruleref{value definition}}
               }, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed 
         \Ruleref{value definition}
    }}{}

\Ruledef{value definition}{ 
  \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
  }
  \nonstandard{1}

\subsubsection{Function Definitions}\label{functiondef2}

\Ruledef{function definitions}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}}, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Rule{access function definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{function definition}
  }}{}

\Ruledef{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }
  \nonstandard{1}

\Ruledef{explicit function definition}{
  \Ruleref{identifier},
  \OptPt{\Ruleref{type variable list}},
  \Lit{:}, \lfeed
  \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}
    , \lfeed \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{name}}
  }
  \nonstandard{1}

\Ruledef{implicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed 
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
  }

%This should be removed and exchanged with a more general solution.
#ifdef VDMSL
\setlength{\nonstandlen}{-2\baselineskip}\addtolength{\nonstandlen}{-.8ex}

\vspace{\nonstandlen}\mbox{}\marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{{\fbox{{\footnotesize Non standard}}}}}
\Ruledef{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}
#endif VDMSL
#ifdef VDMPP
\Ruledef{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}
#endif VDMPP

\Ruledef{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }             

\Ruledef{identifier type pair}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Ruledef{identifier type pair list}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{identifier}, \Lit{:}, \Ruleref{type}}
}

\Ruledef{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Ruledef{parameters list}{
  \Ruleref{parameters}, \SeqPt{\Ruleref{parameters}}
  }

\Ruledef{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Ruledef{function body}{
  \Ruleref{expression} \dsep
#ifdef VDMPP
  \Lop{is not yet specified} \dsep \Lop{is subclass responsibility}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified} 
#endif VDMSL
  } \nonstandard{1}

\subsubsection{Operation Definitions}\label{op-def2}

\Ruledef{operation definitions}{
  \Lop{operations}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                     {\Ruleref{operation definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                     {\Ruleref{operation definition}}
               }, 
         \OptPt{\Lit{;}}
        }
  }\nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{access operation definition}{(
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep\  
     (
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{operation definition}
    }}{}

\Ruledef{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }\nonstandard{1}

\Ruledef{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
#ifdef VDMPP
  , \lfeed
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}
#endif VDMPP
  }\nobreak\nonstandard{1}

\Ruledef{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Ruledef{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
#ifdef VDMPP
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{exceptions}}
  }

\Ruledef{extended explicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
#ifdef VDMPP
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{exceptions}}
}\nonstandard{7}

\Ruledef{operation type}{
  \Ruleref{discretionary type}, \Lit{==>}, \Ruleref{discretionary type}
  }

\Ruledef{operation body}{
  \Ruleref{statement} \dsep 
#ifdef VDMPP
  \Lop{is not yet specified} \dsep \Lop{is subclass responsibility}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified}
#endif VDMSL
  } \nonstandard{1}

\Ruledef{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Ruledef{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Ruledef{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Ruledef{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Ruledef{error list}{
  \Ruleref{error}, \SeqPt{error}
  }

\Ruledef{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }

#ifdef VDMPP
\subsubsection{Instance Variable Definitions}

\Ruledef{instance variable definitions}{
  \Lop{instance}, \Lop{variables}, \lfeed
  \OptPt{\Ruleref{instance variable definition}, \lfeed
         \SeqPt{\Lit{;}, 
               \Ruleref{instance variable definition}
               }
        }
  }

\Ruledef{instance variable definition}{
  \Ruleref{access assignment definition} \dsep
  \Ruleref{invariant definition}
  }

  \Rule{access assignment definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
    \Ruleref{assignment definition}
  }

\Ruledef{invariant definition}{
  \Lop{inv}, \Ruleref{expression}
  }

%\Ruledef{init statement}{
%  \Lop{init}, \Ruleref{statement}
%  }

%\subsubsection{Time Variable Definitions}
%
%\Ruledef{time variable definitions}{
%      \Lop{time}, \Lop{variables},
%      \Ruleref{time spec}, \SeqPt{\Lit{;}, \Ruleref{time spec}}, \OptPt{\Lop{;}}}
%\Ruledef{time spec}{
%      \Ruleref{time var decl} \dsep \Ruleref{assumption} \dsep \Ruleref{effect}}
%\Ruledef{time var decl}{
%      \OptPt{\Lop{input}}, \Ruleref{name list}, \Lit{:}, \Ruleref{type}}
%\Ruledef{assumption}{
%      \Lop{assumption}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}
%\Ruledef{effect}{
%      \Lop{effect}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}
      
\subsubsection{Synchronization Definitions}

\Ruledef{synchronization definitions}{
      \Lop{sync}, \OptPt{\Ruleref{synchronization}}}

\Ruledef{synchronization}{
      \Ruleref{permission predicates} %\dsep
%      \Ruleref{trace structures}
}

\Ruledef{permission predicates}{
      \Ruleref{permission predicate},\lfeed
      \SeqPt{\Lit{;}, \Ruleref{permission predicate}}}
\Ruledef{permission predicate}{
      \Lop{per}, \Ruleref{name},
      \Lop{=$>$}, \Ruleref{expression} \dsep
      \Ruleref{mutex predicate}}

\Ruledef{mutex predicate}{
       \Lop{mutex}, \Lit{(}, \Lop{all}, \Lit{)}  \dsep
       \Lop{mutex}, \Lit{(}, \Ruleref{name list} \Lit{)}}

% \Ruledef{trace structures}{
%       \SeqPt{\Ruleref{subtrace structure}, \Lit{;}},
%       \Ruleref{general trace structure}}
% \Ruledef{subtrace structure}{
%       \Lop{subtrace}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}
% \Ruledef{general trace structure}{
%       \Lop{general}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}

% \Ruledef{trace structure}{
%      \Ruleref{identifier} \dsep
%      \Lit{$<$}, \Ruleref{trace set}, \Lit{,}, \Ruleref{alphabet}, \Lit{$>$} \dsep
%      \Lop{pref}, \Lit{(}, \Ruleref{trace structure}, \Lit{)} \dsep
%      \Lop{del}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{w\_}, \Ruleref{trace structure} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{sync}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{{qsync}}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \lfeed
%      \Lit{,}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{**}, \Ruleref{alphabet}}
% \Ruledef{alphabet}{
%       \Lit{\{}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}, \Lit{\}} \dsep
%       \Lop{a\_}, \Ruleref{trace structure}}

% \Ruledef{trace set}{
%      \Ruleref{trace expression} \dsepl
%      \Ruleref{alphabet}, \Lit{$\ast$} \dsepl
%      \Lop{t\_}, \Ruleref{trace structure}}
% \Ruledef{trace expression}{
%       \Ruleref{term}, \SeqPt{\Lit{;}, \Ruleref{term}}}
% \Ruledef{term}{
%       \Ruleref{cterm} \dsepl \Ruleref{cterm}, \Lit{+} \dsepl \Ruleref{cterm}, \Lit{*}}
% \Ruledef{cterm}{
%       \Lit{(}, \Ruleref{trace expression}, \Lit{)} \dsepl \Ruleref{name}}

\subsubsection{Thread Definitions}

\Ruledef{thread definitions}{ \Lop{thread},
    \OptPt{\Ruleref{thread definition}} } 

\Rule{thread definition}{
#ifdef VICEMAN
    \Ruleref{periodic thread definition} \dsep 
#endif VICEMAN
    \Ruleref{procedural thread definition} }

#ifdef VICEMAN
\Ruledef{periodic thread definition}{
    \Ruleref{periodic obligation} }
  
\Ruledef{periodic obligation}{
  \Lop{periodic},\Lit{(}, \Ruleref{numeral},
  \Ruleref{numeral}, \Ruleref{numeral}, \lfeed \Ruleref{numeral}, 
  \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
}
#endif VICEMAN
   
\Ruledef{procedural thread definition}{
      \Ruleref{statement}}

\subsubsection{Trace Definitions}

\Ruledef{traces definitions}{\Lop{traces},
   \SeqPt{\Ruleref{named trace}}
}

\Ruledef{named trace}{\Ruleref{identifier},
  \SeqPt{\Lit{/}, \Ruleref{identifier}},
  \Lit{:},\Ruleref{trace definition list}
}

\Ruledef{trace definition list}{
  \Ruleref{trace definition term}, 
  \SeqPt{\Lit{;}, \Ruleref{trace definition term}}
}

\Ruledef{trace definition term}{
  \Ruleref{trace definition} \dsep
  \Ruleref{trace definition term}, \Lit{|}, \Ruleref{trace definition}
}

\Ruledef{trace definition}{
  \Ruleref{trace core definition} \dsep
  \Ruleref{trace bindings}, \Ruleref{trace core definition} \dsep
  \Ruleref{trace core definition}, \Ruleref{trace repeat pattern} \dsep
  \Ruleref{trace bindings}, \Ruleref{trace core definition}, 
  \Ruleref{trace repeat pattern}
}

\Ruledef{trace core definition}{
  \Ruleref{trace apply expression} \dsep
  \Ruleref{trace bracketed expression}
}

\Ruledef{trace apply expression}{
  \Ruleref{identifier}, \Lit{.}, \Ruleref{identifier}, 
  \Lit{(}, \Ruleref{expression list}, \Lit{)}
}

\Ruledef{trace repeat pattern}{
  \Lit{*} \dsep 
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{\}} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{,} 
  \Ruleref{numeric literal}, \Lit{\}}
} 

\Ruledef{trace bracketed expression}{
  \Lit{(}, \Ruleref{trace definition list}, \Lit{)}
}

\Ruledef{trace bindings}{
  \Ruleref{trace binding}, \SeqPt{\Ruleref{trace binding}}
}

\Ruledef{trace binding}{
  \Lop{let}, \Ruleref{local definitions}, 
             \SeqPt{\Lit{,}, \Ruleref{local definition}}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{bind}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{bind}, \Lop{be}, \Lop{st}, \Ruleref{expression}, \Lop{in}
}

#endif VDMPP

\subsection{Expressions}

\Ruledef{expression list}{
  \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
  }

\Ruledef{expression}{
  \Ruleref{bracketed expression} \dsep
  \Ruleref{let expression} \dsep
  \Ruleref{let be expression} \dsep
  \Ruleref{def expression} \dsep
  \Ruleref{if expression} \dsep
  \Ruleref{cases expression} \dsep
  \Ruleref{unary expression} \dsep
  \Ruleref{binary expression} \dsep
  \Ruleref{quantified expression} \dsep
  \Ruleref{iota expression} \dsep
  \Ruleref{set enumeration} \dsep
  \Ruleref{set comprehension} \dsep
  \Ruleref{set range expression} \dsep
  \Ruleref{sequence enumeration} \dsep
  \Ruleref{sequence comprehension} \dsep
  \Ruleref{subsequence} \dsep
  \Ruleref{map enumeration} \dsep
  \Ruleref{map comprehension} \dsep
  \Ruleref{tuple constructor} \dsep
  \Ruleref{record constructor} \dsep 
  \Ruleref{record modifier}  \dsep
  \Ruleref{apply} \dsep
  \Ruleref{field select} \dsep
  \Ruleref{tuple select} \dsep
  \Ruleref{function type instantiation} \dsep
  \Ruleref{lambda expression} \dsep
#ifdef VDMPP
  \Ruleref{new expression} \dsep
  \Ruleref{self expression} \dsep
  \Ruleref{threadid expression} \dsep
#endif VDMPP
  \Ruleref{general is expression} \dsep
  \Ruleref{undefined expression} \dsep
#ifdef VDMSL
  \Ruleref{precondition expression} \dsep
#endif VDMSL
#ifdef VDMPP
  \Ruleref{isofbaseclass expression} \dsep
  \Ruleref{isofclass expression} \dsep
  \Ruleref{samebaseclass expression}  \dsep
  \Ruleref{sameclass expression} \dsep
  \Ruleref{act expression} \dsep
  \Ruleref{fin expression} \dsep
  \Ruleref{active expression} \dsep
  \Ruleref{req expression} \dsep
  \Ruleref{waiting expression} \dsep
#endif VDMPP
#ifdef VICEMAN
  \Ruleref{time expression} \dsep
#endif VICEMAN
  \Ruleref{name} \dsep
  \Ruleref{old name}  \dsep
  \Ruleref{symbolic literal}
}
\nonstandard{4}

\subsubsection{Bracketed Expressions}

\Ruledef{bracketed expression}{
  \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\subsubsection{Local Binding Expressions}

\Ruledef{let expression}{
  \Lop{let}, \Ruleref{local definition},
   \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{expression}
  }

\Ruledef{let be expression}{
  \Lop{let}, \Ruleref{bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{expression}
  }

\Ruledef{def expression}{
  \Lop{def}, 
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  }
  \nonstandard{2}

\subsubsection{Conditional Expressions}

\Ruledef{if expression}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
  \SeqPt{\Ruleref{elseif expression}}, \lfeed
  \Lop{else}, \Ruleref{expression}
  }

\Ruledef{elseif expression}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
  }

\Ruledef{cases expression}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:},\lfeed 
  \Ruleref{cases expression alternatives}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
  }

\Ruledef{cases expression alternatives}{
  \Ruleref{cases expression alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
  }

\Ruledef{cases expression alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
  }

\Ruledef{others expression}{
  \Lop{others}, \Lit{->}, \Ruleref{expression}
  }

\subsubsection{Unary Expressions}

\Ruledef{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Ruledef{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

\Ruledef{unary operator}{
  \Ruleref{unary plus} \dsep
  \Ruleref{unary minus} \dsep
  \Ruleref{arithmetic abs} \dsep
  \Ruleref{floor} \dsep
  \Ruleref{not} \dsep
  \Ruleref{set cardinality} \dsep
  \Ruleref{finite power set} \dsep
  \Ruleref{distributed set union} \dsep
  \Ruleref{distributed set intersection} \dsep
  \Ruleref{sequence head} \dsep
  \Ruleref{sequence tail} \dsep
  \Ruleref{sequence length} \dsep
  \Ruleref{sequence elements} \dsep
  \Ruleref{sequence indices} \dsep
  \Ruleref{distributed sequence concatenation} \dsep
  \Ruleref{map domain} \dsep
  \Ruleref{map range} \dsep
  \Ruleref{distributed map merge}
  }

\Ruledef{unary plus}{
  \Lit{+}
  }

\Ruledef{unary minus}{
  \Lit{-}
  }

\Ruledef{arithmetic abs}{
  \Lop{abs}
  }

\Ruledef{floor}{
  \Lop{floor}
  }

\Ruledef{not}{
  \Lop{not}
  }

\Ruledef{set cardinality}{
  \Lop{card}
  }

\Ruledef{finite power set}{
  \Lop{power}
  }

\Ruledef{distributed set union}{
  \Lop{dunion}
  }

\Ruledef{distributed set intersection}{
  \Lop{dinter}
  }

\Ruledef{sequence head}{
  \Lop{hd}
  }

\Ruledef{sequence tail}{
  \Lop{tl}
  }

\Ruledef{sequence length}{
  \Lop{len}
  }

\Ruledef{sequence elements}{
  \Lop{elems}
  }

\Ruledef{sequence indices}{
  \Lop{inds}
  }

\Ruledef{distributed sequence concatenation}{
  \Lop{conc}
  }

\Ruledef{map domain}{
  \Lop{dom}
  }

\Ruledef{map range}{
  \Lop{rng}
  }

\Ruledef{distributed map merge}{
  \Lop{merge}
  }

\Ruledef{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

\subsubsection{Binary Expressions}

\Ruledef{binary expression}{
  \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}
  }

\Ruledef{binary operator}{
  \Ruleref{arithmetic plus} \dsep
  \Ruleref{arithmetic minus} \dsep
  \Ruleref{arithmetic multiplication} \dsep
  \Ruleref{arithmetic divide} \dsep
  \Ruleref{arithmetic integer division} \dsep
  \Ruleref{arithmetic rem} \dsep
  \Ruleref{arithmetic mod} \dsep
  \Ruleref{less than} \dsep
  \Ruleref{less than or equal} \dsep
  \Ruleref{greater than} \dsep
  \Ruleref{greater than or equal} \dsep
  \Ruleref{equal} \dsep
  \Ruleref{not equal} \dsep
  \Ruleref{or} \dsep
  \Ruleref{and} \dsep
  \Ruleref{imply} \dsep
  \Ruleref{logical equivalence} \dsep
  \Ruleref{in set} \dsep
  \Ruleref{not in set} \dsep
  \Ruleref{subset} \dsep
  \Ruleref{proper subset} \dsep
  \Ruleref{set union} \dsep
  \Ruleref{set difference} \dsep
  \Ruleref{set intersection} \dsep
  \Ruleref{sequence concatenate} \dsep
  \Ruleref{map or sequence modify} \dsep
  \Ruleref{map merge} \dsep
  \Ruleref{map domain restrict to} \dsep
  \Ruleref{map domain restrict by} \dsep
  \Ruleref{map range restrict to} \dsep
  \Ruleref{map range restrict by} \dsep
  \Ruleref{composition} \dsep
  \Ruleref{iterate} 
}

\Ruledef{arithmetic plus}{
  \Lit{+}
  }

\Ruledef{arithmetic minus}{
  \Lit{-}
  }

\Ruledef{arithmetic multiplication}{
  \Lit{*}
  }

\Ruledef{arithmetic divide}{
  \Lit{/}
  }

\Ruledef{arithmetic integer division}{
  \Lop{div}
  }

\Ruledef{arithmetic rem}{
  \Lop{rem}
  }

\Ruledef{arithmetic mod}{
  \Lop{mod}
  }

\Ruledef{less than}{
  \Lit{<}
  }

\Ruledef{less than or equal}{
  \Lit{<=}
  }

\Ruledef{greater than}{
  \Lit{>}
  }

\Ruledef{greater than or equal}{
  \Lit{>=}
  }

\Ruledef{equal}{
  \Lit{=}
  }

\Ruledef{not equal}{
  \Lit{<>}
  }

%#ifdef VDMPP
%\Ruledef{approx}{
%  \Lop{\~{}=}
%}
%#endif VDMPP
\Ruledef{or}{
  \Lop{or}
  }

\Ruledef{and}{
  \Lop{and}
  }

\Ruledef{imply}{
  \Lit{=>}
  }

\Ruledef{logical equivalence}{
  \Lit{<=>}
  }

\Ruledef{in set}{
  \Lop{in set}
  }

\Ruledef{not in set}{
  \Lop{not in set}
  }

\Ruledef{subset}{
  \Lop{subset}
  }

\Ruledef{proper subset}{
  \Lop{psubset}
  }

\Ruledef{set union}{
  \Lop{union}
  }

\Ruledef{set difference}{
  \Lit{\char'134}
  }

\Ruledef{set intersection}{
  \Lop{inter}
  }

\Ruledef{sequence concatenate}{
  \Lit{\char'136}
  }

\Ruledef{map or sequence modify}{
  \Lit{++}
  }

\Ruledef{map merge}{
  \Lop{munion}
  }

\Ruledef{map domain restrict to}{
  \Lit{<:}
  }

\Ruledef{map domain restrict by}{
  \Lit{<-:}
  }

\Ruledef{map range restrict to}{
  \Lit{:>}
  }

\Ruledef{map range restrict by}{
  \Lit{:->}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\subsubsection{Quantified Expressions}

\Ruledef{quantified expression}{
  \Ruleref{all expression} \dsep
  \Ruleref{exists expression} \dsep
  \Ruleref{exists unique expression}
  }

\Ruledef{all expression}{
  \Lop{forall}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists expression}{
  \Lop{exists}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists unique expression}{
  \Lop{exists1}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsubsection{The Iota Expression}

\Ruledef{iota expression}{
  \Lop{iota}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsubsection{Set Expressions}

\Ruledef{set enumeration}{
  \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
  }

\Ruledef{set comprehension}{
  \Lit{\{}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\Ruledef{set range expression}{
  \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range}, \Lit{,},
  \lfeed
  \Ruleref{expression},
  \Lit{\}}
  }

\subsubsection{Sequence Expressions}

\Ruledef{sequence enumeration}{
  \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
  }

\Ruledef{sequence comprehension}{
  \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{set bind}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{]}
  }

\Ruledef{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,},
  \Lit{\Range}, \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)} 
  }

\subsubsection{Map Expressions}

\Ruledef{map enumeration}{
  \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
  \Lit{\{}, \Lit{|->}, \Lit{\}}
  }

\Ruledef{maplet}{
  \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
  }

\Ruledef{map comprehension}{
  \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\subsubsection{The Tuple Constructor Expression}

\Ruledef{tuple constructor}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
  }

\subsubsection{Record Expressions}

\Ruledef{record constructor}{
  \Lop{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{record modifier}{
  \Lit{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
  \Ruleref{record modification}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{record modification}}, \Lit{)}
  }

\Ruledef{record modification}{
  \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
  }

\subsubsection{Apply Expressions}

\Ruledef{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Ruledef{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{tuple select}{
  \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
  }

\Ruledef{function type instantiation}{
  \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }
  
\subsubsection{The Lambda Expression}

\Ruledef{lambda expression}{
  \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{The narrow Expression}

\Ruledef{narrow expression}{
  \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)} 
  }

#ifdef VDMPP
\subsubsection{The New Expression}

  \Ruledef{new expression}{
    \Lop{new}, \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\subsubsection{The Self Expression}
  \Ruledef{self expression}{
    \Lop{self}
  }

\subsubsection{The Threadid Expression}
  \Ruledef{threadid expression}{
    \Lop{threadid}
  }
#endif VDMPP

\subsubsection{The Is Expression}

\Ruledef{general is expression}{
  \Ruleref{is expression} \dsep
  \Ruleref{type judgement}
  }

\Ruledef{is expression}{
  \Lit{\keyw{is}\_},\nmk \Ruleref{name}, \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
  \Ruleref{is basic type}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{type judgement}{
  \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\subsubsection{The Undefined Expression}

\Ruledef{undefined expression}{
  \Lop{undefined}
  }
  \nonstandard{1}

\subsubsection{The Precondition Expression}

\Ruledef{pre-condition expression}{
  \Lop{pre\_}, \Lit{(}, \Ruleref{expression}, \lfeed
                        \OptPt{\SeqPt{\Lit{,}, \Ruleref{expression}}},
               \Lit{)}
  }

#ifdef VDMPP
\subsubsection{Base Class Membership}

\Ruledef{isofbaseclass expression}{
      \Lop{isofbaseclass}, \Lit{(}, \Ruleref{identifier}, \Ruleref{expression}, \Lit{)}}

\subsubsection{Class Membership}

\Ruledef{isofclass expression}{
      \Lop{isofclass}, \Lit{(}, \Ruleref{identifier}, \Ruleref{expression}, \Lit{)}}

\subsubsection{Same Base Class Membership}

\Ruledef{samebaseclass expression}{
      \Lop{samebaseclass}, \Lit{(}, \Ruleref{expression}, \lfeed
      \Ruleref{expression}, \Lit{)}}

\subsubsection{Same Class Membership}

\Ruledef{sameclass expression}{
      \Lop{sameclass}, \Lit{(}, \Ruleref{expression}, \lfeed
      \Ruleref{expression}, \Lit{)}}

\subsubsection{History Expressions}

  \Ruledef{act expression}{
    \Lit{\#act}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#act}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{fin expression}{
    \Lit{\#fin}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#fin}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{active expression}{
    \Lit{\#active}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#active}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{req expression}{
    \Lit{\#req}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#req}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{waiting expression}{
    \Lit{\#waiting}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lit{\#waiting}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }

#endif VDMPP

#ifdef VICEMAN

\subsubsection{Time Expressions}

 \Ruledef{time expression}{\Lop{time}}
#endif VICEMAN

\subsubsection{Names}

\Ruledef{name}{
  \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
  }

\Ruledef{name list}{
  \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
  }

\Ruledef{old name}{
  \Ruleref{identifier}, \Lit{\char'176}
  }

\subsection{State Designators}

\Ruledef{state designator}{
  \Ruleref{name} \dsep
  \Ruleref{field reference} \dsep
  \Ruleref{map or sequence reference}
  }

\Ruledef{field reference}{
  \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{map or sequence reference}{
  \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\subsection{Statements}

\Ruledef{statement}{
  \Ruleref{let statement} \dsep
  \Ruleref{let be statement} \dsep
  \Ruleref{def statement} \dsep
  \Ruleref{block statement} \dsep
  \ifthenelse{\boolean{VDMpp}}{\Ruleref{general assign statement}}%
                              {\Ruleref{assign statement}} \dsep
  \Ruleref{if statement} \dsep
  \Ruleref{cases statement} \dsep
  \Ruleref{sequence for loop} \dsep
  \Ruleref{set for loop} \dsep
  \Ruleref{index for loop} \dsep
  \Ruleref{while loop} \dsep
  \Ruleref{nondeterministic statement} \dsep 
  \Ruleref{call statement} \dsep
  \Ruleref{specification statement} \dsep
#ifdef VDMPP
%  \Ruleref{select statement} \dsep
  \Ruleref{start statement} \dsep
  \Ruleref{start list statement} \dsep
%  \Ruleref{delay statement} \dsep
#endif VDMPP
#ifdef VICEMAN
  \Ruleref{duration statement} \dsep
  \Ruleref{cycles statement} \dsep
#endif VICEMAN
  \Ruleref{return statement} \dsep
  \Ruleref{always statement} \dsep
  \Ruleref{trap statement} \dsep
  \Ruleref{recursive trap statement} \dsep
  \Ruleref{exit statement} \dsep
  \Ruleref{error statement} \dsep
  \Ruleref{identity statement} 
  }
  \nonstandard{2}

\subsubsection{Local Binding Statements}

\Ruledef{let statement}{
  \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{local definition}{
  \Ruleref{value definition} \dsep 
  \Ruleref{function definition}
  }

\Ruledef{let be statement}{
  \Lop{let}, \Ruleref{bind}, \OptPt{\Lop{be}, \Lop{st},
  \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{statement}
  }

\Ruledef{def statement}{
  \Lop{def}, \Ruleref{equals definition}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{equals definition}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }
  \nonstandard{1}

\Ruledef{equals definition}{
  \Ruleref{pattern bind}, \Lit{=},
   \Ruleref{expression}}

\subsubsection{Block and Assignment Statements}

\Ruledef{block statement}{
  \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
  \Ruleref{statement}, \SeqPt{\Lit{;},  \Ruleref{statement}}, \OptPt{\Lit{;}}, 
  \Lit{)}
  }\nonstandard{1}

\Ruledef{dcl statement}{
  \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
  }

\Ruledef{assignment definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=}, 
    \Ruleref{expression} }
  }

\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
}%
{}

\Ruledef{assign statement}{
  \Ruleref{state designator}, \Lit{:=}, 
    \Ruleref{expression}
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{multiple assign statement}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \OptPt{\SeqPt{\Lit{;},\Ruleref{assign statement}}},
    \Lit{)}
    }
%  }%
%{}


\subsubsection{Conditional Statements}\label{condstmt2}

\Ruledef{if statement}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
  \SeqPt{\Ruleref{elseif statement}}, \lfeed
  \OptPt{\Lop{else}, \Ruleref{statement}}
  }

\Ruledef{elseif statement}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
  }


\Ruledef{cases statement}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
  \Ruleref{cases statement alternatives}, \lfeed 
  \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
  }

\Ruledef{cases statement alternatives}{
  \Ruleref{cases statement alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
  }

\Ruledef{cases statement alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
  }

\Ruledef{others statement}{
  \Lop{others}, \Lit{->}, \Ruleref{statement}
  }

\subsubsection{Loop Statements}

\Ruledef{sequence for loop}{
  \Lop{for}, \Ruleref{pattern bind}, \Lop{in},
  \OptPt{\Lop{reverse}}, \lfeed
  \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }

\Ruledef{set for loop}{
  \Lop{for}, \Lop{all}, \Ruleref{pattern}, \Lop{in set},
  \Ruleref{expression},\lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{index for loop}{
  \Lop{for}, \Ruleref{identifier}, \Lit{=}, \Ruleref{expression},
  \Lop{to}, \Ruleref{expression}, \lfeed
  \OptPt{\Lop{by}, \Ruleref{expression}}, \lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{while loop}{
  \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }
\subsubsection{The Nondeterministic Statement}

\Ruledef{nondeterministic statement}{
  \Lit{||}, \Lit{(}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
  }

\subsubsection{Call and Return Statements}

#ifdef VDMSL
\Ruledef{call statement}{
  \Ruleref{name}, \Lit{(}, \lfeed
  \OptPt{\Ruleref{expression list}}, \Lit{)}
}
#endif VDMSL
#ifdef VDMPP
  \Ruledef{call statement}{
    \OptPt{\Ruleref{object designator}, \Lit{.}},\lfeed
    \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)},
    }
  \Ruledef{object designator}{
    \Ruleref{name} \dsep
    \Ruleref{self expression} \dsep
    \Ruleref{new expression} \dsep
    \Ruleref{object field reference} \dsep
    \Ruleref{object apply}
  }

  \Ruledef{object field reference}{
    \Ruleref{object designator}, \Lit{.}, \Ruleref{identifier}
  }

  \Ruledef{object apply}{
    \Ruleref{object designator}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
#endif VDMPP

\Ruledef{return statement}{
  \Lop{return}, \OptPt{\Ruleref{expression}}
  }

\subsubsection{The Specification Statement}

\Ruledef{specification statement}{
  \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }\nonstandard{1}

#ifdef VDMPP
%\subsubsection{The Select Statement}
%
%\Ruledef{select statement}{
%      \Lop{sel}, \Lit{(}, \Ruleref{guarded command},\lfeed
%      \SeqPt{\Lit{,}, \Ruleref{guarded command}}, \Lit{)}}
%\Ruledef{guarded command}{
%      \OptPt{\Ruleref{expression}}, \OptPt{\Ruleref{answer statement}},\lfeed
%      \OptPt{\Lop{$->$}, \Ruleref{statement}}}
%\Ruledef{answer statement}{
%      \Lop{answer}, \Brack{\Ruleref{name} \dsepl \Lop{all}}}
%
\subsubsection{Start and Start List Statements}

\Ruledef{start statement}{
    \Lop{start}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

\Ruledef{start list statement}{
      \Lop{startlist}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

%\subsubsection{The Delay Statement}
%
%\Ruledef{delay statement}{
%      \Lop{delay}, \Lit{(},\Ruleref{expression}, \Lit{)}}
#endif VDMPP

#ifdef VICEMAN
\subsubsection{The Duration and Cycles Statements}

\Ruledef{duration statement}{
  \Lop{duration}, \Lit{(}, \Ruleref{numeric literal}, \Lit{)},\lfeed
  \Ruleref{statement}
}

\Ruledef{cycles statement}{
    \Lop{cycles}, \Lit{(}, \Ruleref{numeral}, \Lit{)},\lfeed
    \Ruleref{statement}
  }

#endif VICEMAN

\subsubsection{Exception Handling Statements}

\Ruledef{always statement}{
  \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{trap statement}{
  \Lop{trap}, \Ruleref{pattern bind}, \Lop{with}, \Ruleref{statement},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{recursive trap statement}{
  \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{traps}{
  \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}},
  \Lit{\}}
  }

\Ruledef{exit statement}{
  \Lop{exit}, \OptPt{\Ruleref{expression}}
  }

\subsubsection{The Error Statement}

  \Ruledef{error statement}{
    \Lop{error}
    }\nonstandard{1}

\subsubsection{The Identity Statement}

\Ruledef{identity statement}{
  \Lop{skip}
  }

\subsection{Patterns and Bindings}

\subsubsection{Patterns}\label{patterns2}

\Ruledef{pattern}{
  \Ruleref{pattern identifier} \dsep
  \Ruleref{match value} \dsep
  \Ruleref{set enum pattern} \dsep
  \Ruleref{set union pattern} \dsep
  \Ruleref{seq enum pattern} \dsep
  \Ruleref{seq conc pattern} \dsep
  \Ruleref{map enumeration pattern} \dsep
  \Ruleref{map muinon pattern} \dsep
  \Ruleref{tuple pattern} \dsep
  \Ruleref{record pattern}
  }

\Ruledef{pattern identifier}{
  \Ruleref{identifier} \dsepl \Lit{-}
  }

\Ruledef{match value}{
  \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
  \Ruleref{symbolic literal}
  }

\Ruledef{set enum pattern}{
  \Lit{\{}, \OptPt{\Ruleref{pattern list}}, \Lit{\}}
  }\nonstandard{1}

\Ruledef{set union pattern}{
  \Ruleref{pattern}, \Lit{union}, \Ruleref{pattern}
  }

\Ruledef{seq enum pattern}{
  \Lit{[}, \OptPt{\Ruleref{pattern list}}, \Lit{]}
  }\nonstandard{1}

\Ruledef{seq conc pattern}{
  \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
  }

\Ruledef{map enumeration pattern}{
    \Lit{\{}, [\Ruleref{maplet pattern list}], \Lit{\}}
    }

\Ruledef{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

\Ruledef{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

\Ruledef{map muinon pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

\Ruledef{tuple pattern}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
  } 

\Ruledef{tuple pattern}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
  } 

\Ruledef{record pattern}{
  \Lit{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\subsubsection{Bindings}

\Ruledef{pattern bind}{
  \Ruleref{pattern} \dsepl \Ruleref{bind}
  }

\Ruledef{bind}{
  \Ruleref{set bind} \dsepl \Ruleref{type bind}
  }

\Ruledef{set bind}{
  \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{type bind}{
  \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{bind list}{
  \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
  }

\Ruledef{multiple bind}{
  \Ruleref{multiple set bind} \dsep
  \Ruleref{multiple type bind}
  }

\Ruledef{multiple set bind}{
  \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{multiple type bind}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

\section{Lexical Specification}\label{app-b}\label{ap:lexis}

\subsection{Characters}

The character set is shown in Table~\ref{charSetTable}, with the forms of
characters used in this document. Notice that this character set corresponds
exactly to the ASCII (or ISO 646) syntax.

In the \vdmsl\ standard a character is defined as:

\Ruledef{character}{
  \hyperlink{charSetTable}{plain letter} \dsep
  \hyperlink{charSetTable}{key word letter} \dsep
  \hyperlink{charSetTable}{distinguished letter} \dsep
  Greek letter \dsep
  \hyperlink{charSetTable}{digit} \dsep
  \hyperlink{charSetTable}{delimiter character} \dsep
  \hyperlink{charSetTable}{other characters} \dsep
  \Ruleref{separator}
  }

The plain letters and the keyword letters are displayed in
Table~\ref{charSetTable} (in a document the keyword letters simply use the
corresponding small letters). The distinguished letters use the
corresponding capital and lower-case
letters where the whole quote literal is preceded by
``{\tt <}'' and followed by ``{\tt >}'' (note that quote literals
can also use underscores and digits). The Greek letters can also be used
with a number sign ``{\tt \#}'' followed by the corresponding letter (this
information is used by the \LaTeX\ pretty printer such that the Greek letters
can be produced). All delimiter characters (in the ASCII version of the
standard) are listed in Table~\ref{charSetTable}. In the standard a
distinction between delimiter characters and compound delimiters are
made.
We have
chosen not to use this distinction in this presentation. Please also notice
that some of the delimiters in the mathematical syntax are keywords in the
ASCII syntax which is used here.

\begin{table}[ht]
\setlength{\tabcolsep}{3.5mm}
\setlength{\arraycolsep}{3.5mm}

\rule{\textwidth}{.5mm}
    {\tt
    \begin{tabular}{*{13}{l}} 
        % that's 13 italic columns
        \multicolumn{13}{l}{\rm plain letter:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z \\
        A & B & C & D & E & F & G & H & I & J & K & L & M \\
        N & O & P & Q & R & S & T & U & V & W & X & Y & Z
    \end{tabular}
    }

\blankline
    {\sf  
    \begin{tabular}{*{13}{l}}
        % that's 13 keyword columns
        \multicolumn{13}{l}{\rm keyword letter:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z
    \end{tabular}
    }

\blankline
{\tt
    \begin{tabular}{*{10}{l}}
        % that's 10 math columns
        \multicolumn{10}{l}{\mbox{{\rm delimiter character:}}} \\
          ,         & :         & ;         & =         & (         &
          )         & |         & -         & [         & ]         \\
          \{        & \}        & +         & /         & <         &
          >         & <=        & >=        & <>        &  .        \\
          \verb+*+  & ->        & +>        & ==>       & ||        &
          =>        &   <=>     & |->       & <:        & :>        \\
          <-:       & :->       & \&        & ==        & **        & 
          \verb+^+  & ++        &           &           &           \\
    \end{tabular}
}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{digit:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
        & {\tt 8} 
        & {\tt 9} 
     \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{hexadecimal digit:} \\
        {\tt 0} & {\tt 1} & {\tt 2} & {\tt 3} & {\tt 4} & {\tt 5} & {\tt 6} & {\tt 7} & {\tt 8} & {\tt 9} \\
        {\tt A} & {\tt B} & {\tt C} & {\tt D} & {\tt E} & {\tt F} \\
        {\tt a} & {\tt b} & {\tt c} & {\tt d} & {\tt e} & {\tt f} 
     \end{tabular}

\blankline
    \begin{tabular}{*{8}{l}}
        \multicolumn{8}{l}{octal digit:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
     \end{tabular}

\blankline
    \begin{tabular}{*{6}{l}}
        \multicolumn{6}{l}{other characters:} \\
        {\tt \_} 
        & {\tt \char'140} % `
        & {\tt \char'047} % '
        & {\tt \char'042} % ''
        & {\tt \char'100} % @
        & {\tt \~{}}
    \end{tabular}

\blankline
    \begin{tabular}{p{14cm}}   %{p{\textwidth}}
        newline: \\
        \\
        white space: \\
        \\
        These have no graphic form, but are a combination of white space
        and line break.  There are two separators: without line break
        (white space) and with line break (newline).
    \end{tabular}

\rule{\textwidth}{.5mm}
\hypertarget{charSetTable}{\caption{Character set}}
\label{charSetTable}

\end{table}

\clearpage % to force table to appear *here*


\subsection{Symbols}\label{Symbols}

The following kinds of symbols exist: keywords, delimiters,
% simple names -- these do not seem to exist anymore DJA
symbolic literals, and comments.  The transformation from characters to
symbols is given by the following rules; these use the same notation as the
syntax definition but differ in meaning in that no separators may appear
between adjacent terminals.  Where ambiguity is possible otherwise, two
consecutive symbols must be separated by a separator.

\newcommand{\Lks}[1]{\Lop{#1}\dsepl}
\newcommand{\Lksb}[1]{\Lop{#1}\dsep}
\Ruledef{keyword}{
#ifdef VDMSL
  \Lks{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
  \Lks{as}
  \Lks{atomic}
  \Lks{be}
  \Lks{bool}
  \Lksb{by}
  \Lks{card}
  \Lks{cases}
  \Lks{char}
  \Lks{comp}
  \Lks{compose} 
  \Lksb{conc}
  \Lks{dcl}
  \Lks{def}
  \Lks{definitions}
  \Lks{dinter} 
  \Lks{div}
  \Lksb{dlmodule}
  \Lks{do}
  \Lks{dom}
  \Lks{dunion}
  \Lks{elems}
  \Lks{else}
  \Lks{elseif}
  \Lksb{end}
  \Lks{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lks{exit} 
  \Lks{exports}
  \Lksb{ext} 
  \Lks{false} 
  \Lks{floor}
  \Lks{for} 
  \Lks{forall}
  \Lks{from}
  \Lksb{functions}
  \Lks{hd} 
  \Lks{if}
  \Lks{imports}
  \Lks{in} 
  \Lks{inds}
  \Lks{init}
  \Lksb{inmap}
  \Lks{int}
  \Lks{inter}
  \Lks{inv}
  \Lks{inverse}
  \Lksb{iota}
  \Lks{lambda}
  \Lks{len} 
  \Lks{let}
  \Lks{map}
  \Lks{measure}
  \Lks{merge} 
  \Lks{mod} 
  \Lksb{module}
  \Lks{mu}
  \Lks{munion}
  \Lks{nat}
  \Lks{nat1}
  \Lks{nil} 
  \Lks{not}
  \Lksb{of}
  \Lks{operations}
  \Lks{or}
  \Lks{others}
  \Lksb{post}
  \Lks{power} 
  \Lks{pre}
  \Lks{psubset}
  \Lks{rat}
  \Lks{rd}
  \Lks{real} 
  \Lksb{rem}
  \Lks{renamed}
  \Lks{return}
  \Lks{reverse}
  \Lks{rng}
  \Lks{seq}
  \Lksb{seq1}
  \Lks{set}
  \Lks{skip}
  \Lks{specified}
  \Lks{st}
  \Lks{state}
  \Lksb{struct}
  \Lks{subset}
  \Lks{then}
  \Lks{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
  \Lksb{trap} 
  \Lks{true}
  \Lks{types}
  \Lks{undefined}
  \Lks{union}
  \Lksb{uselib}
  \Lks{values} 
  \Lks{while} 
  \Lks{with}
  \Lks{wr}
  \Lksb{yet}
  \Lop{RESULT} 
#endif // VDMSL
#ifdef VDMPP
  \Lks{\#act}
  \Lks{\#active}
  \Lks{\#fin}
  \Lks{\#req}
  \Lks{\#waiting}
%  \Lksb{a\_}
  \Lksb{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
  \Lksb{async}
  \Lks{atomic}
  \Lks{be}
  \Lks{bool}
  \Lks{by}
  \Lks{card}
  \Lksb{cases}
  \Lks{char}
  \Lks{class}
  \Lks{comp}
  \Lks{compose} 
  \Lks{conc}
#ifdef VICEMAN
  \Lks{cycles}
#endif VICEMAN
  \Lksb{dcl}
  \Lks{def}
%  \Lks{delay}
  \Lks{dinter} 
  \Lks{div}
  \Lks{do}
  \Lks{dom}
  \Lksb{dunion}
#ifdef VICEMAN
  \Lks{duration}
#endif VICEMAN
  \Lks{elems}
  \Lks{else}
  \Lks{elseif}
  \Lks{end}
  \Lksb{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lks{exit} 
  \Lks{ext} 
  \Lks{false} 
  \Lksb{floor}
  \Lks{for} 
  \Lks{forall}
  \Lks{from}
  \Lks{functions}
%  \Lks{general}
  \Lks{hd} 
  \Lks{if}
  \Lksb{in} 
  \Lks{inds}
 % \Lks{init}
  \Lks{inmap}
  \Lks{input}
  \Lks{instance}
  \Lks{int}
  \Lksb{inter}
  \Lks{inv}
  \Lks{inverse}
  \Lks{iota}
  \Lks{is}
  \Lksb{isofbaseclass}
  \Lks{isofclass}
  \Lks{lambda}
  \Lks{len} 
  \Lks{let}
  \Lks{map}
  \Lksb{measure}
  \Lks{merge} 
  \Lks{mod} 
  \Lks{mu}
  \Lks{munion}
  \Lksb{mutex}
  \Lks{nat}
  \Lks{nat1}
  \Lks{new}
  \Lks{nil} 
  \Lks{not}
  \Lks{of}
  \Lksb{operations}
  \Lks{or}
  \Lks{others}
  \Lks{per}
#ifdef VICEMAN
  \Lks{periodic}
#endif VICEMAN
  \Lks{post}
  \Lks{power} 
  \Lksb{pre}
  \Lks{private}
  \Lks{protected}
  \Lks{psubset}
  \Lks{public}
 % \Lksb{qsync}
  \Lksb{rat}
  \Lks{rd}
  \Lks{real} 
  \Lks{rem}
  \Lks{responsibility}
  \Lksb{return}
  \Lks{reverse}
  \Lks{rng}
  \Lks{samebaseclass}
  \Lks{sameclass}
 % \Lksb{sel}
  \Lksb{self}
  \Lks{seq}
  \Lks{seq1}
  \Lks{set}
  \Lks{skip}
  \Lks{specified}
  \Lks{st}
  \Lksb{start}
  \Lks{startlist}
  \Lks{subclass}
  \Lks{subset}
  \Lksb{sync}
#ifdef VICEMAN
  \Lks{system}
#endif VICEMAN
%  \Lks{synonym}
%  \Lks{t\_}
  \Lks{then}
  \Lks{thread}
  \Lks{threadid}
#ifdef VICEMAN
  \Lks{time}
#endif VICEMAN
  \Lksb{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
#ifdef VDMPP
  \Lks{traces}
#endif VDMPP
  \Lks{trap} 
  \Lks{true}
  \Lksb{types}
  \Lks{undefined}
  \Lks{union}
  \Lks{values} 
  \Lks{variables}
%  \Lks{w\_}
  \Lks{while} 
  \Lksb{with}
  \Lks{wr}
  \Lks{yet}
  \Lop{RESULT} 
#endif VDMPP
  }

\Ruledef{separator}{
  \hyperlink{charSetTable}{newline} \dsepl 
  \hyperlink{charSetTable}{white space}
  }

\Ruledef{identifier}{
  \Brack{\hyperlink{charSetTable}{plain letter} \dsepl Greek letter}, \lfeed
  \SeqPt{\Brack{\hyperlink{charSetTable}{plain letter} \dsepl Greek letter} \dsepl % \Ruleref{IS THIS RIGHT}??
    \hyperlink{charSetTable}{digit}      \dsepl
    \Lit{'}  \dsepl
    \Lit{\_}
    }
  }

\medskip

#ifdef VICEMAN
\noindent Note that the \texttt{CPU} and \texttt{BUS} classes are
reserved and cannot be redefined by the user. These two predefined
classes contain the functionality described in
Section~\ref{sec:system} above.
#endif VICEMAN

\noindent %Note that the hyphen which can be used in identifiers is written
%as a low line (also known as an underscore ``\_''), whereas it is
%translated to ``-'' in the mathematical syntax.
All identifiers beginning with one of the reserved prefixes are
reserved: \keyw{init\_}, \keyw{inv\_}, \keyw{is\_}, \keyw{mk\_},
\keyw{post\_} and \keyw{pre\_}.

\Ruledef{type variable identifier}{
  \Lit{@}, \Ruleref{identifier}
  }

\Ruledef{is basic type}{
  \Lop{is\_}, 
  \Brack{%
    \Lop{bool} \dsepl
    \Lop{nat} \dsepl 
    \Lop{nat1} \dsepl 
    \Lop{int} \dsepl 
    \Lop{rat} \dsep 
    \Lop{real} \dsepl
    \Lop{char} \dsepl
    \Lop{token}
    }
  }

\Ruledef{symbolic literal}{
  \Ruleref{numeric literal} \dsepl
  \Ruleref{boolean literal} \dsep
  \Ruleref{nil literal} \dsepl
  \Ruleref{character literal} \dsepl
  \Ruleref{text literal} \dsep
  \Ruleref{quote literal}
  }

\Ruledef{numeral}{
  \hyperlink{charSetTable}{digit}, \SeqPt{\hyperlink{charSetTable}{digit}}
  }

\Ruledef{numeric literal}{
  \hyperlink{charSetTable}{decimal literal} \dsepl \hyperlink{charSetTable}{hexadecimal literal}
  }

\Ruledef{exponent}{
  \Brack{\Lit{E} \dsepl \Lit{e}},
  \OptPt{\Lit{+} \dsepl \Lit{-}},
  \Ruleref{numeral}
  }

\Ruledef{decimal literal}{
  \Ruleref{numeral},
  \OptPt{\Lit{.}, \hyperlink{charSetTable}{digit}, \SeqPt{\hyperlink{charSetTable}{digit}}},
  \OptPt{\Ruleref{exponent}}
}

\Ruledef{hexadecimal literal}{
  \Brack{\Lit{0x} \dsepl \Lit{0X}}, \hyperlink{charSetTable}{hexadecimal digit}, \SeqPt{\hyperlink{charSetTable}{hexadecimal digit}}
}

\Ruledef{boolean literal}{
  \Lop{true} \dsepl \Lop{false}
  }

\Ruledef{nil literal}{
  \Lop{nil}
  }

\Ruledef{character literal}{
  \Lit{\mbox{\,}'\mbox{\,}}, \Ruleref{character} \dsepl 
  \Ruleref{escape sequence} \dsep 
  \Ruleref{multi character}, 
  \Lit{\mbox{\,}'\mbox{\,}}
  }\nonstandard{1}

\Ruledef{escape sequence}{
  \Lit{\char'134\char'134} \dsepl \Lit{{\char'134}r} \dsepl
  \Lit{{\char'134}n} \dsepl \Lit{{\char'134}t} \dsepl
  \Lit{{\char'134}f} \dsepl \Lit{{\char'134}e} \dsepl \Lit{{\char'134}a} \dsep
  \Lit{{\char'134}x} \hyperlink{charSetTable}{hexadecimal digit},\hyperlink{charSetTable}{hexadecimal digit} \dsepl
  \Lit{{\char'134}c} \Ruleref{character} \dsep
  \Lit{{\char'134}} \hyperlink{charSetTable}{octal digit}, \hyperlink{charSetTable}{octal digit}, \hyperlink{charSetTable}{octal digit} \dsep
  \Lit{{\char'134}"} \dsepl
  \Lit{{\char'134}'} \dsepl
  }

\Ruledef{multi character}{Greek letter \dsep
   \Lit{<=} \dsepl \Lit{>=} \dsepl \Lit{<>} \dsepl \Lit{->} \dsepl
   \Lit{+>} \dsepl \Lit{==>} \dsepl \Lit{||} \dsep \Lit{=>} \dsepl
   \Lit{<=>} \dsepl \Lit{|->} \dsepl \Lit{<:} \dsepl \Lit{:>} \dsepl
   \Lit{<-:} \dsep \Lit{:->} \dsepl \Lit{==} \dsepl \Lit{**} \dsepl
   \Lit{++}}  

\Ruledef{text literal}{
  \Lit{\mbox{\,}"\mbox{\,}},
  \SeqPt{%
%    \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl%  was , - changed by br!
%    character -- \Brack{\Lit{\mbox{\,}"\mbox{\,}}\dsepl newline}
     \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl
     \Ruleref{character} \dsepl \Ruleref{escape sequence}
    },
  \Lit{\mbox{\,}"\mbox{\,}}
  }

\Ruledef{quote literal}{
  \hyperlink{charSetTable}{distinguished letter}, \lfeed
  \SeqPt{\Lit{\_} \dsepl \hyperlink{charSetTable}{distinguished letter}
   \dsepl \hyperlink{charSetTable}{digit}}% \Ruleref{M30} (\Ruleref{hyphen allowed})
  }

\Ruledef{Single-line comment}{
  \Lit{--}, \SeqPt{\Ruleref{character} -- \hyperlink{charSetTable}{newline}}, \hyperlink{charSetTable}{newline}
  }

#ifdef VDMPP
\Ruledef{Multiple-line comment}{
  \Lit{/*}, \SeqPt{\Ruleref{character}}, \Lit{*/}
  }
#endif VDMPP

The escape sequences given above are to be interpreted as follows:

\begin{center}
\begin{tabular}{ll}\hline
Sequence & Interpretation\\ \hline
  \Lit{\char'134\char'134} & backslash character\\
  \Lit{{\char'134}r}       & return character\\
  \Lit{{\char'134}n}       & newline character\\
  \Lit{{\char'134}t}       & tab character\\
  \Lit{{\char'134}f}       & formfeed character\\
  \Lit{{\char'134}e}       & escape character\\
  \Lit{{\char'134}a}       & alarm (bell)\\
  \Lit{{\char'134}x} hexadecimal digit, hexadecimal digit
                           & hex representation of character\\
                           & (e.g. \texttt{{\char'134}x41} is `A')\\
  \Lit{{\char'134}c} character 
                           & control character\\
                           & (e.g. \texttt{{\char'134}c A} $\equiv$ 
                                    \texttt{{\char'134}x01})\\
  \Lit{{\char'134}} octal digit, octal digit, octal digit 
                           & octal representation of character\\
  \Lit{{\char'134}{\char'042}}       & the \texttt{{\char'042}} character\\
  \Lit{{\char'134}'}       & the \verb+'+ character \\ \hline
\end{tabular}
\end{center}

\newpage
\section{Operator Precedence}\label{app-c}

The precedence ordering for operators in the concrete syntax is defined
using a two-level approach: operators are divided into families, and an
upper-level precedence ordering, $>$, is given for the families, such that
if families $F\sb{1}$ and $F\sb{2}$ satisfy

\begin{quote}
$F\sb{1} > F\sb{2}$
\end{quote}

\noindent then every operator in the family $F\sb{1}$ is of a higher precedence
than every operator in the family $F\sb{2}$.

The relative precedences of the operators within families is determined by
considering type information, and this is used to resolve ambiguity. The
type constructors are treated separately, and are not placed in a
precedence ordering with the other operators.

There are six families of operators, namely Combinators, Applicators,
Evaluators, Relations, Connectives and Constructors:

\begin{description}%{Connectivesxx}
\item[Combinators:] Operations that allow function and mapping values to be
  combined, and function, mapping and numeric values to be iterated.

\item[Applicators:] Function application, field selection, sequence
  indexing, etc.

\item[Evaluators:] Operators that are non-predicates.

\item[Relations:] Operators that are relations.

\item[Connectives:] The logical connectives.

\item[Constructors:] Operators that are used, implicitly or explicitly, in
  the construction of expressions; e.g.  \keyw{if-then-elseif-else}, `{\tt
    |->}', `\ldots', etc.
\end{description}

\noindent The precedence ordering on the families is:

\begin{quote}
$\mbox{\small combinators} >
\mbox{\small applicators} >
\mbox{\small evaluators}  >
\mbox{\small relations}   >
\mbox{\small connectives} >
\mbox{\small constructors}$
\end{quote}

\subsection{The Family of Combinators}

These combinators have the highest family priority.

\Ruledef{combinator}{
  \Ruleref{iterate} \dsepl \Ruleref{composition}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & combinator \\
    \hline
    1       & \keyw{comp}     \\
    2       & \keyw{iterate}  \\
    \hline
  \end{tabular}
\end{center}

\subsection{The Family of Applicators}

All applicators have equal precedence.

\Ruledef{applicator}{
  \Ruleref{subsequence}
% \dsep \Ruleref{tuple constructor}
  \dsep \Ruleref{apply}
  \dsep \Ruleref{function type instantiation}
  \dsep \Ruleref{field select}
  }

\Rule{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
  \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)}
  }

\Rule{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Rule{function type instantiation}{
  \Ruleref{expression}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }

\Rule{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier} 
  }

\subsection{The Family of Evaluators}

The family of evaluators is divided into nine groups, according to the type
of expression they are used in.

\Ruledef{evaluator}{
  \Ruleref{arithmetic prefix operator} \dsep
  \Ruleref{set prefix operator} \dsep
  \Ruleref{sequence prefix operator} \dsep
  \Ruleref{map prefix operator} \dsep
  \Ruleref{map inverse} \dsep
  \Ruleref{arithmetic infix operator} \dsep
  \Ruleref{set infix operator} \dsep
  \Ruleref{sequence infix operator} \dsep
  \Ruleref{map infix operator}
  }

\Ruledef{arithmetic prefix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lop{abs} \dsepl
  \Lop{floor}
  }

\Ruledef{set prefix operator}{
  \Lop{card} \dsepl
  \Lop{power} \dsepl
  \Lop{dunion} \dsepl
  \Lop{dinter}
  }

\Ruledef{sequence prefix operator}{
  \Lop{hd} \dsepl
  \Lop{tl} \dsepl
  \Lop{len} \dsep
  \Lop{inds} \dsepl
  \Lop{elems} \dsepl
  \Lop{conc}
  }

\Ruledef{map prefix operator}{
  \Lop{dom} \dsepl
  \Lop{rng} \dsepl
  \Lop{merge} \dsepl
  \Lop{inverse}
  }

\Ruledef{arithmetic infix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lit{*} \dsepl
  \Lit{/} \dsepl
  \Lop{rem} \dsepl
  \Lop{mod} \dsepl
  \Lop{div}
  }

\Ruledef{set infix operator}{
  \Lop{union} \dsepl
  \Lop{inter} \dsepl
  \Lit{\char'134}
  }

\Ruledef{sequence infix operator}{
  \Lit{\char'136}
  }

\Ruledef{map infix operator}{
  \Lop{munion} \dsepl
  \Lit{++} \dsepl
  \Lit{<:} \dsepl
  \Lit{<-:} \dsepl
  \Lit{:>} \dsepl
  \Lit{:->}
  }

\noindent The precedence ordering follows a pattern of analogous operators. The
family is defined in the following table.

\blankline
\begin{center}
  \begin{tabular}{ccccc}
    \hline
    precedence level & arithmetic       & set                   & map                    & sequence \\
    1                & {\tt + -}        & \keyw{union} \verb+\+ & \keyw{munion} {\tt ++} & \verb+^+ \\
    2                & \verb+*+ {\tt /} & \keyw{inter}          &                        & \\
                     & \keyw{rem}       &                       &                        & \\
                     & \keyw{mod}       &                       &                        & \\
                     & \keyw{div}       &                       &                        & \\
    3                &                  &                       & \keyw{inverse}         & \\
    4                &                  &                       & {\tt <: <-:}           & \\
    5                &                  &                       & {\tt :> :->}           & \\
    6                & (unary) {\tt +}  & \keyw{card}           & \keyw{dom}             & \keyw{len}         \\
                     & (unary) {\tt -}  & \keyw{power}          & \keyw{rng}             & \keyw{elems}       \\
                     & \keyw{abs}       & \keyw{dinter}         & \keyw{merge}           & \keyw{hd} \keyw{tl} \\
                     & \keyw{floor}     & \keyw{dunion}         &                        & \keyw{conc}        \\
                     &                  &                       &                        & \keyw{inds}        \\
    \hline
  \end{tabular}
\end{center}

\subsection{The Family of Relations}

This family includes all the relational operators whose results are of type
\keyw{bool}.

\Ruledef{relation}{
  \Ruleref{relational infix operator} \dsepl \Ruleref{set relational operator}
  }

\Ruledef{relational infix operator}{
  \Lit{=} \dsepl
  \Lit{<>} \dsepl
  \Lit{<} \dsepl
  \Lit{<=} \dsepl
  \Lit{>} \dsepl
  \Lit{>=}
  }

\Ruledef{set relational operator}{
  \Lop{subset} \dsepl
  \Lop{psubset} \dsepl
  \Lop{in set} \dsepl
  \Lop{not in set}
  }

\blankline
\begin{center}
  \begin{tabular}{ccc}
    \hline
    precedence level & relation \\
    \hline
    1       & {\tt <=}        & {\tt <}         \\
            & {\tt >=}        & {\tt >}         \\
            & {\tt =}         & {\tt <>}        \\
            & \keyw{subset}   & \keyw{psubset}  \\
            & \keyw{in set}   & \keyw{not in set}\\
    \hline \\
  \end{tabular}
\end{center}

\noindent All operators in the Relations family have equal precedence.  Typing
dictates that there is no meaningful way of using them adjacently.

\subsection{The Family of Connectives}

This family includes all the logical operators whose result is of type
\keyw{bool}.

\Ruledef{connective}{
  \Ruleref{logical prefix operator} \dsepl \Ruleref{logical infix operator}
  }

\Ruledef{logical prefix operator}{
  \Lop{not}
  }

\Ruledef{logical infix operator}{
  \Lop{and} \dsepl
  \Lop{or} \dsepl
  \Lit{=>} \dsepl
  \Lit{<=>}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & connective \\ \hline
    1                & {\tt <=>}      \\
    2                & {\tt =>}  \\
    3                & \keyw{or}       \\
    4                & \keyw{and}     \\
    5                & \keyw{not}      \\
    \hline
  \end{tabular}
\end{center}

\subsection{The Family of Constructors}

This family includes all the operators used to construct a value.  Their
priority is given either by brackets, which are an implicit part of the
operator, or by the syntax.

\subsection{Grouping}\label{grouping}

The grouping of operands of the binary operators are as follows:

\begin{list}{\bf no label!}{%
    \def\mylabel#1{\hspace\labelsep #1\hfill}
    \let\makelabel\mylabel
    \settowidth{\labelwidth}{Constructors: }
    \setlength{\leftmargin}{\labelwidth}
    \addtolength{\leftmargin}{2\labelsep}
    }
\item[Combinators:] Right grouping.

\item[Applicators:] Left grouping.

\item[Connectives:] The `{\tt =>}' operator has right grouping.  The other
  operators are associative and therefore right and left grouping are
  equivalent.
  
\item[Evaluators:] Left grouping\footnote{Except the ``map domain restrict
    to'' and the ``map domain restrict by'' operators which have a right
    grouping. This is not standard.}.

\item[Relations:] No grouping, as it has no meaning.

\item[Constructors:] No grouping, as it has no meaning.
\end{list}

\subsection{The Type Operators}\label{preceedence}

Type operators have their own separate precedence ordering, as follows:
\begin{enumerate}
\item Function types: {\tt ->, +>} (right grouping).

\item Union type: {\tt |} (left grouping).

\item Other binary type operators: \verb+*+ (no grouping).

\item Map types: \keyw{map} \ldots \keyw{to} \ldots and \keyw{inmap} \ldots
  \keyw{to} \ldots\ (right grouping).\nonstandard{0}

\item Unary type operators: \keyw{seq of}, \keyw{seq1 of}, \keyw{set of}.
\end{enumerate}

\section{Differences between the two Concrete Syntaxes}\label{sec:diff}

Below is a list of the symbols which are different in the mathematical
syntax and the ASCII syntax:\\
%\samepage
%\begin{center}
\begin{longtable}{|l|l|}\hline
 \ldots$\Gmap$\ldots & {\tt map ... to ...} \kill
 Mathematical syntax & ASCII syntax  \\ \hline\hline
\endhead
\hline
\endfoot
 $\Dot$            & {\tt\char'046} \\
 $\Mult$              & {\tt *}        \\
 $\Le$            & {\tt <=}        \\
 $\Ge$            & {\tt >=}        \\
 $\Neq$            & {\tt <>}       \\
 $\Oto$            & {\tt ==>}      \\
 $\To$             & {\tt ->}       \\
 $\Implies$     & {\tt =>}          \\
 $\Equiv$ & {\tt <=>}               \\
 $\Mapsto$         & {\tt |->}       \\
 $\Fdef$           & {\tt ==}        \\
 $\Iterate$        & {\tt **}        \\
 $\Override$       & {\tt ++}        \\
 $\Mapmerge$         & {\tt munion} \\
 $\Dto$            & {\tt <:}                           \\
 $\Rto$            & {\tt :>}                          \\
 $\Dby$            & {\tt <-:}                          \\
 $\Rby$            & {\tt :->}                         \\
 $\Psubset$         & {\tt psubset}                     \\
 $\Subset$       & {\tt subset}                         \\
 $\Sconc$          & {\tt\char'136}                     \\
 $\Dinter$          & {\tt dinter}                      \\
 $\Dunion$          & {\tt dunion}                      \\
 $\Power$          & {\tt power}                        \\
 \ldots$\Set$            & {\tt set of ...}                    \\
 \ldots$\Seq*$              & {\tt seq of ...}                 \\
 \ldots$\Seq+$              & {\tt seq1 of ...}                 \\
 \ldots$\Gmap$\ldots           & {\tt map ... to ...}                 \\
 \ldots$\Bmap$\ldots           & {\tt inmap ... to ...}                 \\
 $\Muop$           & {\tt mu}                           \\
 $\Bool$           & {\tt bool}                         \\
 $\Nat$            & {\tt nat}                          \\
 $\Int$            & {\tt int}                          \\
 $\Real$           & {\tt real}                         \\
 $\Not$            & {\tt not}                          \\
 $\Inter$          & {\tt inter}                        \\
 $\Union$          & {\tt union}                        \\
 $\In$             & {\tt in set}                       \\
 $\Notin$          & {\tt not in set}                   \\
 $\And$            & {\tt and}                          \\
 $\Or$             & {\tt or}                           \\
 $\All$            & {\tt forall}                       \\
 $\Exists$         & {\tt exists}                       \\
 $\Exists!$        & {\tt exists1}                      \\
 $\Lambdaop$       & {\tt lambda} \\
 $\Iotaop$         & {\tt iota} \\
 $\ldots\Inverse$  & {\tt inverse ...} \\
%#ifdef VDMPP
% $\kWeave$         & {\tt w\_} \\
% $\kTraceset$      & {\tt t\_} \\
% $\kAlphabet$      & {\tt a\_} \\
%#endif VDMPP
\hline
\end{longtable}
% \end{center}

\newpage

\section{Standard Libraries}\label{stdlib}\index{Standard libraries}\index{library}\index{Math}\index{IO}

\subsection{Math Library}
%When more than just the Math is available name should be given to each library by \subsubsection*

The Math library is defined in the 
\ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} 
file.  It provides the following math functions:

\begin{center}
\begin{tabular}{|l|l|p{6cm}|}\hline
\multicolumn{2}{|l|}{\bf Functions} & \bf Pre-conditions\\ \hline
\verb/sin: real +> real/ & Sine &  \index{Sine} \\ \hline
\verb/cos: real +> real/ & Cosine &  \index{Cosine} \\ \hline
\verb/tan: real -> real/ & Tangent & The argument is not an integer multiple 
                                     of $^\pi\!/\!_2$ \index{Tangent} \\ \hline 
\verb/cot: real -> real/ & Cotagent & The argument is not an integer multiple 
                                      of $\pi$ \index{Cotangent} \\ \hline
\verb/asin: real -> real/ & Inverse sine & The argument is not in the interval
                                           from -1 to 1 (both inclusive). 
                                           \index{Inverse sine}\\ \hline
\verb/acos: real -> real/ & Inverse cosine & The argument is not in the 
                                      interval from -1 to 1 (both inclusive). 
                                      \index{Inverse cosine}\\ \hline
\verb/atan:real +> real/ & Inverse tangent & \index{Inverse tangent}\\ \hline
\verb/sqrt: real -> real/ & Square root & The argument is non-negative. 
                                          \index{Square root}\\ \hline
\end{tabular}
\end{center}

and the value:

\begin{quote}
\texttt{pi} = 3.14159265358979323846\index{pi}
\end{quote}

If the functions are applied with arguments that violate possible
pre-conditions they will return values that are not proper
\vdmslpp{\vdmsl}{\vdmpp} values, {\tt Inf} (infinity, e.g.\ {\tt
  tan(pi/2)}) and {\tt NaN} (not a number, e.g.\ {\tt sqrt (-1)}).


#ifdef VDMSL
% \subsubsection{Using the Math Standard Library with Flat Specifications}%
% \index{Math!use with flat specifications}
% 
% To use the standard library in a flat specification, the library file 
% \begin{quote}
% \verb+$TOOLBOXHOME/stdlib/mathflat.vdm+
% \end{quote}
% should be added to the
% current project. Functions from the standard library may then be
% accessed directly as the example below demonstrates:
% \begin{alltt}
% \keyw{types}
% 
% coord :: x : \keyw{real}
%          y : \keyw{real}
% 
% \keyw{functions}
% 
% -- euclidean metric between two points
% dist : coord * coord -> \keyw{real}
% dist (c1,c2) ==
%   sqrt((c1.x - c2.x) * (c1.x - c2.x) +
%        (c1.y - c2.y) * (c1.y - c2.y));
% 
% 
% -- outputs angle of line joining coord with origin
% -- from horizontal, in degrees
% angle : coord -> \keyw{real}
% angle (c) ==
%   atan (c.y / c.x) * 360 / ( 2 * pi)
% \end{alltt}
% 
% \subsubsection{Using the Math Standard Library with Modular Specifications}%
% \index{Math!use with modular specifications}
% 
To use the standard library in a modular specification, the library file 
\begin{quote}
\verb+$TOOLBOXHOME/stdlib/math.vdm+
\end{quote}
should be added to the
current project. This contains the module \texttt{MATH}. Functions
from this library may then be accessed in the usual way, by importing
them into modules as needed. The example below demonstrates this:

\begin{alltt}
\keyw{module} UseLib

  \keyw{imports}
    \keyw{from} MATH \keyw{all}

  \keyw{definitions}

  \keyw{types}

  coord :: x : \keyw{real}
           y : \keyw{real}

  \keyw{functions}

  -- euclidean metric between two points
  dist : coord * coord -> \keyw{real}
  dist (c1,c2) ==
    MATH`sqrt((c1.x - c2.x) * (c1.x - c2.x) +
              (c1.y - c2.y) * (c1.y - c2.y));


  -- outputs angle of line joining coord with origin
  -- from horizontal, in degrees
  angle : coord -> \keyw{real}
  angle (c) ==
    MATH`atan (c.y / c.x) * 360 / ( 2 * MATH`pi)

\keyw{end} UseLib
\end{alltt}

#endif VDMSL
#ifdef VDMPP
To use the standard library the file 
\begin{quote}
\verb+$TOOLBOXHOME/stdlib/math.vpp+
\end{quote}
should be added to the
current project. This contains the class \texttt{MATH}. To access the
functions in this class, instances of the class must be
created; however since values are class attributes, \texttt{pi} may be
accessed directly. The example below demonstrates this:
\begin{alltt}
\keyw{class} UseLib

  \keyw{types}

  coord :: x : \keyw{real}
           y : \keyw{real}

  \keyw{functions}

  -- euclidean metric between two points
  dist : coord * coord -> \keyw{real}
  dist (c1,c2) ==
    \keyw{let} math = \keyw{new} MATH()
    \keyw{in}
    math.sqrt((c1.x - c2.x) * (c1.x - c2.x) +
              (c1.y - c2.y) * (c1.y - c2.y));

  -- outputs angle of line joining coord with origin
  -- from horizontal, in degrees
  angle : coord -> \keyw{real}
  angle (c) ==
    \keyw{let} math = \keyw{new} MATH()
    \keyw{in}
    math.atan (c.y / c.x) * 360 / ( 2 * MATH`pi)

\keyw{end} UseLib
\end{alltt}
#endif VDMPP

\subsection{IO Library}\index{IO}

The IO library is defined in the 
\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}} file, and it
is located
in the directory \verb+$TOOLBOXHOME/stdlib/+.  
It provides the IO functions and
operations listed below. Each read/write function or operation returns
a boolean 
value (or a tuple with a boolean component) representing the success
(\keyw{true}) or failure (\keyw{false}) of the corresponding IO
action. 

\begin{description}
\item[\texttt{writeval[@p]:[@p] +> bool}] \mbox{}\\
  This function writes a VDM value in ASCII format to standard
  output. There is no pre-condition.
\item[\texttt{fwriteval[@p]:seq1 of char * @p * filedirective +>
    bool}] \mbox{}\\
  This function writes a VDM value (the second argument) in ASCII
  format to a file whose  
  name is specified by the character string in the first argument. The
  third parameter has type \texttt{filedirective} which is defined to be:
  \begin{verbatim}
    filedirective = <start>|<append> 
  \end{verbatim}
  If \texttt{<start>} is used, the existing file (if any) is
  overwritten; if \texttt{<append>} is used, output is appended to the
  existing file and a new file is created if one does not already
  exist. There is no pre-condition.
\item[\texttt{freadval[@p]:seq1 of char +> bool * [@p]}] \mbox{}\\
  This function reads a VDM value in ASCII format from the file
  specified by the character string in the first argument. There is no
  pre-condition. The function returns a pair, the first component
  indicating the success of the read and the second component
  indicating the value read if the read was successful.
\item[\texttt{echo: seq of char ==> bool}] \mbox{}\\
  This operation writes the given text to standard output. Surrounding
  double quotes will be stripped, backslashed characters will be
  interpreted as \hyperlink{rule:escape sequence}{escape sequences}. There is no
  pre-condition. 
\item[\texttt{fecho: seq of char * seq of char * [filedirective] ==> bool}]
  \mbox{}\\
  This operation is similar to \texttt{echo} but writes text to a file
  rather than to standard output. The \texttt{filedirective} parameter
  should be interpreted as for \texttt{fwriteval}. The pre-condition
  for this operation is that if an empty string
  is given for the filename, then the \texttt{[filedirective]}
  argument should be \keyw{nil} since the text is written to standard
  output. 
\item[\texttt{ferror:()  ==> seq of char}]
  The read/write functions and operations return false if an error
  occurs. In this case an internal error string will be set. This
  operation returns this string and sets it to \texttt{""}.
\end{description}

As an example of the use of the IO library, consider a
web server which maintains a log of page hits:
#ifdef VDMPP
\begin{alltt}
  \keyw{class} LoggingWebServer

    \keyw{values}
      logfilename : \keyw{seq1 of char} = "serverlog"

    \keyw{instance variables}
      io : IO := \keyw{new} IO();

    \keyw{functions}
      URLtoString : URL -> \keyw{seq of char}
      URLtoString = ...

    \keyw{operations}
      RetrieveURL : URL ==> File
      RetrieveURL(url) ==
        (\keyw{def} - = io.fecho(logfilename, URLtoString(url)^\verb+"\n"+, <append>);
         ... 
        );

      ResetLog : () ==> \keyw{bool}
      ResetLog() ==
        io.fecho(logfilename,\verb+"\n"+,<start>)

  \keyw{end} LoggingWebServer
\end{alltt}
#endif VDMPP

#ifdef VDMSL
\begin{alltt}
  module LoggingWebServer

    \keyw{imports}
      \keyw{from} IO \keyw{all}

    \keyw{exports} \keyw{all}

    \keyw{definitions}

    \keyw{values}
      logfilename : seq1 of char = "serverlog"

    \keyw{functions}
      URLtoString : URL -> \keyw{seq} \keyw{of} \keyw{char}
      URLtoString = ...

    \keyw{operations}
      RetrieveURL : URL ==> File
      RetrieveURL(url) ==
        (\keyw{def} - = IO`fecho(logfilename, URLtoString(url)^\verb+"\n"+, <append>);
         ... 
        );

      ResetLog : () ==> \keyw{bool}
      ResetLog() ==
        IO`fecho(logfilename,\verb+"\n"+,<start>)

  \keyw{end} LoggingWebServer
\end{alltt}
#endif VDMSL

\subsection{VDMUtil Library}\index{VDMUtil}

The VDMUtil library is defined in the 
\ifthenelse{\boolean{VDMsl}}{{\tt vdmutil.vdm}}{{\tt vdmutil.vpp}} file, and it 
is located 
in the directory \verb+$TOOLBOXHOME/stdlib/+.  
It provides the different kind of VDM utility functions and 
operations listed below. 

\begin{description}
\item[\texttt{set2seq[@T]:set of @T +> seq of @T}] \mbox{}\\
This utility function enables an easy conversion of a set of elements without 
ordering into a sequence with an arbitrary ordering of the elements.
\item[\texttt{get\_file\_pos: () +> [seq of char * nat * nat * seq of char * seq of char]}] \mbox{}\\
This function is able to extract context information (file name, line 
number, class name and function/operation name) for a particular part 
of the source text.
\item[\texttt{val2seq\_of\_char[@T]: @T +> seq of char}] \mbox{}\\
This function is able to transform a VDM value into a string.
\item[\texttt{seq\_of\_char2val[@p]:seq1 of char -> bool * [@p]}] \mbox{}\\
This function is able to transform a string (a sequence of chars) into 
a VDM value.
\end{description}
#ifdef VDMPP
\begin{alltt}
\keyw{class} VDMUtil

-- 	VDMTools STANDARD LIBRARY: VDMUtil
--      --------------------------------------------
-- 
-- Standard library for the VDMTools Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customisable. 
-- Dont care's may NOT be used in the parameter lists.

\keyw{functions}
-- Converts a set argument into a sequence in non-deterministic order.
\keyw{static public} set2seq[@T] : \keyw{set of} @T +> \keyw{seq of} @T
set2seq(x) == \keyw{is not yet specified};

-- Returns a context information tuple which represents
-- (file_name * line_num * column_num * class_name * fnop_name) of 
-- corresponding source text
\keyw{static public} 
get_file_pos : () +> [ \keyw{seq of char} * \keyw{nat} * \keyw{nat} * \keyw{seq of char} * \keyw{seq of char} ]
get_file_pos() == \keyw{is not yet specified};

-- Converts a VDM value into a seq of char.
\keyw{static public} val2seq_of_char[@T] : @T +> \keyw{seq of char}
val2seq_of_char(x) == \keyw{is not yet specified};

-- converts VDM value in ASCII format into a VDM value
-- RESULT.#1 = false implies a conversion failure
\keyw{static public} seq_of_char2val[@p]:\keyw{seq1 of char} -> \keyw{bool} * [@p]
seq_of_char2val(s) ==
  \keyw{is not yet specified}
  \keyw{post let mk}_(b,t) = \keyw{RESULT in not} b => t = \keyw{nil};

\keyw{end} VDMUtil
\end{alltt}
#endif VDMPP

#ifdef VDMSL
\begin{alltt}
\keyw{module} VDMUtil

-- 	VDMTools STANDARD LIBRARY: VDMUtil
--      --------------------------------------------
-- 
-- Standard library for the VDMTools Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customisable. 
-- Dont care's may NOT be used in the parameter lists.

\keyw{exports all
definitions
functions}
-- Converts a set argument into a sequence in non-deterministic order.
set2seq[@T] : \keyw{set of} @T +> \keyw{seq of} @T
set2seq(x) == \keyw{is not yet specified};

-- Returns a context information tuple which represents
-- (file_name * line_num * column_num * module_name * fnop_name) 
-- of corresponding source text
get_file_pos : () +> [ \keyw{seq of char} * \keyw{nat} * \keyw{nat} * \keyw{seq of char} * \keyw{seq of char} ]
get_file_pos() == \keyw{is not yet specified};

-- Converts a VDM value into a seq of char.
val2seq_of_char[@T] : @T +> \keyw{seq of char}
val2seq_of_char(x) == \keyw{is not yet specified};

-- converts VDM value in ASCII format into a VDM value
-- RESULT.#1 = false implies a conversion failure
seq_of_char2val[@p]:\keyw{seq1 of char} -> \keyw{bool} * [@p]
seq_of_char2val(s) ==
  \keyw{is not yet specified}
  \keyw{post let mk}_(b,t) = \keyw{RESULT in not} b => t = \keyw{nil};

\keyw{end} VDMUtil
\end{alltt}
#endif VDMSL

\newpage
\addcontentsline{toc}{section}{Index}
\printindex

\end{document}


