% LaTeX 2e Document.
% 
% $Id: user_man.tex,v 1.12 2006/04/19 10:27:25 vdmtools Exp $
% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF compatibility code. 
\makeatletter
\newif\ifpdflatex@
\ifx\pdftexversion\@undefined
\pdflatex@false
%\message{Not using pdf}
\else
\pdflatex@true
%\message{Using pdf}
\fi

\newcommand{\latexorpdf}[2]{
  \ifpdflatex@ #2
  \else #1
  \fi
}

#ifdef A4Format
\newcommand{\pformat}{a4paper}
#endif A4Format
#ifdef LetterFormat
\newcommand{\pformat}{letterpaper}
#endif LetterFormat

\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\latexorpdf{
#ifdef ENG
\documentclass[\pformat,12pt]{article}
#endif ENG
#ifdef JPN
\documentclass[\pformat,12pt]{jarticle}
#endif JPN
}{
\documentclass[\pformat,pdftex,12pt]{article}
}

\usepackage[dvipdfmx]{graphicx, color}
\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}
\usepackage{alltt}
\usepackage{makeidx}
\usepackage{ifthen}
\usepackage{verbatim}
\usepackage{cite}

\usepackage{toolbox}
\usepackage{vdmsl-2e}

#ifdef VDMPP
\usepackage{vpp}
#endif VDMPP

\graphicspath{{figures/}}
\def\seename{$\Rightarrow$}

#ifdef JPN
\AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}}
#endif JPN

\makeindex

\def\vdmsl{{\small VDM-SL}}
\def\vdmpp{{\small VDM}++}
#ifdef VDMSL       %%%%%%%%%%%%%%%%%%%%%%%%%%%% new command for VDM-SL 
\newcommand{\vdmslpp}{VDM-SL}
\newcommand{\vdmslppEm}{VDM-SL}
\newcommand{\ToolboxName}{VDM-SL Toolbox}
\newcommand{\Toolbox}{Toolbox}
\newcommand{\toolbox}{Toolbox}
\newcommand{\vdmde}{vdmde}
\newcommand{\vdmgde}{vdmgde}
\newcommand{\vdmhome}{vdmhome}
\newcommand{\vdmdeNineteen}{vdmde}
\newcommand{\vdmdeNineteenEl}{vdmde.el}
\newcommand{\VdmSlPp}{\VdmSl}
\newcommand{\vdmext}{vdm}
#ifdef ENG
\newcommand{\vdmModView}{\guicmd{Module View}}
#endif ENG
#ifdef JPN
\newcommand{\vdmModView}{\guicmd{モジュールビュー}}
#endif JPN
#endif VDMSL   %%%%%%%%%%%%%%%%%%%%%%%%%%%%% new command for VDM-SL end
#ifdef VDMPP   %%%%%%%%%%%%%%%%%%%%%%%%%%% new command for VDM++
\newcommand{\vdmslpp}{VDM++}
\newcommand{\vdmslppEm}{VDM++}
\newcommand{\ToolboxName}{VDM++ Toolbox}
\newcommand{\Toolbox}{Toolbox}
\newcommand{\toolbox}{Toolbox}
\newcommand{\vdmde}{vppde}
\newcommand{\vdmgde}{vppgde}
\newcommand{\vdmhome}{vpphome}
\newcommand{\vdmdeNineteen}{vppde}
\newcommand{\vdmdeNineteenEl}{vppde.el}
\DeclareRobustCommand{\VdmSlPp}{VDM++-\VdmSl}
\newcommand{\vdmext}{vpp}
#ifdef ENG
\newcommand{\vdmModView}{\guicmd{VDM View}}
#endif ENG
#ifdef JPN
\newcommand{\vdmModView}{\guicmd{VDMビュー}}
#endif JPN
#endif VDMPP %%%%%%%%%%%%%%%%%%%%%%%%%% new vcommand for VDM++
\newcommand{\vdmtoolsver}{v9.0.6}
\newcommand{\cg}{\vdmslpp\ to C++ Code Generator}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}

#ifdef ENG
% The use of VDMSL/VDMPP ifdef's have basicly been exchanged with the
% use of LaTeX ifthenelse's.  For this two LaTeX boolean value VDMSL and
% VDMpp have been defined  (Lowercase p's are used to avoid conflict with
% the VDMPP environment variable.  The typical use are:
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{vdmpp-text}
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{}
%   \ifthenelse{\boolean{VDMpp}}{vdmpp-text}{}
% The advantage of this as opposed to ifdef's is that within a general
% paragraph specific VDM-SL and VDM++ parts can be distinguished without
% problematic empty lines.
% 
#endif ENG
#ifdef JPN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% translated comment by teramoto
% 基本的にVDMSL/VDMPPのifdefの使用はLaTeXのifthenelseの使用に置き換えられている。
% このため、二つのLaTeX　Boolean値VDMSL、VDMppが定義されている（pが小文字なのは環境変数
% VDMPPと区別するためである）使用方法は以下のとおり
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{vdmpp-text} ←本文ではほとんどこれが使われている
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{}
%   \ifthenelse{\boolean{VDMpp}}{vdmpp-text}{}
% ifdefに対し\ifthenelseを使うことの利点は、地の文中に問題を招く空行なしでVDM-SL やVDM++に特有の部分を
% 区別しつつ、埋め込むことができるところにある。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% translated comment by teramoto end
#endif JPN
% The values are initialised such that exactly one of the values is true
% and the other is false.  This should hopefully avoid strange behaviour
% due to possible preprocessing errors.  The default case is VDM-SL.
\newboolean{VDMsl}
\setboolean{VDMsl}{true}
\newboolean{VDMpp}
\setboolean{VDMpp}{false}
#ifdef VDMSL
\setboolean{VDMsl}{true}
\setboolean{VDMpp}{false}
#endif VDMSL
#ifdef VDMPP
\setboolean{VDMpp}{true}
\setboolean{VDMsl}{false}
#endif VDMPP

% This macro can be used in `description' lists where
% the item given to `meti' is put on its own line,
% thereby giving proper (nicer) identation to the
% explanation.
\newcommand{\meti}[1]{\item[#1]\mbox{}\\}

\newcommand{\Index}[1]{#1\index{#1}}

\newcommand{\Lit}[1]{`#1\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\ \ \= = \ \ \= #2  ; %    Adds production rule to index
  \end{tabbing}\end{quote}
  }
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{\Lit{\kw{#1}}}
\newcommand{\Sig}[1]{\Lit{{\tt #1}}}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}

%\usepackage[]{color}
\usepackage{longtable}
\usepackage{float}
\definecolor{covered}{rgb}{0,0,0}     %black
\definecolor{not_covered}{gray}{0.5}  %gray

%\restylefloat{figure}
\setcounter{topnumber}{3}
\def\topfraction{1.0}
\setcounter{bottomnumber}{3}
\def\bottomfraction{1.0}
\setcounter{totalnumber}{3}
\def\textfraction{.1}


\parindent0mm

\newlength{\keywwidth}

\newcommand{\xfigpicture}[4]{
\begin{figure}[hbt]
\setlength{\unitlength}{1mm}
\begin{center}
\mbox{
\begin{picture}(#1,#2)
\put(0,0){\special{psfile=#3 hscale=70 vscale=55}}
\end{picture} }
\end{center}
\caption{#4}
\end{figure}
}

%\newcommand{\qq}{\marginpar{\bf ???}}
\newcommand{\aaa}{\tt }
\newcommand{\cmd}{\tt }
#ifdef ENG
\newcommand{\guicmd}[1]{{\sf #1}}
#endif ENG
#ifdef JPN
\newcommand{\guicmd}[1]{{\gt #1}}
#endif JPN
\newcommand{\keyw}[1]{{\sf #1}}
%\newcommand{\id}[1]{%
%  \settowidth{\keywwidth}{\tt #1}%
%  \protect\makebox[\keywwidth][l]{{\it #1}}}
%\nolinenumbering

\begin{document}
#ifdef VICEMAN
#ifdef ENG
\vdmtoolsmanualcsk{VDMTools User Manual (VDM++ VICE)}
#endif ENG
#ifdef JPN
\vdmtoolsmanualcsk{VDMTools ユーザマニュアル (VDM++ VICE)}
#endif JPN
#else
#ifdef ENG
\vdmtoolsmanualcsk{VDMTools User Manual (\vdmslpp)}
#endif ENG
#ifdef JPN
\vdmtoolsmanualcsk{VDMTools ユーザマニュアル (\vdmslpp)}
#endif JPN
#endif VICEMAN
       {\vdmtoolsver}
       {2016}
       {\vdmslpp}
#ifdef VICEMAN
       {1.0 beta}
#else
       {1.0}
#endif VICEMAN

#ifdef ENG
\section{Introduction} \label{introduction}
#endif ENG
#ifdef JPN
\section{はじめに} \label{introduction}
#endif JPN

%This manual presents an introduction to the \vdmslpp\ \Toolbox.

#ifdef ENG
\VDMTools\ is a set of tools that allows you to develop and analyse
precise models of computing systems. When used in the early stages of
system development, these models can serve as system specifications,
or as an aid in checking the consistency and completeness of user
requirements. The models are expressed either in the ISO VDM-SL
standard language \cite{ISOVDM96}\index{VDM Standard} or in the
object-oriented formal specification language VDM++
\cite{LangManPP-CSK,Fitzgerald&05}. This manual describes the \vdmslpp\ Toolbox, which
provides a range of tools for automatic checking and validation of
models expressed in \vdmslpp\ 
prior to implementation. These range from traditional syntax and type
checking tools to a powerful interpreter that executes models on
request and performs automatic consistency checking during execution.
The execution facilities support the use of testing techniques in
early analysis and design and allow execution of entire test suites in
line with established software engineering practice.  Moreover, the
interpreter enables interactive debugging of models by setting
breakpoints, stepping through statements and expression evaluations,
inspecting the call stack, and checking the values of variables in
scope.

This document provides an introduction and reference manual to the
\vdmslpp\ Toolbox (called the \Toolbox\ in the remainder of the
document). The \vdmslpp\ language is described in the separate
language reference manual
\ifthenelse{\boolean{VDMsl}}{\cite{LangMan-CSK}}{\cite{LangManPP-CSK}}. In the
remainder of this manual we use the term {\em specification\/} to
refer to any model constructed in the language for whatever purpose.
#endif ENG

#ifdef JPN
\VDMTools\ はコンピュータシステムの精巧なモデルを開発・分析するツールである。
システム開発の早期に導入すれば、これらのモデルはシステム仕様として、
あるいはユーザの要求の網羅性や整合性のチェックを助けるものとして役立つ。
モデルはISO VDM-SL 標準言語~\cite{ISOVDM96}\index{VDMひょうじゅん@VDM標準}
あるいはオブジェクト指向形式仕様言語VDM++\cite{LangManPP-CSK}\cite{Fitzgerald&05}によって表現される。
このマニュアルでは \vdmslpp\ ツールボックスに関して記述するが、
このツールは 実装に先立ち、\vdmslpp\ で表現されたモデルの自動チェックと検証をするためのツールである。
その範囲は古くからある構文と型のチェックツールから、必要に応じてモデルを実行する強力なインタープリタにまで及び、
実行中は自動的に整合性チェックを実行する。実行しやすいので分析・設計の早期からテスト技術の利
用が可能であり、確立したソフトウェアエンジニアリングの慣習に沿ってテスト全体を実行することが出来る。
そのうえ、このインタープリタではブレイクポイントの設定、命令文のステップ実行、
表現の評価、コールスタックの調査、スコープにおける変数の値のチェックなど、
モデルのインタラクティブなデバッグが可能である。

本ドキュメントには \vdmslpp\ ツールボックス（この文書では \Toolbox\ と呼ぶ）の紹介とリファレンスマニュアルを記載する。
\vdmslpp\ 言語には別に言語マニュアルがある。
\ifthenelse{\boolean{VDMsl}}{\cite{LangMan-CSK}}{\cite{LangManPP-CSK}}.
このマニュアルでは、{\em 仕様\/}という言葉は目的を問わず本言語で構成されたすべてのモデルを指すものとして使う
#endif JPN

#ifdef ENG
\subsection*{VDM Input Formats}\index{Input!Formats}
#endif ENG
#ifdef JPN
\subsection*{VDM入力フォーマット}\index{インプット!フォーマット}
#endif JPN

#ifdef ENG
The \Toolbox\ supports \vdmslpp\ specifications embedded in either
Microsoft Word or \LaTeX\ documents so that it is possible to analyse
specifications without having to extract them into a special file. We
recommend the use of either one of these two approaches as an
excellent way of combining the model of a system with its
documentation. Having just one version of the specification helps to
avoid inconsistencies arising between working and documented versions
of the specification. If you would rather not use Word or \LaTeX, you
can of course write specifications as clear text in plain ASCII files
using your preferred text editor.

The \Toolbox\ supports input documents in a range of different
languages and scripts\index{Input!Multilingual}. 
Appendix~\ref{sec:multiling} explains how to 
configure the \Toolbox\ for different scripts. 

If you use Microsoft Word to write your \vdmslpp\ specifications, you
should save the documents containing specifications in {\em rich text
  format\/}~(RTF). The \Toolbox\ distribution contains example files in
this format. Throughout this manual, you will see examples using files
from the \Toolbox\ distribution. The names of such example files are
followed by the extension ``{\tt .rtf}'', indicating that they are in
rich text format. 

In this manual we will normally introduce features of the \Toolbox\ 
using Word and RTF.  If you use the \LaTeX\ text processing system to
write your specifications, then note that the \Toolbox\ expects input
containing \LaTeX\ commands mixed with VDM specifications using the
style and format described in Appendix~\ref{sec:latexANDvdm}. The
\Toolbox\ distribution also contains example files in this format,
indicated by the filename extension ``{\tt .\vdmext}'' rather than
``{\tt .rtf}''.  Thus, if an example refers to a file called {\tt
  sort.rtf}, you should instead use the file {\tt
  sort.\vdmext}. References to a directory structure are shown
throughout this manual in the form {\tt examples/sort.vdm} (i.e.\ with a
forward slash)   unless the reference is only relevant under Windows
in which case  it is shown as \verb+examples\sort.vdm+ (i.e.\ with a
backward slash).

If you prefer to write specifications as plain text ASCII files, 
note that the only way to incorporate explanatory text into your
specification is by means of the \vdmslpp\ comment syntax, described
in the Language Manual. Files prepared in this format are normally
given a ``{\tt .\vdmext}'' extension.
#endif ENG

#ifdef JPN
本 \Toolbox\ はMS Wordまたは \LaTeX\ のどちらかの文書を組み込んだ \vdmslpp\ の仕様をサポートしているので、
仕様書の分析をする際に特別なファイルを作成することなく行うことができる。
ドキュメントを使ってシステムのモデルを組み合わせるよい方法として
これらの2つのアプローチのうちどちらかを使用することを推奨する。
作成された仕様書のバージョンと実務の不整合を避けるために、
仕様の形式はどちらかに統一したほうがよい。
Wordも \LaTeX\ も好みでなく、テキストエディタがお好みの場合は
もちろんASCIIのみで書かれたテキストを仕様書として書くことも出来る。

本 \Toolbox\ は異なる言語やスクリプトも入力文書としてサポートしている。
付録~\ref{sec:multiling}\index{インプット!たげんご@他言語}
で異なるスクリプトで \Toolbox\ がどのように構成されるか説明している。

\vdmslpp\ の仕様を書くためにMS Wordを利用するならば、VDM++による仕様記述を含む文書を
{\em Rich Text Format\/}~(RTF)フォーマットで保存しなくてはならない。
\Toolbox\ には、このフォーマットでのサンプルファイルが含まれる。
このマニュアルで、\Toolbox\ に含まれるファイルを使った例を見ることができる。
ファイル名が拡張子.rtfのファイルがサンプルファイルで、これがリッチテキストフォーマット
であることを示している。

このマニュアルでは、通常\Toolbox\ の機能をWordかRTFで紹介する。
仕様を書くのに\LaTeX\ を使う場合、\Toolbox\ 上、入力文書が
付録~\ref{sec:latexANDvdm}に書かれているフォーマットとスタイルを使った、\LaTeX\ 
のコマンドとVDM仕様とが混ざり合ったものと想定されていることに注意してほしい。
\Toolbox\ にはこのフォーマットでもサンプルファイルが入っているが、
拡張子は``{\tt .rtf}''ではなく``{\tt .\vdmext}''である。そのため、例が{\tt
  sort.rtf}というファイルを
参照していた場合、代わりに{\tt
  sort.\vdmext}というファイルを使わなくてはいけない。ディレクトリ構造の参照はこのマニュアルを
通じて以下のような形式で示される。

{\tt examples/sort.vdm} (スラッシュ区切り)  
Windowsでは\verb+examples\sort.vdm+ (英語ではバックスラッシュ区切り).と同じ
である。

ASCII形式のテキストファイルで仕様を記述した場合、テキストの説明文を
（VDM++の）仕様書に組み込む唯一の方法は言語マニュアルに記載されている
\vdmslpp\ コメント構文を用いることだ。このフォーマットについては通常拡張子
``{\tt .\vdmext}''でファイルが用意されている。
#endif JPN

#ifdef ENG
\subsection*{Using This Manual}
#endif ENG
#ifdef JPN
\subsection*{このマニュアルの使い方}
#endif JPN

#ifdef ENG
This manual is divided into three parts. Sections~\ref{sec:overview}
and~\ref{sec:guidedtour} provide an overview of the various tools in
the \Toolbox\ and a ``hands-on'' tutorial introduction to using the
\Toolbox\ via its graphical user interface.  Before working through
this part of the manual the \Toolbox\ should be installed and the
environment variables required should be set~(see
Appendix~\ref{sec:set_env}). The installation of the \Toolbox\ is
described in the document
\ifthenelse{\boolean{VDMsl}}{\cite{InstallMan-CSK}}{\cite{InstallPPMan-CSK}}.
As you work through Section~\ref{sec:guidedtour}, you will get to know
the various tools and control commands available to you.

The second part of the manual~(Section~\ref{sec:ref}) is a reference
guide covering all the features of the \Toolbox\ systematically. All three
available interfaces -- the command line interface, the Emacs interface
and the graphical user interface -- are described for each feature.

The third part of the manual consists of appendices on a range of
topics. 
%Appendix~\ref{ifadsupport} explains how to contact IFAD for support for the \Toolbox.
 Appendix~\ref{sec:vdmlinks} includes
pointers to information resources for VDM, including internet sites,
project descriptions, technical papers and books.
Appendix~\ref{sec:latexANDvdm} explains how you merge text and
specification in \LaTeX\ documents.

% \ifthenelse{\boolean{VDMsl}}{}{Appendix~\ref{sec:inheritex} presents a small
%   example used for illustration purposes in the reference part of this
%   manual.} 
Appendix~\ref{sec:set_env} describes which environment
variables and options can be set for the \Toolbox.
Appendix~\ref{getting-started} describes the Emacs interface.
Appendix~\ref{sec:testscript} presents a few test scripts used for
systematic testing of the sorting specification which is used as a
running example in this manual. \ifthenelse{\boolean{VDMsl}}{And}{} 
Appendix~\ref{sec:trouble} offers some possible solutions 
to common problems encountered when using the \Toolbox\ in conjunction
with Microsoft Word. \ifthenelse{\boolean{VDMsl}}{}{And 
Appendix~\ref{sec:priorityfile} describes the format for defining
priority files for use with the interpreter.} 
#endif ENG

#ifdef JPN
このマニュアルは3つの部分に分かれる。セクション~\ref{sec:overview}と~\ref{sec:guidedtour} は
\Toolbox\ のさまざまなツールの概略とGUIを利用した\Toolbox\ のチュートリアルを提供する。
マニュアルのこの部分を実際に試してみる前に、\Toolbox\ がインストールされていなくては
ならない（付録~\ref{sec:set_env}参照）。\Toolbox\ のインストールについてはこの文書に記述される
\ifthenelse{\boolean{VDMsl}}{\cite{InstallMan-CSK}}{\cite{InstallPPMan-CSK}}。
セクション~\ref{sec:guidedtour}を読み進むにつれ、さまざまなツールや制御コマンドを利用できることが
わかるだろう。

第2のパート~(セクション~\ref{sec:ref})は、\Toolbox\ のシステム的なすべての機能を
カバーするリファレンスガイドである。
3つの利用可能なインターフェースすべて(コマンドラインインターフェース、Emacsインターフェース、
GUI)について、それぞれの機能を記述してある。

このマニュアルの第3のパートは一連のトピックスについての付録で構成されている。
付録~\ref{sec:vdmlinks}はVDMの情報源について記載されているが、これにはインターネットのサイト、
プロジェクトの記述、技術論文や参考文献が含まれている。付録\ref{sec:latexANDvdm}では\LaTeX\ の文書
でどのようにテキストと仕様をマージするかを説明している。

付録~\ref{sec:set_env}では環境を\Toolbox\ 向けにどう設定するかが記述されている。
付録~\ref{getting-started}ではEmacsインターフェースについて。
付録~\ref{sec:testscript}にはSort仕様（このマニュアルで実行可能な例として使われている）
のシステムテストに使うテストスクリプトがいくつか含まれている。\ifthenelse{\boolean{VDMsl}}{そして}{}
付録~\ref{sec:trouble} では\Toolbox\ を使っていると見られるMicrosoft Wordにおいての一般的な問題について、
考えうる解決策をいくつか提供している\ifthenelse{\boolean{VDMsl}}{}
{そして付録~\ref{sec:priorityfile}ではインタープリタで使うファイルの優先順位の定義用の
フォーマットが記述されている。}
#endif JPNP

\newpage

#ifdef ENG
\section{\protect\VDMTools\ Overview}\label{sec:overview}
#endif ENG
#ifdef JPN
\section{\protect\VDMTools\ 概略}\label{sec:overview}
#endif JPN

#ifdef ENG
A \vdmslpp\ specification is a document which aims to describe the
properties of a system in a precise way. The specification can be
distributed among several files in the input formats described in
Section~\ref{introduction}.  Figure~\ref{fig:toolbox} provides an
overview of the functionality of the \Toolbox\ and its additional
features. The various tools are described below:
#endif ENG

#ifdef JPN
\vdmslpp\ 仕様はシステムの特性を精巧な方法で記述することを目的としたドキュメントである。
この仕様はセクション~\ref{introduction}で記述されている入力フォーマットで書かれたいくつかのファイルに
分散される。図~\ref{fig:toolbox}は\Toolbox\ の機能の概要とその付属的な機能を示したものである。
ツールについては下記に記述する。
#endif JPN

\begin{figure}
\begin{center}
%\scalebox{.7}
%#ifdef VDMSL
%\includegraphics{vdmtools_sl}}
%#endif VDMSL
%#ifdef VDMPP
%{\includegraphics{vdmtools_pp}}
%#endif VDMPP
%#ifdef ENG
%\caption{Overview of \protect\VDMTools\label{fig:toolbox}}
%endif ENG
%#ifdef JPN
%\caption{\protect\VDMTools\ 概略\label{fig:toolbox}}
%#endif JPN

#ifdef VDMSL
\includegraphics[width=10cm]{vdmtools_sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=10cm]{vdmtools_pp.png}
#endif VDMPP
#ifdef ENG
\caption{Overview of \protect\VDMTools}
#endif ENG
#ifdef JPN
\caption{\protect\VDMTools\ 概略}
#endif JPN
\label{fig:toolbox}
\end{center}
\end{figure}

\begin{description}
  
#ifdef ENG
\item[Specification Manager] The specification manager keeps track of
  the status of \ifthenelse{\boolean{VDMsl}}{modules}{classes} in the
  specification, which may be spread across several files.
 
\item[Syntax Checker:] The syntax checker checks whether the syntax of
your \vdmslpp\ specification is correct with respect to the definition
of the \vdmslpp\ language. If the syntax is accepted it gives access
to the other tools in the \Toolbox.

\item[Type Checker]
  The type checker contains a powerful type inference mechanism which
  identifies mis-uses of values and operators and which can also show all
  places where run-time errors could occur.

\item[Interpreter and Debugger] The interpreter allows you
  to execute all the executable constructs in \vdmslpp. These range
  from simple value builders like set comprehension and sequence
  enumeration to more advanced constructs like exception handling,
  lambda expressions, loose expressions and pattern matching%
  \ifthenelse{\boolean{VDMpp}}{, or even multithreaded models}{}%
.  One of
  the benefits of executing specifications is that testing techniques
  can be used to assist in their validation. In the development
  process small or large parts of a specification can be executed to
  enhance the designer's knowledge of and confidence in the
  specification. Furthermore, an executable specification can form a
  running prototype.

% \item[Debugger]
  A source-level debugger is an essential aid when working
  with executable specifications. The \vdmslpp\ debugger supports the
  functionality found in debuggers for ordinary programming languages,
  including setting breakpoints, stepping, inspection of variables
  defined in the scope, and inspection of the call stack. 

\item[Integrity Examiner] The integrity examiner extends the static
  checking capabilities of the \vdmslpp\ Toolbox by scanning through
  specifications checking for potential sources of internal
  inconsistencies or integrity violations. The checks include the
  violation of data type invariants, preconditions,  postconditions,
  sequence bounds and map domains. Each \emph{integrity property} is 
  presented as a \vdmslpp\ expression which should evaluate to true --
  if it instead evaluates to false this indicates that there is a
  potential problem with the corresponding part of the specification. 

\item[Test Facility] The test facility allows you to exercise your
  specification using a predefined set of tests called a {\em test
    suite\/}. Test coverage information can be automatically recorded
  during execution of a test suite and presented back to the
  specifier, indicating which parts of the specification are most
  frequently evaluated and which parts have not been covered at all.
  The test coverage information is displayed directly in the source
  file which can be a Microsoft Word or \LaTeX\ document depending
  upon the input format used.

\item[Automatic Code Generator] The \Toolbox\ supports automatic
  generation of \ifthenelse{\boolean{VDMsl}}{C++}{C++ and Java} code
  from \vdmslpp\ specifications\footnote{You must have a separate Code
    Generator license to use this facility.}, helping to achieve
  consistency between specification and implementation. The code
  generator produces fully executable code for 95\%\ of all \vdmslpp\
  constructs, and there are facilities for including user-defined code
  for non-executable parts of the specification.  Once a specification
  has been tested, the code generator can be applied to obtain a rapid
  implementation automatically. The use of the C++ Code Generator is
  described in the document
  \ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}% 
#ifdef VDMPP
\ and the use of the Java Code Generator is described in the document
\cite{CGJavaManPP-CSK}%
#endif VDMPP
.

#ifdef VDMSL
\item[Dynamic Link Facility] This add-on\footnote{You must have a
    separate license to use the Dynamic Link facility.} feature of the
  \Toolbox\ makes it possible to integrate external code into the
  execution of a specification.  This can be used to integrate a
  formal model with components developed in a traditional way and
  provide graphical front-ends for a model.  
#endif VDMSL

\item[Corba Compliant API] The \Toolbox\ provides a Corba compliant
  Application Programmer Interface~(API) which allows other programs
  to access a running \Toolbox. This enables external control of the
  the \Toolbox\ components such as the type checker, interpreter and
  debugger. The API allows any code such as a graphical front-end or
  existing legacy code to control the \Toolbox.

#ifdef VDMPP
\item[Rose-\vdmpp\ Link] The Rose-\vdmpp\ link integrates UML and
  \vdmpp.  It provides a bi-directional translation which gives a
  tight coupling between the \Toolbox\ and Rational Rose. Hence the
  link supports round trip engineering between UML and \vdmpp, where
  the graphical notation is used to provide the structural,
  diagrammatic overview of a model while the formal notation is used
  to provide the detailed functional behaviour. The use of
  the Rose-\vdmpp\ link is described in the document \cite{UMLMan-CSK}.

\item[Java to \vdmpp\ Translator] This feature allows existing legacy Java
  applications to be reverse engineered to \vdmpp. Analysis of the
  application can then be performed at the \vdmpp\ level and new
  features can be specified. Finally, the new specification can be
  translated back to Java. The use of the Java to \vdmpp\ Translator
  is described in \cite{Java2VDMMan-CSK}.
#endif VDMPP
#endif ENG

#ifdef JPN
\item[マネージャー] いくつかのファイルに分かれている仕様書における\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}
の状態トラックを保持する。

\item[構文チェック機能:] \vdmslpp\ 言語の定義的に\vdmslpp\ の仕様書の構文が正しいか
どうかチェックする。構文が受け入れられれば、\Toolbox\ 内の他ツールでも大丈夫である。

\item[型チェック機能]
  強力な型推測メカニズムを持ち、値や演算子の誤用を特定する。
またランタイムエラーの起こりうる箇所も示す。

\item[インタープリタとデバッガ] インタープリタは\vdmslpp\ で実行可能な構成物すべてを実行する。
その範囲は集合内包や列の列挙など単純な構成子からより進化した構成物
（例外の扱い、ラムダ表現、ルーズな表現やパターンマッチング\ifthenelse{\boolean{VDMpp}}{、マルチスレッドモデルまでも}{}）
にも及ぶ。仕様を実行することの利点の一つは、テスト技術がこれらの検証に役立つということだ。
開発プロセスにおいて、仕様書の小（大）部分が設計者の理解と自信を深めるのに有効である。
その上、実行可能な使用は実行プロトタイプを形成する。

ソースレベルのデバッガは実行可能な仕様を用いて仕事をする上で必要不可欠な機能である。
\vdmslpp\ デバッガは通常のプログラミング言語向けのデバッガのような機能をサポートするが、
これにはブレイクポイントの設定、ステップ実行、スコープ内で定義された変数の値チェック、
コールスタックのチェックなどが含まれる。

\item[証明課題生成機能] 証明課題生成機能は仕様書全体をスキャンして内的矛盾点や
整合性を侵害しうる潜在的なソースをチェックする、\vdmslpp\ ツールボックスの静的チェックの
可能性を拡張したものである。データ型の不変条件、事前条件、事後条件、
シーケンス境界やmapドメインの違反チェックが含まれる。\emph{証明課題}は\vdmslpp\ の式で
はtrueと評価され、表される。（－もし変わりにfalseと評価されていたら、それは仕様書の相当する箇所に
潜在的な問題があることを示している）

\item[テスト機能] テスト機能では{\em テストスイート\/}と呼ばれる未定義のテストセットを
使って仕様の実行が可能である。テストカバレッジ情報はテストスイートの実行中自動的に記録され、
特定できる箇所まで戻って表現されるが、これは仕様書の一部において頻繁に評価されるところと
全くカバーされていないところを示すものである。テストカバレッジ情報は使用されている形式
（Wordまたは\LaTeX\ ）で書かれたソースファイル文書に直接表示される。

\item[自動コード生成] ToolboxはVDM++の仕様書からの\ifthenelse{\boolean{VDMsl}}{C++}{C++とJava}の
自動コード生成をサポートしているが、この機能により仕様と実装の間に一貫性が出る。
コード生成は\vdmslpp\ の構成物の95\%\ から実行可能なコードを生成する。仕様の
実行不可能な箇所向けの、ユーザによる定義コードを含む機能も併せ持つ。
いったん仕様がテストされれば、コード生成を自動的で迅速な実装を実現するために適用することができる。C++のコード生成機能の使い方は
本ドキュメント\ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}に記載されている。
Javaのコード生成機能の使い方は本ドキュメントに記載されている。
  \ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}% 
#ifdef VDMPP
\ そしてJavaコード生成の使い方は本ドキュメント
\cite{CGJavaManPP-CSK}に記載されている。
#endif VDMPP

#ifdef VDMSL
\item[動的リンク機能]　この\Toolbox\ のアドオン機能は\footnote{動的リンク機能を
利用するには別ライセンスが必要である} 外部のコードを仕様の実行に加えることを可能にする。
この機能は伝統的な方法で開発されたコンポーネントで構成される形式モデルを結合し、
モデルにグラフィカルなフロントエンドを提供するのに使われる。
#endif VDMSL

\item[Corba対応API] \Toolbox\ はCorba対応APIを提供しており、これにより
実行中の\Toolbox\ に他のプログラムがアクセスできる。これは型チェック機能やインタープリタ、
デバッガなどの\Toolbox\ のコンポーネント外からの制御を可能にするものである。
APIはまたグラフィカルなフロントエンドやツールボックスを制御するレガシーコードなど、どんなコード
でも可能にする。

#ifdef VDMPP
\item[Rose-\vdmpp\ リンク] Rose-\vdmpp\ リンク はUMLと\vdmpp\ を結びつける。
\Toolbox\ とRational Roseを緊密に結びつける双方向の翻訳を提供する。
ゆえにこのリンクはUML と\vdmpp のラウンドトリップエンジニアリングをサポートし、
形式的な記述が機能の詳細な振る舞いを記述するのに使われる一方で、
グラフィカルな記述が構造的でダイアグラムを利用したモデルの概略を提供するのに使われる。
Rose-\vdmpp\ リンクについてはドキュメント\cite{UMLMan-CSK}に記述されている。

\item[Javaから\vdmpp\ への変換ツール] この機能は現存するJavaアプリケーションを
\vdmpp にリバースエンジニアリングするものである。アプリケーションの分析が\vdmpp レベルで
実行され、新たな機能が特定される。最終的に、新たな仕様書がJavaから翻訳される。
Javaから\vdmpp への変換ツールの使い方は\cite{Java2VDMMan-CSK}に記述されている。
#endif VDMPP
#endif JPN

\end{description}

\newpage

#ifdef ENG
\section{A Guided Tour of the \protect\VDMTools} \label{guistart}
\label{sec:guidedtour}
#endif ENG
#ifdef JPN
\section{\protect\VDMTools ガイドツアー } \label{guistart}
\label{sec:guidedtour}
#endif JPN

#ifdef ENG
This section provides a ``guided tour'' of the \Toolbox.  If you are
new to the principles of system modelling in VDM, we recommend that
you should first read either ``{\it Modelling Systems: Practical Tools and Techniques in
Software Development}''~\cite{Fitzgerald&98b}, by John Fitzgerald and
Peter Gorm Larsen or ``{\it Validated Designs for Object--oriented
Systems}''~\cite{Fitzgerald&05}. These are both tutorial books which 
includes many
examples built around VDM specifications which can be explored using
the \Toolbox. \cite{Fitzgerald&98b} is using the ISO standard VDM-SL
notation whereas \cite{Fitzgerald&05} is using the object-oriented
extension called \vdmpp. 
If you do have some knowledge about these general concepts,
\ifthenelse{\boolean{VDMsl}}{but are unfamiliar with the standard
  notation}{but are unfamiliar with the object-oriented extensions in
  \vdmslpp}, we recommend that you review the \vdmslpp\ language
reference manual ``{\it The  \vdmslpp\ Specification Language}''
\ifthenelse{\boolean{VDMsl}}{\cite{LangMan-CSK}}{\cite{LangManPP-CSK}}.
#endif ENG

#ifdef JPN
このセクションでは、\Toolbox\ の「ガイドツアー」を記述する。VDMのシステムモデリングを新たに学ぶ人は、
``{\it ソフトウェア開発のモデル化技法}''~\cite{Fitzgerald&98b}, J.フィッツジェラルド、P.G.ラルセン著、
または、``{\it Validated Designs for Object--oriented Systems}''~\cite{Fitzgerald&05}
を最初に読むことをお勧めする。
これらのチュートリアルブックは、\Toolbox\ を使うことによって生み出されるであろう
VDM仕様を使って作られたさまざまな例を含む。
\cite{Fitzgerald&98b} is using the ISO standard VDM-SL
notation whereas \cite{Fitzgerald&05} is using the object-oriented
extension called \vdmpp. 
これらの一般的な概念を知っているが、
\ifthenelse{\boolean{VDMsl}}{
%%%%%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
標準的な記法に詳しくない人
% for VDM-SL description end
}
{
% for VDM++ description 
\vdmslpp\ でオブジェクト指向向けに拡張された部分に詳しくない人
% for VDM++ description end
%%%%%%%%%%%%%%%%%%%%%%%% comment by teramoto end
}
には、\vdmslpp\ の言語リファレンスマニュアルである``{\it The  \vdmslpp\ Specification Language}''
\ifthenelse{\boolean{VDMsl}}{\cite{LangMan-CSK}}{\cite{LangManPP-CSK}}を一読すること
をお勧めする。
#endif JPN

#ifdef ENG
\subsection{Creating Input to \protect\VDMTools}\index{Input!Creating}
#endif ENG
#ifdef JPN
\subsection{\protect\VDMTools への入力物を作成する}\index{インプット!さくせい@作成}
#endif JPN

#ifdef ENG
In order to use the \Toolbox\ it is necessary to produce a \vdmslpp\ 
specification. In this section we illustrate how to do that using
Microsoft Word in the rich text format (RTF) on a simple sorting
example. If you alternatively prefer using \vdmslpp\ combined with
\LaTeX\ you should consult Appendix~\ref{sec:latexANDvdm}\footnote{It
  is also possible to use plain ASCII \vdmslpp.}. In the remainder of
this section we assume some basic familiarity with Microsoft Word.

Start Microsoft Word by selecting it from the programs entry in the
Windows setup under Windows. Open the
\ifthenelse{\boolean{VDMsl}}{{\tt \vdmhome/examples/sort/sort.rtf}
  file}{{\tt \vdmhome/examples/sort/MergeSort.rtf} file} from the
\Toolbox\ distribution. Reading through this file, you will see that
the document is a mixture of explanatory text and a formal model in
\vdmslpp. All the formal parts are written in the style \texttt{VDM}.
You may not change the formatting of the text in the VDM style
directly in the source text. The pretty-printer will put VDM keywords
in the boldface font anyway. If you wish, you can modify the
appearance of this style, so long as the style's name is not changed:
the \Toolbox\ will only analyse those parts of the document written in
the \texttt{VDM} style.

A definition of the styles which are used by the \Toolbox\ inside
Microsoft Word can be found in the {\tt VDM.dot} file \index{VDM.dot file} 
from the \Toolbox\ distribution. This file can be copied to your template
directory (
\verb+C:\Program Files\Microsoft Office\Templates+ normally)
so that these style definitions will be included if you
select this template when a new document is started (there are also
various ways in which the definitions can be copied into the template
file you normally use).

Now look at the end of the \ifthenelse{\boolean{VDMsl}}{{\tt sort.rtf} file}%
{{\tt MergeSort.rtf}} document.
#ifdef VDMSL
You will see that there is an empty line typeset in the
style \texttt{VDM\_TC\_TABLE}.
#endif VDMSL
#ifdef VDMPP
You will see that the name of the class {\tt MergeSort} is
written in the style \texttt{VDM\_TC\_TABLE}.
#endif VDMPP
We will come back to the
usage of this when we discuss how to record and display test coverage
information. The styles \texttt{VDM\_COV} and \texttt{VDM\_NCOV} are
also used in connection with test coverage information. We will also
come back to these styles later.

If you wish to gain more experience with using Microsoft Word for
producing your input to the \Toolbox\ we recommend that you try to
read in some of the other examples from the \Toolbox\ distribution
after completing this guided tour.
#endif ENG

#ifdef JPN
\Toolbox\ を使用するためには、\vdmslpp\ の仕様を書いておく必要がある。
このセクションでは、シンプルなソートのサンプルを作成することを通じて、
MS Wordのリッチテキストフォーマットを使用した方法を記述する。\LaTeX\ 文書を
使いたい場合は、付録~\ref{sec:latexANDvdm}\footnote{ASCIIのみの\vdmslpp を
使用することも可能}を参照のこと。
このセクションでは、MS Wordを使用すると想定していることを覚えておいてほしい。

MS Wordを起動して、\Toolbox\ から
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
{\tt \vdmhome/examples/sort/sort.rtf}
  ファイル
% for VDM-SL description 
}
{
% for VDM++ description 
{\tt \vdmhome/examples/sort/MergeSort.rtf} ファイル
% for VDM++ description end
%%%%%%%%%%%%%%%%%%%% comment by teramoto end
}を開く。このファイルを一通り読めば、
このドキュメントが説明文と\vdmslpp 形式のモデルであることがわかるはずだ。形式の部分は
\texttt{VDM}スタイルですべて書かれている。
VDMスタイルの文書から直接元の文書に戻すのはおそらく無理だろう。通常のプリンタはVDM
のキーワードを太字のフォントで印刷する。このスタイルの外観を修正することはできるが、
スタイルの名前は変えられない。なぜなら\Toolbox\ が\texttt{VDM}スタイルで書かれた
文書の部分だけを解析するからである。

\Toolbox\ 内で使用されるスタイルの定義は\Toolbox\ の中にある{\tt VDM.dot}ファイル（Word形式）
\index{VDM.dotファイル}に記述されている。このファイルはテンプレートディレクトリ（通常は
\verb+C:\Program Files\Microsoft Office\Templates+ ）に
コピーされるので、新しくドキュメントを作成した場合にテンプレートを選択すると（普通に使用していれば、
このほかにもさまざまな方法でテンプレートディレクトリにスタイル定義がコピーされる）これらのスタイルの定義が
含まれることになる。

\ifthenelse{\boolean{VDMsl}}{{\tt sort.rtf} ファイル}%
{{\tt MergeSort.rtf} ファイル}の最後を見てみよう。
#ifdef VDMSL
\texttt{VDM\_TC\_TABLE}形式の空の行があるのがわかるだろう。
#endif VDMSL
#ifdef VDMPP
クラス名MergeSortが\texttt{VDM\_TC\_TABLE}の形式で書かれているのがわかるだろう。
#endif VDMPP
この使い方は後でテストカバレッジ情報の記録・表示方法についての話をするときに詳しく述べる。
この\texttt{VDM\_COV} および \texttt{VDM\_NCOV} 形式はテストカバレッジの情報と
関連付けるときにも使われる。
これらの形式についても後ほど述べる。

さらにMS Wordを使用して\Toolbox\ への入力物を作成する経験を積む場合は、
「ガイドツアー」を終えた後に\Toolbox\ 内のほかのサンプルファイルを読むことをお勧めする。
#endif JPN


#ifdef VDMSL
#ifdef ENG
\subsection{Starting the VDM-SL Graphical User Interface}\index{Graphical User Interface!Starting} 
#endif ENG
#ifdef JPN
\subsection{GUIでVDM-SLを始める}\index{GUI!スタート} 
#endif JPN
#endif VDMSL
#ifdef VDMPP
#ifdef ENG
\subsection{Starting the VDM++ Graphical User Interface}\index{Graphical User Interface!Starting} 
#endif ENG
#ifdef JPN
\subsection{GUIでVDM++を始める}\index{GUI!スタート} 
#endif JPN
#endif VDMPP

#ifdef ENG
The \Toolbox\ is normally used via its graphical user interface. Before
starting this interface, VDM source files should be copied into a
working directory. The \Toolbox\ distribution contains a specification
of different sorting algorithms, a presentation of which can be found
in the technical report
\ifthenelse{\boolean{VDMsl}}{\cite{SortEx-CSK}}{\cite{SortExpp-CSK}}.  During
this guided tour we will use this sorting specification as our running
example, so copy the directory {\tt \vdmhome/examples/sort} from the
\Toolbox\ distribution and {\tt cd} to it.  This will enable you to
try the tools in the \Toolbox\ directly on your computer while you are
following the tour.

The \Toolbox\ is started by selecting it from the ``Program Files''
entry in the Windows start menu or with the command {\tt \vdmgde}
\index{vdmgde command} on Unix platforms. The \Toolbox\ 
will start up as shown in Figure~\ref{fig:startgui}. This window is
called the {\em main window\/} of the \Toolbox.
#endif ENG

#ifdef JPN
\Toolbox\ は通常GUIを使う。GUIを使い始める前に、VDMのソースファイルがワーキングディレクトリ
にコピーされていなければならない。\Toolbox\ は異なる種類のソートアルゴリズムの仕様を含んでいるが、
これはテクニカルリポート\ifthenelse{\boolean{VDMsl}}{\cite{SortEx-CSK}}{\cite{SortExpp-CSK}}に書かれて
いるとおりである。このガイドツアーでは、このソート仕様をサンプルとして使うため、{\tt \vdmhome/examples/sort}
ディレクトリをコピーしてそこへディレクトリを移動してもらいたい。これで次からのツアーをあなたの環境で
\Toolbox\ 内のツールを直接試すことが出来るようになったはずだ。

\Toolbox\ はWindowsのスタートメニューから選択するか、Unix環境であれば{\tt
  \vdmgde}コマンド\index{vdmgdeコマンド}で起動する。
図~\ref{fig:startgui}は\Toolbox\ の起動画面である。このウィンドウを\Toolbox\ の
{\em メインウインドウ\/}と呼ぶ
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=11cm]{startgui-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=11cm]{startgui-pp.png}
#endif VDMPP
#ifdef ENG
\caption{Graphical User Interface Startup}
#endif ENG
#ifdef JPN
\caption{スタートアップ画面}
#endif JPN
\label{fig:startgui}
\end{center}
\end{figure}

#ifdef ENG
\subsection{On-Line Help}\index{Help}
#endif ENG
#ifdef JPN
\subsection{オンラインヘルプ}\index{オンラインヘルプ}
#endif JPN
 
% %%%%% The next paragraphs should be reinserted when help window is
% %%%%% implemented -- RM
%
% At any time when you are using the \Toolbox\ you can press the ``{\tt
%   F1}'' button and a help window~(as shown in
% Figure~\ref{fig:guihelp}) will appear with
% on-line help for the 
% graphical user interface. The part of the help text that is shown at
% the top of the help window is related to the particular part of the
% \Toolbox\ window in which the cursor is placed. The help text is
% organised in a hypertext format so it is possible to follow links from
% one part of the help text to another.

% \begin{figure}[tbh]
% \begin{center}
% #ifdef VDMSL
% \resizebox{\textwidth}{!}{\includegraphics{guihelp-sl}}
% #endif VDMSL
% #ifdef VDMPP
% \resizebox{\textwidth}{!}{\includegraphics{guihelp-pp}}
% #endif VDMPP
% \caption{The Help Window\label{fig:guihelp}}
% \end{center}
% \end{figure}

% The help window can also be accessed by pressing the  
% \raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{help}}
% button on the \guicmd{Help} toolbar or by selecting the corresponding
% item from the \guicmd{Help} menu. 

#ifdef ENG
On-line help for the \Toolbox\ and the interface in general can %also
be accessed through the \guicmd{Help} toolbar or
the \guicmd{Help} menu. Currently only the following
very limited help is available:
#endif ENG

#ifdef JPN
\Toolbox\ のオンラインヘルプと一般的なインターフェースは\guicmd{ヘルプ}ツールバーや\guicmd{ヘルプ}
メニューからアクセスできる。最近では以下に示す限られたものだけが利用可能である。
#endif JPN

\begin{description}
#ifdef ENG
 \item[\guicmd{About} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{help.png}}):]
  Displays the version number of the \Toolbox.
 \item[\guicmd{aboutqt}  (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{qt.png}}):]
  Displays information about and a reference to Qt, the multiplatform
  C++ GUI toolkit which the \Toolbox\ interface uses.
% \item[\guicmd{What's This?} (\hspace{-1.8mm}
%\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{whatsthis}}):]  
%  Select this item then click the left mouse button over some part of
%  the \Toolbox\ to get a brief description of it. (Currently only
%  partly implemented.) \\
#endif ENG
#ifdef JPN
 \item[\guicmd{ツールについて} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{help.png}}):]
  \Toolbox\ のバージョン番号を表示する.
 \item[\guicmd{Qtについて}  (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{qt.png}}):]
  Qt（\Toolbox\ のインターフェースが利用している、C++のマルチプラットフォーム
  GUIツールキット）へのリファレンス情報を表示する
% \item[\guicmd{What's This?} (\hspace{-1.8mm}
%\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{whatsthis}}):]  
%  これを選択してから\Toolbox\ の一部の上でマウスの左ボタンをクリックすると、
%  その項目についての記述が表示される（現在は一部のみ実装されている）
#endif JPN
\end{description}

#ifdef ENG
\subsection{Menus, Toolbars and Subwindows}

The top of the main window consists of a menu line with six pull-down
menus:
#endif ENG
#ifdef JPN
\subsection{メニュー、ツールバー、サブウインドウ}

メインウインドウの上部は6つのプルダウンメニューが一列になって構成されている。
#endif JPN

\begin{description}
#ifdef ENG
\item[\guicmd{Project}:] A project consists of a
  collection of file  
  names that together form a \vdmslpp\ specification. Under this menu
  heading it is possible to open and save projects, to configure (add
  files to and remove files from) projects, and to create new
  projects. This is also the place from which to exit the \Toolbox\
  and to set options for the various tools in the \Toolbox, for
  example to govern the level of type checking.

\item[\guicmd{File}:] Here you can invoke a file editor for making
  corrections to your specification and also remove displays of source
  files generated by the \Toolbox\ when it reports errors.

\item[\guicmd{Windows}:] Controls to determine which windows are
  displayed in the bottom pane of the main window. Each menu item
  toggles opening/closing of a particular window.

\item[\guicmd{Actions}:] This offers the various
  actions that can be applied to a specification: syntax and type
  checking, generation of integrity properties, code generation, 
#ifdef VDMPP 
translation from Java to \vdmslpp, 
#endif VDMPP 
and pretty printing.

\item[\guicmd{Interpreter}:] This offers
  functions for controlling the interpreter (see
  Section~\ref{interpreter}).
#endif ENG
#ifdef JPN
\item[\guicmd{プロジェクト}:]
  プロジェクトメニューは\vdmslpp\ の仕様書を構成するファイル名の集合で構成されている。
  このメニューからはプロジェクトを開く／保存する、プロジェクトの設定（ファイルの追加／削除）
  をする、新規プロジェクトの作成などができる。\Toolbox\ を終了させたり、\Toolbox\ のさまざまな
  ツールのオプションを設定する機能もここにある。（例えば型チェックのレベルを設定など）

\item[\guicmd{ファイル}:]
  ここからは仕様を訂正するためファイルエディタが起動できる。またエラーが報告されたとき、
  \Toolbox\ によって自動的に表示されるソースファイルの表示を終了させることが出来る。

\item[\guicmd{ウインドウ}:]
  メインウインドウの下にある画面に表示されているウインドウのコントロールを決定する。
  それぞれのメニュー項目は実際のウインドウの開く/閉じるとトグルしている。

  構文や型チェック、証明課題の生成、コード生成、
#ifdef VDMPP 
JavaからVDM++へのリバースエンジニアリング、
#endif VDMPP 
  清書など仕様書に適用されるさまざまなアクションを提供する。

\item[\guicmd{実行}:]
  インタープリタのコントロール機能を提供する（セクション~\ref{interpreter}参照）
%\item[\guicmd{Help}:]
%  \Toolbox\ のオンラインヘルプや一般的なインターフェース
#endif JPN
\end{description}

#ifdef ENG
  Below this menu line are six\footnote{When the \Toolbox\ is started,
  only the three which correspond to the first, third and fourth menus are
  displayed open; the other three are displayed in iconised form above
  them.} toolbars comprising buttons which offer the same
  actions\footnote{Except that the function for exiting from the toolbox
  is only available on the \guicmd{Project} menu.}.
  
  Finally, the lower pane of the main window is used to display various
  subwindows which either present information about the status of the
  current project or offer interfaces to tools within the \Toolbox. The
  available windows are as follows:
#endif ENG
#ifdef JPN
  以下ではこのメニューの6つ\footnote{\Toolbox\ が開始された時、1番目と3番目と4番目の
  メニューに相当するものだけが開く。残りの3つはその上にアイコン化されて表示される}あるツール
  バーの項目について同様のアクションを提供するものを示す。
  
  最終的に、メインウインドウ下の画面は現在のプロジェクトの状態に関する情報や
  \Toolbox\ 内のツールへのインターフェースを提供するさまざまなサブウインドウを表示する
  のに使用される。利用できるウインドウは以下のとおり:
#endif JPN

\begin{description}
#ifdef ENG
\item[\guicmd{Manager}]\index{Manager} Displays the current status of
  the current project. It consists of two parts:

  \begin{description}
  \item[\guicmd{Project View}]\index{Project View} This shows a tree
  representation of 
  the contents of the project comprising the files in the project and
  (only after successfully syntax checking the file) the
  \ifthenelse{\boolean{VDMsl}}{modules}{classes} declared in each
  file.
  \ifthenelse{\boolean{VDMsl}}
  {
    % for VDM-SL description 
     \item[\guicmd{Module View}]\index{Module View} This displays the
       status of each of the individual \vdmslpp\ modules in the
       project.
    % for VDM-SL description end
  }
  {
  % for VDM++ description 
     \item[\guicmd{Class View}]\index{Class View} This offers both a
  \guicmd{VDM View} 
       and a \guicmd{Java View}, which display the status of each of
       the individual \vdmslpp\ classes or Java files in the project
       respectively.
    % for VDM++ description end
  } 
  \end{description}

\item[\guicmd{Source Window}]\index{Source Window}  Displays the part
  of the source specification in which the error currently selected in
  the \guicmd{Error List} was discovered.

\item[\guicmd{Log Window}]\index{Log Window} Displays messages from
  the \Toolbox.
% \item[\guicmd{References}] Displays the dependencies between classes,
%   that is the classes which use the selected class and the classes
%   which the selected class uses~(a class {\em uses\/} another class if it
%   has references to objects of that class, for example through its
%   instance variables or operation calls). 
\item[\guicmd{Interpreter Window}]\index{Interpreter Window} The
interface to the interpreter. 

\item[\guicmd{Error List}]\index{Error List} Reports errors found by
the \Toolbox.
\item[\guicmd{Integrity Properties Window}] Displays the integrity properties
  that have been generated for the specification.
#endif ENG
#ifdef JPN
\item[\guicmd{マネージャー}]\index{マネージャー}
  現在のプロジェクトの状態を表示する。以下\ifthenelse{\boolean{VDMsl}}{}{2つ}のパートからなる。

  \begin{description}
  \item[\guicmd{プロジェクトビュー}]\index{プロジェクトビュー}
  プロジェクトの内容をツリー形式で表示
  プロジェクトの構成ファイルとそれぞれで宣言されている\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} 
  （ファイルの構文チェックが成功したもののみ）が含まれる。
  
  \ifthenelse{\boolean{VDMsl}}
  {
    %%%%%%%%%%%%%%%%%%%% comment by teramoto
    % for VDM-SL description 
       プロジェクトに含まれる\vdmslpp\ モジュールの個々の状態を表示する。
    % for VDM-SL description end
  }
  {
  % for VDM++ description 
     \item[\guicmd{クラスビュー}]\index{クラスビュー}
       \guicmd{VDMビュー}と\guicmd{Javaビュー}の両方があり、プロジェクトに含まれる個々
       の\vdmslpp\ クラス・Javaファイルをそれぞれ表示する。
    % for VDM++ description end
    %%%%%%%%%%%%%%%%%%%%% comment by teramoto end
  } 
  \end{description}

\item[\guicmd{ソースウインドウ}]\index{ソースウィンドウ}
  発見された\guicmd{エラー一覧}内で現在選択中のエラーの元仕様の一部を表示する。

\item[\guicmd{ログウインドウ}]\index{ログウィンドウ}
  \Toolbox\ からのメッセージを表示する
% \item[\guicmd{References}] Displays the dependencies between classes,
%   that is the classes which use the selected class and the classes
%   which the selected class uses~(a class {\em uses\/} another class if it
%   has references to objects of that class, for example through its
%   instance variables or operation calls). 
\item[\guicmd{実行ウインドウ}]\index{インタープリタウィンドウ}
インタープリタとのインターフェース

\item[\guicmd{エラー一覧}]\index{エラーリスト}
\Toolbox\ によって発見されたエラーリポート
\item[\guicmd{証明課題ウインドウ}]
  仕様から生成された証明課題を表示するウインドウ
#endif JPN
\end{description}

#ifdef ENG
When the \Toolbox\ is started, only the \guicmd{Manager} and \guicmd{Log Window} is open.
#endif ENG
#ifdef JPN
\Toolbox\ の起動時には、\guicmd{マネージャー}と\guicmd{ログウインドウ}のみが開いている。
#endif JPN

#ifdef ENG
\subsection{Configuring your Project}
#endif ENG
#ifdef JPN
\subsection{プロジェクトを作成する}
#endif JPN

#ifdef ENG
First you need to configure the \Toolbox\ by indicating which 
files (in your desired input format) are to be analysed. For this
purpose you can select the action \guicmd{Add File to Project} on the
\guicmd{Project} menu or simply press the 
\raisebox{-0.4mm}{\includegraphics[width=0.03\textwidth]{plus.png}}  
(\guicmd{Add Files}) button on the (\guicmd{Project Operations})
toolbar\footnote{In the remainder of this guided tour we concentrate
  on interactions via the toolbar buttons. You can of course always
  use the equivalent menu item if you prefer.}. The dialog box shown
in Figure~\ref{fig:addFiles} will then appear\index{Project!Adding files}.
#endif ENG
#ifdef JPN
まず、どのファイルを分析にかけるかを\Toolbox\ に設定する必要がある。
このため、プロジェクトメニューから\guicmd{選択したファイルを現在のプロジェクトに追加} を選択するか(\guicmd{プロジェクト})
ツールバーから\raisebox{-0.4mm}{\includegraphics[width=0.03\textwidth]{plus.png}}  
(\guicmd{ファイルを追加}) ボタンを押す\footnote{このガイドツアーではツールバーのボタンを経由してのやりとり
を中心に話を進めていることを忘れないでほしい。もしお望みならばもちろん、いつでも同等のメニュー項目を使うことが
できる}。
すると図~\ref{fig:addFiles}に示すようなダイアログボックスが表示される。\index{プロジェクト!ファイルついか@ファイル追加}.
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
#ifdef JPN
\includegraphics[width=11cm]{addFiles-sl.png}
#endif JPN
#ifdef ENG
\includegraphics[width=11cm]{addFiles-slENG.png}
#endif ENG
#endif VDMSL
#ifdef VDMPP
#ifdef JPN
\includegraphics[width=11cm]{addFiles-pp.png}
#endif JPN
#ifdef ENG
\includegraphics[width=11cm]{addFiles-ppENG.png}
#endif ENG
#endif VDMPP
#ifdef ENG
\caption{Adding Files to a Project}
#endif ENG
#ifdef JPN
\caption{プロジェクトにファイルを追加する}
#endif JPN
\label{fig:addFiles}
\end{center}
\end{figure}

#ifdef ENG
\ifthenelse{\boolean{VDMsl}}{%
Here you double click on the {\tt sort-init.rtf} file (or select the
file and add it to the project by 
pressing the ``\guicmd{Add to project}'' button).  This file will then
be included in the project. You can mark more than one file at a time
by holding down the {\cmd Ctrl} key and clicking the left-hand
mouse button on each of the files in turn, and you can mark a list of
files by selecting the first and last files in the list (in either
order), holding down the {\cmd Shift} key while making the second
selection.  Note that {\tt sort-init.rtf} contains a number of
errors for illustration purposes in this guided tour.
}
{%
Mark the six {\tt .rtf} 
files (minus the {\tt MergeSort.rtf} file) by holding down the {\cmd
  Ctrl} key and clicking the left-hand mouse button on each of the
files in turn, then press the ``Open'' button.  These files will then
be included in the project. You can also add a single file to a
project by double clicking the left-hand mouse button on it (but note
that this also closes the dialog box so it is not an efficient way
of adding a number of files), and you can also mark a list of files at
the same time by selecting the first and last files in the list (in
either order), holding down the {\cmd Shift} key while making the second
selection. Note that {\tt MergeSort-init.rtf} contains a number of
errors for illustration purposes in this guided tour.
}

The
\ifthenelse{\boolean{VDMsl}}
{
  {\tt sort-init.rtf} file
}
{
  six {\tt .rtf} files
}
  will now appear in the \guicmd{Project View}
  of the \guicmd{Manager} in the main \Toolbox\ window as
  shown in Figure~\ref{fig:addedfiles}.
#endif ENG
#ifdef JPN
\ifthenelse{\boolean{VDMsl}}
{%
sort-init.rtfファイルをダブルクリックする（またはファイルを選択のうえ``\guicmd{開く}''ボタンを押下して
プロジェクトへファイル追加）。このファイルがプロジェクトに追加されているはずだ。{\cmd Ctrl}キーを押しながら
マウスの左ボタンをひとつずつ順番に押すことで一度に複数ファイルを選択することができ、{\cmd Shift} キーを
押しながらファイルリストの最初と最後を選択する（順番はどちらでもよい）ことで一覧のファイルを選択することも
できる。{\tt sort-init.rtf}にはこのガイドツアーで見せるの目的で、エラーがいくつか入っていることに注意してほしい。
}
{%
{\tt MergeSort.rtf} を除く6つの{\tt .rtf} ファイルを選択して（{\cmd Ctrl} +マウスの左ボタンクリックを順番に繰り返す）、
「開く」ボタンを押す。そうすると選択したファイルがプロジェクトに追加される。単純にマウスの左ボタン
をダブルクリックするだけでもファイル1つであれば追加することができる（ただし、ダイアログが閉じてしまう
ので複数のファイルを追加することはできない）。また{\cmd Shift}キーを押しながら最初のファイルと
最後のファイルを選択してもよい。{\tt MergeSort-init.rtf}ファイルにはこのガイドツアーで見せる目的で、
いくつかのエラーが入っていることに注意してほしい。
}

\ifthenelse{\boolean{VDMsl}}
{
  {\tt sort-init.rtf} ファイル
}
{
  6つの {\tt .rtf}ファイル
}
は下記図~\ref{fig:addedfiles}に示すメインの
\Toolbox\ ウインドウにある\guicmd{マネージャー} の\guicmd{プロジェクトビュー}に表示されているはずだ。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=8cm]{addedFiles-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=8cm]{addedFiles-pp.png}
#endif VDMPP
#ifdef ENG
\caption{Main Window After Addition of Files}
#endif ENG
#ifdef JPN
\caption{ファイル追加後のメインウインドウ}
#endif JPN
\label{fig:addedfiles}
\end{center}
\end{figure}


#ifdef ENG
\subsection{Syntax Checking your VDM Specification}\index{SyntaxChecking}
#endif ENG
#ifdef JPN
\subsection{VDM仕様書の構文チェック}\index{こうぶんチェック@構文チェック} 
#endif JPN

#ifdef ENG
Having configured your project you now need to check whether all the
\ifthenelse{\boolean{VDMsl}}{modules}{classes} obey the syntax rules
of \vdmslpp.  The syntax checker checks whether the syntax of your
specification is correct. Note that when you change a source file you
must syntax check it again before the other tools will be aware of the
changes you have made.
#endif ENG

#ifdef JPN
プロジェクトを作成したら、すべての\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
モジュールが、VDM-SLの
% for VDM-SL description end
}
{
% for VDM++ description 
クラスが、VDM++の
% for VDM++ description end
%%%%%%%%%%%%%%%%%%% comment by teramoto end
}
構文ルールに準じているかチェックする必要がある。構文チェック機能は作成した仕様書の構文が
正しいかどうかチェックする。元ファイルを変更したら、その他のツールが変更が生じていることに
注意する前に、再度構文チェックをしなくてはならないことを忘れないでもらいたい。
#endif JPN

#ifdef ENG
\subsubsection{Parsing the specification}
#endif ENG
#ifdef JPN
\subsubsection{仕様書の解析}
#endif JPN

#ifdef ENG
Select the files for syntax checking by
\ifthenelse{\boolean{VDMsl}}{clicking on the {\tt sort-init.rtf}
file}{marking the six {\tt .rtf} files} in the \guicmd{Project View}
of the \guicmd{Manager}, then press the 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck.png}}  
(\guicmd{Syntax Check}) button on the (\guicmd{Actions})
toolbar to invoke the syntax checker. (Selecting the containing level
 ``Default'' folder and applying the syntax check operation to that
 has the same effect -- this applies the operation to each of the
 files in the folder.) Notice that at this point the
\guicmd{Log Window} opens automatically (if it is not already open)
and displays the message 
\ifthenelse{\boolean{VDMsl}}{``{\tt Parsing "sort-init.rtf"
    ...}''}{``{\tt Parsing "..../DoSort.rtf" ...}'' etc.}.
\ifthenelse{\boolean{VDMsl}}{(More than one file can be selected and
  in that case all of them are syntax checked.)}{} If syntax
  errors\index{Syntax
  Errors} are discovered the \guicmd{Error List}\index{Error List} is
also au\-to\-matically invoked and the \guicmd{Source Window} is
automatically opened. Our sorting example contains two
deliberate syntax errors by way of illustration.
#endif ENG

#ifdef JPN
\guicmd{マネージャー}の\guicmd{プロジェクトビュー}で
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
{\tt sort-init.rtf}ファイルをクリック
% for VDM-SL description end 
}
{
% for VDM++ description 
6つの {\tt .rtf} ファイルを選択
% for VDM++ description end
%%%%%%%%%%%%%%%%% comment by teramoto
}
したら、 
(\guicmd{アクション})ツールバーの\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck.png}}  
(\guicmd{構文チェック})を選択すると構文チェック機能が起動する。
（「デフォルト」フォルダを含むレベルを選択すること、
および構文チェックの操作を適用することは同じ効果をもたらす－つまり、これはそのフォルダ内の
ファイルそれぞれに対する操作として適用される）ここで、\guicmd{ログウインドウ}が自動的に開き
（すでに開いていない場合）、\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
``{\tt Parsing "sort-init.rtf"
    ...}''
% for VDM-SL description end
}
{
% for VDM++ description 
``{\tt Parsing "..../DoSort.rtf" ...}'' 等
% for VDM++ description end 
%%%%%%%%%%%%%%%%%%% comment by teramoto end
}　のメッセージを表示することに注目
してほしい。\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
(構文チェック済みのファイルは複数選択することもできる)
% for VDM-SL description end
}
{
% noting to add here for VDM++ description 
%%%%%%%%%%%%%%%%%%%%%%% comment by teramoto
} 
構文エラー\index{こうぶんエラー@構文エラー} が発見された場合は
\guicmd{エラー一覧}\index{エラーリスト}のウインドウが自動的に起動される。
また\guicmd{ソースウインドウ} も表示される。ソートのサンプルには説明のためわざと二つ構文エラーを入れてある。
#endif JPN

% \subsubsection{Traversing errors}
#ifdef ENG
\subsubsection{Correcting syntax errors}
\index{Syntax Errors!Correcting}
#endif ENG
#ifdef JPN
\subsubsection{構文エラーの修正}
\index{こうぶんエラー@構文エラー!しゅうせい@修正}
#endif JPN

#ifdef ENG
The \guicmd{Error List} is shown in Figure~\ref{fig:error}. Its top
pane shows a list of the places (file name, line number, column
number) at which errors and warnings arose, while the bottom
displays a more detailed explanation of the currently selected
error. Initially, the first error in the list is selected
automatically.
#endif ENG

#ifdef JPN
図~\ref{fig:error}に\guicmd{エラー一覧}を示す。画面の上部にエラーまたはワーニングの生じた
箇所のリスト（ファイル名、行数、カラム番号）が表示され、下部には選択中のエラーの詳細情報が表示される。
最初はリストの先頭のエラーが自動的に選択される。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=\textwidth]{errorList-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=\textwidth]{errorList-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Error List}
#endif ENG
#ifdef JPN
\caption{エラー一覧}
#endif JPN
\label{fig:error}
\end{center}
\end{figure}

#ifdef ENG
The \guicmd{Source Window} displays the part of the source
specification in which the currently selected error was discovered,
the actual position being marked by the window's cursor. For the first
syntax error, the \guicmd{Source Window} appears as shown in
Figure~\ref{fig:source1}.
#endif ENG
#ifdef JPN
\guicmd{ソースウインドウ}は、仕様書の現在選択中のエラーが発見された部分を表示するが、
実際の箇所はウインドウのカーソルでマークされて示される。最初の構文エラーに対しては、
\guicmd{ソースウインドウ}は図~\ref{fig:source1}のように表示される。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=9cm]{sourceWindow-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=9cm]{sourceWindow-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Source Window for the First Error}
#endif ENG
#ifdef JPN
\caption{最初のエラーがソースウインドウに表示された所}
#endif JPN
\label{fig:source1}
\end{center}
\end{figure}

#ifdef ENG
The first error message is as follows:
#endif ENG
#ifdef JPN
最初のエラーメッセージは下記のとおり：
#endif JPNP

#ifdef VDMSL
\verb!C:\vdmhome\examples\sort\sort-init.rtf, l. 23, c. 53:! \\
  \verb!  Expected: <<binary op>>, `(', `)', `,', `.', `[', `!{\tt $\sim$}\verb!', `.#', ! \\
  \verb!            `'' or `, ... ,' before `l1 , l2 )'! \\
  \verb!  Assumed: `*' before `l1 , l2 )'!
#endif VDMSL

#ifdef VDMPP
\begin{verbatim}
C:\vpphome\examples\sort\MergeSort-init.rtf, l. 29, c. 3:
  Expected: <<binary op>>, `(', `.', `;', `operations', `instance',
            `sync', `thread', `end', `functions', `.#', `post'
            `pre', `types' or `values' before `Merge : seq of'
  Assumed: `;' before `Merge : seq of'
\end{verbatim}
#endif VDMPP

#ifdef ENG
Messages of this form indicate the text which was expected but not
found at the error point. The syntax checker reports the error and
makes an assumption about what should have been at the error point in
order to allow it to recover and carry on with the syntax check.
#endif ENG
#ifdef JPN
この形式のメッセージはエラーの発見されたポイントで予測されるものが
見つからなかった場合に表示される。構文チェック機能はエラーを報告し、
起こった箇所において、修正および構文チェックの続行をするためにはどうすべきだった
のか予測を行う。
#endif JPN

#ifdef VDMSL
#ifdef ENG
In our example, the error message tells us that a multiplication symbol
`{\tt*}' was assumed between `{\tt tail}' and `{\tt l1}' in order to
recover from the syntax error (the `{\tt tail}' symbol was read as the
name of an identifier). However, this assumption is incorrect and  you
can see from the  description of the \vdmslpp\ syntax in the Language
Manual~\cite{LangMan-CSK} that the error is in fact that the `{\tt tl}'
operation which returns the tail of a sequence has been wrongly
written as `{\tt tail}'. The error can therefore be fixed by using the
file editor to rewrite `{\tt tail}' as `{\tt tl}'.
#endif ENG
#ifdef JPN
この例では、エラーメッセージによれば、構文チェックを続けるためには
`{\tt tail}' と `{\tt l1}'の間に記号`{\tt*}'が必要だと予測されている（`{\tt tail}'は
識別子の名前とみなされている）。しかしこの想定は間違っている。言語マニュアル~\cite{LangMan-CSK} 
の\vdmslpp\ の記述から、このエラーは実際には、列から先頭を除いたものを返す`{\tt tl}'演算子が間違って`{\tt tail}'
と書かれているために起こったものだとわかる。そのため、このエラーはファイルエディタを使い`{\tt tail}' を `{\tt tl}'に
書き換えれば修正となる。
#endif JPN
#endif VDMSL
#ifdef VDMPP
#ifdef ENG
In this example, the error message tells us that a missing \Lit{;}
before the function {\aaa Merge} has been assumed in order to proceed
with the syntax check, and you can see from the  description of the
\vdmslpp\ syntax in \cite{LangManPP-CSK} that this assumption is correct
-- two function definitions must be separated by the delimiter
\Lit{;}. The error can therefore be fixed by using the file editor to
add the character \Lit{;} to the end of the definition of the function
{\aaa MergeSorter}.
#endif ENG
#ifdef JPN
この例では、エラーメッセージが構文チェックを続けるためには{\aaa Merge} 関数の
前に\Lit{;}が見つからないと予測される、ということを伝えている。\cite{LangManPP-CSK}に
よりこの予測が正しいことが分かる。－2つの関数定義はデリミタ\Lit{;}で区切らなくて
はならない。ゆえにこのエラーはファイルエディタを使い、{\aaa MergeSorter} 関数の定義の
最後に\Lit{;}を追加することで修正される。
#endif JPN
#endif VDMPP

#ifdef ENG
(Note that the source file is not  changed by the syntax checker when
it ``assumes'' something: corrections to the source text should be
done manually by the user.)

You can correct the syntax errors by invoking your preferred editor
(see Appendix~\ref{sec:set_env}) directly from the \Toolbox\
interface. Select the file \ifthenelse{\boolean{VDMsl}}{{\tt
  sort-init.rtf}}{{\tt MergeSort-init.rtf}} in the main window and 
press the \guicmd{External Editor}\index{External Editor} button (%
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{externaleditor.png}}) 
on the (\guicmd{File Operations}) toolbar. Note that if more than
one file is selected when you invoke the \guicmd{External Editor} in
this way you actually get one \guicmd{External Editor} for each of the
selected files.

You can get to the next reported error by pressing the {\fbox{\tt >}}
button which appears to the left of the list of errors or by selecting the
error notifier directly in the top pane of the \guicmd{Error
  List}. Here the explanation is: 
#endif ENG
#ifdef JPN
（構文チェック機能を使っても元ファイルは修正され
ないことに注意してほしい。想定されることが複数ある場合、元ファイルの修正はユーザの
手作業でなされるべきだからである）

構文エラーの修正は、\Toolbox\ 上から好みのエディターを直接起動する
ことで出来るようになる。（付録~\ref{sec:set_env}参照）メインウインドウで
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
{\tt sort-init.rtf}
% for VDM-SL description end
}
{
% for VDM++ description 
{\tt MergeSort-init.rtf}
% for VDM++ description end
%%%%%%%%%%%%%%%%%%%% comment by teramoto end 
}
ファイルを選択し、
(\guicmd{ファイル})ツールバーの\guicmd{外部エディタ}\index{がいぶエディタ@外部エディタ} ボタン
(\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{externaleditor.png}})を押す。
外部エディタの起動時に複数のファイルが選択されていた場合、この方法だと選択したファイル
それぞれが\guicmd{外部エディタ}で表示される。

エラーリストの左側に表示されている {\fbox{\tt >}}ボタンを押すか、\guicmd{エラー一覧}画面の画面上半分に
表示される、エラー箇所の概要を直接選択すると、見たいエラーリポートを読むことが出来る。以下のように説明がされている。
#endif JPN

#ifdef VDMSL
\begin{verbatim}
C:\vdmhome\examples\sort\sort-init.rtf, l. 82, c. 3:
  Expected: <<binary op>>, `(', `.', `;', `operations', `state',
            `functions', `.#', `post', `pre', `types' or `values' 
            before `InsertSorted : PosReal *'
  Assumed: `;' before `InsertSorted : PosReal *'
\end{verbatim}

#ifdef ENG
This tells us that there is a syntax error before `{\tt InsertSorted :
  PosReal *}' and that a preceding semicolon `{\tt ;}' was assumed in
  order to recover from the syntax error. In this case the assumption
  is in fact correct -- you can see from the  description of the
\vdmslpp\ syntax in \cite{UMLMan-CSK} that two function definitions must
  be separated by the delimiter \Lit{;}. The error can therefore be
  fixed by returning to the file editor and adding the character
  \Lit{;} to the end of the definition of the function {\aaa DoSort}.
#endif ENG

#ifdef JPN
これは、 `{\tt InsertSorted :PosReal *}の前で構文エラーが起こっており、回避するためには
セミコロン`{\tt ;}'が必要なのではないかと想定している。この場合予測は正解で、 \cite{UMLMan-CSK}
にある\vdmslpp\ の構文の記述からもわかるように、2つの関数定義はデリミタ \Lit{;}で区切られていなくては
ならない。ゆえにこのエラーはファイルエディタに戻って\Lit{;}を関数{\aaa DoSort}の定義の後ろに追加することで
修正される。
#endif JPN
#endif VDMSL

#ifdef VDMPP
\verb!C:\vpphome\examples\sort\MergeSort-init.rtf, l. 34, c. 53:! \\
 \verb!  Expected: <<binary op>>, `(', `)', `,', `.', `[', `!{\tt $\sim$}\verb!', `.#',! \\
 \verb!              `'' or `, ... ,' before `l1 , l2 )'! \\
 \verb!  Assumed: `*' before `l1 , l2 )'!

#ifdef ENG
This tells us that there is a syntax error before {\tt l1, l2} and
that  a multiplication symbol `{\tt *}' was assumed between `{\tt
  tail}' and `{\tt l1}' in order to recover from the syntax error (the
`{\tt tail}' symbol has been read as the name of an identifier). In
this case the assumption is incorrect and the error is in fact that
the `{\tt tl}' operation which returns the tail of a sequence has been
wrongly written as `{\tt tail}'. Make this correction using the file
editor.
#endif ENG
#ifdef JPN
これは{\tt l1, l2}の前に構文エラーが起こっていて、構文エラーを回避
するためには記号`{\tt *}'が`{\tt tail}'（`{\tt tail}'は識別子の名前であ
ると予測）と`{\tt l1}'の間に必要なのではないかと予測していることを伝えている。
この場合、予測は間違っており実際は列から先頭を除いたものを返す`{\tt tl}'演算子を`{\tt tail}と
書き間違えたことによるエラーである。ファイルエディタを使って修正ができる。
#endif JPN
#endif VDMPP

#ifdef ENG
When you have corrected the syntax errors and saved the file, you must
re-run the syntax checker\index{Syntax Checking} to check your
corrections were right. This time the file should be syntactically
correct, and if you switch to the \vdmModView\ in the 
\ifthenelse{\boolean{VDMsl}}{}{(\guicmd{Class View} of the)} 
\guicmd{Manager} you will see 
that the status\index{Status Information} of 
\ifthenelse{\boolean{VDMsl}}{the module representing our specification
  (called {\tt DefaultMod} because no module structuring has
  been used in this small example)}{each of the six classes ({\aaa
    DoSort, ExplSort, ImplSort, MergeSort, Sorter, SortMachine}) in
  our specification} is now marked with the symbol 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}}
in the syntax column indicating that it is syntactically
  correct. (See Figure~\ref{fig:vdmModView}.) Note that the blanks in the
other columns mean that no attempt has yet been made to type check,
code generate or pretty print  the specification.
#endif ENG
#ifdef JPN
構文エラーを修正してファイルを保存したら、正しく修正できていることを確認するために
再度構文チェック機能\index{こうぶんチェッカー@構文チェック機能}を走らせなくてはならない。今度はファイルは構文的に正しいはずであり、
\guicmd{マネージャー} \ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%% comment by teramoto
% noting to add in here for VDM-SL
}
{
% for VDM++ description 
の(\guicmd{クラスビュー} )
% for VDM++ description end 
%%%%%%%%%%%%%%% comment by teramoto end
} 
内にある\vdmModView\ にウインドウが移り、
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
(この例ではモジュール構造を何も
使用していないため、{\tt DefaultMod} と呼ばれる仕様で代表的なモジュール)
% for VDM-SL description end
}
{
% for VDM++ description 
仕様書にある6つのクラス({\aaa
    DoSort, ExplSort, ImplSort, MergeSort, Sorter, SortMachine}) 
% for VDM++ description end
%%%%%%%%%%%%%%%%%%%%% comment by teramoto end
}
の状態が確認できるだろう。

そして構文的に正しいことを示す記号 \raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}}
が構文の欄についているはずだ。（図~\ref{fig:vdmModView}参照）
その他の欄がブランクなのは、仕様書の型チェックやコード生成、清書などがまだ1度も行われていない
ことを意味している。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=9cm]{moduleView.png}
#ifdef ENG
\caption{The Module View}
#endif ENG
#ifdef JPN
\caption{モジュールビュー}
#endif JPN
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=9cm]{vdmView.png}
#ifdef ENG
\caption{The VDM View}
#endif ENG
#ifdef JPN
\caption{VDMビュー}
#endif JPN
#endif VDMPP
\label{fig:vdmModView}
\end{center}
\end{figure}

#ifdef ENG
Now that the syntax checking has been completed successfully, the
files can be selected for further processing directly in the \vdmModView.
#endif ENG
#ifdef JPN
構文チェックが成功したので、ファイルは\vdmModView\ から直接選択して次の処理に進めることができる。
#endif JPN

#ifdef ENG
\subsection{Type Checking your VDM Specification}
\index{Type Checking}\label{sec:gde-tc}
#endif ENG
#ifdef JPN
\subsection{VDM仕様の型チェック}
\index{かたチェック@型チェック}\label{sec:gde-tc}
#endif JPN

#ifdef ENG
Once a specification has passed the syntax check, the type checker
can be applied. This is invoked by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheck.png}}  
(\guicmd{Type Check}) button on the (\guicmd{Actions}) toolbar.

Select \ifthenelse{\boolean{VDMsl}}{the module {\tt DefaultMod}}{all
  six classes} in the \vdmModView\ and run the type 
checker. After type checking, the \Toolbox\ updates the status 
  information\index{Status Information} in this view to indicate,
using the symbols 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}}
and
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror.png}}
(this is the first symbol
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}}
with a red line through it) 
respectively, whether the type check succeeded or failed for each
\ifthenelse{\boolean{VDMsl}}{module}{class}.

In this example it in fact failed \ifthenelse{\boolean{VDMsl}}{because
the sort specification}{for the {\tt MergeSort} class, which}
generated three type errors and one warning. The errors\footnote{The
  format of type errors is described in more detail in the reference
  part of this manual. See Section~\ref{type check}.} are displayed in
the \guicmd{Error List} as before.

#ifdef VDMPP
The first error, which is shown in Figure~\ref{fig:type_error1}, is
caused by the lower-case {\tt s} in the function name {\tt
  Merge\underline{s}orter} (see the corresponding \guicmd{Source Window} shown in
Figure~\ref{fig:source-type}): this function name should be {\tt MergeSorter}.
#endif VDMPP
#ifdef VDMSL 
The first error, which is shown in Figure~\ref{fig:type_error1},
is that the function {\tt Merge} is actually  called with two sequences of
{\tt real} numbers (see the corresponding \guicmd{Source Window} shown in
Figure~\ref{fig:source-type}) whereas the types of the expected
parameters (as given in the signature for 
{\tt Merge}) are a sequence of {\tt int}~(integers) and a sequence of
{\tt bool}~(Boolean values). As {\tt int} is a subtype of {\tt real}
the first actual parameter could be type correct if all
the numbers in the sequences actually are integers. However, the
second parameter, which is supposed to be a sequence of {\tt bool},
causes the problem.  This error is corrected by changing {\tt bool} to
{\tt int} in the signature for the {\tt Merge} function.
#endif VDMSL
#endif ENG

#ifdef JPN
仕様書がいったん構文チェックをパスしたら、型チェックを行うことが出来る。
型チェックは(\guicmd{アクション})ツールバーの\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheck.png}}  
(\guicmd{型チェック}) ボタンを押すと起動する。

\vdmModView\ で \ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
モジュール{\tt DefaultMod}
% for VDM-SL description end
}
{
% for VDM++ description 
6つのクラスすべて
% for VDM++ description end
%%%%%%%%%%%%%%%%%%%%%% comment by teramoto
} 
を選択し、型チェックを行う。型チェックが終わると、 \Toolbox\ は記号
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}}
と\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror.png}}
（\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}}には赤いラインもつく）
を使って各々の\ifthenelse{\boolean{VDMsl}}
{
% for VDM-SL description 
モジュール
% for VDM-SL description end
}
{
% for VDM++ description 
クラス
% for VDM++ description end 
}に関して型チェックが通ったか通らないかを示し、ビューの状態表示を更新する。

この例では、実は
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
Sortの仕様が
% for VDM-SL description end
}
{
% for VDM++ description 
{\tt MergeSort}クラスが
% for VDM++ description end
%%%%%%%%%%%%%%%%%%%%%%%%% comment by teramoto end
}
型チェックに失敗するようになっている。エラーが3つ\footnote{型エラーのフォーマットに
ついては、このマニュアルのリファレンス部分に詳細が記述されている。セクション~\ref{type check}
参照 }とワーニングが1つ発生するがこれらは以前と同様、\guicmd{エラー一覧} に表示される。

#ifdef VDMPP
最初のエラーは図~\ref{fig:type_error1}でも示しているが、
関数名{\tt Merge\underline{s}orter} の{\tt s}が小文字であることが原因である。
（\guicmd{ソースウインドウ} の表示については図~\ref{fig:source-type}を参照のこと）
この関数名は {\tt MergeSorter}でなくてはならない。
#endif VDMPP

#ifdef VDMSL 
図~\ref{fig:type_error1}に表示されている最初のエラーは、関数{\tt Merge}が、実際は2つ
{\tt real}型の列を引数にして呼ばれている（\guicmd{ソースウインドウ} の表示については
図~\ref{fig:source-type}を参照のこと）ことを示す。が、想定されるパラメータは（{\tt Merge}の
シグネチャから見ると）{\tt int}~(integers)と {\tt bool}~(Boolean値)となっている。{\tt int} は
{\tt real}のサブタイプであるため、実際の第1引数は、列内の数字がすべてintegerで
あったとしても型を訂正される。しかし第2引数はboolの列と想定されているのでこれは問題
である。このエラーは {\tt Merge} 関数のシグネチャの{\tt bool} を{\tt int}に修正することで回避できる。
#endif VDMSL
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=11cm]{typeError1-sl.png}
#endif //VDMSL
#ifdef VDMPP
\includegraphics[width=11cm]{typeError1-pp.png}
#endif //VDMPP
#ifdef ENG
\caption{First error reported when type checking}
#endif ENG
#ifdef JPN
\caption{型チェック後最初のエラー表示}
#endif JPN
\label{fig:type_error1}
\end{center}
\end{figure}

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=11cm]{sourceWindow-type-sl.png}
#endif //VDMSL
#ifdef VDMPP
\includegraphics[width=11cm]{sourceWindow-type-pp.png}
#endif //VDMPP
#ifdef ENG
\caption{The Source Window for the Type Errors}
#endif ENG
#ifdef JPN
\caption{型エラー時のソースウインドウ}
#endif JPN
\label{fig:source-type}
\end{center}
\end{figure}

#ifdef ENG
The second error, which is shown in Figure~\ref{fig:type_error2},
tells us that we tried to apply the \Sig{<=} operator with a
right-hand argument (Rhs) which does not belong to a numeric
type. More specifically, the actual argument (denoted by the keyword
{\sf act:} in the error message) is of type {\tt bool} while the 
expected argument (denoted by the keyword {\sf exp:}) is a real number
({\tt real} is the most general numeric type). Information like this
can be valuable when trying to determine the cause of an error.
#endif ENG

#ifdef JPN
2番目のエラーは図~\ref{fig:type_error2}にも示すとおり、
数値型でない右辺に\Sig{<=}演算子を適用しようとしたために起きたものである。
もっと詳しく言えば、実際の引数は（エラーメッセージ中では{\sf act:}と表示）{\tt bool}型で
宣言されているが予想される引数は（エラーメッセージ中では{\sf exp:}と表示）{\tt real}型である。
（real型は最も一般的な数値型の型である）
エラーの原因を特定しようとする場合のこのような情報は、様々である。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=11cm]{typeError2-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=11cm]{typeError2-pp.png}
#endif //VDMPP
#ifdef ENG
\caption{Second error reported when type checking}
#endif ENG
#ifdef JPN
\caption{2番目の型チェックエラー表示}
#endif JPN
\label{fig:type_error2}
\end{center}
\end{figure}

#ifdef ENG
\ifthenelse{\boolean{VDMsl}}{This error, as well as the third error
which is similar except that it involves the left-hand argument (Lhs) of
the \Sig{<=} operator, is in fact also caused by having written {\tt
  seq of bool} instead of {\tt seq of int} in the signature of the
{\tt Merge} function. Thus, both of these errors are just 
follow-on errors from the first one. So just correct the first
error}{This mistake is in fact caused by the {\tt seq of bool} in the
signature of the {\tt Merge} function, which should be {\tt seq of
  int}. The same mistake also caused the third error, which is similar
to the second, and this disappears when the second error is
removed. So just correct the first two errors} and syntax and type
check the specification again.

Notice how the status information in the main window is updated
during this process. First, when the source file is edited the symbol 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}}  
which indicated in the \vdmModView\ that the file was
syntactically correct is replaced by the symbol 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckmodified.png}}
indicating that there is an inconsistency between the version
currently in the \Toolbox\ and the version on the file system. The
file must be syntax checked again before proceeding. Second, after the
syntax check and type check are re-run, the symbols 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}}
and
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}} 
are shown in the respective status fields to indicate that both
operations were successful.

Note also that the type check operation is considered to be successful
even though the type checker returns a warning. This is because
warnings generally represent redundancy in a specification rather than
actual errors, for example that a particular Boolean expression will
always evaluate to false or that a particular parameter or local
variable is never used in the body of a function or operation. Of
course, such redundancy can actually be the result of an error -- the
expression or statement which raises the warning may have been
mis-typed -- so it is useful to check the warnings to make sure that
this is not the case. In our example, the warning tells us that the
local variable `{\tt e}' which is introduced in the second pattern in
the cases statement in the function {\tt MergeSort} is never
used. This is in fact not an error and the specification is correct as
it stands, but we could remove the warning if we wanted to by
replacing the `{\tt e}' with the ``don't-care'' pattern `{\tt -}'.

Although our specification has now passed the type checking operation
this does not mean that it is guaranteed to be correct and there may
still be some errors (just as there may be run-time errors such as
division by zero in a program even though that program has passed the
syntax and type checks of the compiler for the appropriate programming
language). In order to help to identify potential sources of these
``run-time'' errors in the model, the type checker has an option which
causes it to report an error at all points in the specification which
are potential sources of run-time errors. Then, if one can convince
oneself that the potential errors reported cannot occur, no run-time
errors will appear.  More information about this can be found in the 
reference part of this manual in Section~\ref{sec:def-typechedk}.
#endif ENG

#ifdef JPN
\ifthenelse{\boolean{VDMsl}}{
%%%%%%%%%%%%%%%%%%%%% comment by teramoto
% for VDM-SL description 
このエラーは、\Sig{<=} 演算子の左辺に
実際には{\tt seq of int}であるべきものが{\tt seq of bool} と{\tt Merge}関数のシグネチャ中に
書かれているためであり、3番目のエラーと同じようなエラーである。
そのため、これらのエラーは最初のものに引きずられて出たものである。最初のエラーだけを
修正して
% for VDM-SL description end

}
{
% for VDM++ description 
このエラーは実際には{\tt Merge}関数のシグネチャ中で、 {\tt seq of int}であるべきものが{\tt seq of bool} 
であったせいである。3つ目のエラーも同じ原因であり、2番目のものとも関係しているため、2番目のエラー
が修正されると消える。このため、最初の2つのエラーを修正して
% for VDM++ description end
%%%%%%%%%%%%%%%%%%%%% comment by teramoto end
} 
再度仕様書の構文チェック、型チェックを行う。 

メインウインドウの状態についての情報がこの処理中どのように更新されたか注目してほしい。
まず元ファイルが編集されると、\vdmModView\ でそのファイルが構文的に正しいことを示す記号
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}}  
が、\Toolbox\ 上に現在あるバージョンとファイルシステムにあるバージョンの不整合があることを示す
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckmodified.png}}に変わる。
このファイルは処理を行う前に再度構文チェックが行われていなくてはならない。次に、構文チェックの後、
再度型チェックを走らせると両方の処理が正しく終了したことを示す記号
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}}と
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}} 
がそれぞれの状態表示する場所に表示される。

型チェック処理はワーニングを返してきたとしても成功であることに注意。
これはワーニングは一般的に実際のエラーというよりは仕様の中の余計なものを
表しているためである。例えば、ある特定のbool式がいつもfalseであると予想されたり、
特定のパラメータやローカル変数が関数や操作中で一度も使用されないなどである。
もちろん、このように余計なものは実際にはエラーの原因となることがある
(ワーニングの数を増加させているものの中には、表現や記述のタイプミスもあるかもしれない。)
そのためワーニングをチェックすることは実際取るに足らないことであることを確認するため
にも有用である。例で言えばこのワーニングは{\tt MergeSort} 関数内のcase文の2番目の
パターンにあるローカル変数`{\tt e}'が一度も使用されていないと言っている。これは現実にはエラー
ではなく、仕様書は正しく意味をなしている。ただしワーニングを除去したいのであれば、
`{\tt e}'を`{\tt -}'（“don't-care” pattern）に置き換えればよい。

仕様書は型チェックをパスしたが、これは（仕様書が）正しいことを保障するものではなく、
まだエラーが潜んでいるかもしれない（プログラミング言語に適したコンパイラの構文チェック、
型チェックをパスしたとしても、0除算によるランタイムエラーなどがありうるように）。このようなモデル
中のランタイムエラーの潜在的な元となるところを特定する一助とするために、型チェック機能には
仕様書中でランタイムエラーを起こしうる潜在的なところをすべてエラーとして報告するオプション
がある。そのため、もし報告された潜在的なエラーが起こり得ないと自分自身が納得するなら、
ランタイムエラーは起こらないだろう。これについてのより詳しい情報は、このマニュアルのセクション
~\ref{sec:def-typechedk}を参照のこと。
#endif JPN

% Ueki 2005/01/06 ここまで

% 
% %%%%%%% Next bit needs reinstating and updating when References
% %%%%%%% window is working -- RM 
%
% #ifdef VDMPP
% \subsection{Getting an Overview of the Classes}

% {\bf whole section needs revising -- RM}

% It can be difficult to gain an overview of the structure of a \vdmpp\ 
% specification simply from its ``flat'' documentation. The \Toolbox\ 
% includes two tools which can show the structure of the classes which
% have been read in and syntax checked.  These are called the
% \guicmd{Inheritance Tool} and the \guicmd{Dependency Tool}.
% Alternatively, if you prefer to use UML, the Rose-\vdmslpp\ link could
% be used instead. However, that link will not be considered in this
% manual, instead we refer the interested readers to \cite{UMLMan-CSK}.
% % (see \cite{} for more information).

% \subsubsection{Using the inheritance tool}

% Invoke the \guicmd{Inheritance tool}\index{Inheritance Tool} from the
% \guicmd{Tools} menu in the main window. The inheritance tree of the
% sort specification will now appear in a new window as shown in
% Figure~\ref{fig:inhtree}. The inheritance tree shows that {\tt Sorter}
% is a superclass of {\tt DoSort}, {\tt ExplSort}, {\tt ImplSort} and
% {\tt MergeSort}. The {\tt SortMachine} class has no super- or
% subclasses. The tool gives the inheritance information of those
% classes that have been accepted by the syntax checker.

% \begin{figure}[tbh]
% \begin{center}
% %\resizebox{8cm}{!}{\includegraphics{inhtree}}\
% \caption{The Inheritance Tree of the Sorting Specification\label{fig:inhtree}}
% \end{center}
% \end{figure}

% Besides giving a survey of the inheritance structure of the
% specification, the inheritance tree can also be used to navigate
% through your specification. Select one class in the inheritance tree
% by clicking with the leftmost mouse button. The class will now be
% selected in the main window of the \Toolbox.


% \subsubsection{Using the dependency tool}\label{sec:dependencytool}

% Another way to get a better overview of the structure of a \vdmpp\ 
% specification is to use the \guicmd{Dependency Tool}\index{Dependency
%   Tool} which for a selected class shows:
% \begin{itemize}
% \item its superclasses, 
% \item its subclasses, 
% \item the classes it uses~(a class {\em uses\/} another class if it
%   has references to objects of that class, for example through its
%   instance variables or operation calls), and
% \item the classes which use the selected class.
% \end{itemize}

% Select the \guicmd{Dependency Tool} in the \guicmd{Tools} menu bar in
% the main window. A new window with the \guicmd{Dependency Tool} will
% now pop up. If you select the class {\tt Sorter} in the classes list
% in the main window the \guicmd{Dependency tool} will appear as shown
% in Figure~\ref{fig:dep_sorter}. You can see that {\tt DoSort}, {\tt
%   ExplSort}, {\tt ImplSort} and {\tt MergeSort} are subclasses to the
% {\tt Sorter} class and that the {\tt Sorter} class uses the {\tt
%   SortMachine} class (the {\tt SortMachine} has an instance variable
% which is an object reference to the {\tt Sorter} class).


% \begin{figure}[tbh]
% \begin{center}
% %\resizebox{9cm}{!}{\includegraphics{dependency_sorter}}
% \caption{The Dependency Information on the {\tt Sorter} Class\label{fig:dep_sorter}}
% \end{center}
% \end{figure}

% As with the \guicmd{Inheritance Tool}, you can navigate through the
% specification in the \guicmd{Dependency Tool}. Just click on a class
% in the \guicmd{Dependency Tool} and that class will be selected
% in the main window, in the \guicmd{Dependency Tool} and in the
% \guicmd{Inheritance Tool} if it is open. Now try clicking on class
% {\tt SortMachine}, and you will get the dependency information for
% this class as shown in Figure~\ref{fig:dep_sortmachine}. From this you
% can see that the class has no super- or subclasses, nor is it used by
% any other classes, however, it uses the class {\tt Sorter}.


% \begin{figure}[tbh]
% \begin{center}
% %\resizebox{9cm}{!}{\includegraphics{dependency_sortmachine}}
% \caption{The Dependency Information on the {\em SortMachine} Class\label{fig:dep_sortmachine}}
% \end{center}
% \end{figure}
% #endif //VDMPP

#ifdef ENG
\subsection{Validating your Specification}
#endif ENG
#ifdef JPN
\subsection{仕様書の検証}
#endif JPN

#ifdef ENG
Specifications are developed for a purpose: usually in order to gain a
better understanding of the desired behaviour of a proposed computing
system, or in order to check that some design has desired properties
such as safety, or in order to serve as the basis for subsequent
detailed design or coding. Whatever its purpose, it is not sufficient
for a specification merely to be syntax- and type-correct -- it must
also faithfully express the behaviour of the system being modelled,
albeit at an abstract level.

{\em Validation\/} is the process of increasing confidence that a
formal specification accurately reflects the informally expressed
requirements for the system which is being modelled. A wide range of
validation 
techniques are available when the specification is given in a formal
specification language: specifications may be inspected and they may
be tested; it is even possible to conduct highly rigorous proofs that
specifications exhibit desired properties. The \Toolbox\ provides
support for validation through animation and testing using the
interpreter and the debugger -- executing parts
of the specification on chosen input values -- and through the
generation of integrity properties. This section shows you
how the interpreter, the debugger and the integrity examiner can be
used to check your specification and improve its quality.
#endif ENG

#ifdef JPN
仕様はある目的のために作成される：通常は提案されたコンピュータシステムの
設計された振る舞いの理解を深めるためだったり、安全性などの特性を考慮して
設計されているかチェックするためだったり、次の詳細設計や実装の基礎に役立てる
ためだったりする。その目的は何であれ、単に仕様書の構文や型が正しいだけでは
不十分で、たとえ抽象的なレベルであってもモデル化されたシステムの振る舞いを
忠実に表現していなくてはならない。

{\em 検証\/}は形式仕様が、モデル化されたシステムの非形式に表現された
要求を正確に反映しているかどうかについて自信を深めるプロセスである。
形式仕様言語の仕様書があれば、広範囲の検証技術が使える:仕様書は
詳細に調べることができ、テストもできる。仕様書が設計された特徴を表現して
いるかについて極めて厳格な試験を実施することも可能だ。\Toolbox\ はアニメーションと
デバッガ（仕様書の一部に値を入力して実行）とインタープリタを使ったテストまで、
あるいは証明課題の生成まで検証作業をサポートしている。このセクション
では仕様書のチェックとその品質向上のために使われるインタープリタ、デバッガや
証明課題生成機能をどう使うかについて記述する。
#endif JPN

#ifdef ENG
\subsubsection{Evaluating expressions using the interpreter}
\label{interpreter}\index{Interpreter}
#endif ENG
#ifdef JPN
\subsubsection{インタープリタを使用した式の評価}
\label{interpreter}\index{インタープリタ}
#endif JPN

#ifdef ENG
The interpreter allows you to evaluate and debug expressions and
statements.  These can be arbitrarily complex, including application
of functions and operations and use of variables defined in the scope
of the specifications read into the \Toolbox.  The debugger allows you
to set breakpoints, step through the evaluation, and inspect variables.

The \guicmd{Interpreter Window}\index{Interpreter Window}, shown in
Figure~\ref{fig:interpwin}, is opened by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{interpreter.png}}  
(\guicmd{Interpreter}) button on the (\guicmd{Window Operations})
toolbar. The \guicmd{Interpreter} toolbar is opened at the same
time if it is not already open.
#endif ENG

#ifdef JPN
インタープリタを使って式や命令文を評価しデバッグすることができる。
これらはかなり複雑で、\Toolbox\ に読み込まれている仕様書で定義されている
アプリケーションの関数 や 操作、変数の使用を含んでいる。デバッガを使うと
ブレイクポイントの設定、評価作業のステップ実行、変数の値を見るなどができる。

図~\ref{fig:interpwin}に示す\guicmd{実行ウインドウ}\index{インタープリタウィンドウ}が
(\guicmd{ウインドウ})ツールバーの\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{interpreter.png}}  
(\guicmd{実行})ボタンを押すことによって開く。
\guicmd{実行}ツールバーが、まだ開いていなければ同時に開く。
#endif JPN


\begin{figure}[tbh]
\begin{center}
\includegraphics[width=11cm]{interpreterWindow.png}
#ifdef ENG
\caption{The Interpreter Window}
#endif ENG
#ifdef JPN
\caption{実行ウインドウ}
#endif JPN
\label{fig:interpwin}
\end{center}
\end{figure}

#ifdef ENG
The top two panes of the tool are respectively the
\guicmd{Response} and \guicmd{Dialog} panes: you
can give commands directly to the interpreter in the
\guicmd{Dialog} pane and you receive output from the
interpreter in the \guicmd{Response} pane. To evaluate a \vdmslpp\
expression, you type it directly on the command line in the
\guicmd{Dialog} pane.

Type the following expression into the \guicmd{Dialog} pane:
#endif ENG

#ifdef JPN
ツールの画面2つの上部には、それぞれ\guicmd{Response}  と \guicmd{Dialog}画面がある：
\guicmd{Dialog}画面からはインタープリタに直接コマンドを入れることが出来、
その結果が\guicmd{Response}画面に表示される。\vdmslpp\ の表現を評価するためには、
\guicmd{Dialog}画面からコマンドラインで直接タイプする。 

Dialog画面で下記のようにタイプしてみよう:
#endif JPN

\begin{verbatim}
  print { a | a in set {1,...,10} & a mod 2 = 0 }
\end{verbatim}

#ifdef ENG
It is also possible to refer to the \vdmslpp\ constructs which have
been read in from the 
\ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf} file}{specification
  files}, but before doing this you must first
initialise\index{Interpreter!Initialising} the 
interpreter by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{runI.png}}  
(\guicmd{Init}) button. 
During initialisation, constants are 
evaluated and \ifthenelse{\boolean{VDMsl}}{state values}{instance
  variables} are initialised. 
After initialisation you can refer to any of the functions,
operations, \ifthenelse{\boolean{VDMsl}}{}{instance variables,}
values, types etc.\ which are defined in the
\ifthenelse{\boolean{VDMsl}}{}{classes in the} specification.
#endif ENG

#ifdef JPN
% ueki
% この部分未訳

%It is also possible to refer to the \vdmslpp\ constructs which have
%been read in from the 
%\ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf} file}{specification
%  files}, but before doing this you must first
%initialise\index{Interpreter!Initialising} the 
%interpreter by pressing the 
%\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{runI.png}}  
%(\guicmd{Init}) button. 
%During initialisation, constants are 
%evaluated and \ifthenelse{\boolean{VDMsl}}{state values}{instance
%  variables} are initialised. 
%After initialisation you can refer to any of the functions,
%operations, \ifthenelse{\boolean{VDMsl}}{}{instance variables,}
%values, types etc.\ which are defined in the
%\ifthenelse{\boolean{VDMsl}}{}{classes in the} specification.
#endif JPN

#ifdef ENG
then press RETURN.  The answer is a set of even
numbers. The expression you evaluated was a set comprehension, a value
construction which is explained further in
\ifthenelse{\boolean{VDMsl}}{\cite{UMLMan-CSK}}{\cite{LangManPP-CSK}}.
#endif ENG
#ifdef JPN
Returnキーを押す。
答えとして、偶数の集合が表示される。今検証した式は、集合内包と呼ばれる構成子
である。後に
（\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%% comment by teramoto
%  for VDM-SL description
\cite{UMLMan-CSK}
%  for VDM-SL description end
}
{
%  for VDM-PP description
\cite{LangManPP-CSK}
%  for VDM-PP description end
%%%%%%%%%%%%%%%%%%%%% comment by teramoto end
}
）で説明する。


\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto 
%  for VDM-SL description
{\tt sort-init.rtf} ファイル
}
{
%  for VDM++ description
仕様書のファイル
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto end
}
から読み込んだ\vdmslpp\ の構造を参照することもできるが、
それをやる前に\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{runI.png}}  
(\guicmd{初期化})ボタン を押してインタープリタの初期化\index{インタープリタ!しょきか@初期化} をしなくてはならない。
初期化中、定数は評価され
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto 
%  for VDM-SL description
状態の値
}
{
% for VDM++ description
インスタンス変数
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto end
}
は初期化される。初期化後は、関数、操作、
インスタンス変数、値、型など仕様書\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto 
% nothing to add for VDM-SL here
}
{
% add description for VDM++ here
のクラス
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto end
}内で定義されているものなら
何でも参照できる。 
#endif JPN

#ifdef VDMSL 
#ifdef ENG
In order to see which functions\index{Interpreter!Callable Functions}
you can call 
currently, type {\tt functions} at the prompt in the \guicmd{Dialog}
pane and press RETURN. This displays the list of available
functions. From this list you can see that it is, for example,
possible to call the invariant function\index{Invariant Functions|see
  {\\ Functions, \\ Invariant}}\index{Functions!Invariant} for
types which have an invariant attached to them, like the type {\aaa
  PosReal}. The dialogue is illustrated in Figure~\ref{fig:evalgui}.
#endif ENG
#ifdef JPN
現在どの関数\index{インタープリタ!よびだしかのうかんすう@呼び出し可能関数}が呼び出し可能か
見るには、\guicmd{Dialog}画面のプロンプトで{\tt functions}とタイプしてReturnを
押す。このコマンドは利用できる関数の一覧を表示する。リストからは、例えば不変条件
関数\index{よびだしふかのうかんすう@呼び出し不可能関数 |see {\\ 関数, \\ 不変条件}}
\index{かんすう@関数!ふへんじょうけん@不変条件}
を呼び出せることがわかるだろう。これは
{\aaa PosReal}型のような不変条件を含む型がそれらに付随しているからである。
ダイアログは図~\ref{fig:evalgui}で示す。
#endif JPN
#endif VDMSL

#ifdef VDMPP
#ifdef ENG
In order to see which functions you can call from the class
{\aaa MergeSort}, type {\cmd functions MergeSort} at the
prompt in the
\guicmd{Dialog} pane.  This displays the list of available functions
in class {\aaa MergeSort}.  From this list it can be seen that it is
possible to call the precondition
function\index{Precondition Functions|see{\\ Functions, 
\\ Precondition}}\index{Functions!Precondition} for functions which
have a precondition attached to them, like the function {\aaa
  pre\_Merge}.

Application of functions and operations and inspection of instance
variables and values can only be performed through objects.  Objects
can be created so that they are available for subsequent use in the
interpreter.

The following two commands, when used in the \guicmd{Dialog} pane, will
create an object of class {\aaa MergeSort} named {\aaa ms} then call
the operation {\tt Sort} on {\tt ms} with the sequence {\tt [ 3.1415,
  -56, 34-12, 0 ]} and display the result:

\begin{verbatim}
  create ms := new MergeSort()
  print ms.Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}

Alternatively, objects can 
be created local to the evaluation of a statement in the interpreter.
 For example the call to {\tt MergeSort`Sort}
could also be performed by the following command where the {\tt ms}
object from the previous example is not given any name at all:

\begin{verbatim}
  print new MergeSort().Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}

In this example an object is created local to the evaluation, i.e.\ 
it only exists throughout the evaluation of the {\tt Sort} operation.

In order to look up an instance variable, first create an object of
the class {\tt SortMachine}:

\begin{verbatim}
  create sm := new SortMachine()
\end{verbatim}

The class {\tt SortMachine} has an instance variable {\tt srt} that is
a reference to a {\tt Sorter} object.  Initially {\tt srt} points
to a {\tt MergeSort} object.  Try first to see the value of {\tt srt}
and then call the {\tt Sort} operation on the object it points to:

\begin{verbatim}
  print sm.srt
  print sm.srt.Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}

Figure~\ref{fig:evalgui} shows the results of all the above
evaluations.
#endif ENG
#ifdef JPN
どの関数が{\aaa MergeSort}クラスから呼び出し可能かを見るために、\guicmd{Dialog} 画面の
プロンプトで{\cmd functions MergeSort} とタイプする。これで{\aaa MergeSort}クラスの
呼び出し可能な関数のリストが表示される。リストからは関数{\aaa pre\_Merge}のような、
付随する事前条件がある場合に生成される事前条件関数
\index{ぜんていじょうけんかんすう@前提条件関数 |see{\\ 関数, \\ 事前条件}}
\index{かんすう@関数!じぜんじょうけん@事前条件}
を呼び出すことが可能であることが見て取れる。

関数や操作、インスタンス変数の精査、値の
アプリケーションはオブジェクトを通じてのみ実行される。オブジェクトが生成されているために、
その後インタープリタ内でそれらを利用する事ができる。

以下の2つのコマンドは、\guicmd{Dialog} 画面で使うと、{\aaa ms} という名の {\aaa MergeSort}クラスの
オブジェクトを生成し、引数[3.1415, -56, 34-12, 0 ] で{\tt ms} の{\tt Sort}関数を呼び出し、
結果を表示する。

\begin{verbatim}
  create ms := new MergeSort()
  print ms.Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}

また、オブジェクトはインタープリタ中の記述の評価中でもローカルに生成することが
可能である。例えば、前の例の{\tt ms}オブジェクトのようにオブジェクト名をつけなくても
{\tt MergeSort`Sort}は以下のコマンドで実行できる 

\begin{verbatim}
  print new MergeSort().Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}

この例では、評価の最中ローカルにオブジェクトが生成されるが{\tt Sort} 操作
のテスト中だけオブジェクトが存在することとなる。

インスタンス変数を調べるため、まず {\tt SortMachine}クラスのオブジェクトを生成する。

\begin{verbatim}
  create sm := new SortMachine()
\end{verbatim}

{\tt SortMachine}クラスは{\tt srt}という名前のインスタンス変数を持ち、これは{\tt Sorter}
オブジェクトの参照である。初期値は{\tt srt}には{\tt MergeSort}オブジェクトをさしている。
まず{\tt srt}の値を見てオブジェクトのさす{\tt Sort}関数を呼んでみる。

\begin{verbatim}
  print sm.srt
  print sm.srt.Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}

図~\ref{fig:evalgui}は上記の評価の結果を表している。
#endif JPN

#endif VDMPP

\begin{figure}[tbh]
\begin{center}
\mbox{}
#ifdef VDMSL
%\resizebox{0.8\textwidth}{!}{\includegraphics{evalExpr-sl}}
\includegraphics[width=15cm]{evalExpr-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=15cm]{evalExpr-pp.png}
#endif VDMPP
#ifdef ENG
\caption{Evaluation of Expressions}
#endif ENG
#ifdef JPN
\caption{式の評価}
#endif JPN
\label{fig:evalgui}
\end{center}
\end{figure}

#ifdef VDMSL 
#ifdef ENG
Now you can use the {\tt print} command to call, for example, the
{\aaa Merge} function with two ordered sequences of integers (type,
for instance, {\tt print Merge([1, 3, 6], [-2, 3, 7])}) and the
interpreter will display the result of evaluating the {\aaa Merge}
function with those particular arguments~({\tt [-2, 1, 3, 3, 6, 7]};
see Figure~\ref{fig:evalgui}).

Note that a few \vdmslpp\ constructs are not executable and therefore
cannot be evaluated using the interpreter. For example, if you try
to call the implicitly defined function \index{Implicit
  Functions|see{\\ Functions, \\ Implicit}} \index{Functions!Implicit} {\aaa
  ImplSort}, the interpreter will return an error saying that it
encountered a non-executable construct\index{Non-executable
  Constructs} during evaluation.  See Figure~\ref{fig:evalgui}. 
#endif ENG

#ifdef JPN
これで {\tt print} コマンドが使えるようになった。例えば、{\aaa Merge} 関数
を、2つの順番に並んだInteger列を引数に取り、呼び出すには（例：{\tt print Merge([1, 3, 6], [-2, 3, 7])}とタイプする）
そうすると、インタープリタはこれら特定の引数~({\tt [-2, 1, 3, 3, 6, 7]};
see Figure~\ref{fig:evalgui})について、Merge関数の評価結果を表示する。 

 \vdmslpp\ を構成するものの中には、いくつか実行不可能なものも含まれており、
 ゆえにインタープリタを使用しての評価ができないものがある。例えば、陰関数
 \index{あんもくていぎかんすう@暗黙定義関数|see{\\ 関数, \\ 暗黙}}
 \index{かんすう@関数!あんもく@暗黙} {\aaa ImplSort}
 をコールしようとすると、インタープリタは、評価中に実行不可能な構成物
 \index{じっこうふかのうなこうせいぶつ@実行不可能な構成物}に出くわしたとエラーを返す。
 図~\ref{fig:evalgui}参照のこと。
#endif JPN
#endif VDMSL

#ifdef VDMPP
#ifdef ENG
Note that not all \vdmslpp\ constructs are executable and unexecutable
constructs cannot be evaluated using the interpreter.  For example if
you try to call the implicitly defined function {\aaa
  ImplSort`ImplSorter} with a sequence of numbers, the interpreter
will return an error saying that it encountered a non-executable construct
\index{Non-executable Constructs} during evaluation. See
Figure~\ref{fig:evalgui}.
#endif ENG
#ifdef JPN
\vdmslpp\ の構成物すべてが実行可能なわけではないので、実行可能でない
ものはインタープリタを使った評価が出来ないことに注意。例えば、陰関数{\aaa ImplSort`ImplSorter} を
数字の引数を使って呼び出そうとした場合、インタープリタは評価中に実行不可能な構成物
\index{じっこうふかのうなこうせいぶつ@実行不可能な構成物}に出くわしたとエラーを返す。
図~\ref{fig:evalgui}を参照
#endif JPN
#endif VDMPP

#ifdef ENG
\subsubsection{Setting breakpoints}
\label{sec:gui-breakpoints}\index{Breakpoints}\index{Breakpoints!Setting} 
#endif ENG
#ifdef JPN
\subsubsection{ブレイクポイントの設定}
\label{sec:gui-breakpoints}\index{ブレイクポイント}\index{ブレイクポイント!せってい@設定} 
#endif JPN

#ifdef ENG
Breakpoints cause the interpreter to break execution when evaluating 
functions or operations.

Set a breakpoint in the function \ifthenelse{\boolean{VDMsl}}{{\aaa
MergeSort} by typing {\aaa break MergeSort}}{{\aaa
MergeSorter} in the class {\aaa MergeSort} by typing {\aaa break
MergeSort`MergeSorter}}.

(\ifthenelse{\boolean{VDMsl}}
{
If you are setting a breakpoint in the
current module you can simply refer to the function/operation name.
If you are setting a breakpoint in another module you must qualify the
function/operation name with the name of the module in which it is
defined.
}{When setting a breakpoint the name of the function or
operation must be qualified with the name of the class in which it is
defined.}) The location of the breakpoint will now appear in the
\guicmd{BreakPoints} pane at the bottom right of the
\guicmd{Interpreter Window} together with the number allocated to the
breakpoint (1 in this case since this is the first breakpoint we have
set) and the symbol \raisebox{0.5mm}{{\fbox{\tt\tiny $\surd$}}}\ which
indicates that the breakpoint is enabled.  You can now use the {\cmd
  debug} command\index{debug command} to start the evaluation
instead of the {\cmd print} command\index{print command} used
before. The only difference between the two commands is that {\cmd
  debug} forces the interpreter to stop at breakpoints whereas
{\cmd print} ignores breakpoints.\index{Breakpoints!Ignoring} 
#endif ENG
#ifdef JPN
ブレイクポイントは、インタープリタで関数などの実行をするときに実行を一時中断する。

関数
\ifthenelse{\boolean{VDMsl}}
{ 
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto 
% SLの場合の記述　Start
{\aaa MergeSort}に {\aaa break MergeSort}とタイプすることで
%SLの場合の記述　end
}
{
%PPの場合の記述　Start
クラス{\aaa
MergeSorter} の{\aaa MergeSort} に、{\aaa break
MergeSort`MergeSorter}とタイプすることで
%PPの場合の記述　end 
%%%%%%%%%%%%%%%%%%%%%% comment  by teramoto end
}
ブレイクポイントを設定することができる。

(\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%% comment by teramoto
% description for VDM-SL
現在のモジュールにブレイクポイントを設定するときは、単純に関数または操作
名を参照すればよい。他モジュールにブレイクポイントを設定する場合は、関数または
操作名を定義済みのモジュール名で分類しなくてはならない。
% description for VDM-SL end
}
{
% description for VDM++
ブレイクポイントを設定するとき、定義されたクラス名と関数名の両方が必要
% description for VDM++ end
%%%%%%%%%%%%%%%%%%%%% comment by teramoto end
}) 
ブレイクポイントの箇所は\guicmd{実行ウインドウ}の右下、ほかの設定された
ブレイクポイント（この例では1つしかブレイクポイントを設定していないので、１つである）と
ブレイクポイントが有効であることを示す記号\raisebox{0.5mm}{{\fbox{\tt\tiny $\surd$}}}\ 
と一緒に\guicmd{ブレイクポイント}画面に表示される。
今度は以前使った\index{printコマンド}コマンドを使う代わりに、{\cmd debug}コマンドを使って評価作業を行うことが
出来る。この2つのコマンドの違いは、{\cmd print} がブレイクポイントを無視する一方、{\cmd debug}コマンド
はブレイクポイントで強制的にインタープリタがストップすることである。\index{ブレイクポイント!むし@無視}

以下のようにタイプして
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%% comment by teramoto
% description for VDM-SL
{\aaa MergeSort}
% description for VDM-SL end
}
{
% description for VDM++
{\aaa Sort}
% description for VDM++ end
%%%%%%%%%%%%%%%%%%% comment by teramoto end
}関数を呼び出してみる。
#endif JPN

#ifdef VDMSL
\begin{verbatim}
  debug MergeSort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
  debug new MergeSort().Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}
#endif VDMPP

#ifdef ENG
will cause the interpreter to stop at the breakpoint when it enters
the function \ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa
    Sort}}. At the same time, the source file containing the
specification of the function \ifthenelse{\boolean{VDMsl}}{{\aaa
    MergeSort}}{{\aaa Sort}} is displayed in the \guicmd{Source
  Window} and the current point of evaluation (at the moment this is
the location of the breakpoint, i.e.\ the beginning of the function
\ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa
    Sort}}) is indicated by the cursor. In addition, the
\guicmd{Trace} pane, which is situated at the bottom left of the
\guicmd{Interpreter Window}, shows the function call stack\index{Call
  stack}.

You can now inspect the values of the parameters of the
    \ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa Sort}} 
function, either by printing them using {\cmd print} (e.g.\ by typing
{\aaa print l} in the \guicmd{Dialog} pane)\index{print command}
or by clicking the left mouse button on the \Sig{...} adjacent to
the function name in the \guicmd{Trace} pane at the bottom left of
the \guicmd{Interpreter Window}. Clicking the left mouse button on the
parameters which are revealed will replace them with the \Sig{...}
again.

You can also set breakpoints by selecting the desired position
directly in the appropriate source file. In addition, breakpoints need
not be at the start of a function/operation but can be at any position
within its body.

If the source file is not an RTF file you can set breakpoints by
double-clicking the left or middle mouse button on the desired
position in the file in the \guicmd{Source Window}. If you are using
an RTF source file you must position the cursor at the appropriate
position in the file in Microsoft Word, then press
\texttt{Control-Alt-spacebar} %\index{control-alt-spacebar} 
to set a breakpoint.

You can set breakpoints at any time during debugging, so now use the
source file to set a new breakpoint inside the function {\aaa Merge}
\ifthenelse{\boolean{VDMsl}}{}{in the class {\aaa MergeSort}} as
described above.

Return to the interpreter and press the
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{continueI.png}} 
(\guicmd{Continue}) button on the (\guicmd{Interpreter}) toolbar.  
This causes the execution to carry on to the next breakpoint. In fact
because of the recursive call of \ifthenelse{\boolean{VDMsl}}{{\aaa
    MergeSort}}{{\aaa Sort}} the interpreter will stop at the same
breakpoint again, so press the \guicmd{Continue} button repeatedly
until the execution stops inside the {\tt Merge} function.

As the execution proceeds, the various function/operation calls are
logged in the \guicmd{Trace} pane, and you can use this function call
stack\index{Call stack} to navigate through the steps of the
execution so far. Press the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{upI.png}}  
(\guicmd{Up}) button a couple of times to see how the position in the
function trace context can be changed. The 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{downI.png}}  
(\guicmd{Down}) button can be used to move back down the
trace again.

You can also step through the execution expression by expression by
pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{singlestepI.png}}
(\guicmd{Single Step}) button. Press this a few times and 
see how the cursor in the \guicmd{Source Window} moves to mark the
changes in the current point of evaluation. You now have access not
only to the parameters of the function but also to all the variables
(including local variables) that are in scope at the current point of
evaluation, and you can inspect their values using, for example, the
{\cmd print} command.

This debugging is shown in Figure~\ref{fig:guidebug}.  

#endif ENG
#ifdef JPN
するとインタープリタは
\ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa Sort}}
関数に入ったところのブレイクポイントでストップする。
同時に、
\ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa Sort}}
関数を含む仕様書のソースファイルが\guicmd{ソースウインドウ}に表示され、
現在評価中のポイント（ここではブレイクポイントの場所。例では
\ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa Sort}}
関数の最初のところ）
にカーソルが当たっている。加えて、\guicmd{追跡}画面（\guicmd{実行ウインドウ}の左下）には
コールスタック\index{コールスタック}が表示されている。

ここで、
    \ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa Sort}} 
関数のパラメータの値を{\cmd print}コマンドを使うか（\guicmd{Dialog}画面で{\aaa print l} とタイプする）
\index{printコマンド}、\guicmd{実行ウインドウ}の左下部分にある
\guicmd{追跡} 画面の関数名の近くに表示されている\Sig{...} 部分でマウスの左ボタンをクリックすると詳細に
見ることが出来るはずだ。値の表示されているパラメータ上でマウスの左ボタンをクリックすると、
また\Sig{...} 表示に戻る

適切なソースファイルの箇所を直接選択することでもブレイクポイントを設定することが
できる。加えて、ブレイクポイントは関数･操作の最初である必要はなく、
その内部であればどこでも設定できる。

ソースファイルがRTF形式のファイルでない場合は、マウスの左または真ん中のボタンを
\guicmd{ソースウインドウ}のファイル中、設定したい位置でダブルクリックするとブレイクポイントが
設定できる。
ソースファイルにRTFフォーマットを使っている場合は、Wordでファイルの適切な位置に
カーソルをあて\texttt{Control-Alt-Spaceキー} でブレイクポイントが設定できる。

デバッグ中はいつでもブレイクポイントが設定できる。それではソースファイルを使って、
\ifthenelse{\boolean{VDMsl}}{}{{\aaa MergeSort}クラスの}
{\aaa Merge}関数内にブレイクポイントを設定してみよう。上記のようになる。

インタープリタに戻って(\guicmd{実行})ツールバーの
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{continueI.png}} 
(\guicmd{実行再開})ボタンを押してみよう。これで
次のブレイクポイントまで実行される。実際には
\ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa Sort}}
の再帰的な呼び出しによって、インタープリタは同じブレイクポイントで何度か止まるが、
そのたびに{\tt Merge}関数の中で
実行がとまるまで\guicmd{実行再開}ボタンを何度も押す。

実行が進むにつれ、さまざまな関数が呼ばれ\guicmd{追跡}画面にログが増えていく。
そしてこのコールスタック\index{コールスタック} を実行のステップをトレースするのに使うことが出来る。 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{upI.png}}  
(\guicmd{現在の函数を呼び出している函数に戻るところまで実行})ボタンを何度か押して関数のトレースの前後関係がどう変化しているか確認できる。 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{downI.png}}  
(\guicmd{現在の函数が下位の函数を呼び出すところまで実行})ボタンは追跡を元に戻すときに使う。

\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{singlestepI.png}}
(\guicmd{函数内をステップ実行})ボタンを押すことでステップ実行をすることもできる。ボタンを何度か押してカーソルが
\guicmd{ソースウインドウ} で、実行中評価の現在の箇所の変化をマークするのにどのように動くかを確認してほしい。
これで関数のパラメータだけでなく、スコープ中にあるローカル変数を含めたすべての変数に
アクセス可能になり、例えば{\cmd print} コマンドを使うなどして値の中身を見ることもできる。

図~\ref{fig:guidebug}にデバッグの例を示す。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=\textwidth]{debugging-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=15cm]{debugging-pp.png}
#endif VDMPP
#ifdef ENG
\caption{Debugging a Specification}
#endif ENG
#ifdef JPN
\caption{仕様のデバッグ}
#endif JPN

\label{fig:guidebug}
\end{center}
\end{figure}

#ifdef ENG
You can delete breakpoints, also at any time during the
debugging.\index{Breakpoints!Deleting} Try this by typing 
{\tt delete 1} (i.e.\ delete breakpoint number 1) in the
\guicmd{Dialog} pane of the \guicmd{Interpreter Window}. Selecting the
breakpoint in the \guicmd{BreakPoints} pane of the \guicmd{Interpreter
  Window} and pressing the \guicmd{Delete} button at the top of that
pane has the same effect.

The other two buttons at the top of the \guicmd{BreakPoints} pane are
for enabling and disabling
breakpoints.\index{Breakpoints!Disabling}\index{Breakpoints!Enabling}
Set the breakpoint in the function \ifthenelse{\boolean{VDMsl}}{{\aaa
    MergeSort}}{{\aaa MergeSort`MergeSorter}} again, then select
it in the \guicmd{BreakPoints} pane and press the \guicmd{Disable}
button. Note how the symbol \raisebox{0.5mm}{{\fbox{\tt\tiny
      $\surd$}}}\ is replaced by the symbol
\raisebox{1mm}{{\fbox{\rule[-0.75mm]{0mm}{1.5mm}{\hspace*{1.5mm}}}}}\
to indicate that the breakpoint is disabled. Pressing the
\guicmd{Enable} button will re-enable the breakpoint and the symbol
will change back to \raisebox{0.5mm}{{\fbox{\tt\tiny $\surd$}}}\ to
confirm this.
#endif ENG

#ifdef JPN
ブレイクポイントはデバッグ実行中でも削除することができる\index{ブレイクポイント!さくじょ@削除}。
\guicmd{実行ウインドウ}の\guicmd{Dialog} 画面で\\
{\tt delete 1} (例\ ブレイクポイント1番を削除)\\
とタイプしてみてほしい。（これで1番のブレイクポイントが削除される）
\guicmd{実行ウインドウ}の\guicmd{ブレイクポイント}画面でブレイクポイントを選択して画面上部
にある\guicmd{削除}ボタンを押しても結果は同じである。

\guicmd{ブレイクポイント} 画面上部の他2つのボタンは、ブレイクポイントの有効･無効を設定する。
\index{ブレイクポイント!むこう@無効}\index{ブレイクポイント!ゆうこう@有効}
\ifthenelse{\boolean{VDMsl}}{{\aaa MergeSort}}{{\aaa MergeSort`MergeSorter}}関数
の中にブレイクポイントを再度設定し、それを
\guicmd{ブレイクポイント}画面で選択して\guicmd{無効化}ボタンを押してみよう。
記号
\raisebox{0.5mm}{{\fbox{\tt\tiny $\surd$}}}\
がブレイクポイントが
無効になっていることを示す
\raisebox{1mm}{{\fbox{\rule[-0.75mm]{0mm}{1.5mm}{\hspace*{1.5mm}}}}}\ 
に変わっていることに注目。\guicmd{有効化} ボタンを押すことで
ブレイクポイントは再度有効になり、記号は
\raisebox{0.5mm}{{\fbox{\tt\tiny $\surd$}}}\ 
に戻るはずである。
#endif JPN

% It is also possible to make
% nested debugs.\index{Debugging!Nested} Try doing this and try using the
% {\tt popd}\index{{\tt popd} command} command to restore the context
% that existed when the last {\tt debug} command was invoked.

#ifdef ENG
\subsubsection{Dynamic type checking}
\index{Type Checking!Dynamic}
#endif ENG
#ifdef JPN
\subsubsection{動的型チェック}
\index{かたチェック@型チェック!どうてき@動的}
#endif JPN

#ifdef ENG
Although the type checker reported no errors in our specification,
there may still be type errors because in general it is not possible
to find all type errors by a simple static analysis of type
information (i.e.\ an analysis based only on the types declared in the
signatures of functions and operations). Thus, for example, if a
function is declared as taking an integer (of type {\aaa int}) as its
argument but is applied to an expression which evaluates to a real
number (of type {\aaa real}) this will not raise a static type error
because {\aaa int} is a subtype of {\aaa real} so the application
might be correct provided the function is called at run-time with
parameters which are actually integer reals.

In order to help discover this kind of type error at the specification
level, the interpreter can be configured to perform dynamic type
checking during evaluation.  This option is enabled through the
\guicmd{Interpreter} pane of the \guicmd{Project Options} window, 
which is displayed by pressing the
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{projectoptions.png}} 
(\guicmd{Project Options}) button on the (\guicmd{Project Operations})
toolbar. This is shown in Figure~\ref{fig:interoptions}.
#endif ENG
#ifdef JPN
型チェック機能が仕様書のエラーを見つけなくても、単に静的な型の情報
（\ 関数宣言のみの型チェックを分析した場合など）を分析しただけではすべての
型エラーをみつけることが不可能なので、依然として型エラーが存在する可能性がある。
例えばある関数が引数に{\aaa int}型の値をとると宣言されたが、式が{\aaa real}型の数字だった場合
静的型エラーにはならない。これは{\aaa int} 型が{\aaa real}型のサブタイプであるために、
アプリケーションは実際にはその関数がreal型のパラメータで実行時に呼ばれても、
正しいとしてしまう。

仕様レベルでこの手の型エラーを発見するために、インタープリタが評価実行中に
動的型チェックを実行するよう設定することができる。
このオプションは\guicmd{プロジェクトオプション} ウインドウの\guicmd{実行} タブで設定できるが、プロジェクト
オプションツールバーに表示されている\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{projectoptions.png}} 
 （\guicmd{プロジェクトオプション} ）ボタンを押すことで当該画面が表示される。
下記図~\ref{fig:interoptions}にこれを示す。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12.5cm]{interpreterOptions-sl.png}
#endif VDMSL
#ifdef PPONLY
\includegraphics[width=12.5cm]{interpreterOptions-pp.png}
#endif PPONLY
#ifdef VICEMAN
\includegraphics[width=12.5cm]{interpreterOptions-vice.png}
#endif VICEMAN
#ifdef ENG
\caption{Setting Interpreter Options}
#endif ENG
#ifdef JPN
\caption{インタープリタオプションの設定}
#endif JPN
\label{fig:interoptions}
\index{Options!Interpreter}
\end{center}
\end{figure}

#ifdef ENG
Enabling dynamic type checking causes the interpreter to check actual
types during an evaluation.

To see an example of this, enable dynamic type checking by selecting
it in the \guicmd{Interpreter} pane of the \guicmd{Project Options}
window and pressing the \guicmd{OK} button to accept the new
options. Then evaluate the expression 
#endif ENG

#ifdef JPN
「動的に型チェックする」オプションをを有効にすると、インタープリタは評価実行中、実際の型をチェックする。

今回の例では、\guicmd{プロジェクトオプション}ウインドウの\guicmd{実行} タブで動的型チェックを有効に設定し、
\guicmd{適用} 、\guicmd{OK} ボタンを押すと 、式の評価
#endif JPN

#ifdef VDMSL
\begin{verbatim}
  debug MergeSort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}
#endif VDMSL

#ifdef VDMPP
\begin{verbatim}
  debug new MergeSort().Sort([ 3.1415, -56, 34-12, 0 ])
\end{verbatim}
#endif VDMPP

#ifdef ENG
again in the \guicmd{Dialog} pane. This time the interpreter reports a
dynamic type error. (If you have not deleted or disabled all
breakpoints you will need to step through the specification to see
this.) This is because according to its signature the function
\ifthenelse{\boolean{VDMsl}}{{\aaa Merge}}{{\aaa MergeSort`Merge}}
expects sequences of integers as its parameters whereas the actual
parameters contain the value {\tt 3.1415} which is not an integer but
a real number. This dynamic type error thus reveals a possible error
in the specification -- the top-level function {\aaa MergeSort}
\ifthenelse{\boolean{VDMsl}}{}{ in the {\aaa MergeSorter} class} can
accept sequences of real numbers as its parameters but it calls the
function {\aaa Merge} \ifthenelse{\boolean{VDMsl}}{}{in the same
    class} which is only defined for lists of integers.

In a similar way, the interpreter can be configured to dynamically
check that invariants on types and preconditions and postconditions of
functions and operations are respected (i.e.\ evaluate to {\aaa true})
during evaluation. These options are also enabled through the
\guicmd{Interpreter} pane of the \guicmd{Project Options} window 
shown in Figure~\ref{fig:interoptions}.\index{Precondition Checking}
\index{Postcondition Checking}\index{Invariant Checking}

As an example, return to the \guicmd{Interpreter} pane of the
\guicmd{Project Options} window and enable the option \guicmd{Check of
  pre-conditions}. Now evaluate the previous expression again but this
time omitting the number {\tt 3.1415} from the list. Now the
interpreter reports a precondition violation as shown in
Figure~\ref{fig:dtcerror}. This is because the precondition of the
function \ifthenelse{\boolean{VDMsl}}{{\aaa Merge}}{{\aaa
    MergeSort`Merge}} requires that all the input values 
should be non-negative.
#endif ENG
#ifdef JPN
のところでインタープリタは動的型チェックエラーを報告する。（ブレイクポイントを有効に
設定したままになっていた場合は、一度ステップ実行をする必要がある）これは、関数
\ifthenelse{\boolean{VDMsl}}{{\aaa Merge}}{{\aaa MergeSort`Merge}}
のシグネチャが、引数にint型をとると宣言してあるのに、
実際の引数は{\tt 3.1415}というreal型（int型でない）の数字を含んでいるからである。この動的
型エラーは、仕様書のエラーの可能性を明らかにしている－
\ifthenelse{\boolean{VDMsl}}{}{ {\aaa MergeSorter} クラスの}
{\aaa MergeSort}関数はパラメータとしてreal型の列も許容すべきなのに、
\ifthenelse{\boolean{VDMsl}}{}{同じクラスの}
integerの列のみを許容する{\aaa Merge} 関数を呼び出しているためだ。

似たような方法で、インタープリタが動的に型の不変条件や関数の事前条件、事後条件、
予想される操作（例\ {\aaa true}と評価される）などのチェックをするように設定することが
可能である。これらのオプションも図~\ref{fig:interoptions}.\index{じぜんじょうけんチェック@事前条件チェック}
\index{じごじょうけんチェック@事後条件チェック}\index{ふへんじょうけんチェック@不変条件チェック} にあるような
\guicmd{プロジェクトオプション} ウインドウの\guicmd{実行} 
タブで設定することができる。

例として\guicmd{プロジェクトオプション} ウインドウの\guicmd{実行} タブに戻って、
\guicmd{事前条件をチェックする}のオプションチェックを有効にしてみよう。これで以前の箇所を再度評価してみると、
今度はリストから数字{\tt 3.1415}が省略されてしまっている。今度はインタープリタが図~\ref{fig:dtcerror}に示す
ように事前条件違反を報告している。これは
\ifthenelse{\boolean{VDMsl}}{{\aaa Merge}}{{\aaa MergeSort`Merge}}関数の事前条件が、
入力値の全てが負でないことを要求しているからだ。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12.5cm]{dynamicTCError-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=12.5cm]{dynamicTCError-pp.png}
#endif VDMPP
#ifdef ENG
\caption{Dynamic Type Checking Error}
#endif ENG
#ifdef JPN
\caption{動的型チェックエラー}
#endif JPN
\label{fig:dtcerror}
\end{center}
\end{figure}

#ifdef ENG
\subsubsection{Checking Integrity Properties}\label{pogWalk}
\index{Integrity Properties}
#endif ENG
#ifdef JPN
\subsubsection{証明課題のチェック}\label{pogWalk}
\index{しょうめいかだい@証明課題}
#endif JPN

#ifdef ENG
Dynamic checking of types, invariants, preconditions and
postconditions as described above is basically one form of testing --
it checks for run-time errors for some \emph{specific} input
values. The integrity examiner offers a more general way of
investigating possible run-time errors, though it is perhaps less
intuitive for people who are more familiar with programming than with
mathematics.

The integrity examiner analyses the specification looking for places
where run-time errors could potentially occur and generates a series
of integrity properties which represent conditions under which no
run-time errors should occur. These integrity properties are more
general than dynamic checking because they are presented as
 \vdmslpp\ predicates that involve quantification over all
possible values of the appropriate variables\footnote{In some cases
  the full context is not shown explicitly and the scope of some
  variables has to be determined by inspection of the specification.},
which means that if it 
can be demonstrated that an integrity property is true there will
not be run-time errors associated with that integrity check whatever
the values of the variables involved (dynamic checking of course
only checks that there are no run-time errors for the particular
values of the variables chosen). Of course if an integrity property
can instead be shown to be false this would point to there being a
potential problem with the corresponding part of the specification.

To see how the integrity examiner works in practice, select the 
\ifthenelse{\boolean{VDMsl}}{{\aaa DefaultMod} module}{ {\aaa
    ExplSort} class} then invoke the integrity examiner for this
\ifthenelse{\boolean{VDMsl}}{module}{class} by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{integritycheck.png}}  
(\guicmd{Generate Integrity Properties}) button on the (\guicmd{Actions})
toolbar. The \guicmd{Integrity Properties Window} then opens and
displays the integrity properties generated. This is shown in 
Figure~\ref{fig:integWin}.
#endif ENG
#ifdef JPN
上記の型チェック、不変条件、事前条件、事後条件などの動的チェックは
基本的にテストの一形式である－いくつかの \emph{特別な}入力値に対してランタイム
エラーが起こるかどうかチェックする。証明課題生成機能はランタイムエラーの可能性を
調査するもっと一般的な方法を提供するが、これは数学よりもプログラミングに
通じている人からすれば、あまり直感的に理解できないかもしれない。

証明課題生成機能は仕様書の潜在的にランタイムエラーが起こりうる箇所を探して分析し、
ランタイムエラーが起こりえない条件を表す一連の証明課題を生成する。
これらの証明課題は、動的チェックよりもより一般的に使われるが、それは適切な
変数\footnote{
場合によっては、すべてのコンテクストが明確に示されず、変数のスコープが仕様書の精査によって定義される。
}がとりうる
すべての値の定量化を含む \vdmslpp\ の記述として表現されるからである。
これは、もし証明課題がTrueと実行された場合、変数の値に何が入っていようが
それと関連するランタイムエラーは存在しないことになる（動的チェックの場合、
もちろん選ばれた変数の特定の値についてランタイムエラーが起こらないことが確認できる
にすぎない）。もちろん、証明課題がfalseを示すこともあり、その場合仕様書の
相当する箇所に潜在的な問題があることを指摘している。

実際に証明課題生成機能がどう動くかを見るには、
\ifthenelse{\boolean{VDMsl}}{{\aaa DefaultMod} モジュール}{ {\aaa
    ExplSort} クラス} を選択し
(\guicmd{アクション})ツールバーの\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{integritycheck.png}}  
(\guicmd{証明課題生成})ボタンを押すとこの
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}の整合性
テスターが起動する。\guicmd{証明課題ウインドウ}が開いて表示され、証明課題が
生成される。図~\ref{fig:integWin}にこれを示す。
#endif JPN


\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12.5cm]{integWin-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=12.5cm]{integWin-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Integrity Properties Window}
#endif ENG
#ifdef JPN
\caption{証明課題ウインドウ}
#endif JPN
\label{fig:integWin}
\end{center}
\end{figure}

#ifdef ENG
The top pane of the \guicmd{Integrity Properties Window} shows a list
of the integrity properties together with information about their
status (the \guicmd{Checked} column), their position in the specification (the
\guicmd{Module}, \guicmd{Member} and \guicmd{Location} columns) and
their type (the \guicmd{Type} column). The numbers in the
\guicmd{Index} column simply serve to distinguish different integrity
properties which have the same position. As can be seen from this
example, even a small specification can generate many integrity
properties -- in fact thirty different types of integrity properties
are checked in all -- so in a large specification it is useful to be
able to filter these. The middle two panes of the \guicmd{Integrity
  Properties Window} offer various filtering
methods\ifthenelse{\boolean{VDMsl}}{}{ (see Section~\ref{sec:pog} for
  details)}. Finally, if a particular integrity 
property is selected in the top pane of the window the corresponding
\vdmslpp\ predicate is displayed in the bottom pane of the window, and
at the same time the cursor in the \guicmd{Source Window} indicates
the exact point in the specification to which the selected integrity
property relates. Each integrity property can thus be inspected in
order to try to determine whether or not it is true.
#endif ENG

#ifdef JPN
\guicmd{証明課題ウインドウ}の画面上部に証明課題のリストがそれらの状態
（\guicmd{選択済} 欄）、仕様書の場所（
\guicmd{モジュール}、 \guicmd{メンバー} 、 \guicmd{位置} 欄）と型（\guicmd{型}欄）
の情報と一緒に表示されている。\guicmd{指標} 欄の数字は単純に同じ箇所の違う証明課題
を区別するものである。この例でも見られるように、小さい仕様書であっても、
たくさんの証明課題を生成することがある－実際、30ある証明課題の
すべてがチェックされている－そのため、大きな仕様書ではこれらをフィルターできるため、
有効である。
\guicmd{証明課題ウインドウ} の中ほどの2つの画面で、さまざまなフィルタリング方法が
利用できる
\ifthenelse{\boolean{VDMsl}}{}{ (詳細はセクション~\ref{sec:pog} 参照)。}
最後に、特定の証明課題がウインドウ
のトップ画面で選択されると、それに相当する\vdmslpp\ の記述がウインドウの下の画面に
表示され、同時に\guicmd{ソースウインドウ} のカーソルが仕様書の関連する箇所を示す。
それぞれの証明課題はTrueかそうでないかを決定しようとするため、詳細に調べられる。
#endif JPN

#ifdef VDMSL
#ifdef ENG
Select the \guicmd{Member} attribute in the left-hand pane of the
middle pane of the window, then select the four functions
\guicmd{ExplSort}, \guicmd{IsOrdered}, \guicmd{Permutations}, and
\guicmd{RestSeq} in the same pane and press the
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{right.png}}  
(\guicmd{Add to Filter}) button to add them to the filter. Pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{filter.png}}  
(\guicmd{Filter}) button on the left-hand side of the top pane of
the window then causes the list of integrity properties to be filtered
to show only those which relate to these functions.
#endif ENG

#ifdef JPN
ウインドウの左側の画面にある\guicmd{メンバー}属性を選択し、同じ画面で\guicmd{ExplSort}, 
\guicmd{IsOrdered}, \guicmd{Permutations}, \guicmd{RestSeq}の4関数を選択して
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{right.png}}  
(\guicmd{選択した項目を追加})ボタンを押し、フィルタにこれらを追加する。
ウインドウ上部の左側にある\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{filter.png}}  
(\guicmd{項目の絞込み})ボタンを押すことで、証明課題の一覧がこれらの関数に関連するものだけに
フィルタリングされる。
#endif JPN
#endif VDMSL

#ifdef ENG
Select the first (i.e.\ index number 1) integrity property relating to
the function {\aaa isOrdered}. This has the form:
#endif ENG

#ifdef JPN
{\aaa isOrdered}関数と関連する最初の証明課題（例\ インデックス番号1番）を選
択してみよう。これは下記のような形式になっている：
#endif JPN

#ifdef VDMSL
\begin{verbatim}
  (forall l : seq of real &
  (forall i,j in set inds (l) &
  i > j =>
   i in set inds (l)))
\end{verbatim}
#endif VDMSL

#ifdef VDMPP
\begin{verbatim}
  (forall l : seq of int &
  (forall i,j in set inds (l) &
  i > j =>
   i in set inds (l)))
\end{verbatim}
#endif VDMPP

#ifdef ENG
and, as can be seen from the position of the cursor in the
\guicmd{Source Window}, corresponds to the condition that the sequence
application \verb+l(i)+ in the expression

\begin{verbatim}
  forall i,j in set inds l & i > j => l(i) >= l(j)
\end{verbatim}

must be well-defined, i.e.\ the value {\aaa i} must always belong to the
indices of the sequence {\aaa l}.

In this particular case it is in fact easy to see that the integrity
property is true -- the second quantification in the predicate
directly tells us that both {\aaa i} and {\aaa j} belong to the
indices of {\aaa l}, and whether or not {\aaa i} is bigger than {\aaa
  j} (the third line of the predicate) is irrelevant. The property can
therefore be marked as having been checked, which is done by pressing
the
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{checkmark.png}}  
(\guicmd{Toggle Status}) button to the left of the top pane of the
\guicmd{Integrity Properties Window}.

Now look at the other three integrity properties related to sequence
application. It is also easy to see that these are true: the one
relating to {\aaa isOrdered} is exactly analogous to the one discussed
above except that it relates
to the sequence application \verb+l(j)+ rather than to \verb+l(i)+, so
the same argument applies; the one relating to {\aaa
  Permutations} is immediately true because the second quantification
gives exactly the result required (\verb+i in set inds (l)+); and in
the case of {\aaa RestSeq} the third quantification tells us that
{\aaa j} belongs to the indices of {\aaa l} with {\aaa i} removed
which means that {\aaa j} must belong to the indices of {\aaa
  l}. These three integrity properties can therefore be selected and
marked as checked in the same way.

In cases such as these, the integrity properties could in fact be
verified automatically by a mechanical checker. However, this is not
always possible and in the more complicated cases the reasoning
process needs to be steered by a human even though the actual
reasoning can be mechanised.

%\footnote{A prototype automatic checker and
%  reasoning support system has in fact been produced but this is not
%  yet sufficiently developed for full integration with the
%  Toolbox.}. 

One such more complicated property is the one relating to the 
\ifthenelse{\boolean{VDMsl}}{{\aaa ExplSort} function}{{\aaa
  Sort} operation}, which basically states that there must be at least
  one value {\aaa r} which satisfies the predicate in the implicit
  {\aaa let} statement otherwise the specification does not make
  sense\ifthenelse{\boolean{VDMsl}}{}{\footnote{There is an implicit
      quantification here over the variable {\aaa l} which, according
      to the specification, is an arbitrary sequence of
      integers.}}. It is not so easy to see that this 
  property is true because it involves three user-defined functions
  -- {\aaa Permutations}, {\aaa isOrdered}, and {\aaa RestSeq} which
  is used in the definition of {\aaa Permutations} -- and in
  addition {\aaa Permutations} is defined recursively. However, it is
  easy to see that the integrity property is true \emph{provided} the
  functions {\aaa Permutations} and {\aaa isOrdered} are defined
  correctly -- clearly it is possible to sort any given sequence of
  numbers, so we just need to be sure that the set of sequences
  returned by the function {\aaa Permutations} comprises all possible
  permutations of the input sequence and that the function {\aaa
  isOrdered} defines ordered sequences of numbers correctly.

Look at the definition of the function {\aaa isOrdered} in the
\guicmd{Source Window}. It is relatively easy to see that this is
correct -- its defining predicate states directly that, given any two
positions in the sequence, the number at the later position cannot be
smaller than the number at the earlier position, and this clearly
means that the elements must be in (ascending) order.

Now look at the function {\aaa Permutations}. The first branch of the
cases expression is easy 
to deal with -- there is only one possible permutation of the empty
sequence and sequences with only one element, namely the sequence
itself. For the {\aaa others} branch, we first need to look at the
function {\aaa RestSeq}. It is fairly easy to see that this simply
removes the element at a given position from a given sequence. In the
{\aaa others} branch of the function {\aaa Permutations}, therefore,
we are constructing permutations by choosing an arbitrary element from
the original sequence as the first element of the permutation and
concatenating all possible permutations of the remaining elements of
the original sequence onto this. This therefore gives us all possible
permutations, so the integrity property is satisfied.

Looking now at the remaining two integrity
properties\ifthenelse{\boolean{VDMsl}}{}{, both} relating to the 
function {\aaa RestSeq}, it is easy to see that the one of type {\aaa
  Postcondition}, which requires that the explicit result of the
function satisfies the postcondition if the precondition is satisfied,
is valid -- the function removes one element from the sequence so the
length of the sequence is reduced by one and the elements of the
sequence are either unchanged (in the case when the element removed
occurs more than once in the sequence) or smaller. However, the
property of type {\aaa Invariant} states that every natural number is
different from zero, and this is of course false.

Looking at the specification of {\aaa RestSeq} in the \guicmd{Source
  Window}, you can see that the property is generated by the
  precondition of the function:

\begin{verbatim}
  i in set inds l
\end{verbatim}

In fact it arises because the indices of a sequence is a set of
positive natural numbers (i.e.\ is of type 
\verb+set of nat1+) so that if {\aaa i} is not of type {\aaa nat1} the 
precondition will automatically be false. This indicates that the
{\aaa nat} in the signature of the function should be changed to {\aaa
  nat1}. If this is done, the new integrity property will be 

#ifdef VDMSL
\begin{verbatim}
  (forall l : seq of real, i : nat1 &
  i <> 0)
\end{verbatim}
#endif VDMSL

#ifdef VDMPP
\begin{verbatim}
  (forall l : seq of int, i : nat1 &
  i <> 0)
\end{verbatim}
#endif VDMPP

and this is of course true.

#ifdef VDMSL
Finally, look at the last integrity property, the invariant property
for the function \guicmd{ExplSort}. This has the form
\begin{verbatim}
  (forall l : seq of PosReal &
  (forall xx_10 in set elems (let r in set Permutations(l) be st 
    isOrdered(r) in r ) &
  DefaultMod`inv_PosReal(xx_10)))
\end{verbatim}

This looks quite complicated but in fact it just states that if we
start with a sequence of positive real numbers and order the sequence
then every number in the resulting sequence satisfies the invariant on
the type {\aaa PosReal}, i.e.\ is also a positive real number. This is
clearly true so this property can also be marked as checked.
#endif VDMSL

The integrity properties for the other
\ifthenelse{\boolean{VDMsl}}{functions}{classes} can be dealt with in
a similar way.
#endif ENG

#ifdef JPN
そして\guicmd{ソースウインドウ}のカーソルの位置から、\verb+l(i)+ で表されるシーケンス
 アプリケーションの状態と関連していることがわかり、

\begin{verbatim}
  forall i,j in set inds l & i > j => l(i) >= l(j)
\end{verbatim}

は正しい定義である（例：\ {\aaa i}の値は常に列{\aaa l}のインデックス）。

このような典型的な例では、実際証明課題が正しいことを見て取るのは
簡単だが　-　2番目の記述は、直接的には{\aaa i}も{\aaa j}も{\aaa l}のインデックスであることを示しており、
{\aaa i}が{\aaa j}より大きいかどうかに関わらず（3行目の記述）不適切であるとされている。
それゆえ、この課題はチェックしなくてはならない。\guicmd{証明課題ウインドウ}の
トップ画面左の \raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{checkmark.png}}
(\guicmd{項目の選択/非選択}) ボタンを押すことによってチェックができる。

列 アプリケーションに関連する他の3つの証明課題を見てみよう。
これらが正しいことを確認するのも簡単だ。ひとつは{\aaa isOrdered}が列アプリケーション
\verb+l(j)+ よりも \verb+l(i)+ と関連しているというところで上記で論じた例外に酷似しているため、
同様のが適用できる。{\aaa Permutations}に関連するものは、すぐに正しいことが
わかるがこれは2番目のものが(\verb+i in set inds (l)+)で要求される結果を出していることからである。
3番目の{\aaa RestSeq}の場合は、{\aaa j}は{\aaa l}のインデックスに属していないといけないので、インデックスの
ひとつ{\aaa j}が{\aaa i}と一緒に書かれているのを消さなくてはならないと示している。これら3つの証明課題
は同様の方法で選択し、マーク・チェックすることができる。

これらのようなケースでは、証明課題は機械的チェッカーを使って
実際には自動的に確認をする。しかしより複雑なケースにおいては、いつも
自動確認が使えるわけではなく、実際の推論が自動化されるようなものであったとしても、
推理の過程で人が舵取りをする必要がある。

%\footnote{A prototype automatic checker and
%  reasoning support system has in fact been produced but this is not
%  yet sufficiently developed for full integration with the
%  Toolbox.}. 

そのように複雑な課題の例が
\ifthenelse{\boolean{VDMsl}}{{\aaa ExplSort} function}{{\aaa Sort} }
関数にある。これは基本的には、暗黙の{\aaa let}命令文の述部を満たす
少なくともひとつの値{\aaa r}がなくてはならない（さもないと仕様書は意味を成さない

\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%%%%% no footnote added for VDM-SL
}
{\footnote
	{
	  ここで、変数{\aaa l}、　これは仕様書の記述によれば任意のintの引数群であるが、
      について暗黙の定量化がなされている
	}
%%%%%%%%%%%%%%%%%%%%%%%% this footnote added for VDM++
}
）が、これに関する記述が仕様書にないのである。
この証明課題が正しいことがわかるのはそう簡単な事ではない。なぜなら{\aaa Permutations}の定義を
使っているユーザ定義の関数{\aaa Permutations}, {\aaa isOrdered}, {\aaa RestSeq}が出てくるからである。
加えて、{\aaa Permutations}は帰納的に定義されている。しかしながら、\emph{提供された} 関数{\aaa Permutations} 、
{\aaa isOrdered}が正しく定義されているため、証明課題が正しいことも簡単に見て取れる。
-明らかにどんな数の順番が与えられてもソート可能なので、われわれがすべきことは
{\aaa Permutations}関数で返された順列が入力値としてとりうるすべての順列をカバーしているかということと、
{\aaa isOrdered}関数が順番に引数の数字を正しく定義しているかである。

\guicmd{ソースウインドウ} の{\aaa isOrdered}関数の定義を見てみよう。これが相対的に
正しいことは簡単にわかるはずだ　その定義の記述は直接的には、列における
2つのポジションが与えられているが、後の番号の方は先の方の番号のより小さくなりえないとなっている
－これははっきりとこの要素が（昇）順になっているはずであることを意味している。

{\aaa Permutations}関数を見てみよう。case式の最初の部分は扱いやすい－空の数列の順列
がひとつしかない可能性があり、要素がひとつしかない数列は、はっきり言えば数列
そのものである。{\aaa others}部分については、まず{\aaa RestSeq}関数を見る必要がある。これは
単に与えられた数列から与えられた箇所の要素を取り除けばよいだけだ。{\aaa Permutations}
関数の{\aaa others}部分では、順列の最初の要素として元の数列から任意の要素を選択する
ことと元の数列の残りの要素のすべてのとりうる順列を結合することによって順列を構成している。
それゆえ、これですべてのとりうる順列が与えられるため証明課題は満たされる。

残り2つの証明課題を見てみると、
\ifthenelse{\boolean{VDMsl}}{}{両方とも} 
{\aaa RestSeq}関数に関係するものだが、
ひとつは事前条件の型の一種、これは事前条件が満たされてさえいれば、関数の明確な
結果が{\aaa 事後条件}を満たすことを要求しているが－が有効であることがわかる。この関数は
数列からひとつの要素を取り除くため、数列のLengthが一つ減って数列の要素は変わらないか
（その数列で1回より多く要素の削除が行われた場合）少なくなる。しかしながら、{\aaa 不変条件}の型
の証明課題は、すべての自然数は0と異なるとしており、これはもちろん正しくない。

\guicmd{ソースウインドウ}の{\aaa RestSeq}の仕様を見てみると、証明課題は関数の事前条件から
生成されていることがわかる：

\begin{verbatim}
  i in set inds l
\end{verbatim}

実際、列のインデックスは正の自然数の集合（例.\ \verb+set of nat1+nat1型）であるため、別名をつけるが{\aaa i}が{\aaa nat1}
型でない時点で事前条件は自動的に正しくないことになる。これはこの関数のシグニチャで
{\aaa nat}を{\aaa nat1}に修正するべきだということを意味している。こうすれば、新しい証明課題は

#ifdef VDMSL
\begin{verbatim}
  (forall l : seq of real, i : nat1 &
  i <> 0)
\end{verbatim}
#endif VDMSL

#ifdef VDMPP
\begin{verbatim}
  (forall l : seq of int, i : nat1 &
  i <> 0)
\end{verbatim}
#endif VDMPP

となり、これはもちろん正しい。

#ifdef VDMSL
最後になるが、最後の証明課題、これは関数\guicmd{ExplSort}の
不変条件課題であるが、見てみよう。以下のような形式となっている

\begin{verbatim}
  (forall l : seq of PosReal &
  (forall xx_10 in set elems (let r in set Permutations(l) be st 
    isOrdered(r) in r ) &
  DefaultMod`inv_PosReal(xx_10)))
\end{verbatim}

見たところとても複雑だが、実際は正のreal値をもってこの関数を呼び出すと、すべての
結果の数が{\aaa PosReal}の型の不変条件を満たすことが記述されている。i.e.\ 
もまた正のreal型の数である。これは明らかに正しいので、この課題はチェック済みマーク
がつく。

#endif VDMSL
他\ifthenelse{\boolean{VDMsl}}{関数}{クラス}の証明課題は同じようなやり方で扱うことができる。
#endif JPN

#ifdef VDMPP
#ifdef ENG
\subsubsection{Multi-threaded models}
#endif ENG
#ifdef JPN
\subsubsection{マルチスレッド・モデル}
#endif JPN

% This section should be expanded with a nice multi threaded sorting
% example
#ifdef ENG
\vdmslpp\ supports multiple threads within a model, and this feature of the
language is also supported by the interpreter which allows you to
insert breakpoints within particular threads and to step
through threads. It also allows selection of a particular thread to
step through. The scheduling algorithm used by the interpreter may be
selected from a variety built into the \Toolbox.
#endif ENG

#ifdef JPN
\vdmslpp\ はモデル中でマルチスレッドをサポートしており、この言語の特徴は特定の
スレッドにブレイクポイントを設定したりステップ実行をしたりできるインタープリタでも
サポートされている。特定のスレッドを選んでステップ実行することもできる。インタープリタに
おけるスケジューリングのアルゴリズムは、\Toolbox\ 内から選択される。
#endif JPN
#endif VDMPP

#ifdef VICEMAN
#ifdef ENG
\subsubsection{Timing analysis}
#endif ENG
#ifdef JPN
\subsubsection{タイミング分析}
#endif JPN

#ifdef ENG
\vdmslpp\ supports analysis of the timing behaviour of models. This is
both in terms of whether a model with particular timing behaviour is
schedulable, and also in terms of being able to view the sequence of
events (scheduling of threads, requests, activates and completions of
operation calls) that occur during a particular execution.
#endif ENG
#ifdef JPN
\vdmslpp\ はモデルのタイミング動作分析をサポートする。これは
特定のタイミング動作を伴うモデルがスケジューリング化可能かということと
特定の実行中に起こるイベント(スレッドのスケジューリング、要求、稼動、
複雑な操作コールなど）の一群を見ることができるようにすること
の両方に関してである。
#endif JPN
#endif VICEMAN

#ifdef ENG
\subsection{Introducing Systematic Testing}
#endif ENG
#ifdef JPN
\subsection{体系的テスト}
#endif JPN
\label{tour:testing}

#ifdef ENG
As part of its support for validation, the \Toolbox\ provides a
facility for testing \vdmslpp\ specifications, including test
  coverage measurement.\index{Test
  Coverage}  Test coverage measurement helps you to see
how well a given test suite\index{Test Coverage!Test suite} covers the
specification. This is done by collecting information in a special
test coverage file about which statements and expressions are
evaluated during the execution of the test suite.

There are three steps involved in producing a test coverage report:
#endif ENG

#ifdef JPN
検証のサポートという点からすると、 \Toolbox\ はテストカバレッジの測定結果を
含む\vdmslpp\ の仕様書のテスト向けツールを提供する。テストカバレッジの測定結果は
与えられたテストスイート\index{テストカバレッジ!テストスイート}が仕様書をどのくらいカバーできているか
見るための助けとなる。
これは記述や表現がテストスイートの実行中評価された特別なテストカバレッジファイルで
情報を集めることによってなされる。

テストカバレッジレポートの作成には3つのステップがある。
#endif JPN

\begin{enumerate}
#ifdef ENG
\item
Prepare a {\em test coverage file}\index{Test
Coverage!File}. This file contains
  information about the specification's structure. 
\item Test the specification by making the interpreter execute calls
to the constructs in the specification. This process updates the test
coverage information in the test coverage file.
\item Pretty print the test coverage report: the pretty printer takes
  the specification and test coverage files and produces a nicely typeset
  version of the specification with test coverage information
  included. We will return to this part below in Section~\ref{subsec:pp}.
#endif ENG

#ifdef JPN
\item
{\em テストカバレッジファイル}\index{テストカバレッジ!ファイル}を準備する。
このファイルは仕様書の構造についての情報を含んでいる。

\item
インタープリタに仕様書の構成物の呼び出しを実行させることで仕様書をテストする。
このプロセスはテストカバレッジファイルの情報を更新する。

\item
テストカバレッジレポートを清書する。清書機能は
仕様書とテストカバレッジファイルをとり、うまく活字に組まれたテストカバレッジ情報を
含む仕様書を作り出す。以下についてはセクション~\ref{subsec:pp}でまた記述する。
#endif JPN
\end{enumerate}

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12.5cm]{testCov-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=12.5cm]{testCov-pp.png}
#endif VDMPP
#ifdef ENG
\caption{Collecting Test Coverage Information}
#endif ENG
#ifdef JPN
\caption{テストカバレッジ情報の収集}
#endif JPN
\label{fig:guitcov}
\end{center}
\end{figure}

#ifdef ENG
This process is illustrated in Figure~\ref{fig:guitcov}. First the 
{\tt tcov reset}\index{tcov reset command} is issued to
reset the test coverage file so that it has no information about any
prior testing carried out for the given specification. Then the
\guicmd{print} command is used to evaluate different constructs from
the specification. The command \guicmd{tcov write}\index{tcov
  write command} then saves all the test coverage information
generated since the last \guicmd{tcov reset} command to the file
\texttt{vdm.tc}. Finally, the command \guicmd{rtinfo}\index{rtinfo command} 
displays a table summarising the information in
this test coverage 
file. This consists of a list of the various functions and operations
in the specification together, each annotated with the number of times
that function/operation has been called during testing and the
percentage of its specification which has been tested at least once.

Note that the command-line version of the \vdmslpp\ \Toolbox\ 
(\ifthenelse{\boolean{VDMsl}}{\texttt{vdmde}}{\texttt{vppde}}) also
has facilities to support the collection of test coverage
information.

Naturally realistic testing would involve many more tests before the
information is written to the test coverage file \texttt{vdm.tc} using the
\guicmd{tcov write} command. Indeed, for
real projects you would generally set up an entire test environment 
where you make a small script file which automates this whole
process. This can also compare the actual results of individual tests
against expected results (it is necessary to use the {\tt -O} option
for this).  Appendix~\ref{sec:testscript} contains an example of such
a script file for both Windows and Unix.
#endif ENG

#ifdef JPN
このプロセスは図~\ref{fig:guitcov}に記述されている。まず{\tt tcov reset}\index{tcov resetコマンド}をテストカバレッジ
ファイルをリセットするために発行するため、与えられた仕様書のテスト情報には何も
載っていない。それから仕様書と異なる物を評価するため\guicmd{print}コマンドを使う。それから、
\guicmd{tcov write}\index{tcov writeコマンド}で先ほど
の\guicmd{tcov reset}を発行してから生成されたテストカバレッジ情報
すべてを\texttt{vdm.tc}ファイルに保存する。最後に、コマンド\guicmd{rtinfo}\index{rtinfoコマンド} が
テストカバレッジファイルの情報を要約したテーブルを表示する。これが仕様書のさまざまな関数や操作
のリストをひとつに構成し、それぞれテスト中に何回その関数／操作が呼び出され
ているかと、仕様書の1度以上テストされた箇所のパーセンテージの注釈がつく。

\vdmslpp\ \Toolbox\ （\ifthenelse{\boolean{VDMsl}}{\texttt{vdmde}}{\texttt{vppde}}）
のコマンドラインバージョンもテストカバレッジ情報の収集をサポートするため
同様の機能を有していることに注意してほしい。

\guicmd{tcov write} コマンドを使って\texttt{vdm.tc} ファイルにテストカバレッジ情報を書き込む前に、
実際のテストでは自然にもっとたくさんのテストを増やしていくものだ。本当に実際の
プロジェクトでは、一般的にこのプロセス全体を自動化するために小さなスクリプトファイル
を書くなどして全体的なテスト環境を構築したする。これもまた予測される結果に対する
実際の個々のテスト結果と比較できる（通常{\tt -O} オプションが使うのに必要である）。
付録~\ref{sec:testscript}にこのようなWindowsとUnixのスクリプトファイルの例が含まれている。
#endif JPN

#ifdef ENG
\subsection{Pretty Printing}\label{subsec:pp}
#endif ENG
#ifdef JPN
\subsection{清書機能}\label{subsec:pp}
#endif JPN

#ifdef ENG
\index{Pretty Printing}
%\index{generating \LaTeX|see{pretty printing}}
%\index{latex@\LaTeX|see{pretty printing}}

The pretty printer transforms a specification from its input format to
a pretty printed version of the specification. Typically this pretty
printed version is used for documentation purposes.

In order to see pretty printing at work, first go to the \guicmd{Pretty
Printer} pane of the \guicmd{Project Options} window and enable one of the
options to produce indexes (it does not matter which of the 
two options you choose when the RTF format is used) and also the test
coveraging colouring option. You also need to copy the {\tt vdm.tc}
file you have just produced to the working directory of the
\Toolbox, which you can determine using the {\tt pwd}\index{pwd command}
which you can run in the \guicmd{Dialog} pane of the
interpreter\footnote{If the project you are working on has been saved
  then the directory in which it was saved will be the working
  directory.}.

Select \ifthenelse{\boolean{VDMsl}}{the {\tt sort-init.rtf} file}{all
six {\tt .rtf} files} in the \guicmd{Project View} in the
\guicmd{Manager}, then press the % should this work in VDM/Module Views? 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprint.png}}
(\guicmd{Pretty Print}) button on the
(\guicmd{Actions}) toolbar. In the \guicmd{Log Window} you will
see that this produces \ifthenelse{\boolean{VDMsl}}{a file {\tt
sort-init.rtf.rtf}}{a {\tt .rtf.rtf} file for each of the selected
input files}. Start Microsoft Word on the
\ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf.rtf}}{{\tt dosort.rtf.rtf}}
file. Notice how all the \vdmslpp\ keywords have been converted to
boldface type. The
other parts of your specification have been typeset using the Word
styles {\tt VDM\_COV} and {\tt VDM\_NCOV} which relate to the covered
and non-covered parts respectively. The definition of these styles can
be changed and unless you use a colour printer for your documents it
is necessary to modify the definition of the {\tt VDM\_NCOV} style
(e.g.\ by using grey for the non-covered parts).

Go to the bottom of the \ifthenelse{\boolean{VDMsl}}{{\tt
sort-init.rtf.rtf}}{{\tt dosort.rtf.rtf}} file. Note how the
text written in the {\tt VDM\_TC\_TABLE} style has been replaced with a
table showing the test coverage statistics. The three columns give
respectively the name of the function/operation, the number of calls
of that construct in 
the test coverage file, and the percentage coverage for it. The table
looks like\footnote{Note that this is quite similar to part of the
information we saw directly inside the \guicmd{Response} pane of
the interpreter in the previous section.}:
#endif ENG

#ifdef JPN
\index{せいしょきのう@清書機能}
%\index{generating \LaTeX|see{pretty printing}}
%\index{latex@\LaTeX|see{pretty printing}}

清書機能は仕様書を入力フォーマットから清書版に変更する。この
清書版は大体ドキュメント化の目的で使われる。
  
清書機能が動いているところを見るには、まず\guicmd{プロジェクトオプション} 画面の
\guicmd{清書}タブをクリックし、インデックスを生成するためにオプションをひとつ有効にし
（RTFフォーマットが使われていれば2つのうちどちらを使っても問題はない）、テストカバレッジの
色オプションも有効にする。たった今\Toolbox\ のワーキングディレクトリ に生成した{\tt vdm.tc}ファイルを
コピーしておく必要もある。インタープリタの\guicmd{Dialog} 画面から{\tt pwd}\index{pwdコマンド}を入力することで確定できる。

\guicmd{マネージャー}の\guicmd{プロジェクトビュー}で
\ifthenelse{\boolean{VDMsl}}{the {\tt sort-init.rtf} ファイル}{6つの {\tt .rtf} ファイルすべて} 
を選択し、(\guicmd{アクション})ツールバーの 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprint.png}}
(\guicmd{清書}) ボタンを押す。\guicmd{ログウインドウ} に
\ifthenelse{\boolean{VDMsl}}
{
%%%%%%%%%%%%%%%%%%%%%%%%%%%　comment by teramoto
% description for VDM-SL
ファイル{\tt sort-init.rtf.rtf}
% description for VDM-SL end
}
{
% description for VDM++
それぞれの選択された入力ファイルに対応する {\tt .rtf.rtf} ファイル
% description for VDM++ end
%%%%%%%%%%%%%%%%%%%%%%%%%%%　comment by teramoto end
}
が出来ているのがわかるはずだ。
\ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf.rtf}}{{\tt dosort.rtf.rtf}}
ファイルでWordを起動してみる。
\vdmslpp\ のキーワードはすべて太字になっていることに注意してほしい。仕様書のその他の部分は、
Wordの{\tt VDM\_COV}  と  {\tt VDM\_NCOV} 形式を使って書かれており、それぞれカバーされた部分とカバー
されていない部分に関連している。これらの形式の定義は変更することができ、ドキュメントに
カラープリンタを使うのであれば{\tt VDM\_NCOV} 形式の定義を変更する必要がある
（例\ カバーされていない部分はグレーを使う）

\ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf.rtf}}{{\tt dosort.rtf.rtf}}
ファイルの最後に行ってみよう。{\tt VDM\_TC\_TABLE} 形式で書かれた
テキストがどのようにテストカバレッジを示す統計資料をあらわすテーブルに置き換わっているか
に注目。3つの欄が関数/操作名、テストカバレッジファイル内で呼ばれた回数、
それのカバレッジのパーセンテージの3つである。テーブルはこのようになる\footnote{前のセクションのインタープリタの
\guicmd{Response} 画面内で直接見られた情報の一部にとてもよく似ていることに注意。} 
#endif JPN

\begin{center}
\begin{tabular}{|l|r|r|}\hline
\textbf{name}   & \textbf{\#calls} & \textbf{coverage} \\ \hline
DoSort          & 4     & 100\% \\
ExplSort        & 0     & 0\%\\
InsertSorted    & 3     & 62\%\\
IsOrdered       & 0     & 0\%\\
IsPermutation   & 0     & 0\%\\
Merge           & 0     & 0\%\\
MergeSort       & 0     & 0\%\\
Permutations    & 0     & 0\%\\
RestSeq         & 0     & 0\%\\
\textbf{total}  &       & 15\%\\\hline
\end{tabular} 
\end{center}

#ifdef ENG
Finally, go to the end of the file and select the \guicmd{Index
and Tables ...} item from the \guicmd{Insert} pull down menu inside
Microsoft Word. Decide the layout you wish to use for the index
overview of the definitions in the \ifthenelse{\boolean{VDMsl}}{{\tt
sort-init.rtf.rtf}}{{\tt dosort.rtf.rtf}} file. Press \guicmd{Ok} and see how
an index of VDM definitions can be created automatically.

Using the alternative pretty printing mechanisms with \LaTeX\ is quite
different but this is explained in the reference section of this
manual (see Section~\ref{sec:testing}).
#endif ENG

#ifdef JPN
最後に、ファイルの最後にいって、Wordの\guicmd{挿入} プルダウンメニューから\guicmd{Index
and Tables ...}を選択する。
\ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf.rtf}}{{\tt dosort.rtf.rtf}}
の定義の概要の見出しのためのレイアウトを希望するものに決めて\guicmd{Ok}ボタンを押すと
DMの定義のインデックスが自動的に生成される。

双方向の清書機構を\LaTeX\ に使用する際とはまったく違うが、このマニュアルの
リファレンスセクション（セクション~\ref{sec:testing}参照）で説明する。
#endif JPN

#ifdef ENG
\subsection{Generating Code}
\index{C++ Code Generation}
\index{Code Generation|see {\\ C++ Code Generation, \\ Java Code Generation}}
#endif ENG
#ifdef JPN
\subsection{コード生成}
\index{C++コードせいせい@C++コード生成}
\index{コードせいせい@コード生成 |see {\\ C++コード生成, \\ Javaコード生成}}
#endif JPN

#ifdef ENG
If you have a license \index{License} for the \vdmslpp\ to C++
Code Generator you can automatically have your specification
translated into C++ code by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cplusplus.png}}
(\guicmd{Generate C++}) button. See
\ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}} for further
information about the C++ Code Generator.
#endif ENG

#ifdef JPN
\vdmslpp\ からC++へのコード生成のライセンス\index{ライセンス} を持っていれば、 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cplusplus.png}}
(\guicmd{C++生成}) ボタンを押して自動的に仕様書からC++のコードを生成することが出来る。
C++コード生成についての詳細は、
\ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}を参照のこと。
#endif JPN

#ifdef VDMPP

#ifdef ENG
\index{Java Code Generation}

Similarly, if you have a license \index{License} for the \vdmslpp\ to Java
Code Generator you can automatically have your specification
translated into Java code by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java.png}}
(\guicmd{Generate Java}) button. See
\cite{CGJavaManPP-CSK} for further information about the Java Code
Generator.
#endif ENG

#ifdef JPN
\index{Javaコードせいせい@Javaコード生成}

同様に、\vdmslpp\ からJavaへのコード生成のライセンスを持っていれば、
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java.png}}
(\guicmd{Java生成}) ボタンを押すことで自動的に仕様書からJavaのコードを生成することができる。
Javaコード生成の詳細については、\cite{CGJavaManPP-CSK} を参照のこと。
#endif JPN

#endif VDMPP

#ifdef VDMSL
#ifdef ENG
\subsection{The Dynamic Link Facility}\index{Dynamic Link Facility}
#endif ENG
#ifdef JPN
\subsection{動的リンク機能}\index{どうてきリンクきのう@動的リンク機能}
#endif JPN

#ifdef ENG
Another additional feature which needs a special license
\index{License} is 
called the Dynamic Link facility. This feature
enables you to interpret a 
combination of a system which is partly specified in \vdmslpp\ and is
partly present in C++ code\index{C++ Files}. This feature is not
illustrated by the sort example, but it is illustrated in
\cite{DLMan-CSK}. Also see \cite{DLMan-CSK}
for further information about the Dynamic Link facility.
#endif ENG
#ifdef JPN
特別なライセンス\index{ライセンス}を必要とする追加機能がもうひとつあり、動的リンク機能と呼ばれている。
この機能は、一部\vdmslpp\ に特有で、一部C++のコード\index{C++ファイル}に現存するシステムを結合させたものを
解釈することを可能にする。Sortの例ではこの機能の例証はないが、\cite{DLMan-CSK}には示されている。動的リンク機能
についての詳細な情報は\cite{DLMan-CSK}を参照のこと。
#endif JPN

#endif VDMSL

#ifdef ENG
\subsection{The \protect\VDMTools\ API}

All of the functionality of \VDMTools\ is exposed to external programs
via a Corba-compliant application programmers interface (API). Details
of how to use this API may be found in \cite{APIMan-CSK}.
#endif ENG

#ifdef JPN
\subsection{\protect\VDMTools\ API}

\VDMTools\ のすべての機能は、Corba APIを経由して外部プログラムにエクスポートすることができる。
APIの使い方についての詳細は\cite{APIMan-CSK}を参照のこと。
#endif JPN

%\subsubsection{Display of test coverage information in the GUI} \label{guirti}

%The tool \texttt{Test Coverage Tool} in the GUI can be used for
%displaying the collected test coverage information. The tool should be
%opened, the file for which test coverage information is wanted should
%be selected, and the button \texttt{Show Coverage} should be pressed.
%The specification file will be shown in the display window with the
%uncovered expressions and statements marked on the leading character
%with a red background (or underlined for B\&W displays).

#ifdef ENG
\subsection{Exiting \protect\VDMTools}
#endif ENG
#ifdef JPN
\subsection{\protect\VDMTools の終了}
#endif JPN

#ifdef ENG
When you wish to exit the \Toolbox\ you should select the
\guicmd{Exit} item on the \guicmd{Project} menu in
the main window. If you exit without saving the project, a dialog
window will appear asking if you want to save your project.

This completes the guided tour of the \Toolbox. We hope that you now have
a better understanding of the kind of fuctionality it can provide. Now
you should be able to start using the \Toolbox\ for your own
\vdmslpp\ models. The remaining parts of this manual are a detailed
reference guide providing more details about particular features.
#endif ENG

#ifdef JPN
\Toolbox\ を終了させたいときは、メインウインドウの\guicmd{プロジェクト} メニューから\guicmd{終了} を選ぶ。
プロジェクトを保存せずに終了しようとすると、ダイアログが現れてプロジェクトを保存するかどうか聞いてくる。

これで\Toolbox\ の「ガイドツアー」は終了である。ツールの提供する機能がよりよく理解出来ていることと思う。
自身の\vdmslpp\ のモデルで\Toolbox\ を使い始められるようになっているはずだ。このマニュアルの残りの部分では、
特定の部分の特徴について詳細なリファレンスガイドとなっている。
#endif JPN

\newpage
#ifdef ENG
\section{The \protect\VDMTools\ Reference Manual}\label{sec:ref}
#endif ENG
#ifdef JPN
\section{\protect\VDMTools\ リファレンスマニュアル}\label{sec:ref}
#endif JPN

#ifdef ENG
This section is structured into a number of subsections covering each
of the tools in the \Toolbox. For each tool, its use through each of
the three interfaces (the graphical user interface, the Emacs
interface and the command line interface) is described.
#endif ENG

#ifdef JPN
このセクションは\Toolbox\ 内のツールそれぞれをカバーする数々のサブセクションで
構成されている。それぞれのツールはGUI、Emacs、コマンドラインの各インターフェースで
使用することができる。以下それぞれについて記述する。
#endif JPN

#ifdef ENG
\subsection{The Overall Graphical User Interface}\label{sec:GUI}
\index{Graphical User Interface}\index{Graphical User Interface!Starting}
#endif ENG
#ifdef JPN
\subsection{GUI全般}\label{sec:GUI}
\index{GUI}\index{GUI!スタート}
#endif JPN

#ifdef ENG
The graphical user interface to the \Toolbox\ is started by selecting
it from the programs entry in the Windows setup under Windows or with
the command {\tt \vdmgde}\index{vdmgde command} on Unix platforms.
This opens the main graphical user interface window, which is shown in 
Figure~\ref{fig:startgui2}. 
#endif ENG

#ifdef JPN
\Toolbox\ のGUIはウインドウズのプログラムから選択するか、Unix環境で{\tt \vdmgde}\index{vdmgdeコマンド} を
入力することで起動する。図~\ref{fig:startgui2}に示すGUIのメインウインドウが開く。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=11cm]{startgui-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=11cm]{startgui-pp.png}
#endif VDMPP
#ifdef ENG
\caption{Graphical User Interface Startup}
#endif ENG
#ifdef JPN
\caption{GUIスタートアップ画面}
#endif JPN
\label{fig:startgui2}
\end{center}
\end{figure}

#ifdef ENG
The top of this window consists of a menu line with six pull-down
menus, below which are six toolbars \footnote{When the \Toolbox\ is
  started, only three toolbars are displayed open, the other three
  being displayed in iconised form above them.} comprising buttons
which offer the same actions as the menus \footnote{Except that the
  function for exiting from the toolbox is only available on the
  \guicmd{Project} menu.}. The bottom part of the window is used to
display various subwindows which either present information about the
status of the current project or offer interfaces to tools within the
\Toolbox. We describe each of the menus/toolbars and the available
subwindows, grouped according to functionality, in the following
subsections.

\subsubsection{Project handling}\index{Project}
A project consists of a collection of files that together form a
\vdmslpp\ specification. Projects can be saved to and read from disk,
which means that you do not need to configure the \Toolbox\ with the
individual files every time you wish to use it: you simply
open the relevant project file. Projects are only available in the
graphical user interface.

The \guicmd{Manager}\index{Manager}, which is opened/closed by
pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{browser.png}}
button on the \guicmd{Window Operations} toolbar or by
selecting the appropriate item from the \guicmd{Windows} menu,
displays the current status of the current
project and is also  the place where you select which subset of
project files you want the various \Toolbox\ operations to be applied
to. It consists of two parts: the \guicmd{Project View} and the
\ifthenelse{\boolean{VDMsl}}{\guicmd{Module View}}{\guicmd{Class
      View}}.

The \guicmd{Project View} displays a tree representation of the contents
of the project comprising the files in the project and (only after
successfully syntax checking the file) the
\ifthenelse{\boolean{VDMsl}}{modules}{classes} declared in each file. 
It is shown in Figure~\ref{fig:projectView}.
#endif ENG

#ifdef JPN
ウインドウのトップは6つのプルダウンメニューで構成されており、その下にはメニューと
同様のアクション を提供するボタン\footnote{ツールボックスの終了は\guicmd{プロジェクト} 
メニューからしかできない}から成る6つのツールバー
\footnote{\Toolbox\ を起動したときはツールバーは3つしか開いておらず、他の3つは
上部にアイコン化されて表示されている.} 
がある。ウインドウの下の
部分は現在のプロジェクトの状態についての情報や\Toolbox\ 内ツールのインターフェースを提供する
さまざまなサブウインドウを表示するのに使われる。以下のサブセクションでは、メニュー、
ツールバー、サブウインドウそれぞれについて機能別に記述する。

\subsubsection{プロジェクト・ハンドリング}\index{プロジェクト}
プロジェクトは\vdmslpp\ 形式の仕様書のファイルを集めたもので構成される。
プロジェクトは保存されディスクから読み込むことが出来るが、これは\Toolbox\ に
個々のファイルを毎度毎度使いたいときに保存する設定をする必要がないことを意味する：
ただ適切なプロジェクトファイルを開けばよいだけなのだ。プロジェクトはGUIでのみ利用できる。

\guicmd{マネージャー}\index{マネージャー}は、\guicmd{ウインドウ} メニューから適切なものを
選択するかまたは\guicmd{ウインドウ} 
ツールバーの\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{browser.png}}ボタンを
押下することで起動/終了するが、現在のプロジェクトの状態を表示するだけ
でなく、操作しようとするプロジェクトファイルのサブセットに対し適用しようとするさまざまな\Toolbox\ の
操作を選ぶ場所でもある。\guicmd{プロジェクトビュー} と
\ifthenelse{\boolean{VDMsl}}{\guicmd{モジュールビュー}}{\guicmd{クラスビュー}}
の2つで構成される。

\guicmd{プロジェクトビュー} はプロジェクトのファイル構成（構文チェック済みのファイルのみ）と各々のファイルで
宣言されている
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} の内容をツリー構造で表示する。
図\ref{fig:projectView}にそれを示す。
#endif JPN

\begin{figure}[tbh]
\begin{center}
\mbox{}
#ifdef VDMSL
#ifdef JPN
\includegraphics[width=9cm]{projectView-sl.png}
#endif JPN
#ifdef ENG
\includegraphics[width=9cm]{projectView-slENG.png}
#endif ENG
#endif VDMSL
#ifdef VDMPP
#ifdef JPN
\includegraphics[width=9cm]{projectView-pp.png}
#endif JPN
#ifdef ENG
\includegraphics[width=9cm]{projectView-ppENG.png}
#endif ENG
#endif VDMPP
#ifdef ENG
\caption{The Project View}
#endif ENG
#ifdef JPN
\caption{プロジェクトビュー}
#endif JPN
\label{fig:projectView}
\end{center}
\end{figure}

#ifdef VDMPP

#ifdef ENG
The \guicmd{Class View} comprises both the \guicmd{VDM View} and the
\guicmd{Java View}.
#endif ENG

#ifdef JPN
\guicmd{クラスビュー} は \guicmd{VDMビュー} と\guicmd{Javaビュー}で構成される。
#endif JPN

#endif VDMPP

#ifdef ENG
When \vdmslpp\ files have been successfully syntax checked the names
of the \ifthenelse{\boolean{VDMsl}}{modules}{classes} defined in those
files are listed in the \vdmModView. This view also displays the
status of each of the individual 
\ifthenelse{\boolean{VDMsl}}{modules}{classes} in the project: the
symbols 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cplusplusdone.png}},
#ifdef VDMPP
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{javadone.png}},
#endif VDMPP
and
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprintdone.png}}
in the appropriate columns indicate respectively that the
\ifthenelse{\boolean{VDMsl}}{module}{class} has been successfully
syntax checked, type checked, translated to C++,
\ifthenelse{\boolean{VDMsl}}{}{translated to Java,} and pretty
printed;
similarly, the corresponding symbols with a (red) line through them (%
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckerror.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cpluspluserror.png}},
#ifdef VDMPP
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{javaerror.png}},
#endif VDMPP
and
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprinterror.png}})
indicate that the particular action failed. Note that a blank in a
column means that no attempt has yet been made to perform that
particular action. Note also that if one of the files in the project
is modified on the file system the symbol
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckmodified.png}}
is displayed in the \guicmd{Syntax} column  to indicate
that there is an inconsistency between the version currently in the \Toolbox\ and the
version on the file system and that the file should be syntax checked
again before proceeding.
#endif ENG

#ifdef JPN
\vdmslpp\ のファイルが構文チェックを無事パスすると、それらのファイルで定義されている
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} の
名前が\vdmModView\ にリスト表示される。このビューはプロジェクトでの
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} それぞれの状態を記号
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cplusplusdone.png}},
#ifdef VDMPP
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{javadone.png}},
#endif VDMPP
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprintdone.png}}
で各々適切な欄にこれらは、当該\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} が
正常に構文チェック済み（syntax checked）、型チェック済み（type checked）、
C++コードを生成済み（translated to C++）、
\ifthenelse{\boolean{VDMsl}}{}{Javaコードを生成済み（translated to Java）、} 清書済み（pretty printed）
なのを示すが、似たような印で各記号に赤線が入ったもの
(%
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckerror.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cpluspluserror.png}},
#ifdef VDMPP
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{javaerror.png}},
#endif VDMPP
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprinterror.png}})
は個々の処理が失敗したことを示す。空欄だった場合は、まだ個々の処理が実行されて
いないことを示す。プロジェクト中のファイルのひとつがこのシステム上で修正されると、\guicmd{構文} 欄
に現在の\Toolbox\ でのファイルのバージョンとファイルシステムでのバージョンに不整合が起こっ
ていることを示す記号が表示される。そのファイルは他の処理に進む前に再度構文チェックを行うべきである。
#endif JPN

#ifdef VDMPP

#ifdef ENG
The \guicmd{Java View} is analogous to the \guicmd{VDM View} except
that it shows the names and the status of classes defined in Java
files (again these must have been successfully syntax checked in order
for anything more than the file name to appear). The
symbols 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}},
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckerror.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}} and
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror.png}}
are again shown in the appropriate column to indicate whether or not
the class has been successfully syntax checked and type checked, and
the symbols 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmdone.png}}
and
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmerror.png}}
in the third column denote respectively that the class has been
successfully or unsuccessfully translated from Java to \vdmslpp.
Again a blank in a column means that no attempt has yet been made to
perform that particular action, and if one of the files in the project
is modified on the file system the symbol
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckmodified.png}}
is displayed in the \guicmd{syntax check} column  to indicate
that there is an inconsistency between the version currently in the \Toolbox\ and the
version on the file system and that the file should be syntax checked
again before proceeding.
#endif ENG

#ifdef JPN
\guicmd{Javaビュー} は\guicmd{VDMビュー} と似ているがJavaファイルで定義されたクラスの状態と名前を表示するところが
異なる（しつこいようだが構文チェックが成功していないと表示されない）。クラスが正しく構文チェック/型チェックを
通ったかを示す記号
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone.png}},
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckerror.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror.png}}
が再度該当する欄に表示される。3つ目の欄にはクラスがそれぞれJavaから \vdmslpp\ へ正しく変換されたかどうか(
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmdone.png}},
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmerror.png}})
が表記される。もう一度言うが空欄はまだ個々の処理が一度も実行されていないことを意味する。
プロジェクト中のファイルのひとつがこのシステム上で修正されると、\guicmd{構文チェック} 欄に 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckmodified.png}}マークが表示され、
現在の\Toolbox\ でのファイルのバージョンとファイルシステムでのバージョンに不整合が起こっていることを示す。
そのファイルは他の処理に進む前に再度構文チェックを行うべきである。
#endif JPN

#endif VDMPP

#ifdef ENG
Various operations for manipulating projects, including opening and
saving projects, adding files to and removing files from projects, and
creating new projects, are available from the \guicmd{Project}
menu and the corresponding \guicmd{Project
  Operations} toolbar, which are
shown in Figure~\ref{fig:projectMenuToolbar}.
#endif ENG

#ifdef JPN
プロジェクトを開く/保存する、プロジェクトへのファイルの追加と削除、新規プロジェクトの作成などを
含むプロジェクト操作のためのさまざまな処理が\guicmd{プロジェクト}メニューとそれに相当する\guicmd{プロジェクト}
ツールバーから利用できる。これを図~\ref{fig:projectMenuToolbar}に示す。
#endif JPN

\begin{figure}[tbh]
\begin{center}
\mbox{}
#ifdef VDMSL
\includegraphics[width=9cm]{projectMenuToolbar-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=9cm]{projectMenuToolbar-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Project Menu and Project Operations Toolbar}
#endif ENG
#ifdef JPN
\caption{プロジェクトメニューとプロジェクトツールバー}
#endif JPN
\label{fig:projectMenuToolbar}
\end{center}
\end{figure}

#ifdef ENG
The same menu/toolbar also offer facilities for setting options
relating to the \Toolbox\ environment, for setting options for the
various tools within the \Toolbox, and for exiting the \Toolbox\
(only available on the menu). In more  detail, the available actions
are as follows:
#endif ENG

#ifdef JPN
同じメニュー/ツールバーを使って、\Toolbox\ の環境に関係するオプション設定、
\Toolbox\ 中のさまざまなツールのオプション設定、\Toolbox\ の終了（メニューからのみ可能）
をすることができる。以下で利用できる処理について詳しく述べる。
#endif JPN

\begin{description}

#ifdef ENG
\item[\guicmd{New Project} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectnew.png}}):]
Select this item if you are currently working on 
  a \vdmslpp\ project and you would like to start working on a new
  one.

\item[\guicmd{Load Project ...} (\hspace{-1.2mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{load.png}}\hspace{.6mm}):]
Select this item if you wish to open an already 
  existing project. A file browser will appear and you can select the
  desired project file. When it has been loaded the \Toolbox\ will
  automatically syntax check all the files in the project.

\item[\guicmd{Save Project} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectsave.png}}):]
  Use this item if you have changed the 
  configuration of your current project and want to save the new
  configuration.

\item[\guicmd{Save Project As ...} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectsaveas.png}}):]
  Use this item to save your current 
  configuration under a different name. A file browser will appear and
  you can place the new project file where you like and give it the
  name you prefer.

\item[\guicmd{Add File to Project ...} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{plus.png}}):] 
  Use this to add files to the
  project  the \Toolbox\ is currently working with. A window like the
  one shown in Figure~\ref{fig:addFiles} will appear allowing you to
  select the appropriate files. 

\item[\guicmd{Remove File from Project} (\hspace{-1.5mm}
 \raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{minus.png}}):]
 Use this to remove files from
 the current project. A dialog box will appear asking you to confirm
 the removal. 

\item[\guicmd{Project Options ...} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectoptions.png}}):].
  This opens the \guicmd{Project Options} window, which allows various options
  to be set for the following elements of the \Toolbox:
  \index{Options!Project}
  \begin{itemize}
    \item \guicmd{interpreter} (described in
  Section~\ref{sec:interpreter});
#ifdef VICEMAN
    \item \guicmd{VICE} (described in
  Section~\ref{sec:interpreter});
#endif VICEMAN
    \item \guicmd{type checker}  (described in Section~\ref{sec:tc});
    \item \guicmd{pretty printer}  (described in Section~\ref{sec:pp});
    \item \guicmd{C++ code generator} (described in Section~\ref{sec:cg})%

#ifdef VDMSL
% Nothing...
#endif VDMSL
#ifdef VDMPP
    \item \guicmd{Java code generator}  (described in Section~\ref{sec:cgjava});
    \item \guicmd{Java to VDM++ translator}  (described in~\cite{Java2VDMMan-CSK}). 
#endif VDMPP
  \end{itemize}

\item[\guicmd{Tool Options ...} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{tooloptions.png}}):].
  This opens the \guicmd{Tool Options} window, which allows various
  environment variables and interface options to be set for the
  \Toolbox\ as a whole. These options are described in
  Appendix~\ref{sec:set_env}. \index{Options!Tool}

\item[\guicmd{Recent Projects}:]
  This opens a list of the recent projects that have been used on the
  computer.

\item[\guicmd{Exit}:] Choose this item to leave the \Toolbox. If you
  have not already saved your project the \Toolbox\ will ask whether
  you wish to do so. Note that this action is not available on the
  toolbar. 
#endif ENG

#ifdef JPN
\item[\guicmd{新規プロジェクト} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectnew.png}}):]
  新しいプロジェクト上で作業を始めたいときに選ぶ項目

\item[\guicmd{プロジェクトを開く} (\hspace{-1.2mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{load.png}}\hspace{.6mm}):]
  すでに存在するプロジェクトを開きたいときに選ぶ項目。ファイルブラウザが表示され希望する
  プロジェクトファイルを選択することができる。これがロードされると\Toolbox\ はプロジェクト中の
  すべてのファイルに自動的に構文チェックをかける。

\item[\guicmd{保存} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectsave.png}}):]
  プロジェクトの設定を変えてそれを保存したいときに使用する項目

\item[\guicmd{別名で保存} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectsaveas.png}}):]
  現在の構成を別な名前で保存したい場合に使う。ファイルブラウザが表示され新しい
  プロジェクトを保存する場所を好きに設定できる。また名前も好きなものに出来る。

\item[\guicmd{ファイルを追加} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{plus.png}}):] 
  ツールボックス上の現在のプロジェクトにファイルを追加するときに使う。
  図~\ref{fig:addFiles} に示したようなウインドウが表示され、追加したいファイルを選択することができる。

\item[\guicmd{ファイルを削除} (\hspace{-1.5mm}
 \raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{minus.png}}):]
 プロジェクトからファイルを削除したいときに使う。削除の確認ダイアログが表示される。

\item[\guicmd{プロジェクトオプション} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{projectoptions.png}}):].
  \begin{itemize}
    \item \guicmd{実行} (セクション ~\ref{sec:interpreter}参照);
    \item \guicmd{型チェック}  (セクション~\ref{sec:tc}参照);
    \item \guicmd{清書}  (セクション~\ref{sec:pp}参照);
    \item \guicmd{C++コード生成} (セクション~\ref{sec:cg}参照)

#ifdef VDMSL
% Nothing...
#endif VDMSL
#ifdef VDMPP
    \item \guicmd{Javaコード生成}  (セクション~\ref{sec:cgjava}参照);
    \item \guicmd{Java からVDM++生成}  (~\cite{Java2VDMMan-CSK}参照). 
#endif VDMPP
  \end{itemize}

\item[\guicmd{ツールオプション} (\hspace{-1.5mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{tooloptions.png}}):].
  \guicmd{ツールオプション} ウインドウを開く。\Toolbox\ のインターフェースオプションの
  設定ができる。これらのオプションについては付録~\ref{sec:set_env}を参照のこと。

\item[\guicmd{最近使ったプロジェクト}:]
  PCで最近使ったプロジェクトのリストを開く。

\item[\guicmd{終了}:]
  \Toolbox\ を終了する。プロジェクトを保存していない場合は、\Toolbox\ が
  保存するかどうかを聞いてくる。ツールバーからは使えないことに注意。
#endif JPN

\end{description}

#ifdef ENG
\subsubsection{Operations on specifications}
#endif ENG
#ifdef JPN
\subsubsection{仕様書の操作}
#endif JPN

#ifdef ENG
The \Toolbox\ offers a range of functions which can be applied to a
specification: syntax checking; type checking; generating integrity
properties; generating C++
\ifthenelse{\boolean{VDMsl}}{}{or Java} code;
\ifthenelse{\boolean{VDMsl}}{}{translation from Java to \vdmslpp;} and
pretty printing. These are invoked through the \guicmd{Actions} menu
or the corresponding \guicmd{Actions} toolbar, which are
illustrated in Figure~\ref{fig:actionsMenuToolbar}.
#endif ENG

#ifdef JPN
 \Toolbox\ は仕様に適用させうる広範囲な機能を提供している：構文チェック、
型チェック、証明課題の生成、
C++\ifthenelse{\boolean{VDMsl}}{}{/Java} のコード生成、
\ifthenelse{\boolean{VDMsl}}{}{Javaから \vdmslpp の生成、;} 
清書など。これらはアクションメニューまたはそれに
相当するアクションツールバーから起動することが出来る。図~\ref{fig:actionsMenuToolbar}にこれを示す。
#endif JPN

\begin{figure}[tbh]
\begin{center}
\mbox{}
#ifdef VDMSL
\includegraphics[width=11cm]{actionsMenuToolbar-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=11cm]{actionsMenuToolbar-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Actions Menu and Toolbar}
#endif ENG
#ifdef JPN
\caption{アクションメニューとツールバー}
#endif JPN
\label{fig:actionsMenuToolbar}
\end{center}
\end{figure}

#ifdef ENG
Each action is applied to every
file/\ifthenelse{\boolean{VDMsl}}{module}{class} which is currently
selected in the \guicmd{Manager}, though the actions are to a certain
extent interdependent so that some of them can only be carried out 
 when the selected \ifthenelse{\boolean{VDMsl}}{modules}{classes} have
 a status which enables the desired functionality to be applied. For
 example, the type checker and the pretty printer features are 
enabled only when the \ifthenelse{\boolean{VDMsl}}{module}{class} has
been accepted by the syntax checker.

The various actions are described in more detail in later sections as follows:
#endif ENG

#ifdef JPN
それぞれのアクションはマネージャで現在選択中のファイル・
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} 各々に適用される。
アクションはある程度まで相互依存しているため、そのうちのいくらかは選択された
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}  が
求められ適用する機能を可能にする状態の時にのみ実行される。例えば、型チェック機能と
清書の機能は
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} が構文チェック機能をパスしてから適用できる。

さまざまなアクションが下記に示すセクションで詳細に記述される。
#endif JPN

\begin{description}

#ifdef ENG
\item[\guicmd{Syntax Check} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck.png}}):] see Section~\ref{sec:parser} 

\item[\guicmd{Type Check} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{typecheck.png}}):] see Section~\ref{sec:tc} 

\item[\guicmd{Generate Integrity Properties} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{integritycheck.png}}):] see Section~\ref{sec:pog} 

\item[\guicmd{Generate C++} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{cplusplus.png}}):] see Section~\ref{sec:cg} 

#ifdef VDMPP
\item[\guicmd{Generate Java} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{java.png}}):] see Section~\ref{sec:cgjava}
#endif VDMPP

\item[\guicmd{Pretty Print} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{prettyprint.png}}):] see Section~\ref{sec:pp}

#ifdef VDMPP
\item[\guicmd{Java to VDM} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{java2vdm.png}}):] see~\cite{Java2VDMMan-CSK}
#endif VDMPP

#endif ENG

#ifdef JPN
\item[\guicmd{構文チェック} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck.png}}):] セクション~\ref{sec:parser}参照 

\item[\guicmd{型チェック} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{typecheck.png}}):] セクション~\ref{sec:tc}参照 

\item[\guicmd{証明課題生成} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{integritycheck.png}}):] セクション~\ref{sec:pog} 参照

\item[\guicmd{C++コード生成} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{cplusplus.png}}):] セクション~\ref{sec:cg}参照 

#ifdef VDMPP
\item[\guicmd{Javaコード生成} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{java.png}}):] セクション~\ref{sec:cgjava}参照
#endif VDMPP  

\item[\guicmd{清書} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{prettyprint.png}}):] セクション~\ref{sec:pp}参照

#ifdef VDMPP
\item[\guicmd{JavaからVDM生成} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{java2vdm.png}}):] ~\cite{Java2VDMMan-CSK}参照 
#endif VDMPP  

#endif JPN

\end{description}

#ifdef ENG
\subsubsection{The log window, error list and source window}
#endif ENG
#ifdef JPN
\subsubsection{ログウインドウ、エラーリストウインドウ、ソースウインドウ}
#endif JPN

#ifdef ENG
The \guicmd{Log Window} displays messages from the \Toolbox, including
messages reporting on the success or failure of applying the actions
described above. It opens automatically (if it is not already open)
when a new message is displayed. Alternatively, it can be
opened/closed by hand by pressing the 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{log.png}}
button on the \guicmd{Window Operations} toolbar or by
selecting the corresponding item from the \guicmd{Windows} menu.

%   The \guicmd{Log Window} has three icons:
%   \begin{list}{}{}
%   \item[\includegraphics{clearBig}] This erases the content of the
%     log window.
%   \item[\resizebox{1cm}{!}{\includegraphics{print}}] This prints
%     the content of the frame to your printer. (Not available on the
%     Windows platform).
%   \item[\resizebox{1cm}{!}{\includegraphics{pipe}}] This pipes the
%     content of the buffer. When you select this icon a window pops up
%     and asks for a command to do the pipe command. (Not available on
%     the Windows platform).
%   \end{list}

The \guicmd{Error List} reports errors discovered by the \Toolbox\
while performing actions. It has two panes as shown in
Figure~\ref{fig:error2}. The top pane shows a list of the places (file
name, line number, column number) at which errors and warnings arose,
while the bottom displays a more detailed explanation of the currently
selected error. The format of the various errors which can arise
  during syntax checking and type checking is described in
  Sections~\ref{subsub:synerr} and~\ref{subsub:tcerr} respectively.  
Initially, the first error in the list is selected
automatically. You can get to the next/previous reported error by
pressing respectively the {\fbox{\tt >}} or \fbox{{\tt <}} button
which appears to the left of the error list. Alternatively you can
move to an arbitrary error by selecting the error notifier directly in
the top pane of the \guicmd{Error List}.
#endif ENG

#ifdef JPN
\guicmd{ログウインドウ} は\Toolbox\ からのメッセージを表示するが、これには上で記述
した動きを適用したときの成功･失敗の報告メッセージを含む。すでに開いていない限り、
新しいメッセージを表示するときに自動的に開く。代わりに\guicmd{ウインドウ} ツール
バーで \raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{log.png}}
ボタンを押すか\guicmd{ウインドウ} メニューで相当する項目を選ぶことで手動でウインドウ
を開いたり閉じたりすることも出来る。

%   The \guicmd{Log Window} has three icons:
%   \begin{list}{}{}
%   \item[\includegraphics{clearBig}] This erases the content of the
%     log window.
%   \item[\resizebox{1cm}{!}{\includegraphics{print}}] This prints
%     the content of the frame to your printer. (Not available on the
%     Windows platform).
%   \item[\resizebox{1cm}{!}{\includegraphics{pipe}}] This pipes the
%     content of the buffer. When you select this icon a window pops up
%     and asks for a command to do the pipe command. (Not available on
%     the Windows platform).
%   \end{list}

\guicmd{エラー一覧} はアクション実行中に\Toolbox\ によって発見されたエラーを報告する。
図~\ref{fig:error2}に示すとおり2つの画面から構成される。上のほうの画面はエラーやワーニングの
起こった箇所（ファイル名、行数、欄番号）のリストを示し、一方下の画面では
選択中のエラーの詳細な説明が表示される。構文チェック中や型チェック中に
生じるさまざまなエラーの形式は、セクション~\ref{subsub:synerr} と~\ref{subsub:tcerr} に
それぞれ記述されている。最初は、自動的にリストの先頭のエラーが選択されている。
エラーリストの左にある {\fbox{\tt >}} or \fbox{{\tt <}} ボタンを押すことでエラーリスト内の
次･前へ移動できる。代わりに\guicmd{エラー一覧}の上の画面にあるエラー通知を示す印を直接選択
しても任意のエラーへ動かすことができる。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=\textwidth]{errorList-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=\textwidth]{errorList-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Error List}
#endif ENG
#ifdef JPN
\caption{エラー一覧}
#endif JPN
\label{fig:error2}
\end{center}
\end{figure}

#ifdef ENG
The \guicmd{Error List} opens automatically (if it is not already
open) when a new error is discovered. Alternatively, it can be
opened/closed by hand by pressing the  
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{error.png}}
button on the \guicmd{Window Operations} toolbar or by
selecting the corresponding item from the \guicmd{Windows} menu.

The \guicmd{Source Window} also opens automatically (if it is not
already open) when a new error is discovered. It displays the part of 
the source specification in which the currently selected error was
discovered, the actual position of the error being marked by the
window's cursor. The \guicmd{Source Window} corresponding to the
\guicmd{Error List} illustrated in Figure~\ref{fig:error2} is shown in  
Figure~\ref{fig:source2}.
#endif ENG

#ifdef JPN
\guicmd{エラー一覧} はすでに開いていない限り新しいエラーが見つかると自動的に開く。
代わりに \guicmd{ウインドウ} ツールバーで 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{error.png}}ボタンを押すか
\guicmd{ウインドウ} メニューで相当する項目を選ぶことで手動でウインドウを開いたり
閉じたりすることも出来る。

\guicmd{ソースウインドウ} もまたすでに開いていない限り新しいエラーが見つかると自動的に開く。
現在選択中のエラーが発見された元の仕様書の一部を表示し、実際のエラーの位置は
ウインドウズのカーソルでマークされる。図~\ref{fig:error2}に記述された\guicmd{エラー一覧} に
相当する\guicmd{ソースウインドウ} を図~\ref{fig:source2}に示す。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=\textwidth]{sourceWindow-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=\textwidth]{sourceWindow-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Source Window}
#endif ENG
#ifdef JPN
\caption{ソースウインドウ}
#endif JPN
\label{fig:source2}
\end{center}
\end{figure}

#ifdef ENG
Many source files can be present in the \guicmd{Source Window} at the
same time but only the contents of one of them is shown. The display
can be changed to show a different source file by selecting the tab
corresponding to that file at the top of the \guicmd{Source
  Window}. New source files can be added to the display by hand by
double-clicking the left mouse button on the file name (or on one of
the \ifthenelse{\boolean{VDMsl}}{modules}{classes} contained in the
file) in the \guicmd{Manager}. Source files can be removed from the
display by pressing either the 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{fileclose.png}}
(\guicmd{Close file}) button or the 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{filecloseall.png}}
(\guicmd{Close all files}) button on the \guicmd{File Operations}
toolbar: the former (%
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{fileclose.png}})
closes only the file which is currently visible, while the latter (%
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{filecloseall.png}})
closes all files.

The \guicmd{Source Window} can be opened/closed by hand by pressing
the  
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{source.png}}
button on the \guicmd{Window Operations} toolbar or by
selecting the corresponding item from the \guicmd{Windows} menu.
#endif ENG

#ifdef JPN
多くのソースファイルが\guicmd{ソースウインドウ}に表示されているが、内容が表示されている
のはそのうち1つだけである。違うソースファイルを見たければ、\guicmd{ソースウインドウ}の上部に
あるファイルに相当するタブを選択することで表示が変わる。新しいソースファイルを
足すには、\guicmd{マネージャー}で手動でファイル名（またはファイルに含まれる
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} のひとつ）を
ダブルクリックする。ソースファイルは\guicmd{ファイル} ツールバーの 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{fileclose.png}}
(\guicmd{ソースウインドウから選択されたファイルを閉じる}) ボタン
または 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{filecloseall.png}}
(\guicmd{ソースウインドウのすべてのファイルを閉じる}) ボタンを押すと画面上から消える。 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{fileclose.png}})ボタンは
現在表示中のファイルを閉じ、
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{filecloseall.png}})ボタンは
すべてのファイルを閉じる。

\guicmd{ソースウインドウ} は\guicmd{ウインドウ} ツールバーの
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{source.png}}ボタンを
押すか\guicmd{ウインドウ} メニューから同様の項目を選択することで開いたり閉じたり出来る。
#endif JPN

#ifdef ENG
\subsubsection{Editing files}
#endif ENG
#ifdef JPN
\subsubsection{ファイルの編集}
#endif JPN

#ifdef ENG
In order to allow you to fix errors reported by the \Toolbox\ without
leaving the \Toolbox\ you can invoke your preferred editor (see
Appendix~\ref{sec:set_env}) directly on files in the current project:
simply select the appropriate file(s) in the \guicmd{Manager} and
press the \guicmd{External Editor}\index{External Editor} button (%
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{externaleditor.png}}) 
on the (\guicmd{Project Operations}) toolbar. Note that if more than
one file is selected when you invoke the \guicmd{External Editor} in
this way you actually get one \guicmd{External Editor} for each of the
selected files.

The \Toolbox\ automatically registers the changes that you make to the
file(s) when you save them in the editor. However, the edited versions
of the files are not re-processed automatically so whenever you edit a
source file you must run the syntax checker on it again before the
other tools in the \Toolbox\ will be aware of the changes you have
made.
#endif ENG

#ifdef JPN
\Toolbox\ を終了させずにエラーを修正するために、好みのエディタ(付録~\ref{sec:set_env}参照)を
作業中のプロジェクトのファイルから直接起動することができる：単純に編集したいファイルを
\guicmd{Manager} で選択し、\guicmd{プロジェクト}ツールバーの\guicmd{外部エディタ}
\index{がいぶエディタ@外部エディタ} ボタン(%
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{externaleditor.png}})を押す。
この方法で\guicmd{外部エディタ}を起動するときに複数のファイルが選択した場合、ひとつの
\guicmd{外部エディタ}で選択したファイルそれぞれを表示する。

\Toolbox\ はエディタで保存した変更を自動的に登録する。しかし編集されたファイルの
バージョンは自動的に更新されることはないので、ソースファイルを編集したら他のツールを使う前に
必ず構文チェック機能を再度走らせれば、\Toolbox\ にも変更が反映される。
#endif JPN

% \subsubsection{Tracking dependencies}

% The \guicmd{References} window displays the dependencies between
% classes, that is the classes which use the selected class and the
% classes which the selected class uses~(a class {\em uses\/} another
% class if it has references to objects of that class, for example
% through its instance variables or operation calls). It can be opened
% by pressing the  
% \raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{references}}
% button on the \guicmd{Window Operations} toolbar or by selecting the
% corresponding item from the \guicmd{Windows} menu, and closed by
% pressing the \guicmd{Ok} in the bottom right-hand corner of the window
% itself. %\fbox{{\bf needs completing! -- RM}}.
% This feature is not yet implemented. 

#ifdef ENG
\subsubsection{Using the interpreter}
#endif ENG
#ifdef JPN
\subsubsection{インタープリタを使う}
#endif JPN

#ifdef ENG
The interpreter allows you to evaluate and debug expressions and
statements. The \guicmd{Interpreter Window}, which provides an
interface to the interpreter, is opened by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{interpreter.png}}  
(\guicmd{Interpreter}) button on the (\guicmd{Window Operations})
toolbar, and the \guicmd{Interpreter} menu and toolbar offer a range
of operations which can be applied in the interpreter. The interpreter
is described in detail in Section~\ref{sec:interpreter}.
#endif ENG

#ifdef JPN
インタープリタを使って式と命令文のデバッグ、評価ができる。\guicmd{実行ウインドウ}
はインタープリタへのインターフェースを提供するが、(\guicmd{ウインドウ})ツールバーの 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{interpreter.png}}  
(\guicmd{実行}) ボタンを押すと開く。また\guicmd{実行} メニューおよびツールバーは
インタープリタでできるあらゆる処理を提供する。詳細はセクション~\ref{sec:interpreter}で記述する。
#endif JPN

#ifdef ENG
\subsubsection{On-line help}
\index{Help}
#endif ENG
#ifdef JPN
\subsubsection{オンラインヘルプ}
\index{ヘルプ}
#endif JPN
% 
% %%%%% This next paragraph should be reinserted when help window is
% %%%%% implemented -- RM
%
% At any time when you are using the \Toolbox\ you can press the ``{\tt
%   F1}'' button and a help window~(as shown in
% Figure~\ref{fig:guihelp}) will appear with on-line help for the
% graphical user interface. The part of the help text that is shown at
% the top of the help window is related to the particular part of the
% \Toolbox\ window in which the cursor is placed. The help text is
% organised in a hypertext format so it is possible to follow links from
% one part of the help text to another.

% The help window can also be accessed by pressing the  
% \raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{help}}
% button on the \guicmd{Help} toolbar or by selecting the corresponding
% item from the \guicmd{Help} menu. 

#ifdef ENG
On-line help for the \Toolbox\ and the interface in general can %also
be accessed through the \guicmd{Help} toolbar or the \guicmd{Help}
menu. Currently only the following very limited help is available:
#endif ENG

#ifdef JPN
\Toolbox\ のオンラインヘルプと一般的なインターフェースは\guicmd{ヘルプ} ツールバーや\guicmd{ヘルプ} メニューから
アクセスできる。最近では以下に示す限られたものだけが利用可能である。
#endif JPN

\begin{description}
#ifdef ENG
 \item[\guicmd{About} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{help.png}}):]
  Displays the version number of the \Toolbox.

 \item[\guicmd{aboutqt}  (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{qt.png}}):]
  Displays information about and a reference to Qt, the multiplatform
  C++ GUI toolkit which the \Toolbox\ interface uses.

% \item[\guicmd{What's This?} (\hspace{-1.8mm}
%\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{whatsthis}}):]  
%  Select this item then click the left mouse button over some part of
%  the \Toolbox\ to get a brief description of it. (Currently only
%  partly implemented.) \\
#endif ENG

#ifdef JPN
 \item[\guicmd{ツールについて} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{help.png}}):]
  \Toolbox\ のバージョン番号を表示する

 \item[\guicmd{Qtについて}  (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{qt.png}}):]
  Qt（\Toolbox\ のインターフェースが利用している、C++のマルチプラットフォーム
  GUIツールキット）へのリファレンス情報を表示する

% \item[\guicmd{What's This?} (\hspace{-1.8mm}
%\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{whatsthis}}):]  
%  これを選択してから\Toolbox\ の一部の上でマウスの左ボタンをクリックすると、
%  その項目についての記述が表示される（現在は一部のみ実装されている）
#endif JPN
\end{description}


#ifdef ENG
\subsection{The Overall Command Line Interface}\label{subsec:maincommand}
\index{Command Line Interface}\index{Command Line Interface!Starting}
#endif ENG
#ifdef JPN
\subsection{コマンドラインインターフェース全般}\label{subsec:maincommand}
\index{コマンドラインインターフェース}\index{コマンドラインインターフェース!かいし@開始}
#endif JPN

#ifdef ENG
The command line interface is started from a command prompt by
typing\footnote{Either the executable {\tt \vdmde}\ must be in the
  search path or the full path to it must be given as well.}:

{\tt \vdmde\ specfile}

When {\tt \vdmde} is called from the command line without any options
and with only one file argument (which must contain a \vdmslpp\ 
specification), the tool will enter the command mode and begin by
syntax checking the argument file.

The user manipulates, executes and debugs a specification using a
number of commands typed at the prompt produced by the \Toolbox.  The
commands given below are supported by {\tt \vdmde}.  The abbreviations
in parentheses are short forms for the commands.

A number of the commands cannot be called before the specification has
been initialised (see the {\cmd init} command in
Section~\ref{sec:interpreter}).  These commands are marked with a star
({\tt *}).

A number of commands can be used to display the names of different
constructs. These are,
\ifthenelse{\boolean{VDMsl}}{\textbf{modules},}{\textbf{classes},}
\textbf{functions}, \textbf{operations},
\ifthenelse{\boolean{VDMsl}}{\textbf{states}}{\textbf{instvars}},
\textbf{types} and \textbf{values}.  Help for the \Toolbox\ commands
can be obtained using either \textbf{info} or \textbf{help}. Sequences
of frequently used commands can be collected in script files and
activated using the \textbf{script} command. General operating system
calls can be made using the \textbf{system} command. The \textbf{dir}
command can be used to add more directories to the search path used by
the \Toolbox. \textbf{pwd} gives the current
working directory. Finally the \textbf{quit} and \textbf{cquit}
commands can be used to leave the command line version of the
\Toolbox.  These commands are described as follows:
#endif ENG

#ifdef JPN
コマンドラインインターフェースはプロンプトから以下のように入力 することで起動する。
\footnote{実行可能な{\tt \vdmde}コマンドがサーチパスに必ずあるか、フルパス指定をしなくてはならない}:

{\tt \vdmde\ specfile}

コマンドラインから{\tt \vdmde} がオプションなし・1つのファイル名（\vdmslpp\ の仕様書を
含んでいなければならない）のみで入力されると、ツールはコマンドモードに入り指定された
ファイルの構文チェックを始める。

ユーザーは\Toolbox\ が提供するたくさんのコマンドをプロンプトからタイプすることで、
仕様書の操作、実行、デバッグができる。下記で与えられたコマンドは{\tt \vdmde}によってサポートされている。
丸カッコ内の省略形はコマンドの短縮形である。

多くのコマンドが、仕様書の初期化前には使用できない。（{\cmd init}コマンドについては、
セクション~\ref{sec:interpreter}を参照）これらのコマンドには({\tt *})マークがついている。

異なる構成物の名前を表示するのに、多くのコマンドが使われる。
\ifthenelse{\boolean{VDMsl}}{\textbf{modules},}{\textbf{classes},} 
\textbf{functions}, \textbf{operations}, 
\ifthenelse{\boolean{VDMsl}}{\textbf{states}}{\textbf{instvars}},
\textbf{types}, \textbf{values}
である。\textbf{info} または\textbf{help}を使って\Toolbox\ のコマンドの
ヘルプが得られる。
頻繁に使われるコマンドのシーケンスはスクリプトファイルに集められ、 \textbf{script} コマンドを使って
実行することができる。一般的なOSのシステムコールは\textbf{system} コマンドで発行することができる。
\textbf{dir}コマンドはツールボックスの検索パスにディレクトリを足すときに使う。\textbf{pwd} コマンドは現在の
ワーキングディレクトリを表示する。最後に\textbf{quit}または\textbf{cquit}コマンドでコマンドライン入力の
\Toolbox\ を終了することが出来る。下記でこれらコマンドについて記述する。
#endif JPN

\begin{description}

#ifdef ENG
#ifdef VDMPP
\item[*classes] \index{classes command}\mbox{} \\
  Displays the names of the defined classes and their status.
#endif VDMPP

#ifdef VDMSL
\item[modules] \index{modules command}\mbox{}\\
  Displays the names of defined modules and information about their
  status.
#endif VDMSL
#endif ENG

#ifdef JPN
#ifdef VDMPP
\item[*classes] \index{classesコマンド}\mbox{} \\
  定義済みのクラス名とその状態を表示
#endif VDMPP

#ifdef VDMSL
\item[modules] \index{modulesコマンド}\mbox{}\\
  定義済みのモジュール名とその状態情報を表示
#endif VDMSL
#endif JPN

#ifdef ENG
\item[*functions]  \ifthenelse{\boolean{VDMpp}}{{\tt
      class}}{}\index{functions command}\mbox{}\\ 
  Displays the names of the functions defined in
  \ifthenelse{\boolean{VDMsl}}{the current module}{class {\tt class}}.
  Includes precondition, postcondition and invariant functions which are
  automatically created when the specification includes such constructs.

#ifdef VDMPP
\item[*operations] {\tt class}\index{operations command}\mbox{}\\
  Displays the names of  the operations defined in the given class.
#endif VDMPP

#ifdef VDMSL
\item[*operations] \index{operations command}\mbox{}\\
  Displays the names of all operations defined in the current module.
#endif VDMSL

#ifdef VDMPP
\item[*instvars] {\tt class}\index{instvars command}\mbox{}\\
  Displays the names of the instance variables of the given class.
#endif VDMPP
  
#ifdef VDMSL
\item[*states]\index{states command}\mbox{}\\
  Displays the names of defined global state names.
#endif VDMSL

\item[*types] \ifthenelse{\boolean{VDMpp}}{{\tt class}}{}\index{types command}\mbox{}\\ 
  Displays the names of the types defined in
  \ifthenelse{\boolean{VDMsl}}{the current module}{the given class}.

\item[*values] \ifthenelse{\boolean{VDMpp}}{{\tt class}}{}\index{values command}\mbox{}\\ 
  Displays the names of the values defined in the 
  \ifthenelse{\boolean{VDMsl}}{current module}{given class}.

\item[help \mbox{[{\tt command}]}] \index{help command}\mbox{}\\
  On-line help explaining all available commands in
  the same style as is used in this section. Without an argument it
  lists all the available commands. Otherwise the command {\tt
    command} is described.

\item[info \mbox{[{\tt command}]}] \index{info command}\mbox{}\\
  Same as {\tt help}.

\item[script {\tt file}] \index{script command}\mbox{}\\
  Reads and executes the script in {\tt file}.  A script is a
  sequence of \vdmslpp\ commands.  These can be any of the commands
  described in this section and in other sections about the
  command line interface.  When the script has been executed, the
  control is returned to the \Toolbox.

\item[system (sys) {\tt command}]\index{system command}\mbox{}\\
  Executes a shell command.

\item[dir \mbox{[{\tt path ...}]}] \index{dir command}\mbox{}\\
  Adds a directory to the list of active directories. These are the
  directories that will be searched automatically when trying to
  locate a specification file.
  
  When calling this command with no arguments the list of active
  directories is printed to the screen. The directories will be
  searched in the displayed order.

\item[pwd] \index{pwd command} \mbox{}\\
  Gives the current working directory i.e.\ the directory in which
  the current project file is placed (if a project file exists). In
  all cases this is the directory in which the \texttt{vdm.tc} file must
  be placed, and where files generated by the code generator
  \ifthenelse{\boolean{VDMpp}}{and the Rose-VDM++ Link}{} are written.

\item[cquit] \index{cquit command} \mbox{}\\
  Quits the debugger without asking for confirmation.  This is useful
  when using the debugger in a batch job.

\item[quit (q)] \index{quit command}\mbox{}\\
  Same as {\tt cquit}.
%Quits the \Toolbox. Asks for confirmation.  \\
#endif ENG

#ifdef JPN
\item[*functions]  \ifthenelse{\boolean{VDMpp}}{{\tt
      class}}{}\index{functionsコマンド}\mbox{}\\ 
  \ifthenelse{\boolean{VDMsl}}{現在のモジュール}{クラス{\tt class}}で定義される関数名を表示する。
  事前条件、事後条件、関数の不変条件は仕様書がそれを含む場合自動的に作成される

#ifdef VDMPP
\item[*operations] {\tt class}\index{operationsコマンド}\mbox{}\\
  与えられたクラス名で定義される操作名を表示する
#endif VDMPP

#ifdef VDMSL
\item[*operations] \index{operationsコマンド}\mbox{}\\
  現在のモジュールで定義されたすべての操作名を表示する
#endif VDMSL

#ifdef VDMPP
\item[*instvars] {\tt class}\index{instvarsコマンド}\mbox{}\\
  与えられたclass名で定義されるインスタンス変数名を表示する
#endif VDMPP

#ifdef VDMSL
\item[*states]\index{statesコマンド}\mbox{}\\
  定義済みのグローバルステート名を表示する
#endif VDMSL

\item[*types] \ifthenelse{\boolean{VDMpp}}{{\tt class}}{}\index{typesコマンド}\mbox{}\\ 
  \ifthenelse{\boolean{VDMsl}}{現在のモジュールで}{与えられたクラス名で}
  定義済みの型名を表示する

\item[*values] \ifthenelse{\boolean{VDMpp}}{{\tt class}}{}\index{valuesコマンド}\mbox{}\\ 
  \ifthenelse{\boolean{VDMsl}}{現在のモジュールで}{与えられたクラス名で}
  定義される値の名前を表示する

\item[help \mbox{[{\tt command}]}] \index{helpコマンド}\mbox{}\\
  このセクションで使われているような、すべての利用可能なコマンドを説明する
  オンラインヘルプと同じスタイル。引数なしだと利用可能なコマンドすべてのリストを
  表示する。そうでない場合は引数で与えられた{\tt コマンド}の説明となる。

\item[info \mbox{[{\tt command}]}] \index{infoコマンド}\mbox{}\\
  {\tt help}と同じ。

\item[script {\tt file}] \index{scriptコマンド}\mbox{}\\
  {\tt file}からスクリプトを読み込み、実行する。スクリプトは\vdmslpp\ コマンドの羅列である。
  これらはコマンドラインインターフェースであればこのセクションや他のセクションで記述
  されたどのコマンドも使用できる。スクリプトの実行が終わると、コントロールは\Toolbox\ に戻る

\item[system (sys) {\tt command}]\index{systemコマンド}\mbox{}\\
  シェルコマンドを実行する

\item[dir \mbox{[{\tt path ...}]}] \index{dirコマンド}\mbox{}\\
  アクティブなディレクトリのリストにディレクトリを追加する。これらのディレクトリは
  仕様書のファイルの場所を探すとき自動的にサーチされる。
  このコマンドを引数なしで実行するとアクティブなディレクトリのリストが画面に
  表示される。ディレクトリは表示された順にサーチされる。

\item[pwd] \index{pwdコマンド} \mbox{}\\
  現在のワーキングディレクトリを表示する。例えば、プロジェクトファイルがあれば
  作業中のプロジェクトファイルのある場所である。すべての場合、vdm.tcファイルのある
  場所であり、コード生成で生成されたファイル\ifthenelse{\boolean{VDMpp}}{やRose-VDM++リンク}{} 
  が書き込みをするところとなる。

\item[cquit] \index{cquitコマンド} \mbox{}\\
  確認の質問なしでデバッガを終了する。バッチジョブでデバッガを
  使うときに利用するとよい

\item[quit (q)] \index{quitコマンド}\mbox{}\\
  {\tt cquit}と同じ
%\Toolbox\ の終了。確認の質問を聞いてくる\\
#endif JPN

\end{description}

#ifdef ENG
\subsubsection{Initialisation file}\index{Command Line Interface!Initialisation File} 
#endif ENG
#ifdef JPN
\subsubsection{ファイルの初期化}\index{コマンドラインインターフェース!ファイルのしょきか@ファイルの初期化}
#endif JPN

#ifdef ENG
It is possible to put command line interface commands into an
``initialisation file''. These commands will be executed automatically 
when the \Toolbox\ is started from the command line.

The initialisation file must be called {\tt .\vdmde}\index{.\vdmde\ file} 
and must be located either in the directory from which the
\Toolbox\ is started or in the same directory as the specification
file which is given as argument.
#endif ENG

#ifdef JPN
コマンドラインインターフェースでは、「ファイルの初期化」をすることができる。
これらのコマンドは\Toolbox\ をコマンドラインで起動すると自動的に実行される。

初期化ファイルは{\tt .\vdmde ファイル}\index{.\vdmde ファイル}で指定され、
引数としてファイルを指定するためには
\Toolbox\ が起動するディレクトリか仕様書のファイルのあるディレクトリと同じ
ディレクトリになくてはならない。
#endif JPN

\newpage
#ifdef ENG
\subsection{The Syntax Checker}\label{sec:parser}
#endif ENG
#ifdef JPN
\subsection{構文チェック機能}\label{sec:parser}
#endif JPN

#ifdef ENG
The syntax checker checks whether your specification conforms to the
syntax given in the language definition. The other tools in the system
rely on the specification being syntax-correct, so your
specification must have been syntax checked with no syntax errors
before the other tools in the \Toolbox\ can be applied. Note that when you
change a source file you must syntax check it again before the other
tools will be aware of the changes you have made.
\ifthenelse{\boolean{VDMsl}}{{\bf Note also that it is not possible to
mix modular specifications and flat specifications in one project.}}{}

The syntax checker can be accessed from either the graphical, command
line or Emacs interface.

The syntax checker aims to report as many of the syntax errors in a
specification as possible at the same time. Consequently, it uses an
advanced recovery mechanism which allows it to detect and recover from
a syntax error before passing on to report subsequent syntax errors in
the specification. It does this either by ignoring some symbols in the 
specification or by assuming additional symbols. The error messages it
gives 
include information about what was expected at an error point in the
specification and what was ignored or assumed in order to allow the
checker to carry on. Initially, it is easiest to understand the error
messages by concentrating on what was assumed or ignored because this
guess by the syntax checker is often close to the real error.
#endif ENG

#ifdef JPN
構文チェック機能は作成した仕様書が言語定義であたえられている構文に沿うもので
あるかどうかチェックする。このシステムのほかのツールは仕様書が構文的に正しい
前提で動くため、仕様書は\Toolbox\ のほかのツールを適用する前に構文チェックを行い、
構文エラーのない状態にしておく必要がある。
\ifthenelse{\boolean{VDMsl}}{{\bf 元ファイルを修正した場合は、他のツールが
修正に気づく前に構文チェックを再度しておかなければ成らないことに注意すること。}}{}

構文チェック機能はGUI、コマンドライン、Emacsのいずれのインターフェースを使っても使用することができる。

構文チェック機能の狙いは仕様書の構文エラーを出来るだけ多く同時にレポート
することである。このため、構文チェック機能は最新のリカバリー機構を使用しているが、
これにより構文エラーを見過ごしてしまう前に捕捉し復旧することや、すぐ次に
生じる仕様書の構文エラーを報告することができる。仕様書のある記号を
無視したり足りない記号を想定したりすることでこれを可能にする。
エラーメッセージは、仕様書のエラーが起こった箇所で何が期待されていたかということや
チェッカーが実行し続けるためには何が無視されるべきで何が想定されるのかということに
ついての情報もあたえてくれる。最初は、何が想定/無視されるのかということに集中する
ことによってエラーメッセージを理解するのが最も簡単である。なぜならこの構文チェック機能に
よる推測は実際のエラーに近いものであることが多いからだ。
#endif JPN

#ifdef ENG
\subsubsection{The graphical user interface}
#endif ENG
#ifdef JPN
\subsubsection{GUI}
#endif JPN

#ifdef ENG
To start the syntax checker from the graphical user interface, select 
the files or \ifthenelse{\boolean{VDMsl}}{modules}{classes} (more than
one, if you wish) you want to check or recheck in the \guicmd{Project
  View} or the \vdmModView\ of the \guicmd{Manager} as
appropriate\footnote{If you select 
  \ifthenelse{\boolean{VDMsl}}{modules}{classes} in the 
  \vdmModView\ of the \guicmd{Manager} the syntax checker is
  actually applied to the set of files which contain the selected
  \ifthenelse{\boolean{VDMsl}}{modules}{classes} -- the \Toolbox\ only
  knows which files have been edited. This of course means
  that if a particular file contains more than one
  \ifthenelse{\boolean{VDMsl}}{module}{class} definition and you 
  select only some of those \ifthenelse{\boolean{VDMsl}}{modules}{classes}
  then the other \ifthenelse{\boolean{VDMsl}}{modules}{classes} in the
  same file are implicitly included.}, then press the
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck.png}}  
(\guicmd{Syntax Check})
button on the (\guicmd{Actions})
toolbar to invoke the syntax checker. The \guicmd{Log Window} opens
automatically (if it is not already open) and displays information
about the checking process for each selected file or class in turn. If
syntax errors\index{Syntax Errors} are discovered, the \guicmd{Error 
List}\index{Error List} and the \guicmd{Source Window} are also 
au\-to\-matically invoked. 
#endif ENG

#ifdef JPN
構文チェック機能をGUIで起動するには、チェックしたいファイルまたは
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} （複数選択可能）
\footnote{
%--------------------------footnote inserted-----------
  \vdmModView\ で
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} を選択すると、構文チェック機能は実際には選択した
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} の含まれる
　ファイル一式に適用される－\Toolbox\ はどのファイルが編集されたかということしか知らない。
　これはもし特定のファイルが複数の
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} 定義を含んでいて、そのうちのいくつかだけを
  選択していた場合には、暗黙のうちに同じファイルの他
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} が処理に含まれる。
%--------------------------footnote inserted end-----------
}
を\guicmd{マネージャー} の\guicmd{プロジェクトビュー} または\vdmModView\ で選択して、
(\guicmd{アクション})ツールバーの \raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck.png}}  
(\guicmd{構文チェック})ボタンを押す。
\guicmd{ログウインドウ} が（開いていなければ）自動的に開き選択したファイルやクラスそれぞれのチェックの
進行状況についての情報を順番に表示する。構文エラー\index{こうぶんエラー@構文エラー}が発見されると、
\guicmd{エラー一覧}\index{エラーリスト} と\guicmd{ソースウインドウ} が自動的に起動する。
#endif JPN

#ifdef ENG
\subsubsection{Format of syntax errors} \label{subsub:synerr}
#endif ENG
#ifdef JPN
\subsubsection{構文エラーのフォーマット} \label{subsub:synerr}
#endif JPN

#ifdef ENG
When a syntax error in the specification is discovered the syntax
checker\index{Syntax Errors!Format} displays information about the
error in the \guicmd{Error List} as follows:
#endif ENG

#ifdef JPN
仕様書の構文エラーが見つかると、構文チェック機能\index{こうぶんエラー@構文エラー!フォーマット} は
\guicmd{エラー一覧}に以下のような情報を表示する。
#endif JPN

\begin{enumerate}

#ifdef ENG
\item It prints the symbols which were \textbf{expected} at the place
  of the syntax error.

\item It prints how it tried to recover from the syntax error, which
  could be by \textbf{inserting} one or more symbols, by
  \textbf{ignoring} one or more symbols, or by \textbf{replacing} 
  some input symbols with other symbols at the point of the syntax
  error. The specification file is {\em not\/} changed by this
  operation, i.e.\ the change is only performed internally within the
  syntax checker to enable it to detect multiple syntax errors.
#endif ENG

#ifdef JPN
\item
 構文エラーの箇所にどんな記号が（足りないことが）\textbf{想定される(expected)}か

\item
  構文エラーから復旧するにはどうすればよいか。記号を\textbf{挿入}するか、
  記号を\textbf{無視}するか、違う記号に\textbf{置き換える}かなど。仕様書のファイル自体は
  この処理によって何も変わらない（構文チェック機能内でのみ実行される変化であり、
  これがさまざまな構文エラーを捕捉することを可能にしている）
#endif JPN

\end{enumerate}

#ifdef ENG
The symbols are displayed in a mixture of three formats:
#endif ENG
#ifdef JPN
記号は3つの形式の混合で表示される:
#endif JPN

\begin{itemize}
#ifdef ENG
\item Display of text within single quotes, e.g.\ {\tt
    `functions'}.

\item Display of a meta-symbol, e.g.\ \verb!<end of file>!, the
  designation of the end of the file.

\item Display of a group of similar tokens as a single token, e.g.\ 
  \verb!<<type>>!, the syntactic unit {\tt type} whose definition can
  be found in
  \ifthenelse{\boolean{VDMsl}}{\cite{UMLMan-CSK}}{\cite{LangManPP-CSK}}. This
  is done to shorten the list of expected symbols.
#endif ENG

#ifdef JPN
\item
     シングルクォート内に表示~e.g.\ {\tt `functions'}.

\item
  メタシンボルの表示~e.g.\ \verb!<end of file>!, 「ファイルの最後」の意味

\item
  似たようなトークン群をシングルトークンとして表示~e.g.\ 
  \verb!<<type>>!, 構文上のユニット {\tt type} (定義は
  \ifthenelse{\boolean{VDMsl}}{\cite{UMLMan-CSK}}{\cite{LangManPP-CSK}}) 予想される記号のリストを
  短くするためにこれがなされる
#endif JPN
\end{itemize}

#ifdef ENG
\subsubsection{The command line interface}\label{subsec:parcom}
\index{Command Line Interface!Syntax Checker}
#endif ENG
#ifdef JPN
\subsubsection{コマンドラインインターフェース}\label{subsec:parcom}
\index{コマンドラインインターフェース!こうぶんチェッカー@構文チェック機能}
#endif JPN

#ifdef ENG
The syntax of the command to invoke the syntax checker at the command
line is:
#endif ENG
#ifdef JPN
コマンドラインから構文チェック機能を起動するコマンドの構文は:
#endif JPN

{\tt \vdmde\ -p [-w] [-R testcoverage] specfile(s) ...}

\vspace{0.5cm}

\noindent
#ifdef ENG
With the {\tt -p} option, {\tt \vdmde} syntax checks a number of files,
each containing \ifthenelse{\boolean{VDMsl}}{one or more modules or
  parts of a flat specification}{one or more classes}.  Syntax errors
are reported to {\aaa stderr}.

The additional options that can be used with the syntax checker are:
#endif ENG

#ifdef JPN
{\tt -p} オプションをつかえると、{\tt \vdmde}コマンドは
それぞれ
\ifthenelse{\boolean{VDMsl}}{1つ以上のモジュール、またはフラットな仕様書の一部}{1つ以上のクラス}
を含むたくさんのファイルをチェックする。
エラーは{\aaa stderr}で報告される。

その他の追加オプションは、
#endif JPN

\begin{description}
#ifdef ENG
\item[{\tt -w}] This option causes the \Toolbox\ to write the
  \vdmslpp\ parts of RTF files in ASCII files. The names of these
  ASCII files will be the RTF file names with the extra extension {\tt
    .txt}, e.g.\ {\tt sort.rtf} will yield {\tt sort.rtf.txt}.
  
  This option is typically used in a test environment to reduce the
  time used to parse specification files. If the documentation parts
  of RTF files are very large this can slow down the parsing since
  the entire file must be parsed. For example, figures tend to make the
  documentation part of a file very large.

\item[{\tt -R}] Causes the \Toolbox\ to produce a test coverage file
  {\tt testcoverage} which is used to keep track of how often different
  constructs have been exercised during testing of a \vdmslpp\ 
  specification. In the current version this test coverage file must
  be called {\tt vdm.tc} for the pretty printer to work.  See
  Section~\ref{vdmtc} for an example.
#endif ENG

#ifdef JPN
\item[{\tt -w}]
   \vdmslpp\ のRTFファイルの一部をASCIIに書き出す。ASCIIのファイル名は
  RTFのファイル名に拡張子{\tt .txt}がつく。例){\tt sort.rtf}は{\tt sort.rtf.txt}となる

  このオプションはテスト環境で仕様書の解析時間を減らすためによく使われる。
  RTFファイルの文書の部分が大きいと、ファイル全体を解析しなければならないため
  とても遅くなる。例えば、図はファイルの文書部分をとても大きくしてしまう傾向がある。

\item[{\tt -R}]
   \vdmslpp\ 仕様書のテスト中違う構成物がどれだけ実行されたかを記録するのに
  使われるテストカバレッジファイルを生成する。（ファイル名は引数
  {\tt testcoverage}で指定できる）現在のバージョンでは、このテストカバレッジ
  ファイルは{\tt vdm.tc}という名前でなくてはならない（清書機能が動くため）。
  例についてはセクション~\ref{vdmtc} を参照。
#endif JPN
\end{description}

#ifdef ENG
\subsubsection{The Emacs interface}
#endif ENG
#ifdef JPN
\subsubsection{Emacsインターフェース}
#endif JPN

#ifdef ENG
In the Emacs interface all commands are given at the command
prompt. Syntax checking is made by the \textbf{read} command and
traversing the syntax errors is done using the \textbf{first},
\textbf{last}, \textbf{next} and \textbf{previous} commands. The
location of the errors is shown in the specification
window. In more detail, the commands are:
#endif ENG

#ifdef JPN
Emacsインターフェースでは、すべてのコマンドをプロンプトから入力する。
構文チェックは\textbf{read}コマンドで行われ、構文エラーを詳しく見るには
\textbf{first}, \textbf{last}, \textbf{next}, \textbf{previous} コマンドが使われる。
#endif JPN

\begin{description}
#ifdef ENG
\item[read (r) {\tt file(s)}] \index{read command}\mbox{}\\
  Syntax checks specifications from {\tt file(s)}
  \ifthenelse{\boolean{VDMsl}}{The file(s) must contain either module
    definitions or definitions of functions, values, operations, types,
    and possibly a state definition.}%
    {The file(s) must contain definitions of classes
    including operations, functions, values, types, and instance
    variables.}

  The contents of each file is treated as a whole.  This means that
  if a syntax error occurs then none of the \vdmslpp\ constructs in
  the file are included.  This is also the case if the file contains
  \ifthenelse{\boolean{VDMsl}}{more than one module}{more than one
    class}~(i.e.~none of the
  \ifthenelse{\boolean{VDMsl}}{modules}{classes} are included).  If a
  file is syntax checked successfully and redefines a 
  \ifthenelse{\boolean{VDMsl}}{module}{class} which
  is already defined in a syntax checked file then a warning is
  given.

\item[first (f)] \index{first command}\mbox{}\\
  This command displays the position of the first recorded error or
  warning message from the syntax checker, type checker, code
  generator or pretty printer.

\item[last] \index{last command}\mbox{}\\
  This command displays the position of the last recorded error or
  warning message from the syntax checker, type checker, code
  generator or pretty printer.

\item[next (n) \index{next command}]\mbox{}\\
  This command displays the position of the next recorded message in
  the source file window.  It is used to display error or warning
  messages from the syntax checker, type checker, code generator and
  pretty printer.

\item[previous (pr)] \index{previous command}\mbox{}\\
  This command displays the position of the previous recorded message.
  It is also used to display error or warning messages from the syntax
  checker, type checker, code generator and pretty printer.
#endif ENG

#ifdef JPN
\item[read (r) {\tt file(s)}] \index{readコマンド}\mbox{}\\
  {\tt file(s)}から仕様の構文チェックを行う。
  \ifthenelse{\boolean{VDMsl}}
    {
      {\tt file(s)}はモジュール定義または関数、値、操作、型、場合によっては状態の定義を
      含まなくてはならない。
    }%
    {
      {\tt file(s)}は関数、値、型、インスタンス変数などを含むクラスの定義を含まなくてはならない。
    }

  それぞれのファイルの内容は全体として扱われる。これはもし構文エラーが
  起こっても、そのファイルの\vdmslpp\ での構成物は何も含まれないということを意味する。
  またこれはもしそのファイルが複数の
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} を含んでいた場合も含む
  （\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}  には何も含まれない）。
  ファイルが構文チェックをパスし、構文チェック済みのファイルですでに定義された
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} が再定義
  されたならば、ワーニングが発生する。

\item[first (f)] \index{firstコマンド}\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  からなど最初に記録されたエラーまたはワーニングメッセージを表示する。

\item[last] \index{lastコマンド}\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  などから最後に記録されたエラーまたはワーニングメッセージを表示する。

\item[next (n) \index{nextコマンド}]\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  などからソースファイルウインドウの次の位置に記録されたエラーまたはワーニングメッセージを表示する

\item[previous (pr)] \index{previousコマンド}\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  などからソースファイルウインドウの前の位置に記録されたエラーまたはワーニングメッセージを表示する
#endif JPN

\end{description}

\newpage
#ifdef ENG
\subsection{The Type Checker}\label{sec:tc}
\label{sec:def-typechedk}\label{type check} \index{Type Checking}
#endif ENG
#ifdef JPN
\subsection{型チェック機能}\label{sec:tc}
\label{sec:def-typechedk}\label{type check} \index{かたチェック@型チェック}
#endif JPN

#ifdef ENG
The type checker assesses whether expressions are of the types
expected for their positions in a specification. However, type
correctness is not always as clear-cut as it seems. For example, if a
function takes an {\aaa int} as argument but is applied to an
expression of type {\aaa real}, then, since {\aaa int} is a subtype of
{\aaa real}, the application might be correct
provided the function is called at run-time with actual parameters
which happen to be integer reals. On the other hand, the application
might also be incorrect since {\aaa real} contains elements that are
not part of {\aaa int}. We say that such an application is {\em
  possibly\/} well-formed but not {\em definitely\/} well-formed.

In fact the type checker can perform type checking at either of these
two different levels: possible and definite well-formedness. In short
the difference between them is that specifications which are possibly
well-formed can be type correct but are not guaranteed to be so,
whereas specifications that are definitely well-formed are guaranteed
to be type correct.\index{Type Correctness|see{\\ Possible Well-formedness,
    \\ Definite Well-formedness}}\index{Well-formedness|see{\\ Possible
    Well-formedness, \\ Definite Well-formedness}} Thus, the function
application discussed in the previous paragraph  would pass a possible
well-formedness (``pos'') type check \index{Possible Well-formedness}
but fail a definite well-formedness (``def'') type check: \index{Definite Well-formedness}
the ``def'' check would identify it as a possible source of a run-time error.

The definite well-formedness check \index{Definite Well-formedness} will identify all places where
run-time errors could potentially occur. These include applications of
functions which have a precondition (the precondition must be
satisfied before an application of that function is made) and
applications of partial operators which are built directly into VDM
(e.g.\ the arithmetic division operator which gives a run-time error
if its second argument is zero), as well as possible inconsistencies
resulting from the use of a subtype in a definition, either through an
invariant or through the use of one part of a union type.

In general a ``def'' type check will yield more error messages than
a ``pos'' type check. Therefore we recommend that you always run a ``pos''
check on your specification first in order to deal with all the points
where the specification is not even possibly type correct, then run the ``def''
check in order to identify possible causes of run-time errors. In many
cases, you will be able to eliminate these from consideration, for
example because an expression is protected by being in one limb of an
``if \ldots then \ldots else \ldots'' expression where the condition
prevents the run-time error condition from arising. In other cases,
the ``def'' check may identify conditions for which you do want to
introduce protection  by modifying the specification.

The type checker can be accessed either from the GUI, from the command
line version of the \Toolbox, or from the Emacs interface.
#endif ENG
  
#ifdef JPN
型チェック機能は記述されているものが仕様書のその位置に想定される型であるか
どうかを評価する。しかし、型の正しさはそれが想定するようにいつもはっきりしたもの
であるわけではない。例えば、ある関数が引数に{\aaa int}型の値をとっているが記述としては
{\aaa real}型が適用されているとすると、{\aaa int}型は{\aaa real}型のサブタイプなので、提供されたその
関数は実行時たまたま実際には{\aaa int}型の引数をとって呼ばれ、アプリケーションが正しい
のかもしれない。また{\aaa real}型は{\aaa int}の一部ではないため、アプリケーションは正しくないの
かもしれない。このようなアプリケーションは{\em おそらく\/}よくまとめられているとは言えても、
{\em 明確に\/}よくまとめられているとは言えないのである。

実際、型チェック機能はこれら2つの異なるレベルどちらでも型チェックを実行することができる。
端的に言えばこれら2つの違いは「おそらく適格な仕様書」が型としては正しいがそうである
ことがきちんと保障されていない一方で「明確に適格な仕様書」は型として正しいことが
保障されているのことにある
\index{かたのただしさ@型の正しさ |see{\\ pos型, \\ def型}}
\index{てきかくせい@適格性 |see{\\ pos型, \\ def型}}。
そのため、全節で論じた関数の
アプリケーションは「おそらく適格な（possible well-formedness (``pos'') ）型の」チェック \index{posがた@pos型}
は通っても「明確に適格な（definite well-formedness (``def'') ）型の」チェック \index{defがた@def型}
は通らないことになる：``def''型チェックはランタイムエラーの潜在的な原因となるものを特定するからである。

``def''型チェック \index{defがた@def型} は潜在的にランタイムエラーが起こりうる箇所をすべて特定する。
これらは事前条件のある関数（事前条件はアプリケーションのその関数が呼ばれる前に
満たされていなければならない）を持つアプリケーションやVDMへ直接ビルトされる一部の
演算子（例.\ 除算演算子は2番目の引数が0だとランタイムエラーを起こす）を含む
アプリケーションを含み、同様に定義にサブタイプを使ったことから来る潜在的な不整合をも含む。

一般的に、``def''型のチェックは``pos''型のチェックよりエラーメッセージが多くなる。
そのため仕様書をチェックするときはまず型がおそらく正しくない箇所を扱うため``pos'タイプの
チェックを行い、それからランタイムエラーの原因となる潜在的な箇所を特定する目的で``def''型
チェックを行うことをお勧めする。多くのケースで、これら
例えば、表記が``if \ldots then \ldots else \ldots'' 式の内にあるせいで、ランタイムエラーの条件が発生
するのを阻害する状態になっている箇所などを考慮外にすることができるだろう。
その他のケースとしては、``def''型のチェックは仕様書の修正による防備を導入したいために
状態を特定することができる。

型チェック機能はGUIからでも\Toolbox\ のコマンドラインからでも、Emacsインターフェースからでもアクセス可能である。
#endif JPN


#ifdef ENG
\subsubsection{The graphical user interface}
#endif ENG
#ifdef JPN
\subsubsection{GUI}
#endif JPN

#ifdef ENG
In order to invoke the type checker from the graphical user interface
select the files or classes (more than one, if you wish) to be checked
or rechecked in the \guicmd{Project View} or the \vdmModView\ of
the \guicmd{Manager} as appropriate, then press the 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{typecheck.png}} 
(\guicmd{Type Check})
button on the (\guicmd{Actions})
toolbar. The \guicmd{Log Window} opens
automatically (if it is not already open) and displays information
about the checking process for each selected file or class in turn. If
type errors\index{Type Errors} are discovered, the \guicmd{Error
List}\index{Error List} and the \guicmd{Source Window} are also 
au\-to\-matically invoked. 
\ifthenelse{\boolean{VDMsl}}{}{Note
that since the \Toolbox\ knows the dependencies between all classes,
all the super classes of the selected classes will also be type
checked.}
#endif ENG

#ifdef JPN
GUIで型チェック機能を起動するには、\guicmd{マネージャー} の\guicmd{プロジェクトビュー} または\vdmModView\ で
チェックしたいファイルまたはクラスを選択し、(\guicmd{アクション})ツールバーの
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{typecheck.png}} 
(\guicmd{型チェック})ボタンを押す。
\guicmd{ログウインドウ} が自動的に開き、選択されたファイル
\ifthenelse{\boolean{VDMsl}}{}{やクラス}それぞれについてチェックの進行状況に
ついての情報を順番に表示する。型エラー\index{かたエラー@型エラー} が発見されると
\guicmd{エラー一覧}\index{エラーリスト}と\guicmd{ソースウインドウ} が自動的
に起動される。
\ifthenelse{\boolean{VDMsl}}{}{\Toolbox\ はクラス間の依存関係をすべて把握しているため、
選択されたクラスのスーパークラスもすべて型チェックされる。}
#endif JPN

#ifdef ENG
\subsubsubsection{Setting options}
#endif ENG
#ifdef JPN
\subsubsubsection{オプション設定}
#endif JPN

#ifdef ENG
The choice between checking for possible \index{Possible Well-formedness} or definite type \index{Definite Well-formedness} 
well-formedness is 
made in the \guicmd{Type checker} pane of the \guicmd{Project Options} window,
which is displayed by pressing the
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{projectoptions.png}}
(\guicmd{Project Options}) button on the (\guicmd{Project Operations})
toolbar. This is shown in Figure~\ref{fig:opttc}. Either ``pos'' type
checking or ``def'' type checking will always be enabled. The default
is possible well-formedness checking.
#endif ENG

#ifdef JPN
``pos''型チェック \index{posがた@pos型} または``def''型チェック \index{defがた@def型} 
のどちらの適格性チェックをするかは\guicmd{プロジェクトオプション} ウインドウの
\guicmd{型チェック}タブで(\guicmd{プロジェクト})ツールバー上の 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{projectoptions.png}}
(\guicmd{プロジェクトオプション}) ボタンを押すとできる。
これを図~\ref{fig:opttc}に示す。``pos''型の``def''型どちらもいつでも利用可能である。
デフォルトは``pos''型の適格性チェックが有効になっている。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12cm]{tcOptions-sl.png}
#endif VDMSL
#ifdef PPONLY
\includegraphics[width=12cm]{tcOptions-pp.png}
#endif PPONLY
#ifdef VICEMAN
\includegraphics[width=12cm]{tcOptions-vice.png}
#endif VICEMAN
#ifdef ENG
\caption{Setting Type Checker Options}
#endif ENG
#ifdef JPN
\caption{型チェック機能のオプション設定}
#endif JPN
\label{fig:opttc}
\index{Options!Type Checker}
\end{center}
\end{figure}

#ifdef ENG
Two further options are also offered:
#endif ENG
#ifdef JPN
以下2つのオプションも提供されている。
#endif JPN

\begin{list}{}{}
#ifdef ENG
\item[{\sf Extended type check}:] If enabled, a number of additional
  warnings such as ``Result of `conc' can be an empty sequence'' will
  be included when type checking. \\
  default: disabled.

\item[\textsf{Warning/error message separation}:] If enabled,
  separates error messages and warnings from the type checker when
  they are displayed in the \guicmd{Error List}: error messages are
  displayed before warnings.\\
  default: enabled. 
#endif ENG

#ifdef JPN
\item[{\sf 拡張型チェック}:]  有効になった場合、“Result of ‘conc’ 
  can be an empty sequence”などの追加ワーニングが型チェックの際にたくさん出る。\\
  デフォルト: 無効。

\item[\textsf{ワーニング/エラーメッセージ分離}:] 有効になった場合、エラー一覧に表示する
  際に型チェック機能の出すエラーメッセージとワーニングを分ける。エラーメッセージはワーニングの
  前に表示される。\\
  デフォルト: 有効。
 % JSF: This extended type checking must be described fully somewhere
#endif JPN
\end{list}


#ifdef ENG
\subsubsection{Format of type errors and warnings}\label{subsub:tcerr}
#endif ENG
#ifdef JPN
\subsubsection{エラーおよびワーニングのフォーマット}\label{subsub:tcerr}
#endif JPN

#ifdef ENG
All warnings provided by the type checker are textual descriptions
explaining what the potential problem is. Some errors such as unknown
identifiers are also simply textual. However, the majority of type
errors are structured into three lines, in which the first line gives
a textual explanation about what the problem is, the second line gives
the actual type inferred by the type checker (identified by the keyword
\texttt{act:}), and the third line gives the type expected by the type
checker (identified by the keyword \texttt{exp:}). The syntax for these
type descriptions is almost identical to the normal \vdmslpp\ type syntax
with the following exceptions:
#endif ENG

#ifdef JPN
型チェック機能の吐き出すすべてのワーニングは潜在的な問題は何かという説明のテキスト
記述である。未定義の識別子なども同様に単純なテキスト形式である。しかし、
型エラーの大半は3行で構成され、1行目では問題についてのテキストの説明、
2行目は型チェック機能が推測する実際の型（\texttt{act:}というキーワードで特定される）3行目は
型チェック機能が予想する型（\texttt{exp:}というキーワードで特定される）である。これらの型の
記述についての構文はほぼ通常の\vdmslpp\ の型の構文と同様である。（下記は例外）
#endif JPN

\begin{itemize}
#ifdef ENG
\item {\tt seq of A } is represented as {\tt seq1 of A | []}, where
  {\tt []} is the type for an empty sequence.
  
\item {\tt map A to B } is represented as {\tt map A to B | \{|->\}},
  where {\tt \{|->\}} is the type for an empty map.
  
\item {\tt set of A } is represented as {\tt set of A | \{\}}, where
  {\tt \{\}} is the type for an empty set.
  
\item {\tt [A]} is represented as {\tt A | nil}.
  
\item {\tt \#} stands for any type. The type checker typically infers
  this type if it cannot infer anything better in an error situation.
#endif ENG

#ifdef JPN
\item {\tt seq of A }  {\tt seq1 of A | []} と同じ意味。 {\tt []} は空シーケンスの型。
  
\item {\tt map A to B } {\tt map A to B | \{|->\}}と同じ意味。{\tt \{|->\}} は空マップの型。 
  
\item {\tt set of A } {\tt set of A | \{\}}と同じ意味。 {\tt \{\}} は空セットの型。
  
\item {\tt [A]}  {\tt A | nil}と同じ意味。
  
\item {\tt \#} はどんな型の代わりにもなる。型チェック機能はエラーの状況では
  他に何も思い当たらない場合は、この型を推測に当てはめる
#endif JPN
\end{itemize}

#ifdef ENG
Examples of type errors can be found in Section~\ref{sec:gde-tc}.
#endif ENG
#ifdef JPN
型エラーの例はセクション~\ref{sec:gde-tc}に記述されている。
#endif JPN

#ifdef ENG
\subsubsubsection{Understanding errors from ``def'' type check} \index{Definite Well-formedness}
#endif ENG
#ifdef JPN
\subsubsubsection{``def''型チェックで考えられるエラー} \index{defがた@def型}
#endif JPN

#ifdef ENG
Recall that the ``def'' check produces an error report wherever it is not
possible to guarantee that an expression will always be of the correct type. 
In order to understand some of the warning and error messages
generated during a check for definite well-formedness, it can often be
helpful to  insert the word `DEFINITELY' in the error message
implicitly. Thus, for example, if the message

{\tt Error : Pattern in Let-Be-expression cannot match}

is returned in a check for definite well-formedness you should read it as

{\tt Error : Pattern in Let-Be-expression cannot DEFINITELY match}

i.e.\ that there could be values for which the pattern may not match.
When the type checker reports an error, it will often display which
type it inferred and which type it expected at a given point. This can
be valuable when trying to find out what is wrong.
#endif ENG

#ifdef JPN
式がいつも正しい型であると保証することができない箇所はどこでも、`def'' チェックを実行することで
エラーレポートを作り出すことができる。`def''タイプの適格性チェックをすることで出てきたワーニングや
エラーのうちいくつかを理解するために、`DEFINITELY'（明確に）という言葉をエラーメッセージに暗に
挿入してみるとよい。例えば、メッセージ

{\tt Error : Pattern in Let-Be-expression cannot match}

が`def''チェックで帰ってきたとすると、これを以下のように読んでみる。

{\tt Error : Pattern in Let-Be-expression cannot DEFINITELY match}

すなわち、 パターンにマッチしない値をとりうる。型チェック機能がエラーを報告するときは、
その位置に推測される型と予想される型を表示する。これは何がいけないのかを見つけるには有効である。
#endif JPN

#ifdef ENG
\subsubsection{The command line interface}
\index{Command Line Interface!Type Checker}
#endif ENG
#ifdef JPN
\subsubsection{コマンドラインインターフェース} 
\index{コマンドラインインターフェース!かたチェッカー@型チェック機能}
#endif JPN

{\tt \vdmde\ -t [-df] specfile(s) ...}

\vspace{0.5cm}

\noindent
#ifdef ENG
With the {\tt -t} option {\tt \vdmde} type checks the {\tt
  specfile(s)}.  First, the specification is parsed. Then, if no syntax
errors are detected, the specification is type checked (the default
is to check for possible well-formedness). Type errors are reported to
{\aaa stderr}.

The additional options which can be used with the type checker are:
#endif ENG

#ifdef JPN
{\tt -t} オプションを使うと{\tt \vdmde}コマンドは{\tt specfile(s)}の型チェックを行う。まず、仕様書が解析される。
それから構文エラーが見つからなければ、仕様書の型チェック（デフォルトは'pos''タイプの
適格性チェック）がなされたことになる。型のエラーは{\aaa stderr}に報告される。

その他の型チェック機能の追加オプションは下記のとおり:
#endif JPN

\begin{description}
#ifdef ENG
\item[{\tt -d}] Causes the type checker to check for definite
  well-formedness.  The difference between possible and definite
  well-formedness is described in the language reference manual
  (\ifthenelse{\boolean{VDMsl}}{\cite{UMLMan-CSK}}{\cite{LangManPP-CSK}}). In 
  short the check for definite well-formedness returns the
  type-related proof obligations.
  
\item[{\tt -f}] Causes the type checker to perform an extended type
  check.  This will give some extra warning and error messages for
  both possible and definite well-formedness checks such as ``Result
  of `conc' can be an empty sequence''.
#endif ENG

#ifdef JPN
\item[{\tt -d}]
  'def''タイプの適格性チェックを実行する。'pos''と'def''タイプの適格性チェックの違いについては、
  言語マニュアルに記載されている。(\ifthenelse{\boolean{VDMsl}}{\cite{UMLMan-CSK}}{\cite{LangManPP-CSK}})。
  端的に言うと'def''タイプの適格性チェックは型に関する立証の義務を返す
  
\item[{\tt -f}]
  拡張された型チェックを実行する。`pos'' `def''どちらの適格性チェックであっても``Result of `conc' 
  can be an empty sequence''のようないくらか多くのワーニングとエラーメッセージが出る。
#endif JPN
\end{description}

#ifdef ENG
\subsubsection{The Emacs interface}
#endif ENG
#ifdef JPN
\subsubsection{Emacsインターフェース}
#endif JPN

#ifdef ENG
In the Emacs interface all commands are given at the command prompt.
Type checking is performed by the \textbf{typecheck} command and
traversing the warnings and type errors is done using the
\textbf{first}, \textbf{last}, \textbf{next} and \textbf{previous}
commands, as for syntax errors. The location of the errors is
shown in the specification window. The extended type check option for
the type checker can be enabled using the \textbf{set} command and
disabled using the \textbf{unset} command. In more detail, the
available commands are as follows:
#endif ENG

#ifdef JPN
Emacsインターフェースではすべてのコマンドをプロンプトから入力する。型チェックは
 \textbf{typecheck}コマンドで実行され、ワーニングと型エラーを詳細に見るには構文エラーと
同様 \textbf{first},  \textbf{last},  \textbf{next} ,  \textbf{previous} コマンドを使う。エラーの箇所は
specificationウインドウで示される。拡張された型チェックのオプションは \textbf{set}コマンドで有効にでき、
 \textbf{unset}コマンドで無効にすることができる。詳しくは下記に利用可能なコマンドを記述する。
#endif JPN

\begin{description}  
#ifdef ENG
\item[typecheck (tc) \ifthenelse{\boolean{VDMsl}}{{[}{\tt
      module}{]}}{{\tt class}} {\tt option}]\index{typecheck command}\mbox{}\\ 
  This command makes a static type check of the given
  \ifthenelse{\boolean{VDMsl}}{module.  If no module is supplied the
    current module is checked}{class}.
  (``{\tt *}'' is used to do \ifthenelse{\boolean{VDMsl}}{module}{class} all current directories in type check.)
  The {\tt option} can be either {\tt pos} or {\tt def}, indicating whether the
  specification should be checked for possible or definite
  well-formedness.

  If a type error occurs it is reported, with position
  information, in the specification window.

\item[first (f)] \index{first command}\mbox{}\\
  This command displays the position of the first recorded error or
  warning message from the syntax checker, type checker, code
  generator or pretty printer.

\item[last] \index{last command}\mbox{}\\
  This command displays the position of the last recorded error or
  warning message from the syntax checker, type checker, code
  generator or pretty printer.

\item[next (n) \index{next command}]\mbox{}\\
  This command moves the current position to the next recorded error
  or warning message in the source file window.  It is used to
  display error or warning messages from the syntax checker, type
  checker, code generator or pretty printer.

\item[previous (pr)] \index{previous command}\mbox{}\\
  This command moves the current position to the previous recorded
  error or warning message in the source file window. It is also used to
  display error or warning messages from the syntax checker, type
  checker, code generator or pretty printer.

\item[set full]\index{set command}\index{set full command}\mbox{}\\
  The command {\tt set} enables setting of the internal options of the
  \Toolbox.  If the command is called without parameters it displays
  the current settings.
  \begin{description}
    \item[{\tt full}] enables extended type checks. This option has
      effect for both possible and definite well-formedness checks. By
      default this option is disabled.
  \end{description}
% JSF: should probably give a full list of options here.
\item[unset full]\index{unset full command}\mbox{}\\
  Disables the extended type checks.
#endif ENG

#ifdef JPN
\item[typecheck (tc) \ifthenelse{\boolean{VDMsl}}{{[}{\tt
      module}{]}}{{\tt class}} {\tt option}]\index{typecheckコマンド}\mbox{}\\ 
  与えられた\ifthenelse{\boolean{VDMsl}}{モジュール(モジュールが提供されていない場合は現在の
  モジュールがチェックされる)}{クラス}の静的型チェックを行う。
  （カレントディレクトリの全\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}を型チェックするには、``{\tt *}'' 記号を用いる）
  {\tt option}は{\tt pos} または{\tt def}であり
  これは仕様書がposタイプまたはdefタイプのどちらで適格性をチェックするかを表す。

  型エラーが起こって報告されると、specificationウインドウに情報が表示される。

\item[first (f)] \index{firstコマンド}\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  からなど最初に記録されたエラーまたはワーニングメッセージを表示する。

\item[last] \index{lastコマンド}\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  などから最後に記録されたエラーまたはワーニングメッセージを表示する。

\item[next (n) \index{nextコマンド}]\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  などからソースファイルウインドウの次の位置に記録されたエラーまたはワーニングメッセージを表示する

\item[previous (pr)] \index{previousコマンド}\mbox{}\\
  構文チェック機能、型チェック機能、コード生成、清書機能
  などからソースファイルウインドウの前の位置に記録されたエラーまたはワーニングメッセージを表示する

\item[set full]\index{setコマンド}\index{set fullコマンド}\mbox{}\\
\Toolbox\ の内部オプションをすべて有効にする。パラメータなしで実行されると
現在の設定を表示する。
  \begin{description}
    \item[{\tt full}]は拡張された型チェックを有効にする。このオプションは
      posタイプ・defタイプどちらの適格性チェックにも有効である。デフォルトは無効。
  \end{description}
% JSF: should probably give a full list of options here.
\item[unset full]\index{unset fullコマンド}\mbox{}\\
  拡張された型チェックを無効にする
#endif JPN
\end{description}

\newpage
#ifdef ENG
\subsection{The Interpreter and Debugger}\label{sec:interpreter}
#endif ENG
#ifdef JPN
\subsection{インタープリタとデバッガ}\label{sec:interpreter}
#endif JPN

#ifdef ENG
The interpreter and debugger enable execution of \vdmslpp\ 
specifications. It is not necessary to have type checked any
\ifthenelse{\boolean{VDMsl}}{modules}{classes} before the interpreter
can be used (but naturally more run-time errors are likely to occur
when a specification is not type correct). The interpreter/debugger
can be accessed from either the GUI, the command line
interface or the Emacs interface.

The only \vdmslpp\ constructs that cannot be executed are implicitly
defined functions and operations,\index{Functions!Implicit} 
\ifthenelse{\boolean{VDMsl}}{}{specification statements,}  type
bindings, and expressions conforming to the restrictions that our
modelling of the \vdmslpp\ three-valued logic
impose. \ifthenelse{\boolean{VDMsl}}{}{Support for the concurrency 
and real-time parts of \vdmslpp\ is also not yet available within the
interpreter.} These constructs are described further in
\ifthenelse{\boolean{VDMsl}}{\cite{UMLMan-CSK}}{\cite{LangManPP-CSK}}.
#endif ENG

#ifdef JPN
インタープリタとデバッガは\vdmslpp\ の仕様書の実行を可能にする。かならずしもインタープリタを
使う前にすべての\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} の型チェックをする必要はない
（が仕様書の型が正しくないとよりランタイムエラーが起こりやすくなる）。
インタープリタ・デバッガはGUI、コマンドライン、Emacsいずれのインターフェースを使ってもアクセス可能である。

\vdmslpp\ の構成物で実行できないものは、陰関数や陰操作\index{かんすう@関数!あんもく@暗黙} 、
\ifthenelse{\boolean{VDMsl}}{}{仕様の記述 、}型の縛り、モデリングに\vdmslpp\ の3値論理を課す制約に従った式
である。\ifthenelse{\boolean{VDMsl}}{}{\vdmslpp\ の平行性とリアルタイム部分も、インタープリタではまだ利用できない。}
#endif JPN

#ifdef ENG
\subsubsection{The graphical user interface}\label{sec:interp-gui}
#endif ENG
#ifdef JPN
\subsubsection{GUI}\label{sec:interp-gui}
#endif JPN

#ifdef ENG
The \guicmd{Interpreter Window}\index{Interpreter Window} can be
opened/closed by pressing the  
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{interpreter.png}}  
(\guicmd{Interpreter}) button on the (\guicmd{Window Operations})
toolbar or by selecting the corresponding item from the
\guicmd{Windows} menu.

The top two panes of the tool are respectively the
\guicmd{Response} and \guicmd{Dialog} panes: you
can give commands directly to the \guicmd{Interpreter} in the
\guicmd{Dialog} pane and you receive output from the
interpreter in the \guicmd{Response} pane. To evaluate a \vdmslpp\
expression, you type it directly on the command line in the
\guicmd{Dialog} pane.

The two panes at the bottom of the tool are the \guicmd{Trace} and the
\guicmd{Breakpoints} panes. The first of these shows the
function/operation call stack\index{Call stack} which logs the various
function/operation calls made as well as the actual parameters to
each of those calls. The parameters are generally elided by default
and just appear in the form \Sig{...}. They can be revealed  by
clicking the left mouse button on the \Sig{...}. Clicking the left
mouse button on the revealed parameters will replace them with
\Sig{...} again.

% The start of an execution is
%   identified by inverse video such that it is possible to see where
%   nested debugging is used.

The \guicmd{Breakpoints} pane shows a list of the locations of all the
current breakpoints together with their status, which may be
\guicmd{enabled} (indicated by a \raisebox{0.5mm}{{\fbox{\tt\tiny
      $\surd$}}}\ to the left of the function/operation name) or
\guicmd{disabled} (indicated by a
\raisebox{1mm}{{\fbox{\rule[-0.75mm]{0mm}{1.5mm}{\hspace*{1.5mm}}}}}\
to the left of the function/operation name). The buttons at the top of
the pane respectively enable\index{Breakpoints!Enabling},
disable\index{Breakpoints!Disabling}, or
delete\index{Breakpoints!Deleting} the breakpoints currently selected
in this list.

The \guicmd{Interpreter} menu and toolbar offer a range of
operations which can be applied in the
interpreter:\index{Interpreter!Commands}
#endif ENG

#ifdef JPN
\guicmd{実行ウインドウ}\index{インタープリタウィンドウ} は(\guicmd{ウインドウ})ツールバーの
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{interpreter.png}}  
(\guicmd{実行}) ボタンを
押すことで開いたり閉じたり出来る。\guicmd{ウインドウ} メニューから同様の機能を選択することでも
起動が可能である。

このツールには画面が2つある。それぞれ\guicmd{Response}画面と\guicmd{Dialog} 画面である：
\guicmd{Dialog} 画面からは\guicmd{インタープリタ} に直接コマンドを入力することが出来、その結果を
\guicmd{Response}画面で見ることが出来る。\vdmslpp\ の式を評価するには、\guicmd{Dialog} 画面から
コマンドラインで直接入力する。

ツールの下2つの画面は\guicmd{追跡} 画面と\guicmd{ブレイクポイント} 画面である。
\guicmd{追跡}画面は実際の引数を伴った関数のコールスタック\index{コールスタック}を表示する。
引数は一般的にデフォルトでは省略され、ただ\Sig{...}と表示されるだけである。
\Sig{...}表示の上でマウスの左ボタンをクリックすると詳細を見ることが出来る。
再度左ボタンをクリックするとまた\Sig{...}表示に戻る。

% The start of an execution is
%   identified by inverse video such that it is possible to see where
%   nested debugging is used.

\guicmd{ブレイクポイント} 画面は現在のブレイクポイントの位置と状態を表示するが、それぞれ関数名の左側に
\guicmd{有効化} (\raisebox{0.5mm}{{\fbox{\tt\tiny
      $\surd$}}}\ と表示) または
\guicmd{無効化} (
\raisebox{1mm}{{\fbox{\rule[-0.75mm]{0mm}{1.5mm}{\hspace*{1.5mm}}}}}と表示)となる。
画面上部のボタンはそれぞれ現在リスト中で選択しているブレイクポイントの有効化\index{ブレイクポイント!ゆうこう@有効}、
無効化\index{ブレイクポイント!むこう@無効}、
削除\index{ブレイクポイント!さくじょ@削除} にあたる。

\guicmd{実行}メニューとツールバーはインタープリタでできるさまざまな操作を提供している。
\index{インタープリタ!コマンド}
#endif JPN

\begin{description}
#ifdef ENG
\item[\guicmd{Init} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{runI.png}}):]
\index{Interpreter!Initialising}
Initialise the specification. This means that all the
  global values and \ifthenelse{\boolean{VDMsl}}{states}{instance
variables} are initialised. Initialisation of the interpreter must be
made first to enable use of the definitions which have been syntax checked.

\item[\guicmd{Step} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stepI.png}}):] 
Execute the next statement, without stepping into
  function and operation calls,
  and then break. This button is not useful with functions because it
  evaluates the entire body expression.
  
\item[\guicmd{Step In} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stepintoI.png}}):] 
Execute the next expression or statement, including
  stepping into function and operation calls, and then
  break.
  
\item[\guicmd{Single Step} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{singlestepI.png}}):] 
Execute the next subexpression or substatement, without
  stepping into function and operation calls, and then
  break.

\item[\guicmd{Continue} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{continueI.png}}):] 
Use this to continue execution after a
  breakpoint until the next breakpoint or the end of the
  expression/statement evaluation is reached.
  
\item[\guicmd{Finish} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stopI.png}}):] 
Finish the evaluation of the current function
  or operation and return to the caller. The command is traditionally
  used together with {\tt Step In}.
  
\item[\guicmd{Up} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{upI.png}}):] 
This command can only be called after the
specification has been initialised and the debugger has stopped at a
breakpoint. It has the effect that the current context is shifted one
level up compared to the place currently shown in the display
window. Thus, the context is changed to the place in the current
function trace where the current function/operation was called.

\item[\guicmd{Down} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{downI.png}}):]
This command can only be called after the specification has been
initialised and the debugger has stopped at a breakpoint. It has the
effect that the current context is shifted one level down compared to
the place currently shown in the display window. Thus, the context is
changed to the place in the current function trace where the current
function/operation called its sub-function/operation.

\item[\guicmd{Stop} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{pauseI.png}}):] 
Stop the evaluation of an
  expression. Access to local and global variables depends on whether
  the button has been pressed within a \guicmd{print} or a
  \guicmd{debug} command~(see the description of these commands below
  for a description of this). The command is traditionally
  used to break a possible infinite loop in one's specification.
#endif ENG

#ifdef JPN
\item[\guicmd{処理系を初期化} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{runI.png}}):]
\index{インタープリタ!しょきか@初期化}
仕様書の初期化をする。これによりグローバル変数と
\ifthenelse{\boolean{VDMsl}}{状態}{インスタンス変数} が初期化される。
インタープリタの初期化は構文チェック済みの定義の使用を可能にするため、最初に
なされなければならない。

\item[\guicmd{ステップ実行} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stepI.png}}):] 
  次の命令文を実行する。関数内部に入らず次の行でとまる。このボタンは記述の
  全体を評価するため関数にはさほど有用ではない。

\item[\guicmd{函数内をステップ実行} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stepintoI.png}}):] 
  次の式または命令文を実行する。関数内部に入ってとまる。
  
\item[\guicmd{1ステップ実行} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{singlestepI.png}}):] 
  次のサブ式またはサブ命令文を実行する。関数内には入らずにとまる。

\item[\guicmd{実行再開} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{continueI.png}}):] 
  次のブレイクポイントまで続けて実行したいときやまたは式や命令文の最後まで評価が到達したときに使用する。
  
\item[\guicmd{函数の実行を終了} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stopI.png}}):] 
  現在の関数や操作の評価を終了し、呼び出し元に戻る。このコマンドはもともと{\tt 函数内をステップ実行}とともに使われた。
  
\item[\guicmd{一段上の函数の呼び出し位置を表示} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{upI.png}}):] 
このコマンドは仕様書が初期化された後、デバッガがブレイクポイントでとまった
ときに使用が可能。現在ディスプレイウインドウに表示されている箇所に比べて
1レベル上にコンテキストをシフトする効果がある。このため、コンテキストは
現在の関数から呼び元の関数へと移る。

\item[\guicmd{一段下の函数の呼び出し位置を表示} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{downI.png}}):]
このコマンドは仕様書が初期化された後、デバッガがブレイクポイントでとまったときに
使用が可能。このコマンドは仕様書が初期化された後、デバッガがブレイクポイントで
とまったときに使用が可能。現在ディスプレイウインドウに表示されている箇所に比べて
1レベル下にコンテキストをシフトする効果がある。このため、コンテキストは現在の関数
から呼び先の関数へと移る。

\item[\guicmd{実行中断} (\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{pauseI.png}}):] 
  式の評価をStopする。ローカル変数やグローバル変数へのアクセスは\guicmd{print}や\guicmd{debug}コマンド
  （これらのコマンドの記述については下記を参照）内でこのボタンが押されたかどうかに依存する。
  このコマンドはもともと仕様書内の潜在的な無限ループをブレークするのに使用された。
#endif JPN
\end{description}

#ifdef ENG
\subsubsubsection{Commands available in the dialog pane}
#endif ENG
#ifdef JPN
\subsubsubsection{Dialog画面で利用できるコマンド}
#endif JPN

#ifdef ENG
In addition to the operations described above, commands to the
interpreter can be input directly by typing them in the
\guicmd{Dialog} pane. These are described below. However, a number of
these commands can only be executed after the interpreter has
been initialised (by pressing the
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{runI.png}}
(\guicmd{Init}) button).\index{Interpreter!Initialising}  These are
marked with a star ({\tt *}).

An expression can be evaluated using either the
\textbf{print}\index{print command} or the
\textbf{debug}\index{debug command} command.  The only difference
between the two commands 
is that {\bf debug} causes the interpreter to stop at breakpoints
whereas {\bf print} ignores breakpoints.\index{Breakpoints!Ignoring}

Breakpoints can be set using the \textbf{break} command\index{break command}
\index{Breakpoints!Setting} or by 
double-clicking on the desired position in the \guicmd{Display}
window\footnote{When the RTF format is used double-clicking does not
work. Instead one must press Ctrl-Alt-Spacebar on the line where one
wishes to break inside Microsoft Word.}.

When a break point is reached
it is possible to continue the execution using either the
\guicmd{Step}~(\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stepI.png}}),
\guicmd{Single Step}~(\hspace{-1.8mm} 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{singlestepI.png}}),
\guicmd{Step In}~(\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{upI.png}}),
\guicmd{Continue}~(\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{continueI.png}})
or \guicmd{Finish}~(\hspace{-1.8mm} 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stopI.png}})
buttons to proceed with the execution. Breakpoints can be deleted
using the \textbf{delete} command.\index{delete command}\index{Breakpoints!Deleting} 

#ifdef VDMPP
Objects can be created using the \textbf{create} command
\index{create command} and destroyed
using the \textbf{destroy} command\index{destroy command}. The
\textbf{objects} command\index{objects command} gives 
a list of the names of all the current objects.

There are also three commands relating to threads: the identifier of
the current thread (during an execution) can be obtained using the
\textbf{curthread} command\index{curthread command}; a list of all
the threads currently executing can be obtained using the
\textbf{threads} command\index{threads command}; and a 
different thread can be selected using the \textbf{selthread}
command\index{selthread command}.
#endif VDMPP

#ifdef VICEMAN
The default timing behaviour of the interpreter can be modified using
the \textbf{timefile} command, which reads a file containing timing
information and merges it with the interpreters default behaviour.
#endif VICEMAN

#ifdef VDMSL
The name of the ``current'' module (during an execution) can be
inspected using the \textbf{curmod} command.\index{curmod command} It is possible to push a 
new module on top of the stack of modules using the \textbf{push}
command.\index{push command} In the same way a module can be popped from the top of the
stack using the \textbf{pop} command.\index{pop command} The current stack of modules can
be inspected using the \textbf{stack} command.\index{stack command}
#endif VDMSL

In addition to these commands, which are explained in more detail below,
Section~\ref{subsec:maincommand} also contains a number of commands
which are useful in the \guicmd{Dialog} window.

The up-arrow and down-arrow keys can be used to scroll through
previous commands. Pressing enter in this history list will execute
the corresponding command.  If some characters have been written
before beginning to scroll through the history list only those
previous commands that start with these exact characters are shown.

Pressing enter without typing a new command executes the previous
command.
#endif ENG

#ifdef JPN
上記に記述された操作に加え、\guicmd{Dialog} 画面でこれらをタイプすることでインタープリタへ
コマンドを直接入力することができる。これらは下記に示される。しかし、これらのコマンド
のうち多くがインタープリタの初期化（\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{runI.png}}
(\guicmd{Init}) ボタンを押下することで可能）後でなければ実行できない。\index{インタープリタ!しょきか@初期化}
これらのコマンドには({\tt *})マークをつけてある。

\textbf{print}\index{printコマンド} または
\textbf{debug}\index{debugコマンド}コマンドを使って式の評価をすることができる。2つのコマンドの違いは、
{\bf debug}コマンドを使うとブレイクポイントでとまるのに対し、{\bf print}コマンドではとまらないことにある。
\index{ブレイクポイント!むし@無視}

ブレイクポイントは\textbf{break}コマンドまたは\guicmd{ソース}ウインドウにて希望する箇所をダブルクリックすると
設定できる \footnote{RTFフォーマットを使っている場合、ダブルクリックは使えない。その代わり、Microsoft Word内に
ブレイクポイントを設定したい場合、（ブレイクポイントを）設定したい箇所でCtrl-Alt-スペースを押すと設定できる。}。

ブレイクポイントに来ると、\guicmd{ステップ実行}~(\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stepI.png}}),
\guicmd{1ステップ実行}~(\hspace{-1.8mm} 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{singlestepI.png}}),
\guicmd{一段上の函数の呼び出し位置を表示}~(\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{upI.png}}),
\guicmd{実行再開}~(\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{continueI.png}}),
\guicmd{函数の実行を終了}~(\hspace{-1.8mm} 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{stopI.png}})などの
操作が可能になる。ブレイクポイントは\textbf{delete} コマンド.\index{deleteコマンド}
\index{ブレイクポイント!さくじょ@削除}で削除できる。

#ifdef VDMPP
\textbf{create}コマンド\index{createコマンド} を使うとオブジェクトを生成することが出来、
\textbf{destroy}コマンド\index{destroyコマンド}を使うとオブジェクトを
破棄することが出来る。\textbf{objects}コマンド\index{objectsコマンド} では
現在のオブジェクトの名前がリスト表示される。

スレッド関連のコマンドが3つある。現在（実行中）のスレッドは\textbf{curthread}コマンド\index{curthreadコマンド}で得られる。
現在実行中のスレッドの一覧を見るのは\textbf{threads}\index{threadsコマンド} コマンドで、違うスレッドの選択は
\textbf{selthread}\index{selthreadコマンド} コマンドでそれぞれ可能である。
#endif VDMPP

#ifdef VICEMAN
インタープリタのデフォルトのタイミング動作は、\textbf{timefile} コマンドで修正
することができる。このコマンドはタイミング情報を含むファイルを読み込み、インタープリタの
デフォルトの動作とマージする。
#endif VICEMAN

#ifdef VDMSL
  ``現在の''モジュール（実行中のもの）は\textbf{curmod}コマンド\index{curmodコマンド} 
  を使って詳細に見ることができる。\textbf{push}コマンド\index{pushコマンド} 
  を使うとモジュールスタックの先頭に新たなモジュールをpush
  することができる。同様に\textbf{pop} コマンド\index{popコマンド} 
  を使うとモジュールスタックの先頭にあるモジュールをpopすることができる。
  現在のモジュールスタックは\textbf{stack} command.\index{stackコマンド}で詳細に見ることができる。
  
#endif VDMSL

これらのコマンドに加えて、詳細は下記で説明されるが、セクション~\ref{subsec:maincommand}には
\guicmd{Dialog}画面で利用できるたくさんのコマンドが載っている。

上矢印キーと下矢印キーは、前に実行したコマンドの履歴をスクロールして見るのに使える。
この履歴リストでEnterキーを押すとそのコマンドを実行する。履歴をスクロールする前に文字入力が
あった場合は、履歴リストのうち入力した文字列で始まるコマンドのみを表示する。

新しいコマンドを入力せずにEnterキーを押すと直前のコマンドを実行する。
#endif JPN

\begin{description}

#ifdef ENG
\item[*break (b) \mbox{[{\tt name}]}] 
\index{break command}\index{Breakpoints!Setting}\mbox{}\\
  Sets a breakpoint at the function or
  operation with the given name.
  \ifthenelse{\boolean{VDMpp}}{The name must consist of
    the function/operation name qualified with the name of the class
    in which it is defined~(i.e.\ in the form {\tt
  ClassName`OperationName}).}{}

  When this command is evaluated a number is allocated for the new 
  breakpoint and this is shown in the \guicmd{Response} pane. The name
  and number of the new breakpoint are also added to the list of
  breakpoints in the \texttt{Breakpoints} pane.

  If called with no argument, it displays a list of all the currently 
  defined breakpoints.

\item[*break (b) \mbox{\texttt{name number} [\texttt{number}]}]\mbox{}\\
\index{break command}\index{Breakpoints!Setting}\mbox{}\\
 This sets a breakpoint on the line with the given number in the file
 with the given name. If a second number is given, this is 
 interpreted as the column at which the breakpoint should be set.

Note that if the source file is not an RTF file you can also set
breakpoints by double-clicking the left or middle mouse button on the
desired position in the file in the \guicmd{Source Window}. If you are
using an RTF source file you can similarly set a breakpoint by
positioning the cursor at the appropriate position in the file in
Microsoft Word, then pressing
\texttt{Control-Alt-spacebar}\index{Breakpoints!Setting in Microsoft
  Word}%
  \footnote{This works with versions of the VDM template,
  VDM.dot,\index{VDM.dot file} 
  distributed with Toolbox version \vdmtoolsver\
  and onwards.}.

#ifdef VDMSL
\item[curmod] \index{curmod command}\mbox{}\\
  When the specification is structured into modules, this command
  prints the name of the current module.
#endif VDMSL

#ifdef VDMPP
\item[*create (cr)] {\tt name := stmt}\index{create command}\mbox{}\\
  This command creates an object reference of name {\tt name}
  initially assigned to {\tt stmt}.  {\tt stmt} must be either a
  call statement referring to an object or a new statement. (See
  \cite{LangManPP-CSK} for an explanation of the different kinds of
  statements.)  Afterwards the object {\tt name} will be in the scope
  of the debugger.
  
\item[curthread]\index{curthread command}\mbox{}\\
  Prints the identifier of the thread currently being executed.
#endif VDMPP

\item[debug (d) {\tt expr}] \index{debug command} \mbox{}\\
  Evaluates and prints the value of the \vdmslpp\ expression {\tt
    expr}.  The execution will be stopped at all enabled breakpoints
  \index{Breakpoints} with the current position of the execution being
  displayed in the  \guicmd{Source Window} and the call stack being
  shown in the 
  \guicmd{Trace} pane. If a run-time error occurs, the
  execution is stopped in the context where the error occurred
  with the position of the error being displayed in the \guicmd{Source Window}
  window and the call stack being shown in the \guicmd{Trace}
  pane.
  
  When evaluating an expression in the interpreter you can use the 
  symbol {\tt \$\$}\index{\$\$} to refer to the result of the last
  evaluation. See the description of the {\tt print} command for more
  information.
  
  If the \guicmd{Stop} button is pressed during a
  debug\index{Interpreter!Stopping} 
  command the evaluation of the command is stopped at the expression
  or statement being evaluated when the button is pressed. All the
  variables within scope of that expression or statement can be
  accessed afterwards.
  
\item[*delete {\tt number, ...}] 
\index{delete command}\index{Breakpoints!Deleting}\mbox{}\\
  Deletes the breakpoint(s) with the given number(s). The breakpoints
  are also removed from the \texttt{Breakpoints} pane.
  
#ifdef VDMPP
\item[*destroy] {\tt name}\index{destroy command}\mbox{}\\
  Destroys the object with the given name.
#endif VDMPP

\item[*disable \texttt{number, ...}]
\index{disable command}\index{Breakpoints!Disabling}\mbox{}\\
  Disables the breakpoint(s) with the given number(s).
  
\item[*enable \texttt{number, ...}]
\index{enable command}\index{Breakpoints!Enabling}\mbox{}\\
  Enables the breakpoint(s) with the given number(s).
  
\item[init (i)] \index{init command}\mbox{}\\ Initialises
  the interpreter with all definitions from the specification. This
  includes initialising the
  \ifthenelse{\boolean{VDMsl}}{states}{instance variables} and all
  values. If a value is multiply defined this will be reported during
  this initialisation. The initialisation command will initialise all
  files read into the \Toolbox\ in the same session. Therefore it is
  not necessary to initialise each file separately after it has been
  read.
  
#ifdef VICEMAN
\item[*gettime]\index{gettime command}\mbox{}\\
  Returns the current time in the interpreter, as computed 
  on the basis of the time file and duration statements.
#endif VICEMAN

#ifdef VDMPP
\item[*objects] \index{objects command}\mbox{}\\
  Displays the objects created within the debugger.
#endif VDMPP

\item[*popd] \index{popd command}\mbox{}\\
  This command is used when nested debugging is taking place i.e.\ when
  an expression is debugged while already at a breakpoint in another
  evaluation. The effect of a 
  \textbf{popd} command is to restore the environment to that which
  existed when the last \textbf{debug} command was invoked.

\item[print (p) {\tt expr}, ...] \index{print command}\mbox{}\\
  Evaluates and prints the value of the \vdmslpp\ expression(s) {\tt
    expr} with all breakpoints disabled. If a run-time error occurs
  the execution stops and the position of the error is
  displayed in the \guicmd{Source Window}.
  
  In addition to the normal \vdmslpp\ values the {\tt print} command
  can also return the values {\tt FUNCTION\_VAL} and {\tt
    OPERATION\_VAL}\@.  This happens if the result of the evaluation is
  a function or an operation (for example if a function
  is evaluated just by giving the function name without supplying any
  parameters enclosed in parentheses).
  
  When evaluating an expression in the interpreter you can use the 
  symbol {\tt \$\$}\index{\$\$} to refer to the result of the last
  evaluation. This symbol is treated as an expression and can
  therefore be embedded in other \vdmslpp\ expressions as shown in
  the following examples:

\begin{quote}
\begin{verbatim}
vdm> p 10
10
vdm> p $$+$$, 2*$$
20
40
vdm> 
\end{verbatim}
\end{quote}

  If the \guicmd{Stop} button\index{Interpreter!Stopping}
  is pressed during a 
  print command the evaluation of the command is stopped. No variables
  can be accessed afterwards.
  
#ifdef VDMPP
\item[priorityfile (pf) \mbox{[{\tt filename ...}]}]
  \index{priorityfile command}\mbox{}\\
  If called with a valid filename, this reads the priority information
  from this file and uses it when scheduling threads if
  priority-based scheduling is enabled.

  If called with no argument it lists the current priority file being
  used by the interpreter.

  See Appendix~\ref{sec:priorityfile} for details of the required
  format for priority files.

\item[*push {\tt name}]\index{push command} \mbox{}\\
  The class {\tt name}\/ is pushed onto the modules stack and becomes
  the active class after initialisation.
  
\item[*pop] \index{pop command}\mbox{}\\
  The current class is popped off the stack. 
If there is no active class a warning is issued and
  nothing happens.
%\item[*popd] \index{popd command}\mbox{}\\
%  In case you have nested debuggings the {\tt popd}) command pops the
%  top-most debugging away. This can be very convenient if one is
%  debugging a large VDM model and then by mistake tries to print a
%  value that is misspelled. Then one can return to the previous
%  debugging session using the {\tt popd} command.\\

\item[selthread]\texttt{id}\index{selthread command}\mbox{}\\
  Sets the currently executing thread to be that with identifier
  \texttt{id}.
#endif VDMPP

#ifdef VICEMAN
\item[*timefile (tf) \mbox{[{\tt filename ...}]}] \index{timefile}\mbox{}\\
  If called with a valid filename, this reads the timing information
  from this file and merges it with the interpreter's default time
  map.

  If called with no argument it lists the current time map being
  used by the interpreter.
  
  See Section~\ref{sec:timefile} for details of the required
  format for time files.
#endif VICEMAN

#ifdef VDMPP
\item[threads]\index{threads command}\mbox{}\\
  Displays a list of the threads currently being executed in the
following format:

\begin{quote}
  $<$ \textit{thread id} $>$\ $<$ \textit{object ref} $>$\ $<$
\textit{status} $>$
\end{quote}

where \textit{thread id} is the unique identifier of the thread,
\textit{object ref} is the identifier of the object within which the
thread is defined (\texttt{none} if this is the thread of control
initiated by the interpreter), and \textit{status} is one of the
following:

\begin{tabular}{lp{10cm}}\hline
Status & Meaning \\ \hline
Blocked    & the thread is waiting for a permission predicate to
             become true. \\ 
Stopped    & the thread has stopped at a breakpoint.\\
Running    & the thread is currently being executed by the
interpreter. \\
Sleeping   & the thread can be
scheduled, but has actually not started running yet.\\
MaxReached & the maximum number of instructions per time slice has
              been reached by this thread. \\ \hline 
\end{tabular}
#endif VDMPP

#ifdef VDMSL
\item[*push {\tt name}]\index{push command} \mbox{}\\
  The module {\tt name}\/ is pushed onto the modules stack and becomes
  the active module after initialisation.
  
\item[*pop] \index{pop command}\mbox{}\\
  The current module ({\tt curmod}) is popped off the stack ({\tt
    stack}). If there is no active module a warning is issued and
  nothing happens.
  
\item[*popd] \index{popd command}\mbox{}\\
  This command is used when nested debugging is taking place i.e.\ when
  an expression is debugged while already at a breakpoint in another
  evaluation. The effect of a
  \textbf{popd} command is to restore the environment to that which
  existed when the last \textbf{debug} command was invoked.

\item[*stack]\index{stack command}\mbox{}\\
  Displays the names of the pushed modules.
#endif VDMSL

\item[tcov]\index{tcov command}\mbox{}\\
The test coverage command {\bf tcov} makes it possible to control 
the collection of test coverage information. It is used in combination 
with various keywords as follows:

\begin{description}
\item[tcov read \mbox{\texttt{filename}}] \index{tcov read command}\mbox{}\\ 
  Reads the test coverage information saved in the given file.
  
  Note that if you syntax check a file after reading in a test coverage 
  file the coverage information for that file will be reset and the test coverage
  information will be lost unless you  write the test coverage information
  before the file is syntax checked.
  Also be aware that the pretty printing function always uses the test coverage
  file that is specified in the specification file.

\item[tcov write \mbox{\texttt{filename}}] \index{tcov write command}\mbox{} \\ 
  Writes the existing test coverage information to the given file.
  
\item[tcov reset]\index{tcov reset command} \mbox{} \\
  Resets all test coverage information to zero.
  
\end{description}
#endif ENG

#ifdef JPN
\item[*break (b) \mbox{[{\tt name}]}] 
\index{break コマンド}\index{ブレイクポイント!せってい@設定}\mbox{}\\
  与えられた{\tt name}で指定した関数･操作の箇所にブレイクポイントを設定する。
\ifthenelse{\boolean{VDMpp}}%
{%
{\tt name}は定義されたクラス名で分類された関数･操作名で
構成されていなくてはならない。（クラス名`操作名）
}%
{%
}

  このコマンドが実行されると、新しいブレイクポイントに番号が割り当てられ、\guicmd{Response} 画面に
  表示される。新しいブレイクポイントの名前と番号が \texttt{ブレイクポイント} 画面のブレイクポイントの一覧に足される。

  引数なしで実行されると、現在設定されているブレイクポイントの一覧を表示する。

\item[*break (b) \mbox{\texttt{name number} [\texttt{number}]}]\mbox{}\\
\index{breakコマンド}\index{ブレイクポイント!せってい@設定}\mbox{}\\
 与えられたファイル名の、数字で与えられた行にブレイクポイントを設定する。
 2番目の引数（数）が与えられた場合、ブレイクポイントを設定する箇所として解釈される。

元のファイルがRTF形式でなかった場合、\guicmd{ソースウインドウ}でマウスの左ボタンをダブルクリックすることでも
ブレイクポイントが設定できる。
RTFフォーマットを使っている場合、Wordでファイルを開きカーソルを適切な箇所に当てて、
\texttt{Ctrl-Alt-スペース}\index{ブレイクポイント!Microsoft Wordのせってい@Microsoft Wordの設定}%
を押すと設定できる\footnote{ツールボックスのバージョン\vdmtoolsver\ 以降に割り当てられたVDMテンプレートの
バージョンVDM.dot\index{VDM.dotファイル} で動く}。 

#ifdef VDMSL
\item[curmod] \index{curmodコマンド}\mbox{}\\
  仕様書がモジュールで構成されている場合、現在のモジュール名を出力する。
#endif VDMSL

#ifdef VDMPP
\item[*create (cr)] {\tt name := stmt}\index{createコマンド}\mbox{}\\
  参照名{\tt name}でオブジェクトを生成し、まず{\tt stmt}に割り当てる。
  {\tt stmt}は、オブジェクトを参照する呼出し命令または新しい命令文（他の種類の命令文の説明については
  \cite{LangManPP-CSK}を参照のこと）。その後、{\tt name}オブジェクトはデバッガのスコープに置かれる。
  
\item[curthread]\index{curthreadコマンド}\mbox{}\\
  現在実行中のスレッドの識別子を出力する。
  
#endif VDMPP

\item[debug (d) {\tt expr}] \index{debugコマンド} \mbox{}\\
  \vdmslpp\ の式{\tt expr}の値を評価し、表示する。有効なブレイクポイント\index{ブレイクポイント} すべてで
  実行がとまるが、このとき現在実行中の箇所が\guicmd{ソースウインドウ} に、\guicmd{追跡} 画面に
  コールスタックが表示される。ランタイムエラーが起こると、エラーの起こった箇所で実行は止まり、
  エラーが\guicmd{ソースウインドウ} に、コールスタックが\guicmd{追跡} 画面に表示される。
  
  インタープリタ内の式を評価したい場合は、記号{\tt \$\$}\index{\$\$}を使って最後の評価の結果を参照する。
  詳細は下記{\tt print} コマンドの記載を参照。
  
  debugコマンド実行中に\guicmd{実行中断} ボタンが押されると\index{インタープリタ!ていし@停止} 、ボタンが押されたときに
  評価中だった式や命令文でコマンドの評価は中断される。その式や命令文のスコープ中にある変数はすべて
  後でアクセス可能である。
  
\item[*delete {\tt number, ...}] 
\index{deleteコマンド}\index{ブレイクポイント!さくじょ@削除}\mbox{}\\
  引数number(s)で指定したブレイクポイントを削除する。ブレイクポイントは\texttt{ブレイクポイント} 画面からも消える。
  
#ifdef VDMPP
\item[*destroy] {\tt name}\index{destroyコマンド}\mbox{}\\
  {\tt name}で指定したオブジェクトを破棄する。
#endif VDMPP

\item[*disable \texttt{number, ...}]
\index{disableコマンド}\index{ブレイクポイント!むこう@無効}\mbox{}\\
  \texttt{number}で指定したブレイクポイントを無効にする。

\item[*enable \texttt{number, ...}]
\index{enableコマンド}\index{ブレイクポイント!ゆうこう@有効}\mbox{}\\
  \texttt{number}で指定したブレイクポイントを有効にする。
  
\item[init (i)] \index{initコマンド}\mbox{}\\ Initialises
  インタープリタにある仕様書からのすべての定義を初期化する。%
  これは%
  \ifthenelse{\boolean{VDMsl}}{状態}{インスタンス変数} とすべての値の初期化も含む。%
  値が多重定義されていた場合は、%
  初期化の間に報告される。初期化コマンドは、同じセッションにあるツールボックスに読み%
  込まれているすべてのファイルを初期化する。そのため、読み込んであるファイルを個別に%
  初期化する必要はない。
  
#ifdef VICEMAN
\item[*gettime]\index{gettimeコマンド}\mbox{}\\
  インタープリタの現在時刻を返す。時刻ファイルとDurationの
  記述をもとにして計算したものとなる。
#endif VICEMAN

#ifdef VDMPP
\item[*objects] \index{objectsコマンド}\mbox{}\\
  デバッガ中で生成されているオブジェクトを表示する。
#endif VDMPP

%\item[*popd] \index{popdコマンド}\mbox{}\\
%  デバッグを入れ子にして行われているときに使われる。（ある式がデバッグ中、
%  ほかの評価でそのブレイクポイントが評価された）\textbf{popd}コマンドは、最後に
%  \textbf{debug}コマンドが起動されたときの環境に戻す効果がある。

\item[print (p) {\tt expr}, ...] \index{printコマンド}\mbox{}\\
  すべてのブレイクポイントを無効にして、 \vdmslpp\ の式{\tt expr}の値を評価し、表示する。
  ランタイムエラーが起こった場合、実行は止まりエラーの箇所が\guicmd{Source Window}に表示される。\\
  
  通常の\vdmslpp\ の値に加えて、{\tt print}コマンドは{\tt FUNCTION\_VAL}  と{\tt OPERATION\_VAL} も
  返すことができる。これは評価の結果が関数や操作になった場合（例：関数名だけ
  与えられていて、引数を与えられず（）で囲まれている関数が評価された場合）\\
  
  インタープリタで式を評価する場合、最後の評価の結果を参照するのに記号
   {\tt \$\$}\index{\$\$} を使うことができる。この記号は式として扱うことができ、
  下記の例に示すように他の\vdmslpp\ の式に組み込まれている。

\begin{quote}
\begin{verbatim}
vdm> p 10
10
vdm> p $$+$$, 2*$$
20
40
vdm> 
\end{verbatim}
\end{quote}

  printコマンド実行中に\guicmd{実行中断} ボタン\index{インタープリタ!ていし@停止}を押すと
  コマンドの評価は中断される。その後はどの変数にもアクセスできない。
  
#ifdef VDMPP
\item[priorityfile (pf) \mbox{[{\tt filename ...}]}]
  \index{priorityfileコマンド}\mbox{}\\
  有効なファイル名を指定した場合、指定したファイルからpriority情報を読み込んで
  スレッドのスケジューリングに利用する。（priorityスケジューリングが有効なとき）\\

  引数なしで実行された場合、現在インタープリタで使用されているpriorityファイルを一覧表示する。\\

  Priorityファイルのフォーマットの詳細については付録~\ref{sec:priorityfile}を参照のこと。

\item[*push {\tt name}]\index{pushコマンド} \mbox{}\\
  指定したクラス {\tt name} がモジュールスタックにプッシュされ、init後にアクティブなクラスになる。 

\item[*pop] \index{popコマンド}\mbox{}\\
  現在のクラスがスタックから取り出される。
  もしアクティブなクラスが存在しない場合、警告が発行され何も起きない。
  
\item[*popd] \index{popdコマンド}\mbox{}\\
  {\tt popd}コマンドは、デバッグを入れ子にした時に、最上位のデバッグを取り出す。
  これは、1つの大きなVDMモデルをデバッグしていて、スペルミスされた値をプリントしようとする時に、
  非常に便利である場合がある。
  そして、{\tt popd}コマンドを用いることで、1つ前のデバッグセクションまで戻ることができる。

\item[selthread]\texttt{id}\index{selthreadコマンド}\mbox{}\\
  \texttt{id}. \\
  現在実行中のスレッドを\texttt{id}に置き換える
#endif VDMPP

#ifdef VICEMAN
\item[*timefile (tf) \mbox{[{\tt filename ...}]}] \index{timeファイル}\mbox{}\\
  有効なファイル名が指定された場合、このコマンドは指定したファイルから
  タイミング情報を読み込み、インタープリタのデフォルト時刻マップにマージする。

  引数なしで実行された場合は、インタープリタに使用されている現在時刻のマップ
  を表示する。
  
  timeファイルに要求されるフォーマットの詳細については、セクション~\ref{sec:timefile}参照のこと。
#endif VICEMAN

#ifdef VDMPP
\item[threads]\index{threadsコマンド}\mbox{}\\
現在実行中のスレッドの一覧を下記のフォーマットで表示する。
\begin{quote}
  $<$ \textit{thread id} $>$\ $<$ \textit{object ref} $>$\ $<$
\textit{status} $>$
\end{quote}
\textit{thread id}はスレッドの識別子であり、ユニークな値である。
オブジェクトの参照はスレッドの定義中でのオブジェクトの識別子（インタープリタ主導で
コントロールされているスレッドの場合は\texttt{none} ）、\textit{status}は下記のうちいずれかである：

\begin{tabular}{lp{10cm}}\hline
状態 & 意味 \\ \hline
Blocked    & 実行許可待ち \\ 
Stopped    & ブレイクポイントでStop中.\\
Running    & インタープリタにより現在実行中. \\
MaxReached & このスレッドによりタイムスライス毎の命令の最大数に達した. \\ \hline 
\end{tabular}
#endif VDMPP

#ifdef VDMSL
\item[*push {\tt モジュール名}]\index{pushコマンド} \mbox{}\\
  指定した {\tt モジュール名} は、モジュールスタックにプッシュされ、init後にアクティブなモジュールになる。 
  
\item[*pop] \index{popコマンド}\mbox{}\\
  現在のモジュール({\tt curmod})スタック{\tt stack})からpopされる。アクティブモジュールが
  ない場合は、警告が発行され何も起こらない。
  
\item[*stack]\index{stackコマンド}\mbox{}\\
  Pushされたモジュール名を表示する。
#endif VDMSL

\item[tcov]\index{tcovコマンド}\mbox{}\\
テストカバレッジコマンド {\bf tcov} を使うと、テストカバレッジ情報の集積をコントロール
することができる。
次に示すさまざまなキーワードとの組み合わせで使われる。

\begin{description}
\item[tcov read \mbox{\texttt{filename}}] \index{tcov readコマンド}\mbox{}\\ 
  \texttt{filename}で示されるファイルに保存されているテストカバレッジ情報を読む。
  
  テストカバレッジファイルを呼んだ後に構文チェックをかけた場合、構文チェックをかけた
  ファイルのカバレッジ情報はリセットされ、構文チェックをする前にどこかへテストカバレッジ
  情報を書き出しておかない限り失われることに注意。pretty printing機能がいつも仕様書の
  ファイルから特定されるテストカバレッジファイルを参照していることにも注意が必要である。

\item[tcov write \mbox{\texttt{filename}}] \index{tcov writeコマンド}\mbox{} \\ 
  \texttt{filename}で指定されたファイルに存在するテストカバレッジ情報を書き込む
  
\item[tcov reset]\index{tcov resetコマンド} \mbox{} \\
  テストカバレッジ情報をリセットする
  
\end{description}
#endif JPN

\end{description}


#ifdef ENG
\subsubsubsection{Setting options}
#endif ENG
#ifdef JPN
\subsubsubsection{オプション設定}
#endif JPN


#ifdef ENG
The interpreter has a number of options which can be set in the 
\guicmd{Interpreter} pane of the \guicmd{Project Options} window (see
Figure~\ref{fig:optint}). These options are:
#endif ENG
#ifdef JPN
インタープリタには\guicmd{プロジェクトオプション}ウインドウの\guicmd{実行} 画面で指定できる
たくさんのオプションがある（図~\ref{fig:optint}参照）。以下に示すとおり：
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VICEMAN
\includegraphics[width=12.5cm]{interpreterOptions-vice.png}
#endif VICEMAN
#ifdef VDMSL
\includegraphics[width=12.5cm]{interpreterOptions-sl.png}
#endif VDMSL
#ifdef PPONLY
\includegraphics[width=12.5cm]{interpreterOptions-pp.png}
#endif PPONLY
#ifdef ENG
\caption{Setting Interpreter Options}
#endif ENG
#ifdef JPN
\caption{インタープリタのオプション設定}
#endif JPN
\label{fig:optint}
\index{Options:Interpreter}
\end{center}
\end{figure}

\begin{list}{}{}
#ifdef ENG
\item[{\sf Dynamic type check}:] If this check is enabled the
  type of expressions will be checked according to the definition
  given in the \vdmslpp\ specification whenever a type has been
  fixed. \\
  default: disabled.
  
\item[{\sf Dynamic checks of invariants}:] If this check is
  enabled, expressions will be checked against the invariant on their
  type whenever such an invariant exists. \\
  default: disabled.
  
\item[{\sf Check of pre-conditions}:]\index{Precondition Checking} If this check is enabled
  the precondition of every \ifthenelse{\boolean{VDMsl}}{function and
    operation}{function} which is evaluated will be checked before
  the \ifthenelse{\boolean{VDMsl}}{function or operation}{function} is
  called. \\
  default: disabled.
  
\item[{\sf Check of post-conditions}:]\index{Postcondition Checking}
  If this check is enabled 
  the postconditions of every function and operation which is
  evaluated will be checked after the function or operation has been
  evaluated. \\
  default: disabled.
  
\item[{\sf Pretty printing of values}:] Causes the pretty printer to
  use a nice, easy-to-read style for printing values in which line
  breaks and a homogeneous indentation are inserted. \\
  default: enabled.
  
\item[{\sf Initialise random generator with}:]
Initialises a random number generator with the given integer.  This
causes a random order of evaluation of substatements in
non-deterministic statement constructs.  The integer must be larger
than or equal to zero. A
negative number disables random evaluation of non-deterministic
statements. \\
default value: -1.

#ifdef VDMPP
\item[\textsf{Enable priority-based scheduling}:] enables use of
  priority-based scheduling instead of round-robin scheduling.\\
  default: disabled
  
\item[\textsf{Maximum instructions per time slice}:]
  sets the number of instructions per time slice to be the given
  integer (used for instruction number slice scheduling).\\
  default value: 1000.
  
\item[\textsf{Primary Scheduling Algorithm}:]
  Sets the primary scheduling algorithm to be either
  pure cooperative scheduling or instruction number slicing.\\
  default: Instruction number slicing.
#endif VDMPP
#endif ENG

#ifdef JPN
\item[{\guicmd{動的に型チェックする}}:]
  このチェックを有効にすると、型がすでに定着したものであっても、式の型が 
  \vdmslpp\ の仕様書に与えられた定義に沿ってチェックされる。 \\
  デフォルト：無効

\item[{\guicmd{不変条件をチェックする}}:]
  このチェックを有効にすると、式がそのような不変条件が存在するときはいつでも、型と照合する \\
  デフォルト：無効
  
\item[{\guicmd{事前条件をチェックする}}:]\index{じぜんじょうけんチェック@事前条件チェック}
  このチェックを有効にするとすべての関数の評価済み事前条件が関数呼び出しの前にチェックされる。 \\
  デフォルト：無効
  
\item[{\guicmd{事後条件をチェックする}}:]\index{じごじょうけんチェック@事後条件チェック}
  このチェックを有効にすると評価済みのすべての関数・操作の事後条件が、
  関数・操作の評価後にチェックされる。 \\
  デフォルト：無効
  
\item[{\guicmd{値を清書する}}:]
  清書機能によりよく、読みやすいスタイルを使わせるために改行やインデントを挿入する。
  
\item[{\guicmd{乱数発生初期値}}:]
与えられたInt値で乱数ジェネレータを初期化する。
これにより非決定性の命令文を構成するものにおいてサブ命令文の評価を
ランダムな順番で行うことができる。指定する数は0以上でなければならない。
負の数はランダムな非決定性の命令文の評価には使えない。 \\
デフォルトの値 ： -1

#ifdef VDMPP
\item[\guicmd{優先権スケジュールを有効にする}:]
  ラウンドロビンスケジューリングの代わりにプライオリティスケジューリングの使用を有効にする \\
  デフォルト：無効
  
\item[\guicmd{単位時間あたりの最大命令数}:]
  タイムスライスごとの命令の数を指定する。（スライススケジューリングの命令数に使う） \\
  デフォルトの値：1000\\
  
\item[\guicmd{主スケジュール方法}:]
  主なスケジューリングアルゴリズムを指定する。pure cooperative scheduling か 
  instruction number slicingのどちらか。 \\
  デフォルト：Instruction number slicing

#endif VDMPP
#endif JPN
\end{list}

#ifdef VICEMAN
\begin{figure}[tbh]
\begin{center}
\includegraphics[width=12.5cm]{viceOptions-vice.png}
#ifdef ENG
\caption{Setting VICE Specific Interpreter Options}
#endif ENG
#ifdef JPN
\caption{インタープリタのオプション設定}
#endif JPN
\label{fig:optintvice}
\index{Options!VICE}
\end{center}
\end{figure}

#ifdef ENG
In addition to these interpreter options there are additional options
specific to VICE. These can be set using the the 
\guicmd{VICE} pane of the \guicmd{Project Options} window (see
Figure~\ref{fig:optintvice}). These options are:
#endif ENG

#ifdef JPN
これらのインタプリタオプションに加えて、VICE特有の追加オプションがある。
これらは\guicmd{Project Options} ウィンドウの\guicmd{VICE} 
(図~\ref{fig:optintvice}参照)を使用してセットすることが出来る。
これらのオプションは以下に示す通り:
#endif JPN

\begin{list}{}{}
#ifdef ENG
\item[{\sf Step Size}:] This is an indication of how long steps
measured in time units each CPU is allowed to take before then next
CPU needs to have an opportinuty to proceed. This option only have an
effect when multiple CPUs are present in a VDM model. Since multiple
CPUs are simulated (and they advance their own time) this option is
used for indicate the granularity needed in the simulation. The lower
the number the shorter amounts of time units will each CPU be allowed
to proceed before the next CPU gets an opportunity. However, because
of the context switching inside the interpreter this also means that
the smaller then number the slower will the simulation be. Per default
this is set to 100 time units.

\item[{\sf Jitter Mode}:] When periodic threads are used different
strategies can be used with respect to the permitted amount of
jitter. The safest strategy is to use the default which is that
periodic threads are considered schedulable as {\sf early} as
possible. In this way it is unlikely that they will appear delayed
unless the processor is heavily loaded with work. The second
alternative that can be chosen is to use {\sf random} which will make
an arbitrary choice in the interval around the next periodic time
(indicated with the allowed jitter before and after). Finally the last
option is to make the periodic thread schedulable as {\sf late} as
possible, but this certainly have the list that delays will be likely
(in case the processor is already doing something else).

\item[{\sf Default CPU Capacity}:] This is the CPU capacity used for
processors where the CPU constructor has not been used to override the
CPU capacity. 

\item[{\sf Specify Virtual CPU Capacity}:] The environment (and the
debug thread starting in the interpreter will be executed on a virtual
CPU. Per default this is infinitely fast (unchecked box) but in case
the user wish the execution load of the environment to be taken into
account it is possible to check the box and set the capacity of of the
virtual processor to whatever desired. 

\item[{\sf Trace Logging}:] The traces being logged will per default
not include information about the arguments and the results from
operations being called. This is made because the trace files gets
bigger when this additional information is logged and the execution
will be slower. However, if desired it is possible to either log this
information for all operations or for selected ones. If this logging
is made it is possible to see these values in the trace files being
logged and the {\sf showtrace} tool is able to take this additional
information into account as well.
#endif ENG

#ifdef JPN
\item[{\sf ステップサイズ}:] 
これは、次のCPUが開始するための機会を必要とする前に、
それぞれのCPUに対して時間単位で測定されるステップがどれくらい取ることを許されるかという指示である。
このオプションは複数のCPUがVDMモデル内に存在するときだけ効果がある。
複数のCPUがシュミレーションされる(それらは自身の時間で進む)ので、
このオプションはシュミレーション内で必要とされる精度を表すために使用される。 
時間単位のより低い数、より少ない量においてそれぞれのCPUは次のCPUが機会を得る前に開始することが許されている。
しかしながら、インタープリタ内のコンテクスト切り替えのために、
これもより小さい数・より遅い数でシュミレーションすることを意味する。
デフォルトで、これは100時間単位でセットされる。

\item[{\sf 揺らぎ方}:] 周期スレッドが使用されるとき、許された揺らぎの量を考慮して
異なる方法で使用することが出来る。
最も安全な方法は、出来るだけ{\sf Early}スケジュール可能と考えられるデフォルトを使用することである。
この方法では、処理装置がより重い仕事を与えられなければ遅れが現れそうもない。
二つ目の選択可能な代替手段は、次の周期的な時間間隔をきまぐれな選択をする {\sf Random} を使用することである。
(前か後に許された揺らぎを示す)
最後のオプションは出来るだけ{\sf Late}スケジュール可能な周期スレッドを作ることである。
しかし、これは確かに遅れが起こりそうなリストを持っている。
(この場合、処理装置はすでに何か他のことを行っている)

\item[{\sf 未指定時のCPU処理能力}:] これは処理装置のために使用されるCPU容量である。
また、CPUコンストラクタはCPU容量をオーバーライドするために使用されない。

\item[{\sf 仮想CPUの処理能力を指定する}:] その環境(そして、インタープリタ内で始動するデバッグスレッド)は
仮想CPU上で実行されるだろう。
デフォルトではこれは無限に早い(チェックボックスがOFF)が、
この場合、ユーザは環境の実行負荷をアカウント内に取ることを望んでいる。
そのアカウントはチェックボックスをチェックし、要求するものは何でも仮想処理装置の容量をセットすることが可能である。

\item[{\sf 操作の引数の記録}:] デフォルトでは記録されたトレースは、呼び出した操作の引数と結果についての情報は含まない。
これが作成されるのは、追加情報が記録された時や、その実行がより遅くなる時にトレースファイルがより大きくなってしまうからである。
しかしながら、もし望むのであれば、全ての操作または選択されたもののどちらかの情報の記録をとることは可能である。
もし、このログを作成するならば、記録されたトレースファイルの値を見ることが可能である。
また、 {\sf showtrace} ツールはこの追加情報を考慮に入れることが出来る。
#endif JPN
\end{list}



%#ifdef JPN
%setオプションはVICE特有のものだということに注意。 \texttt{set}コマンドはインタープリタウインドウ
%で使用されなくてはならない。
%#endif JPN
#endif VICEMAN


#ifdef ENG
\subsubsection{Standard libraries}\label{subsec:standardlib}
#endif ENG
#ifdef JPN
\subsubsection{スタンダードライブラリ}\label{subsec:standardlib}
#endif JPN

#ifdef ENG
Currently there are three standard libraries: one for VDM utilities, 
one for maths and one
for input/output functionality.
#endif ENG
#ifdef JPN
現状、3つのスタンダードライブラリが存在する。VDMユーティリティとMathsとinput/output機能についてである。
#endif JPN

#ifdef ENG
\subsubsection*{The VDMUtil Library}
The interpreter provides a VDMUtil standard library. The functions and
values available and their concrete syntax are described in
\cite{LangMan-CSK}. To use this library the file
\ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}}{{\tt VDMUtil.vpp}} 
must be part of the project. 
The file is located in the \ifthenelse{\boolean{VDMsl}}{{\tt vdmhome/stdlib}}
{{\tt vpphome/stdlib}} directory.

The \ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}}{{\tt VDMUtil.vpp}} 
file contains a number of functions that are all defined as \keyw{is not yet specified}. 
In a general \vdmslpp\ specification such functions cannot be executed by the interpreter, 
but for these particular functions definitions
exist within the toolbox.  Thus, if you include the
\ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}}{{\tt VDMUtil.vpp}} 
file in you project these utility functions will be available with your specification.
#endif ENG

#ifdef JPN
\subsubsection*{VDMUtilライブラリ}
インタープリタはVDMUtilという標準ライブラリを提供する
\footnote{インタープリタ上でのみ使用が可能であり、コード生成には対応していない。}。
このライブラリに関する機能・利用可能な値・及びそれらの具体的な構文は\cite{LangMan-CSK}で説明される。
このライブラリを使うためには、
\ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}ファイルが}{{\tt VDMUtil.vpp}ファイルが}プロジェクトの一部でなければならない。
このファイルは、
\ifthenelse{\boolean{VDMsl}}{{\tt vdmhome/stdlib}}{{\tt vpphome/stdlib}}ディレクトリに配置されている。

\ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}}{{\tt VDMUtil.vpp}}ファイルには、
全てが \keyw{is not yet specified}で定義されたいくつかの関数が含まれている。
一般的な \vdmslpp 仕様では、\keyw{is not yet specified}で定義された関数を実行できないが、
これら特定の関数が実行できるための定義が \Toolbox に含まれている。
したがって、プロジェクトに追加したこれら
（\ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}}{{\tt VDMUtil.vpp}}ファイル）
のユーティリティが持つ機能は、記述した仕様中で利用可能となる。
#endif JPN

#ifdef ENG
\subsubsection*{The Maths Library}
#endif ENG
#ifdef JPN
\subsubsection*{Mathsライブラリ}
#endif JPN

#ifdef ENG
The interpreter provides a maths standard library. The functions and
values available and their concrete syntax are described in
\cite{LangMan-CSK}. To use this library the file
\ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} must be part of the
project. The file is located
in the \ifthenelse{\boolean{VDMsl}}{{\tt vdmhome/stdlib}}{{\tt
    vpphome/stdlib}} directory.

The \ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} file contains a number of
functions that are all defined as \keyw{is not yet specified}. In a
general \vdmslpp\ specification such functions cannot be executed by
the interpreter, but for these particular functions definitions
exist within the toolbox.  Thus, if you include the
\ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} file in you project these maths
functions will be available with your specification.
#endif ENG

#ifdef JPN
インタープリタはmathスタンダードライブラリを提供している。関数と値が
利用可能であり、具体的な構文については\cite{LangMan-CSK}.に記述されている。
このライブラリを利用するには、ファイル
\ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} 
がプロジェクトの一部になくてはならない。
このファイルは\ifthenelse{\boolean{VDMsl}}{{\tt vdmhome/stdlib}}{{\tt vpphome/stdlib}} ディレクトリに存在する。

\ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}}ファイルは
\keyw{is not yet specified}として定義されているさまざまな関数を含む。
一般的な \vdmslpp\ の仕様書ではそのような関数はインタープリタでは実行できないが、これらの
特定の関数定義はツールボックス内に存在する。
このため、\ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}}ファイルをプロジェクトにincludeすると、
仕様書内でmaths関数を利用することができる。
#endif JPN

#ifdef ENG
\subsubsection*{The IO Library}
#endif ENG
#ifdef JPN
\subsubsection*{IOライブラリ}
#endif JPN

#ifdef ENG
The interpreter provides an IO (input/output) standard library. The
functions and values available and their concrete syntax are described
in \cite{LangMan-CSK}. 
To use this library the file
\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}}
must be part of the project.
The file is located
in the \ifthenelse{\boolean{VDMsl}}{{\tt vdmhome/stdlib}}{{\tt
vpphome/stdlib}} directory.

The \ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}} 
file contains a number of functions that
are all defined as \keyw{is not yet specified}. In a general \vdmslpp\
specification such functions cannot be executed by the interpreter,
but for these particular functions definitions exist within the
toolbox.  Thus, if you include the \ifthenelse{\boolean{VDMsl}}{{\tt
io.vdm}}{{\tt io.vpp}} file in you
project these IO functions will be available with your
specification.
#endif ENG

#ifdef JPN
インタープリタはIO (input/output)のスタンダードライブラリを提供している。
関数と値が利用可能であり、具体的な構文については\cite{LangMan-CSK}.に記述されている。
このライブラリを使用するには、ファイル
\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}}
がプロジェクトの一部になくてはならない。
ファイルはvpphome/stdlibディレクトリに存在する。

\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}}ファイルは
\keyw{is not yet specified}として定義されているさまざまな関数を含む。
一般的な\vdmslpp\ の仕様書ではこのような関数はインタープリタにより実行することができないが、
これら特定の関数のための定義はツールボックス内に存在している。そのため、
\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}}ファイルをプロジェクトにincludeすると、
これらのIOの関数が仕様書上で利用可能になる。
#endif JPN

#ifdef ENG
\subsubsection{The command line interface}\label{subsec:intercom}
\index{Command Line Interface!Interpreter}\index{Command Line Interface!Debugger} 
#endif ENG
#ifdef JPN
\subsubsection{コマンドラインインターフェース}\label{subsec:intercom}
\index{コマンドラインインターフェース!インタープリタ}\index{コマンドラインインターフェース!デバッガ} 
#endif JPN

#ifdef ENG
The interpreter/debugger is invoked by the following command:
#endif ENG
#ifdef JPN
インタープリタおよびデバッガは下記のコマンドで起動される：
#endif JPN

#ifdef VDMPP
  {\tt \vdmde\ -i [-O res-file] [-R testcoverage] [-D [-I]] [-P] [-Q]}\\
  {\tt \mbox{\hspace{4em}} [-Z priority-file] [-M num] argfile specfiles
#ifdef VICEMAN
  \\
  \mbox{\hspace{4em}} [-T num] [-X num] -F [time-file]
#endif VICEMAN
  }
#else
  {\tt \vdmde\ -i [-DIPQ] [-R testcoverage] [-O res-file] argfile specfile(s)}
#endif VDMPP



\vspace{0.5cm}

#ifdef ENG
\noindent
With the {\tt -i} option {\tt \vdmde}\index{\vdmde\!command line
  options} evaluates a \vdmslpp\ expression (or a sequence of
\vdmslpp\ expressions separated by commas) in the file {\tt argfile} in the
context of the specification in the {\tt specfile}(s). The result of
the evaluation is reported to {\aaa stdout}.
When a sequence of
expressions is used, it is possible to refer to the result of the
previous expression by writing {\tt \$\$}.\index{\$\$}

If a run-time error is encountered, the interpretation is terminated
and an error message is displayed. The error message contains position
information for the construct that caused the error and a message
describing the type of error.

The additional options that can be used with the interpreter are:
#endif ENG

#ifdef JPN
\noindent 
{\tt -i}オプションをつけると{\tt \vdmde}\index{\vdmde\!コマンドラインオプション}
コマンドは{\tt argfile}ファイル中、
ファイル{\tt specfile(s)}中の仕様のコンテキストの\vdmslpp\ の式（またはコンマで区切られた式のかたまり）
を評価する。評価の結果は{\aaa stdout}に報告される。一連の式が使われると、記号
 {\tt \$\$}を使って直前の式の結果を参照することができる。

ランタイムエラーに出くわすと、インタープリタは終了しエラーメッセージが表示される。
エラーメッセージはエラーの原因となった構成物の場所の情報と、エラーの型についてのメッセージを含む。

インタープリタで使用されるその他の追加オプションは以下のとおり： 
#endif JPN

\begin{description}

#ifdef ENG
\item[{\tt -D}] Enables dynamic type checking.
    \index{Dynamic Type Checking|see {\\ Type Checking, \\ Dynamic}}\index{Type Checking!Dynamic}
  
\item[{\tt -I}] Enables invariant checking. This option only has effect if the {\tt -D} option is enabled as well.

\item[{\tt -P}] Enables precondition checking for all
\ifthenelse{\boolean{VDMsl}}{functions and operations}{functions}
which are evaluated. \index{Precondition Checking}

\item[{\tt -Q}] Enables postcondition checking for all functions and
operations which are evaluated\index{Postcondition Checking}.

\item[{\tt -R}] 
  The result of the interpretation will be the same as if the argument
  file was evaluated with the specification files used for generating
  the {\tt testcoverage} file. The difference is that the interpreter
  will update the {\tt testcoverage} file with run-time information and
  save it to the hard disk after the evaluation. See Section~\ref{vdmtc}
  for an example.
  
\item[{\tt -O res-file}] Prints the result of evaluating the {\tt
    argfile} to the {\tt res-file}. If {\tt res-file} already exists
  it will be overwritten. This option is typically used in test
  scripts in which the result is automatically compared with expected
  results.

#ifdef VDMPP
\item[{\tt -Z priority-file}] Evaluate using priority based
  scheduling. Only has effect if used with a multi-threaded model.
#endif VDMPP

#ifdef VICEMAN
\item[{\tt -T num}] Use num for task switching constant.
\item[{\tt -X num}] Use num as a scaling factor for time.
\item[{\tt -F time-file}] 
                    Read the specified file and use it as the time map.
#endif VICEMAN

#ifdef VDMPP
\item[{\tt -M num}] Use num as the number of instructions per slice.
#endif VDMPP
#ifdef VICEMAN
, or maximum amount of time per slice, according to primary scheduling algorithm in use.
#endif VICEMAN
#ifdef VDMPP
\item[{\tt -S algorithm}] Use the specified scheduling algorithm. This
  may be one of:
  \begin{description}
  \item[{\tt pure\_cooperative}] Pure cooperative scheduling;
  \item[{\tt instruction\_number\_slice}] Instruction number sliced
    scheduling.
#endif VDMPP
#ifdef VICEMAN
  \item[{\tt timeslice}] Time sliced scheduling
#endif VICEMAN
#ifdef VDMPP
  \end{description}
#endif VDMPP
#endif ENG

#ifdef JPN
\item[{\tt -D}] 動的型チェックを有効にする
    \index{どうてきかたチェック@動的型チェック |see {\\ 型チェック, \\ 動的}}
    \index{かたチェック@型チェック!どうてき@動的}
  
\item[{\tt -I}] 不変条件チェックを有効にする。\index{ふへんじょうけんチェック@不変条件チェック} \\
  {\tt -D}オプションも有効にしないと意味を成さない。\\

\item[{\tt -P}]
評価済みのすべての
\ifthenelse{\boolean{VDMsl}}{関数および操作}{関数}
の事前条件チェックを有効にする。\index{じぜんじょうけんチェック@事前条件チェック}

\item[{\tt -Q}]
評価済みのすべての関数および操作の事後条件チェックを有効にする\index{じごじょうけんチェック@事後条件チェック}

\item[{\tt -R}]
  インタープリタの実行結果が、{\tt testcoverage}ファイルを生成するのに仕様書の
  ファイルと一緒にargumentファイルも使ったかのようになる。違いはインタープリタが
  {\tt testcoverage}ファイルのランタイムエラー情報を更新し、評価後それをハードディスクに
  保存することである。具体的な例はセクション~\ref{vdmtc}を参照のこと
  
\item[{\tt -O res-file}]
  {\tt argfile}の評価結果を{\tt res-file}に保存する。{\tt res-file}がすでに存在する場合は上書きされる。
  このオプションは結果を自動的に予想される結果と比較するテストスクリプトでよく使われる。
  
#ifdef VDMPP
\item[{\tt -Z priority-file}]
  priorityベースのスケジューリングの使用を評価する。マルチスレッドモデルでのみ効果を発する。
#endif VDMPP
#ifdef VICEMAN
\item[{\tt -T num}] タスク切換定数に引数numを使う
\item[{\tt -X num}] 時間あたりのスケーリングファクターとして引数numを使う
\item[{\tt -F time-file}] 時間mapとして指定されたファイルを読み込み、使用する
#endif VICEMAN
#ifdef VDMPP
\item[{\tt -M num}] {\tt num}をタイムスライスごとの命令数とする
#endif VDMPP
#ifdef VICEMAN
\\ またはスライスごとの時間の総計の最大値とする（使用中のプライマリスケジューリングアルゴリズムに
依存する）
#endif VICEMAN
#ifdef VDMPP

\item[{\tt -S algorithm}]
  特定のスケジューリングアルゴリズムを使う。次のうちいずれか：
  \begin{description}
  \item[{\tt pure\_cooperative}] Pure cooperative scheduling;
  \item[{\tt instruction\_number\_slice}] Instruction number sliced
    scheduling.
#endif VDMPP
#ifdef VICEMAN
  \item[{\tt timeslice}] Time sliced scheduling
#endif VICEMAN
#ifdef VDMPP
  \end{description}
#endif VDMPP
#endif JPN

\end{description}

#ifdef ENG
\subsubsection{The Emacs interface}
#endif ENG
#ifdef JPN
\subsubsection{Emacsインターフェース}
#endif JPN

#ifdef ENG
In the Emacs interface all commands are given at the command
prompt. Initialisation of the interpreter must be made first to enable
use of the definitions which have been syntax checked. This is done
using the \textbf{init} command. A number of commands cannot be
called before the specification has 
been initialised (see the {\cmd init} command below).  These commands
are marked with a star ({\tt *}).

An expression can be evaluated using
either the \textbf{print} or the \textbf{debug} command.  The only
difference between the two commands is that {\bf debug} will force
the interpreter to stop at breakpoints whereas {\bf print} ignores
breakpoints.\index{Breakpoints!Ignoring} Breakpoints can be set using
the \textbf{break} command. When a breakpoint is reached it is
possible to continue the execution using either the \textbf{step},
\textbf{singlestep}, \textbf{stepin}, \textbf{cont} or \textbf{finish}
commands to
proceed with the execution. Breakpoints can be deleted using the
\textbf{delete} command.

The \textbf{backtrace} command can be used to inspect the call stack.
Options to the interpreter can be set using the \textbf{set} command
and they can be reset using the \textbf{unset} command.

#ifdef VDMPP
New objects can be created using the \textbf{create} command and then
can be destroyed again using the \textbf{destroy} command. The names
of the current objects can be seen using the \textbf{objects} command.
#endif VDMPP
#ifdef VDMSL
The name of the ``current'' module (during an execution) can be
inspected using the \textbf{curmod} command. It is possible to push a
new module on top of the stack of modules using the \textbf{push}
command. In the same way a module can be popped from the top of the
stack using the \textbf{pop} command. The current stack of modules can
be inspected using the \textbf{stack} command.
#endif VDMSL
#endif ENG

#ifdef JPN
Emacsインターフェースではすべてのコマンドをプロンプトから入力する。まずインタープリタの
初期化を行うことで構文チェック済みの定義を使用することが出来るようになる。
初期化は\textbf{init}コマンドで行う。多くのコマンドがインタープリタの初期化後でなくては使用できない
（下記{\cmd init}コマンドを参照）。これらのコマンドには({\tt *})マークをつけてある。

\textbf{print}または\textbf{debug}コマンドで式を評価することが出来る。これら2つの違いは
{\bf debug}コマンドを使うとブレイクポイントでとまるのに対し、{\bf print}コマンドでは
とまらないことにある\index{ブレイクポイント!むし@無視} 。ブレイクポイントは\textbf{break}コマンドで設定できる。
ブレイクポイントに来ると、\textbf{step}, \textbf{singlestep}, \textbf{stepi}n, \textbf{cont}, \textbf{finish} 
コマンドが可能になる。
ブレイクポイントは\textbf{delete}コマンドで削除できる。

backtraceコマンドはコールスタックを調べるのに使う。インタープリタのオプションは\textbf{set}コマンドを使って
設定することが出来、\textbf{unset}コマンドを使ってリセットすることも出来る。

#ifdef VDMPP
\textbf{create}コマンドを使って新しいオブジェクトを生成することが出来、\textbf{destroy}コマンドを使って
破棄することが出来る。現在のオブジェクトの名前を見るには\textbf{objects}コマンドが使える。
#endif VDMPP
#ifdef VDMSL
\textbf{curmod}コマンドを使うと現在の（実行中の）モジュール名を詳細に見ることが
できる。モジュールスタックの先頭に新しいモジュールを\textbf{push}を使ってPushする
こともできる。\textbf{stack}コマンドを使うと現在のモジュールスタックを詳細に見ることができる。
#endif VDMSL
#endif JPN

\begin{description}

#ifdef ENG
\item[*backtrace (bt)] \index{backtrace command}\mbox{}\\
  Displays the function/operation
  call stack.
\item[*break (b) \mbox{[{\tt name }]}] 
\index{break command}\index{Breakpoints!Setting}\mbox{}\\
  Sets a breakpoint at the function or
  operation with the given name.
  
  \ifthenelse{\boolean{VDMpp}}{The name must consist of
    the function/operation name qualified with the name of the class
    it is defined in.}{} 
    
    A number is allocated for the  breakpoint and this is displayed
    as the result of the command.

    If \textbf{break} is called without parameters it displays all the
    current breakpoints.

\item[*break (b) \mbox{\texttt{name number} [\texttt{number}]}]\mbox{}\\
\index{break command}\index{Breakpoints!Setting}\mbox{}\\
 This sets a breakpoint in the file with the given name at the line
 with the given number. If a second number is given, this is
 interpreted as the column at which the breakpoint should be set.
 
#ifdef VDMPP
\item[*create (cr)] {\tt name := stmt}\index{create command}\mbox{}\\
  This command creates an object reference of name {\tt name}
  initially assigned to {\tt stmt}.  {\tt stmt} must be either a
  call statement referring to an object or a new statement. (See
  \cite{LangManPP-CSK} for an explanation of the different kinds of
  statements.)  Afterwards the object {\tt name} will be in the scope
  of the debugger.
#endif VDMPP

\item[*cont (c)] \index{cont command}\mbox{}\\
  Continues execution after a breakpoint until another breakpoint or
  the end of the evaluation is reached.

#ifdef VDMSL
\item[curmod] \index{curmod command}\mbox{}\\
  If the specification is structured into modules this command
  prints the name of the current module.
#endif VDMSL

#ifdef VDMPP
\item[curthread]\index{curthread command}\mbox{}\\
  Prints the identifier of the thread currently being executed.
#endif VDMPP

\item[debug (d) {\tt expr}] \index{debug command} \mbox{}\\
  Evaluates and prints the value of the \vdmslpp\ expression/statement
  {\tt expr}.  The execution stops at enabled breakpoints
  \index{Breakpoints} and the breakpoint position is displayed. If a
  run-time error occurs, the execution stops in the context
  where the error occurred and the position of the error is
  displayed in the specification window.
  
  In order to use the last evaluated result in a following
  expression, {\tt \$\$}\index{\$\$} can be used. See the description
  of the {\tt print} command for more information.
    
\item[*delete {\tt name ...}] \index{delete command}\mbox{}\\
  Deletes the breakpoint set at the function(s) or
  operation(s) with the given
  name(s). \ifthenelse{\boolean{VDMpp}}{Function and operation names must be
    qualified with the name of the class they are defined in.}{}
#ifdef VDMPP
\item[*destroy] {\tt name}\index{destroy command}\mbox{}\\
  Destroys the object referred to by {\tt name}.
#endif VDMPP

\item[*disable \texttt{number}]
\index{disable command}\index{Breakpoints!Disabling}\mbox{}\\
  Disables the breakpoint with the given number.

\item[*enable \texttt{number}]
\index{enable command}\index{Breakpoints!Enabling}\mbox{}\\
  Enables the previously disabled breakpoint with the given number.

\item[*finish]\index{finish command}\mbox{}\\
  Finishes the evaluation of the current function or
  operation and returns to the
  caller. The command is traditionally used together with {\tt stepin}.

#ifdef VICEMAN
\item[*gettime]\index{gettime command}\mbox{}\\
  Returns the current time in the interpreter, as computed 
  on the basis of the time file and duration statements.
#endif VICEMAN

\item[init (i)] \index{init command}\mbox{}\\ This command initialises
  the interpreter with all definitions from the specification. This
  includes initialising the
  \ifthenelse{\boolean{VDMsl}}{states}{instance variables} and all
  values. If a value is multiply defined this will be reported during
  this initialisation. The initialisation command will initialise all
  files read into the \Toolbox\ in the same session. Therefore it is
  not necessary to initialise each file separately after it has been
  read in using the {\tt read} command.

#ifdef VDMPP
\item[*objects] \index{objects command}\mbox{}\\
  Displays the objects created within the debugger.
  
\item[*pop] \index{pop command}\mbox{}\\
  The current class is popped off the stack. 
If there is no active class a warning is issued and
  nothing happens.
#endif VDMPP

\item[*popd] \index{popd command}\mbox{}\\
  This command is used when nested debugging is taking place i.e.\ when
  an expression is debugged while already at a breakpoint in another
  evaluation. The effect of a
  \textbf{popd} command is to restore the environment to that which
  existed when the last \textbf{debug} command was invoked.
 
\item[print (p) {\tt expr},...] \index{print command}\mbox{}\\
  Evaluates and prints the value of the \vdmslpp\ expression(s) {\tt
    expr} with all breakpoints disabled. If a run-time error occurs
  the execution will be stopped and the position of the error is
  displayed.

  In addition to the normal \vdmslpp\ values the {\tt print} command
  can also return the values {\tt FUNCTION\_VAL} and {\tt
    OPERATION\_VAL}\@.  This happens if the result of the evaluation is
  a function or an operation (for example if a function
  is evaluated just by giving the function name without supplying any
  parameters enclosed in parenthesis).
  
  In order to use the last evaluated result in a following expression,
  {\tt \$\$} can be used.  {\tt \$\$} is treated as an expression and
  can therefore be embedded in other \vdmslpp\ expression(s) as shown
  in the following   example:

\begin{quote}
\begin{verbatim}
vdm> p 10
10
vdm> p $$+$$, 2*$$
20
40
vdm> 
\end{verbatim}
\end{quote}

#ifdef VDMPP
\item[priorityfile (pf) \mbox{[{\tt filename ...}]}] \index{priorityfile command}\mbox{}\\
  If called with a valid filename, this reads the priority information
  from this file and uses it when scheduling threads, if
  priority-based scheduling is enabled.
  
  If called with no argument, this lists the current priority file being
  used by the interpreter.

  See Appendix \ref{sec:priorityfile} for further details of required
  format for priority files.

\item[*push {\tt name}]\index{push command} \mbox{}\\
  The class {\tt name}\/ is pushed onto the modules stack and becomes
  the active class after initialisation. 
#endif VDMPP

\item[remove \mbox{\texttt{number}}]
\index{remove command}\index{Breakpoints!Removing}\mbox{}\\
  Removes the breakpoint with the given number.
#ifdef VDMPP
\item[selthread]\texttt{id}\index{curthread command}\mbox{}\\
  Sets the currently executing thread to be that with identifier
  \texttt{id}.
#endif VDMPP

\item[set {\tt option} \ifthenelse{\boolean{VDMsl}}{\mbox{[{\tt
        argument}]}}{}]\index{option command}\mbox{}\\
  Enables setting of the internal options of the interpreter.  If the
  command is called without parameters it displays the current
  settings. {\tt option}\/ can be one of the following:
  
  \begin{description}
  \item[{\tt dtc}] enables dynamic type checking.
  \item[{\tt inv}] enables dynamic checks of invariants. In order for
    {\tt inv} to have any effect, {\tt dtc} must be enabled as well.
  \item[{\tt pre}] enables check of preconditions.
  \item[{\tt post}] enables check of postconditions.
  \item[{\tt ppr}] enables pretty print format. All values will be
    displayed with line-breaks and indentation according to the
    structure of the value.
  \item[{\tt seed integer}] initialises a random number generator with
    the given integer.  This causes a random order of evaluation of
    sub-statements in nondeterministic statement constructs.  The
    integer must be $\geq 0$. A negative number will disable random
    evaluation of nondeterministic statements.
#ifdef VDMPP
  \item[{\tt primaryalgorithm string}] sets the primary scheduling
    algorithm used by the interpreter to be the given string. This
    string may be:
    \begin{description}
    \item[{\tt pure\_cooperative}] \texttt{(pc)} - use pure
      cooperative scheduling;
    \item[{\tt instruction\_number\_slice}] \texttt{(in)} - use
      instruction number slicing scheduling
#endif VDMPP
#ifdef VICEMAN
    \item[{\tt timeslice}] \texttt{(ts)} - use time slice scheduling 
#endif VICEMAN
#ifdef VDMPP
    \end{description}
    Here the names in parentheses are abbreviations which may be
    used. See Section~\ref{subsec:scheduling} for more details of the
    different scheduling algorithms. Default is 
    {\tt instruction\_number\_slice}
  \item[{\tt maxinstr integer}] use the given integer as the maximum
    number of instructions per slice. See
    Section~\ref{subsec:scheduling} for details of how this value is
    used. Default is 1000.
  \item[{\tt priority}] enables priority-based scheduling.
    Section~\ref{subsec:scheduling} for details of how this is
    used. 
#endif VDMPP
#ifdef VICEMAN
  \item[{\tt maxtime integer}] use the given integer as the maximum
    amount of time per time slice, if the primary scheduling algorithm
    is time slice.
  \item[{\tt taskswitch integer}] sets the task switching constant to
    be the given integer. See Section~\ref{subsec:timing} for details
    of how this value is used. Default is 0.
  \item[{\tt logfile filename}] sets the logfile to be the given
    filename. Default is ``logfile''.
  \item[{\tt timefactor integer}] sets the timefactor to be the given
    integer. Default is 1.
#endif VICEMAN
  \end{description}
  
  All options are false by default, except {\tt ppr}.
 
\item[*singlestep (g)] \index{singlestep command}\mbox{}\\
  Executes the next expression, sub-expression or statement
  and breaks.

\item[*step (s)] \index{step command}\mbox{}\\
  Executes the next statement and breaks. This command will not step
  into function and operation calls. This command is not useful with
  functions because it evaluates the entire expression.

\item[*stepin (si)] \index{stepin command}\mbox{}\\
  Executes the next expression or statement and then breaks. This
  command will also step into function and operation calls.

#ifdef VICEMAN
\item[timefile (tf) \mbox{[{\tt filename ...}]}] \index{timefile command}\mbox{}\\
  If called with a valid filename, this reads the timing information
  from this file and merges it with the interpreter's default time
  map.

  If called with no argument, this lists the current time map being
  used by the interpreter.

  See Appendix \ref{sec:timefile} for further details of required
  format for time files, and section \ref{subsec:timing} for details
  of how the time file is used.
#endif VICEMAN

#ifdef VDMPP
\item[threads]\index{threads command}\mbox{}\\
  Displays a list of the threads currently being executed in the
following format:
\begin{quote}
  $<$ \textit{thread id} $>$\ $<$ \textit{object ref} $>$\ $<$
\textit{status} $>$
\end{quote}
where \textit{thread id} is the unique identifier of the thread,
\textit{object ref} is the identifier of the object within which the
thread is defined (\texttt{none} if this is the thread of control
initiated by the interpreter), and \textit{status} is one of the following

\begin{tabular}{lp{10cm}}\hline
Status & Meaning \\ \hline
Blocked    & the thread is waiting for a permission predicate to
             become true. \\ 
Stopped    & the thread has stopped at a breakpoint.\\
Running    & the thread is currently being executed by the interpreter. \\
MaxReached & the maximum number of instructions per time slice has
              been reached by this thread. \\ \hline 
\end{tabular}
#endif VDMPP

\item[tcov]\index{tcov command}\mbox{}\\
The test coverage command {\bf tcov} makes it possible to control 
collection of test coverage information:

  \begin{description}
  \item[tcov read filename]\index{tcov read command}\mbox{}\\
    Reads the test coverage information saved in the given file.

    Note, that if you syntax check a file after reading in a test coverage 
    file, the coverage information for that file will be reset and the test coverage
    information will be lost unless you write the test coverage information
    before the file is syntax checked.
    Also be aware that the pretty printing function always uses the test coverage
    file that is specified in the specification file.

  \item[tcov write filename]\index{tcov write command}\mbox{} \\
    Writes the existing test coverage information to the given file.
  
  \item[tcov reset]\index{tcov reset command}\mbox{} \\
    Resets all test coverage information to zero.
  \end{description}

  
\item[unset {\tt option}, ...]\index{unset command}\mbox{}\\
  Disables one or more of the internal options of the \Toolbox. See the
  {\tt set} command for a description of the possible options.

#ifdef VDMSL
\item[*push {\tt name}]\index{push command} \mbox{}\\
  The module {\tt name}\/ is pushed onto the modules stack and becomes
  the active module after initialisation.

\item[*pop] \index{pop command}\mbox{}\\
  The current module ({\tt curmod}) is popped off the stack ({\tt
    stack}). If there is no active module a warning is issued and
  nothing happens.

\item[*stack]\index{stack command}\mbox{}\\
  Displays the names of the pushed modules.
#endif VDMSL
#endif ENG

#ifdef JPN
\item[*backtrace (bt)] \index{backtraceコマンド}\mbox{}\\
  関数/操作のコールスタックを表示する。
  
\item[*break (b) \mbox{[{\tt name }]}] 
\index{breakコマンド}\index{ブレイクポイント!せってい@設定}\mbox{}\\
  {\tt name}で指定された関数または操作にブレイクポイントを設定する。\\
  \ifthenelse{\boolean{VDMpp}}{指定された関数/操作名は定義されたクラス名で分類された%
  もので構成されていなくてはならない。}{} 
  
  このコマンドが実行されると、新しいブレイクポイントに番号が割り当てられ、コマンドの実行結果として表示される。

  引数なしで\textbf{break} が呼び出されると現在のブレイクポイントをすべて表示する。

\item[*break (b) \mbox{\texttt{name number} [\texttt{number}]}]\mbox{}\\
\index{breakコマンド}\index{ブレイクポイント!せってい@設定}\mbox{}\\
 与えられたファイル名の、数字で与えられた行にブレイクポイントを設定する。
 2番目の引数（数）が与えられた場合、ブレイクポイントを設定する箇所として解釈される。
 
#ifdef VDMPP
\item[*create (cr)] {\tt name := stmt}\index{createコマンド}\mbox{}\\
  参照名{\tt name}でオブジェクトを生成し、まず{\tt stmt}に割り当てる。
  {\tt stmt}は、オブジェクトを参照する呼出し命令または新しい命令文
  （他の種類の命令文の説明については\cite{LangManPP-CSK} を参照のこと）。その後、
  {\tt name}オブジェクトはデバッガのスコープに置かれる。
#endif VDMPP

\item[*cont (c)] \index{contコマンド}\mbox{}\\
  次のブレイクポイントまで続けて実行したいときやまたは式や命令文の最後まで評価が到達したときに使用する。

#ifdef VDMSL
\item[curmod] \index{curmodコマンド}\mbox{}\\
  仕様書がモジュールで構成されている場合、このコマンドは現在のモジュール名を
  出力する。
#endif VDMSL

#ifdef VDMPP
\item[curthread]\index{curthreadコマンド}\mbox{}\\
  現在実行中のスレッドの識別子を出力する。
#endif VDMPP

\item[debug (d) {\tt expr}] \index{debugコマンド} \mbox{}\\
  \vdmslpp\ の式{\tt expr}の値を評価し、表示する。有効なブレイクポイント\index{ブレイクポイント} すべてで
  実行がとまるが、このとき現在実行中の箇所が表示される。ランタイムエラーが起こると、
  エラーの起こった箇所で実行は止まり、エラーがソースウインドウに表示される。
  
  最後の評価結果を見るには、記号{\tt \$\$}\index{\$\$} を使うことが可能である。
  詳細については{\tt print}コマンドの記述を参照のこと。
    
\item[*delete {\tt name ...}] \index{deleteコマンド}\mbox{}\\
    引数{\tt name}で指定した関数や操作に設定されているブレイクポイントを削除する。
    \ifthenelse{\boolean{VDMpp}}%
    {%
        関数名・操作名は定義されたクラス名で分類された関数･操作名で構成されていなくてはならない
    }%
    {}%
    
#ifdef VDMPP
\item[*destroy] {\tt name}\index{destroyコマンド}\mbox{}\\
  {\tt name}で参照されるオブジェクトを破棄する。
#endif VDMPP

\item[*disable \texttt{number}]
\index{disableコマンド}\index{ブレイクポイント!むこう@無効}\mbox{}\\
  与えられた{\tt number}で指定したブレイクポイントを無効にする。

\item[*enable \texttt{number}]
\index{enableコマンド}\index{ブレイクポイント!ゆうこう@有効}\mbox{}\\
  与えられた{\tt number}で指定したブレイクポイントを有効にする。

\item[*finish]\index{finishコマンド}\mbox{}\\
  現在評価中の関数または操作を抜けて呼び元に戻る。もともとは{\tt stepin}と対で使われる。

#ifdef VICEMAN
\item[*gettime]\index{gettimeコマンド}\mbox{}\\
  インタープリタの現在時刻を返す。時刻ファイルとDurationの
  記述をもとにして計算したものとなる。
#endif VICEMAN

\item[init (i)] \index{initコマンド}\mbox{}\\
  インタープリタ内の仕様書のすべての定義を初期化する。
  これには
  \ifthenelse{\boolean{VDMsl}}{状態}{インスタンス変数} 
  とすべての値も含まれる。値が多重定義されていた
  場合は、初期化中に報告される。初期化コマンドは\Toolbox\ の同じセッションに
  読み込まれているすべてのファイルを初期化する。ゆえに{\tt read}コマンドでファイルが
  読み込んであれば、個々のファイルを別々に初期化する必要はない。

#ifdef VDMPP
\item[*objects] \index{objectsコマンド}\mbox{}\\
  デバッガ中で生成されたオブジェクトを表示する。
#endif VDMPP

\item[*pop] \index{popコマンド}\mbox{}\\
  現在のクラスがスタックに出される。
  もしアクティブなクラスがない場合は、警告を発した上で何も起こらない。

\item[*popd] \index{popdコマンド}\mbox{}\\
  デバッグが入れ子にして行われているときに使われる。（ある式がデバッグ中、ほかの評価で
  そのブレイクポイントが評価された）popdコマンドは、最後に\textbf{debug}コマンドが
  起動されたときの環境に戻す効果がある。
 
\item[print (p) {\tt expr},...] \index{printコマンド}\mbox{}\\
  すべてのブレイクポイントを無効にして、\vdmslpp\ の式{\tt expr}の値を評価し、表示する。
  ランタイムエラーが起こった場合、実行は止まりエラーの箇所が表示される。

   通常の\vdmslpp\ の値に加えて、{\tt print}コマンドは{\tt FUNCTION\_VAL}  と{\tt OPERATION\_VAL} も
  返すことができる。これは評価の結果が関数や操作になった場合（例：関数名だけ
  与えられていて、引数を与えられず（）で囲まれている関数が評価された場合）
  
  最後の評価の結果を参照するのに記号 {\tt \$\$}を使うことができる。この記号は式として扱うことができ、
  下記の例に示すように他の\vdmslpp\ の式に組み込まれている。

\begin{quote}
\begin{verbatim}
vdm> p 10
10
vdm> p $$+$$, 2*$$
20
40
vdm> 
\end{verbatim}
\end{quote}

#ifdef VDMPP
\item[priorityfile (pf) \mbox{[{\tt filename ...}]}] \index{priorityfileコマンド}\mbox{}\\
  priorityスケジューリングが有効なときに有効なファイル名を指定した場合、
  指定したファイルからpriority情報を読み込んでスレッドのスケジューリングに利用する。
  
  引数なしで呼び出された場合、インタープリタで使用されている現在のプライオリティファイル
  をリスト表示する。

  プライオリティファイルで要求されるフォーマットについての詳細は、\ref{sec:priorityfile} 
  を参照のこと。

\item[*push {\tt name}]\index{pushコマンド} \mbox{}\\
  {\tt name} で指定したクラスがモジュールスタックにプッシュされ、
  初期化後にアクティブなクラスとなる。
#endif VDMPP

\item[remove \mbox{\texttt{number}}]
\index{removeコマンド}\index{ブレイクポイント!さくじょ@削除}\mbox{}\\
  \texttt{number}で指定したブレイクポイントを削除する。

#ifdef VDMPP
\item[selthread]\texttt{id}\index{curthreadコマンド}\mbox{}\\
  \texttt{id}.\\
  現在実行中のスレッドを識別子\texttt{id}のものにする。 
#endif VDMPP

\item[set {\tt option} \ifthenelse{\boolean{VDMsl}}{\mbox{[{\tt
        argument}]}}{}]\index{optionコマンド}\mbox{}\\
  インタープリタ内部のオプション設定を行う。引数なしで実行された場合は現在の設定を表示する。\\
  オプションは{\tt option}\/が使用できる。
  
  \begin{description}
  \item[{\tt dtc}] 動的型チェックを有効にする
  \item[{\tt inv}] 不変条件の動的チェックを有効にする。 {\tt dtc}も有効になっていないと意味をなさない。
  \item[{\tt pre}] 事前条件のチェックを有効にする。
  \item[{\tt post}] 事後条件のチェックを有効にする。
  \item[{\tt ppr}] 清書のフォーマットを有効にする。すべての値が構造に従ってされて表示される。
  \item[{\tt seed integer}]
    乱数ジェネレータを与えられた数字で初期化する。非決定性の命令文で
    構成されたもののうちのサブ命令文の評価をランダムに行うためである。integerは
     0以上でなくてはならない。負の数は非決定性の命令文のランダムな評価を無効に
    してしまうからである。
#ifdef VDMPP
  \item[{\tt primaryalgorithm string}]
    インタープリタで使用されるプライマリのスケジューリングアルゴリズムを設定する。stringは下記2つのうちいずれか
    \begin{description}
    \item[{\tt pure\_cooperative}] \texttt{(pc)} - use pure
      cooperative scheduling;
    \item[{\tt instruction\_number\_slice}] \texttt{(in)} - use
      instruction number slicing scheduling
#endif VDMPP
#ifdef VICEMAN
    \item[{\tt timeslice}] \texttt{(ts)} - use time slice scheduling 
#endif VICEMAN
#ifdef VDMPP
    \end{description}
    ここで、()内の名前は使用される略語である。スケジューリングアルゴリズムについて
    の詳細は、セクション~\ref{subsec:scheduling}を参照のこと。
    デフォルトは{\tt instruction\_number\_slice}
  \item[{\tt maxinstr integer}]
    タイムスライス毎の命令の最大数を{\tt maxinstr integer}で指定する。指定した値が
    どう使われるかはセクション~\ref{subsec:scheduling} を参照のこと。デフォルトは1000。
  \item[{\tt priority}]
    priorityベースのスケジューリングを有効にする。詳細はセクション~\ref{subsec:scheduling} 参照のこと。
#endif VDMPP
#ifdef VICEMAN
  \item[{\tt maxtime integer}]
    プライマリのスケジューリングアルゴリズムが、time sliceであった場合、
    与えられたinteger値をタイムスライスごとの時間の総計の最大値として使用する。
  \item[{\tt taskswitch integer}]
    タスク切換定数を与えられたinteger値に設定する。この値がどのように使われるかは、
    セクション~\ref{subsec:timing} を参照のこと。デフォルトは0。
  \item[{\tt logfile filename}]
    ログファイル名を与えられた{\tt filename}にする。デフォルトは``logfile''。
  \item[{\tt timefactor integer}]
    timefactorを与えられたinteger値に設定する。デフォルトは1。
#endif VICEMAN
  \end{description}
  
  すべてのオプションはデフォルトではfalseである（{\tt ppr}を除く）。
 
\item[*singlestep (g)] \index{singlestepコマンド}\mbox{}\\
  次の式を実行する。サブ式・命令文で止まる。

\item[*step (s)] \index{stepコマンド}\mbox{}\\
  次の命令文を実行して止まる。このコマンドは関数や操作内部には入らない。
  式全体を評価するので関数には有効でない。

\item[*stepin (si)] \index{stepinコマンド}\mbox{}\\
  次の式・命令文を実行して止まる。関数・操作内部にも入る。

#ifdef VICEMAN
\item[timefile (tf) \mbox{[{\tt filename ...}]}] \index{timefileコマンド}\mbox{}\\
  有効なファイル名を伴って呼び出された場合、指定したファイルからタイミング情報を呼び出して
  インタープリタのデフォルトのタイムmapとマージする。

  引数なしで呼び出された場合、インタープリタに使用されている現在時刻のmapを
  リスト表示する。

  タイムファイルに要求されるフォーマットの詳細に関しては、セクション\ref{sec:timefile}
  を、また、タイムファイルがどのように使用されるかについてはセクション\ref{subsec:timing}を
  参照のこと。
#endif VICEMAN

#ifdef VDMPP
\item[threads]\index{threadsコマンド}\mbox{}\\
現在実行中のスレッドの一覧を下記のフォーマットで表示する：
\begin{quote}
  $<$ \textit{thread id} $>$\ $<$ \textit{object ref} $>$\ $<$
\textit{status} $>$
\end{quote}
\textit{thread id} はスレッドの識別子であり、ユニークな値である。
\textit{object ref} はスレッドの定義中でのオブジェクトの識別子（インタープリタ主導で
コントロールされているスレッドの場合は\texttt{none} ）、\textit{status}は下記のうちいずれかである：

\begin{tabular}{lp{10cm}}\hline
状態 & 意味 \\ \hline
Blocked    & 実行許可待ち \\ 
Stopped    & ブレイクポイントでStop中.\\
Running    & インタープリタにより現在実行中. \\
MaxReached & このスレッドによりタイムスライス毎の命令の最大数に達した. \\ \hline 
\end{tabular}
#endif VDMPP

\item[tcov]\index{tcovコマンド}\mbox{}\\
テストカバレッジコマンド {\bf tcov} を使うことによって、テストカバレッジ情報の集合を
コントロールすることができる。

  \begin{description}
  \item[tcov read filename]\index{tcov readコマンド}\mbox{}\\
    {\tt filename}で示されるファイルに保存されているテストカバレッジ情報を読みこむ。

    テストカバレッジファイルを呼んだ後に構文チェックをかけた場合、構文チェックをかけた
    ファイルのカバレッジ情報はリセットされ、構文チェックをする前にどこかへテストカバレッジ
    情報を書き出しておかない限り失われることに注意。pretty printing機能がいつも仕様書
    のファイルから特定されるテストカバレッジファイルを参照していることにも注意が必要である。

  \item[tcov write filename]\index{tcov writeコマンド}\mbox{} \\
    {\tt filename}で指定されるファイルに存在するテストカバレッジ情報を書き込む。
  
  \item[tcov reset]\index{tcov resetコマンド}\mbox{} \\
    テストカバレッジ情報をリセットする。
  \end{description}

  
\item[unset {\tt option}, ...]\index{unsetコマンド}\mbox{}\\
  \Toolbox\ 内のオプション設定を無効にする。可能なオプションについての記述は
  {\tt set}コマンドの項を参照のこと。

#ifdef VDMSL
\item[*push {\tt name}]\index{pushコマンド} \mbox{}\\
  モジュール{\tt name} がモジュールスタックの先頭にPushされ、初期化の後アクティブ
  モジュールとなる。

\item[*pop] \index{popコマンド}\mbox{}\\
 現在のモジュール({\tt curmod})がスタックからpopされる（{\tt stack}）。
 アクティブなモジュールがなかった場合は、ワーニングが発行され何も起こらない。

\item[*stack]\index{stackコマンド}\mbox{}\\
  Pushされたモジュール名を表示する。

#endif VDMSL
#endif JPN

\end{description}

#ifdef VICEMAN

#ifdef ENG
\subsubsection{Timing analysis}\label{subsec:timing}
#endif ENG
#ifdef JPN
\subsubsection{タイミング分析}\label{subsec:timing}
#endif JPN
#ifdef ENG
The \Toolbox\ supports timing analysis of models. An overview of this
is shown in Figure~\ref{fig:timing}.
#endif ENG
#ifdef JPN
\Toolbox\ はタイミング分析モデルをサポートしている。これの概略は図~\ref{fig:timing}.に
示す。
#endif JPN

\begin{figure}
\begin{center}
\begin{picture}(300,90)
\put(165,10){\framebox(50,80){\Toolbox}}
\thicklines
\put(120,30){\vector(1,0){45}}\put(20,27){Default time map}
\put(120,70){\vector(1,0){45}}\put(20,67){User time map}
\put(215,50){\vector(1,0){45}}\put(265,47){Logfile}
\end{picture}
#ifdef ENG
\caption{Timing Analysis: Overview}
#endif ENG
#ifdef JPN
\caption{タイミング分析：概略}
#endif JPN
\label{fig:timing}
\end{center}
\end{figure}

#ifdef ENG
Essentially, during execution the interpreter takes information from
the time map concerning the timing behaviour of the target
architecture and uses this to increment an internal clock. This
internal clock is then used as the basis for scheduling periodic
threads. It is also used to time stamp events that occur. 
Each entry in the time trace file consists of an event name, and event
information, separated by \texttt{->}. Events fall into different
categories, object history events, message events, declaration events,
deployment events and thread events. The category
dictates the event information provided.
#endif ENG
#ifdef JPN
基本的に、実行中インタープリタはターゲット・アーキテクチャのタイミング振る舞いに関係するタイムmapから情報をとり、
内部時計をインクリメントするのにこれを使用している。この内部時計は周期的なスレッドのスケジューリングの基礎と
して使われる。タイムスタンプイベントとしても使われる。イベントは下記いずれかのようになる：
#endif JPN

\begin{description}
#ifdef ENG
\item[Object history events] consist of operation requests, activations and
completions. The information provided for such events are: the
operation called; information whether it is an asynchronous operation;
the object reference id and the \texttt{CPU} id on which the operation has
been called; the class which the object is an instance of; and the
time at which the event occurred.

\item[Message events] are similar to operation requests except that they
    identify requests, activations and completions of messages communicated
    over a \texttt{BUS}. These messages are automatically derived by 
    \VDMTools\ when an operation is to be invoked on an instance that has been
    deployed to a different \texttt{CPU}. Each message is given a unique
    identification. Thus, it is only the message request events that contain
    all information about the \texttt{BUS} used, the \texttt{CPU} it is 
    coming from and to, etc. Importantly it also contains a size attribute
    that is derived from the values that are passed over as parameters for
    the operation to be called at the other \texttt{CPU}. 

\item[Declaration events] are included in system ``classes'' where
    it is possible to declare
    \texttt{CPU}'s and \texttt{BUS}'es. In addition \texttt{CPU}'s may be
    implicitly declared when new objects are created inside the \texttt{World}
    class and this is also logged.

\item[Deployment events] are logged whenever objects are created. 
     An object may initially be created and deployed at the virtual 
     \texttt{CPU} (always with cpuid 0) and then subsequently deployed
     at a different \texttt{CPU}.

\item[Thread events] correspond to a thread being created, killed,
swapped in or out, or (for
periodic threads) a thread which has missed its deadline being swapped
in. In this case the thread id is provided, together with the object
reference id for the object owning the thread, the class which the
object is an instance of, the time of the event, and (for delayed
periodic threads) the delay.
#endif ENG

#ifdef JPN
\item 操作要求;
\item 操作起動 (パーミッションがそのオペレーションは条件を満たしたと断定する);
\item 操作完了;
\item スレッドがスワップインして現在のスレッドになった;
\item 現在のスレッドがスワップアウトした;
\item 周期的なスレッドがスワップインしたが、.期限切れとなった
#endif JPN
\end{description}


#ifdef ENG
Each event is logged in a file named \texttt{logfile} written to the
same directory as the project file is saved in, or the directory in
which the toolbox was started. Together with each event is a reference
to an object (for operations, the object on which the operation has
been invoked; for threads, the object owning the thread), together
with the time at which the event occurred.

The timing behaviour of the target architecture as determined by the
time map can be overridden using duration statements. See
\cite{LangManPP-CSK} for details. Details of the precise syntax for time
files can be found in Appendix~\ref{sec:timefile}.

The amount of time required to switch from one thread to another is a
constant for a particular execution. This constant can be changed to
any desired value using the \texttt{taskswitch} setting.

The effect of different processors can be simulated by using the
\texttt{timefactor} setting. This multiplies all time increments by
the given time factor, except for
#endif ENG
#ifdef JPN
イベントはそれぞれ、\texttt{logfile}ファイルに書き込まれるが、これはプロジェクトファイルのあるディレクトリと同じ
ところにまたはツールボックスの開始ディレクトリに保存される。各々のイベントとともにオブジェクト（操作、
操作が起動されたオブジェクト、スレッド、スレッドを持つオブジェクト）への参照
イベントの起こった時間とタイムmapによって決定されるターゲット・アーキテクチャのタイミング振る舞いは
Durationの命令文を使用してオーバーライドされる。詳細は\cite{LangManPP-CSK} を
参照のこと。タイムファイルの正確な構文の詳細は付録~\ref{sec:timefile}に記述がある。

あるスレッドから違うスレッドへスイッチするときかかる時間の合計は特定の実行定数
である。この定数は\texttt{taskswitch} 設定を使うことで好きな値に変えることができる。

異なるプロセッサの効果は\texttt{timefactor} 設定を使用することでシュミレートできる。
これはすべての時刻の増分を与えられた値に増やす。（下記は除く）
#endif JPN

\begin{itemize}
#ifdef ENG
\item The duration in a duration statement;
\item The time taken to switch tasks.
#endif ENG
#ifdef JPN
\item duration 命令文中のduration;
\item タスク切換に要する時間
#endif JPN
\end{itemize}

#ifdef ENG
Both of these remain absolute times.
#endif ENG
#ifdef JPN
これらは両方とも絶対時刻のままである。
#endif JPN

#ifdef ENG
At the moment one external generic analysis tool for trace files produced by
\VDMTools\ exists. This is an open source tool called \texttt{showtrace} and
it has been implemented on top of the \texttt{Eclipse} platform 
\cite{Carlson05}. 

The \texttt{showtrace} tool is able to type check a trace file and if it 
is parsed and checked to be correct it is able to show:

\begin{itemize}
\item A system architecture with the \texttt{CPU}'s and the connecting
      \texttt{BUS}'es as shown in Figure~\ref{fig:cpuarchitecture}.
\item An execution overview the illustrates when the different 
      \texttt{CPU}'s and \texttt{BUS}'es are active (see 
      Figure~\ref{fig:exeoverview} for an example).
\item A detailed graphical overview for each \texttt{CPU} where the
      different objects that have been deployed to that \texttt{CPU} and
      the different threads executing are shown (see 
      Figure~\ref{fig:detailedexe} for an example).
\end{itemize}

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{cpuarchitecture.png}
\end{center}
\caption{A CPU Architecture Overview (see \cite{VICEGuide-CSK})
\label{fig:cpuarchitecture}}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{exeoverview.png}
\end{center}
\caption{An extract from an execution overview (see \cite{VICEGuide-CSK})}
\label{fig:exeoverview}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{detailedexe.png}
\end{center}
\caption{A detailed \texttt{CPU} execution (see \cite{VICEGuide-CSK})}
\label{fig:detailedexe}
\end{figure}
#endif ENG
#endif VICEMAN

#ifdef VDMPP

#ifdef ENG
\subsubsection{Scheduling of threads}\label{subsec:scheduling}
#endif ENG
#ifdef JPN
\subsubsection{スレッドのスケジューリング}\label{subsec:scheduling}
#endif JPN

#ifdef ENG
The following different primary scheduling algorithms are available:
#endif ENG
#ifdef JPN
下記のプライマリスケジューリングアルゴリズムが利用できる：
#endif JPN

\begin{description}

#ifdef ENG
\item[Pure Cooperative] Under this algorithm a thread will be executed
until:
\begin{itemize}
\item It completes successfully;
\item It reaches an operation call for which the corresponding
permission predicate is false;
\item A breakpoint is met or the interpreter is interrupted.
\end{itemize}
\item[Instruction number slicing] Under this algorithm a thread will
be executed until:
\begin{itemize}
\item It completes successfully;
\item It reaches an operation call for which the corresponding
permission predicate is false;
\item The number of (internal) instructions it has executed since
being scheduled exceeds the \texttt{maxinstr} constant.
\item A breakpoint is met or the interpreter is interrupted.
\end{itemize}
#endif ENG

#ifdef JPN
\item[Pure Cooperative]
このアルゴリズム下で、スレッドは下記のようになるまで実行される：
\begin{itemize}
\item 正常に完了;
\item 相当するパーミッションxxがfalseとなるオペレーションコールに到達;
\item ブレイクポイントに到達または、インタープリタが割り込みされた
\end{itemize}
\item[Instruction number slicing]
このアルゴリズム下で、スレッドは下記のようになるまで実行される：
\begin{itemize}
\item 正常に完了;
\item 相当するパーミッションxxがfalseとなるオペレーションコールに到達;
\item スケジューリングされ実行された(内部の)命令数が\texttt{maxinstr} 定数を超えた
\item ブレイクポイントに到達または、インタープリタが割り込みされた
\end{itemize}
#endif JPN

#endif VDMPP

#ifdef VICEMAN

#ifdef ENG
\item[Time Slice] Under this algorithm a thread will be executed
until:
\begin{itemize}
\item It completes successfully;
\item It reaches an operation call for which the corresponding
permission predicate is false;
\item The amount of time it has executed since
being scheduled exceeds the \texttt{maxtime} constant.
\item A breakpoint is met or the interpreter is interrupted.
\end{itemize}
#endif ENG

#ifdef JPN
\item[Time Slice]
このアルゴリズム下で、スレッドは下記のようになるまで実行される：
\begin{itemize}
\item 正常に完了;
\item 相当するパーミッションxxがfalseとなるオペレーションコールに到達;
\item スケジューリングされ実行された時間の総計が\texttt{maxtime} 定数を超えた
\item ブレイクポイントに到達または、インタープリタが割り込みされた
\end{itemize}
#endif JPN

#endif VICEMAN

#ifdef VDMPP
\end{description}
#endif VDMPP

#ifdef VDMPP

#ifdef ENG
Selection of which thread to schedule next (secondary scheduling
algorithm) follows a simple round-robin strategy, which may optionally
be priority-based (set using the \texttt{Enable priority-based
  scheduling} option; see Section~\ref{sec:interp-gui}).

Note that if priority-based scheduling is used, the main thread
(i.e.\ the thread initiated by the user) \textit{always} has highest
priority, above and beyond any priorities specified in the priority
file.
#endif ENG

#ifdef JPN
次にどのスレッドをスケジューリングするかの選択（セカンダリのスケジューリングアルゴリズム
）は単純なラウンドロビンスケジューリングに従うが、これは任意でプライオリティベースのオプション
を選択することができる(\texttt{Enable priority-based
  scheduling} オプションを設定する。セクション~\ref{sec:interp-gui}を参照)。

プライオリティベースのスケジューリングが使われている場合、メインのスレッド（ユーザが開始した
スレッド）は\textit{常に}最上位のプライオリティとなる。プライオリティファイルで特定されるどんな
プライオリティよりも高い。 
#endif JPN

#endif VDMPP


% 
% %%%%%%% Next bit needs reinstating and updating when References
% %%%%%%% window is working -- RM 
%

% #ifdef VDMPP
% \newpage
% \subsection{The Inheritance Tool}\label{sec:inherit-ref}

% The \guicmd{Inheritance} tool shows the inheritance structure of
% \vdmslpp\ specifications. The inheritance tool can only be accessed
% using the graphical user interface of the \Toolbox.\index{Inheritance
%   Tool} It is invoked from the \guicmd{Tools} menu in the main window.
% A new window with an inheritance tree for the \vdmslpp\ specification
% will appear.  The inheritance tree presents information about all the
% classes which has been been accepted by the syntax checker. For
% illustration purposes a simple example is shown in
% Figure~\ref{fig:inhtree2}. This example is presented in plain ASCII
% format in Appendix~\ref{sec:inheritex}. The inheritance tree shows
% that {\tt A} is superclass to {\tt B} and {\tt C}, and that both {\tt
%   B} and {\tt C} and superclasses of {\tt D} (i.e.\ multiple
% inheritance). {\tt B} is also a superclass for {\tt E}. The {\tt F}
% class has no super- or subclasses.

% \begin{figure}[tbh]
% \begin{center}
% \resizebox{11cm}{!}{\includegraphics{inhtree2}}\
% \caption{The Inheritance Tree of the simple example\label{fig:inhtree2}}
% \end{center}
% \end{figure}

% Besides giving an overview of the inheritance structure of the
% specification, the inheritance tree can also be used to navigate
% through your specification. When a class is selected in the
% inheritance tree by clicking with the leftmost mouse button the class
% will also be selected in the main window of the \Toolbox.


% \newpage
% \subsection{The Dependency Tool}\label{sec:depend-ref}

% The \guicmd{Dependency Tool}\index{Dependency Tool} is capable
% for a selected class to show:
% \begin{itemize}
% \item its superclasses, 
% \item its subclasses,
% \item the classes it uses. A class uses another class if it has
%   references to other objects, for example through its instance
%   variables or operation calls.
% \item the classes which uses the class.
% \end{itemize}
% The information about the super- and sub-classes can also be seen from
% the \guicmd{Inheritance tool} (see Section~\ref{sec:inherit-ref}). However, the
% information about where a class is used and which classes it uses may
% be valuable for the developer.

% The dependency tool can only be accessed using the graphical user
% interface of the \Toolbox.\index{Dependency Tool} It is invoked from
% the \guicmd{Tools} menu in the main window. A new window with
% dependency information for the currently selected class will pop up.

% For illustration purposes a simple example is shown in
% Figure~\ref{fig:dep_sorter2}. This example is presented in plain ASCII
% format in Appendix~\ref{sec:inheritex}. Here the {\tt B} class is
% selected. It can be seen that {\tt B} has {\tt A} as superclass and
% {\tt D} and {\tt E} as subclasses. It uses the class {\tt F} via an
% instance variable. Likewise it is used in the class {\tt C} via an
% instance variable.

% \begin{figure}[tbh]
% \begin{center}
% \resizebox{9cm}{!}{\includegraphics{dependency2}}
% \caption{The Dependency Tool with a simple example\label{fig:dep_sorter2}}
% \end{center}
% \end{figure}

% Sometimes the selected class will be marked with a {\tt *}. This
% indicates that the information listed in the {\tt uses} and {\tt used
%   by} lists is not complete. This occurs in those cases where all the
% classes need to be type checked before the class dependencies can be
% inferred. (See Section~\ref{sec:tc}).
% The information shown will be correct, however, the lists might not
% include all the classes used.  Therefore, if you want to be sure
% that the information shown in the association lists is complete you
% should type check all your classes in the specification.

% As with the \guicmd{Inheritance Tool}, you can navigate through the
% specification in the \guicmd{Dependency Tool}. Just click on a class
% in the \guicmd{Dependency Tool} and that class will be selected, both
% in the main window, in the \guicmd{Dependency Tool} and in the
% \guicmd{Inheritance Tool} if it is open.

% The calculation of which classes use each other can be a CPU intensive
% task affecting the speed of syntax and type checking. To reduce this
% effect the information in the \guicmd{Dependency Tool} is updated only
% when it is opened in the \guicmd{Tools} menu or when the \guicmd{Update
%   Dependencies} button is pressed, not when syntax or type checking.

% #endif //VDMPP

\newpage
#ifdef ENG
\subsection{The Integrity Examiner}\label{sec:pog}
#endif ENG
#ifdef JPN
\subsection{証明課題生成機能}\label{sec:pog}
#endif JPN

#ifdef ENG
The integrity examiner analyses the specification looking for places
where run-time errors could potentially occur and generates a series
of integrity properties which, if true, are sufficient to ensure that
no run-time errors should occur. In all thirty different types of
integrity properties are checked by the examiner.

Thee integrity properties are presented as \vdmslpp\ predicates that 
involve quantification over all possible values of the appropriate
variables\footnote{In some cases the full context is not shown
  explicitly and the scope of some variables has to be determined by
  inspection of the specification.}, which means that if it can be
demonstrated that an integrity property is true there will not be
run-time errors associated with that integrity check whatever the
values of the variables involved. Of course if an integrity property
can instead be shown to be false this would point to there being a
potential problem with the corresponding part of the specification.

The integrity examiner can only be accessed from the graphical
interface. 

To run the integrity examiner, select the files or
\ifthenelse{\boolean{VDMsl}}{modules}{classes} (more than one, if you
wish) you want to run it on in the \guicmd{Project View} or the
\vdmModView\ of the \guicmd{Manager}, then press the
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{integritycheck.png}}  
(\guicmd{Generate Integrity Properties}) button on the (\guicmd{Actions})
toolbar. The \guicmd{Log Window} opens automatically (if it is not
already open) and displays information about the examination process
for each selected file or \ifthenelse{\boolean{VDMsl}}{module}{class}
in turn, and the \guicmd{Integrity Properties Window} opens and
displays the integrity properties generated. The \guicmd{Integrity
  Properties Window} is shown in Figure~\ref{fig:integWin2}.
#endif ENG

#ifdef JPN
証明課題生成機能は、仕様書の潜在的にランタイムエラーが起ころうる箇所を
調べ一連の証明課題を生成する。これはもしtrueであればランタイムエラーが起こりえないことを
保障するに十分なものである。この機能によって30の異なるタイプの証明課題がチェックされる。

証明課題は適切な変数\footnote{いくつかの場合においては、すべてのコンテクストが明確に示されず
  変数のスコープを仕様書の精査によって決定しなくてはならないこともある} のすべての値の数値化を含む
\vdmslpp\ の述部として表現されており、
これは証明課題がtrueだと証明された場合には変数にどんな値が含まれていようとも、
その課題関連のランタイムエラーはありえないことを意味する。もちろん、証明課題が
falseになることもあり、その場合は仕様書の該当する箇所に潜在的な問題があることを指摘
していることになる。

証明課題生成機能はGUIからのみ利用できる。

証明課題生成機能を使用するには、\guicmd{マネージャー},の\guicmd{プロジェクトビュー} または
\vdmModView\ でファイルや
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} （複数選択可）を選択し(\guicmd{アクション})ツールバーの 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{integritycheck.png}}  
(\guicmd{証明課題生成}) ボタンを押す。 （すでに開いていない場合）自動的に\guicmd{ログウインドウ} 
が開き、選択されたファイルまたは
\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} それぞれのテストの進行状況を順番に
表示し、\guicmd{証明課題ウインドウ} が開いて生成された証明課題が表示される。
\guicmd{証明課題ウインドウ} は図~\ref{fig:integWin2}に示す。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12.5cm]{integWin-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=12.5cm]{integWin-pp.png}
#endif VDMPP
#ifdef ENG
\caption{The Integrity Properties Window}
#endif ENG
#ifdef JPN
\caption{証明課題ウインドウ}
#endif JPN
\label{fig:integWin2}
\end{center}
\end{figure}

#ifdef ENG
The top pane of the \guicmd{Integrity Properties Window} shows a list
of the integrity properties together with information about their
status (the \guicmd{Checked} column), their position in the
specification (the \guicmd{Module}, \guicmd{Member} and
\guicmd{Location} columns) and 
their type (the \guicmd{Type} column). The numbers in the
\guicmd{Index} column simply serve to distinguish different integrity
properties which have the same position. Clicking on a list heading
orders the properties based on that particular attribute.

Selecting a particular integrity property in the top pane of the
window causes the corresponding \vdmslpp\ predicate to be displayed in
the bottom pane of the window. At the same time the cursor in the
\guicmd{Source Window} indicates the exact point in the specification to
which the selected integrity property relates. Each integrity property
can thus be inspected in order to try to determine whether or not it
is true. For a more detailed explanation of this, see the example in
Section~\ref{pogWalk}.

The buttons 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{up.png}} and
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{down.png}} on the
left-hand side of the top pane move the selection to the previous or
the next integrity property respectively, while the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{checkmark.png}}  
(\guicmd{Toggle Status}) button toggles the status of the selected
integrity property between checked and unchecked.

The
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{filter.png}}  
(\guicmd{Filter}) button is used in conjunction with the middle two
panes of the window to filter the list of integrity properties. The
left-hand pane of the two shows lists of the possible values for each
of 
the attributes, while the right-hand pane shows the particular values
of each attribute that the filter will use. Attribute values can be
added to or removed from the filter by selecting them in the
appropriate pane and pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{right.png}}  
(\guicmd{Add to Filter}) or the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{left.png}}  
(\guicmd{Remove from Filter}) button respectively. Pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{filter.png}}  
(\guicmd{Filter}) button then causes the list of integrity properties
to be filtered to show only those whose attributes match the selected
attribute values. When no attributes are selected no filter is used so
all integrity properties are shown.
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{filter.png}}
#endif ENG

#ifdef JPN
\guicmd{証明課題ウインドウ} の上部には証明課題の一覧が状態の情報（\guicmd{選択}欄）、
仕様書の箇所（\guicmd{モジュール}, \guicmd{メンバー}, \guicmd{位置} 欄）、型（\guicmd{型}欄）と一緒に
表示される。\guicmd{指標}欄の番号は、単に同じ箇所の違う証明課題を区別するために
振られた番号である。リストの先頭をクリックすると証明課題を特別な属性に基づいて
整列する。

ウインドウ上部の画面で証明課題を選択すると、下部の画面にそれに相当する
\vdmslpp\ の述部が表示される。同時に、ソースウインドウのカーソルが仕様書の
選択した証明課題が関連する箇所に移動する。証明課題はそれぞれtrueか
そうでないかを決定しようとするため詳細に調べられなくてはならない。
これについての詳細はセクション~\ref{pogWalk}に記述がある。

画面左の
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{up.png}} ,
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{down.png}} ボタンで
前／次の証明課題に移動できる。 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{checkmark.png}}  
(\guicmd{項目の選択/非選択})ボタンは選択された証明課題の状態をチェック済み／未チェックに変える。

(\guicmd{項目の絞込み}) ボタンは証明課題の一覧にフィルターをかけるためウインドウ
中ほどの2つの画面で連動して使われる。2つのうち左側の画面はそれぞれの
属性の可能な値のリストを表示し、右側の画面はフィルターが使う属性おのおのの
特定の値を表示する。属性の値は画面上で選択して%
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{right.png}}  
(\guicmd{選択した項目を追加}) または%
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{left.png}}  
(\guicmd{選択した項目を削除})ボタンを押すとフィルターに追加・削除できる。 %
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{filter.png}}  
(\guicmd{Filter}) ボタンを押すと証明課題の一覧がフィルターされ選択された値に%
マッチする属性のものしか表示されなくなる。属性が何も選択されていないときは、%
フィルターがかからないので証明課題はすべて表示される。
#endif JPN

\newpage
#ifdef ENG
\subsection{The Pretty Printer}\label{sec:pp}
#endif ENG
#ifdef JPN
\subsection{清書機能}\label{sec:pp}
#endif JPN

#ifdef ENG
The pretty printer transforms a specification from its input format to
a pretty printed version of the specification. Typically this pretty
printed version is used for documentation purposes. The output format
for the pretty printer depends on the input format of the
specification. If the input format is RTF the output format will also
be RTF. If the input format is a mixture of \LaTeX\ commands and
\vdmslpp\ specification the output format is a file which can be processed
by \LaTeX. 
The main difference between the layout of the
two different outputs produced by the pretty printer is that the one
to Microsoft Word uses the ASCII version of \vdmslpp\ whereas the
\LaTeX\ one uses a mathematical representation of \vdmslpp\ which
is used in most VDM text books and articles.

The pretty printer can construct cross-referenced indexes and can also
take test coverage information into account, both in the form of
colouring of the parts of the specification that have not been covered
and in the form of tables describing the percentage coverage of
functions and operations.

If your input files are in  RTF format, you can insert a table
summarising the percentage test coverage by including the name of the
\ifthenelse{\boolean{VDMsl}}{module}{class} written in the
\texttt{VDM\_TC\_TABLE} style at the desired position in the {\tt
  .rtf} file, and test coverage colouring information is written by the
pretty printer using the styles \texttt{VDM\_COV} and
\texttt{VDM\_NCOV}. All three styles are included in the {\tt VDM.dot} 
file\index{VDM.dot file} from the \Toolbox\ distribution.

The \LaTeX\ generator uses the \VdmSlPp\ macros together with the
appropriate corresponding style file:
\ifthenelse{\boolean{VDMsl}}{{\tt vdmsl.sty}\index{vdmsl.sty file}}{{\tt vpp.sty}\index{vpp.sty file}} for \LaTeX\ and 
{\tt vdmsl-2e.sty} for \LaTeX$2_{\varepsilon}$. These macros and style
files are also supplied as part of the \Toolbox\
distribution. Section~\ref{vdmtc} and Appendix~\ref{sec:latexANDvdm}
describe in detail how to set up the necessary \LaTeX\ environment for
using the generated \LaTeX\ file.

The testing facilities are discussed further in
Section~\ref{sec:testing}.

The pretty printer can be accessed from either the GUI, the
command line interface or the Emacs interface.
#endif ENG

#ifdef JPN
清書機能は仕様書を入力フォーマットから清書版に変更する。
この清書版は文書化の目的で使われることが多い。
清書機能の出力フォーマットは仕様書の入力フォーマットに依存する。
入力フォーマットがRTF形式ならば出力フォーマットもRTF形式となる。入力フォーマットが
 \LaTeX\ コマンドと\vdmslpp\ 仕様書の混合ならば、出力フォーマットは \LaTeX\ 形式と成る。
2つの清書機能の生み出す異なる出力結果のレイアウトの違いは、
Microsoft Wordが\vdmslpp\ のASCIIバージョンを使っているのに対し \LaTeX\ のほうはほとんどの
VDMのテキストや論文で使われている数学的表現の\vdmslpp\ を使っていることである。

清書機能は相互参照つきの索引を構築することができ、テストカバレッジ情報も
考慮に入れることができる。まだカバーされていない仕様書の一部が色つきになる形式と
関数・操作のカバレッジがパーセンテージで記述されているテーブル形式の両方で可能である。

入力ファイルがRTF形式の場合、\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} 名を含むことに
よって{\tt .rtf}ファイルの任意の場所に\texttt{VDM\_TC\_TABLE} 形式で書かれたテストカバレッジの
パーセンテージを要約したテーブルを
挿入することができ、清書機能が書いたテストカバレッジの色つきの情報は、
 \texttt{VDM\_COV}  、\texttt{VDM\_NCOV}形式を使っている。これら3つの形式は\Toolbox\ に含まれる
{\tt VDM.dot}ファイル\index{VDM.dotファイル}にincludeされている。

\LaTeX\ ジェネレータはVDM++-VdmSlマクロを適切な相当する形式のファイルに結合する
：\ifthenelse{\boolean{VDMsl}}{{\tt vdmsl.sty}\index{vdmsl.styファイル}}{{\tt vpp.sty}\index{vpp.styファイル}} for \LaTeX\ と 
{\tt vdmsl-2e.sty} for \LaTeX$2_{\varepsilon}$である。
これらのマクロとスタイルファイルは\Toolbox\ の一部として供給されてもいる。
セクション~\ref{vdmtc}と付録~\ref{sec:latexANDvdm}で、生成された\LaTeX\ ファイルを使用して
\LaTeX\ 環境をセットアップする方法の詳細について記述されている。

テストツールについてはセクション~\ref{sec:testing}でも論じられている。

清書機能はGUI、コマンドライン、Emacsいずれのインターフェースを使ってもアクセス可能である。
#endif JPN

#ifdef ENG
\subsubsection{The graphical user interface}
#endif ENG
#ifdef JPN
\subsubsection{GUI}
#endif JPN

#ifdef ENG
In order to invoke the pretty printer from the graphical user
interface, first select the files you want the \Toolbox\ to pretty
print in the \guicmd{Project View} of the
\guicmd{Manager}\footnote{You can alternatively select
  \ifthenelse{\boolean{VDMsl}}{modules}{classes} in the 
  \vdmModView\ of the \guicmd{Manager} and the pretty printer is
  then applied to the set of files which contain the selected
  \ifthenelse{\boolean{VDMsl}}{modules}{classes}. This of course means
  that if a particular file contains 
  more than one \ifthenelse{\boolean{VDMsl}}{module}{class} definition and you
  select only some of those \ifthenelse{\boolean{VDMsl}}{modules}{classes}
  then the other \ifthenelse{\boolean{VDMsl}}{modules}{classes} in the
  same file are implicitly included.}, then 
invoke the pretty printer by  pressing the  
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprint.png}}
(\guicmd{Pretty Printer}) button.
#endif ENG

#ifdef JPN
清書機能をGUIで起動するには、\guicmd{マネージャー}の\guicmd{プロジェクトビュー} %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% footnote begin here
\footnote{%
  \guicmd{マネージャー} の\vdmModView\ でも
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}を選択することができる。
  清書機能は実際には選択した
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}の含まれるファイル一式に
  適用される。これはもし特定のファイルが複数の
   \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}定義を含んでいて、そのうちの
  いくつかだけを選択していた場合には、暗黙のうちに同じ
  ファイルの他  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス}が処理に含まれることを意味する。
},%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% footnote end here
で\Toolbox\ に清書させたいファイルを選択し、 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{prettyprint.png}}
(\guicmd{清書}) ボタンを押すことで起動する。
#endif JPN

#ifdef ENG
\subsubsubsection{Setting options}
#endif ENG
#ifdef JPN
\subsubsubsection{オプション設定}
#endif JPN

#ifdef ENG
The pretty printer has a number of options which can be set in the 
\guicmd{Pretty printer} pane of the \guicmd{Project Options} window (see
Figure~\ref{fig:optpp}). These options are:
#endif ENG
#ifdef JPN
清書機能には\guicmd{プロジェクトオプション} ウインドウの\guicmd{清書} タブで設定できる
オプションがいくつかある。（図~\ref{fig:optpp}参照）これらは以下のとおり。
#endif JPN

\begin{list}{}{}

#ifdef ENG
\item[{\sf Output index of definitions}:] Produces an index for
  definitions of functions, operations, types,
  \ifthenelse{\boolean{VDMsl}}{states and modules}{instance variables
    and classes}. \\
  default: disabled.
  
\item[{\sf Output index of definitions and uses}:] Produces an index for
  definitions of functions, operations, types,
  \ifthenelse{\boolean{VDMsl}}{states and modules}{instance
    variables and classes}, and for used occurrences of types,
    functions and operations. The Microsoft Word pretty printer is not
    able to take any uses of constructs into account and thus there is
    no difference between this option and the first option under
    Windows.\\ 
  default: disabled.

\item[{\sf Test coverage colouring}:] This enables highlighting
  in colour of those parts of the specification which have not been
  executed during testing. The coverage information is written to the
  test coverage file along with the standard test coverage information
  if this option is enabled. \\
  default: disabled.
#endif ENG

#ifdef JPN
\item[{\guicmd{定義の索引を出力}}:]
  関数、操作、型、
   \ifthenelse{\boolean{VDMsl}}{状態、モジュール}{インスタンス変数、クラス} の定義のインデックスを生成する。\\
  デフォルト：無効
\item[{\guicmd{定義と仕様の索引を出力}}:]
  関数、操作、型、%
  \ifthenelse{\boolean{VDMsl}}{状態、モジュール}{インスタンス変数、クラス} の定義、型や関数・
  操作の使用された事象のインデックスを生成する。Microsoft Wordでは
  清書機能がこれらの使用のすべてを考慮に入れることができないため、Windows環境では
  このオプションと最初のオプションに差異はない。\\
  デフォルト：無効

\item[{\guicmd{テストカバレッジの色付け}}:]
  仕様書のうちテストされていない箇所をハイライト表示する。このオプションが有効なとき、
  カバレッジ情報は通常のカバレッジ情報と一緒にテストカバレッジファイルに書き込まれる。\\
  デフォルト：無効
#endif JPN

\end{list}

#ifdef ENG
Note that only one of the options {\sf Output index of definitions}
  and {\sf Output index of definitions and uses} can be enabled at any
  time.
#endif ENG
#ifdef JPN
いつでも、\guicmd{定義の索引を出力} と \guicmd{定義と仕様の索引を出力}のどちらか
だけが有効になることに注意。
#endif JPN

% teramoto ここまで見直し 06/09/15

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12cm]{ppOptions-sl.png}
#endif VDMSL
#ifdef PPONLY
\includegraphics[width=12cm]{ppOptions-pp.png}
#endif PPONLY
#ifdef VICEMAN
\includegraphics[width=12cm]{ppOptions-vice.png}
#endif VICEMAN
#ifdef ENG
\caption{Setting Pretty Printer Options}
#endif ENG
#ifdef JPN
\caption{清書機能のオプション設定}
#endif JPN
\label{fig:optpp}
\index{Options!Pretty Printer}
\end{center}
\end{figure}

#ifdef ENG
\subsubsection{The command line interface} \label{vdm2tex}
\index{Command Line Interface!Pretty Printer}
#endif ENG
#ifdef JPN
\subsubsection{コマンドラインインターフェース} \label{vdm2tex}
\index{コマンドラインインターフェース!せいしょ@清書}
#endif JPN

{\tt \vdmde\ -l [-nNr] specfile(s) ...}

\vspace{0.5cm}

\noindent
#ifdef ENG
With the {\tt -l} option {\tt \vdmde} takes a \vdmslpp\
specification as its input and generates a pretty printed
document. The format of this document depends on the
input format. If the input format was RTF the name of the output file
will be the same as the input file extended with {\tt .rtf}. This
generated file can stand alone and be taken into Microsoft Word
directly. If the input format is a mix of \LaTeX\ and \vdmslpp\ 
specification the name of the output file will be the same as the
input file extended with {\tt .tex}. This generated file(s) can be
included directly in any \LaTeX\ document.

The additional options which can be used with the pretty printer are:
#endif ENG

#ifdef JPN
{\tt \vdmde} に {\tt -l} オプションをつけると引数で指定した\vdmslpp\ 仕様書のファイルを入力ファイルとして
清書したドキュメントを作成する。作成される文書のフォーマットは入力フォーマットに
依存する。入力フォーマットがRTFの場合は、出力ファイルのファイル名は入力ファイルと
同じ名前に{\tt .rtf}がついた形となる。生成されたファイルは単独で直接Wordに取り込める。
入力フォーマットが\LaTeX\ と\vdmslpp\ 仕様書の混ざったものだった場合は出力ファイルの名前は
入力ファイルと同じ名前に{\tt .tex}がついた形となる。この生成されたファイルは直接\LaTeX\ 
文書として扱える。

清書機能で使用できるオプションは以下のとおり：
#endif JPN

\begin{description}

#ifdef ENG
\item[{\tt -r}] Runs the pretty printer, inserting additional coverage
  information obtained from the test coverage file. For \LaTeX\ 
  documents special macros are used in the specification to show which
  parts have or have not been exercised by the test suites.  In the
  current version the test coverage file\index{Test Coverage!File}
  must be called {\tt vdm.tc} 
  and it must be placed in the working directory (which can be found
  using the \texttt{pwd} command). The test
  coverage file will have been generated by running the syntax
  analyser with its own {\tt -R} option~(see Section~\ref{sec:parser}).
  
  Section~\ref{sec:latexANDvdm} describes in detail how to produce the
  test coverage report from the \LaTeX\ file produced by this command.

\item[{\tt -n}] For RTF documents this option will mark all
  function/operation definitions with indexes. Inside the generated
  {\tt .rtf} file you can then insert a table with all indexes by
  including the name of the
  \ifthenelse{\boolean{VDMsl}}{module}{class} written in the
  \texttt{VDM\_TC\_TABLE} style at the desired position.
  For \LaTeX\ documents the option inserts \LaTeX\ 
  macros around all definitions of functions, operations, types,
  states and modules to be used to generate an index.  Then an
  index can be produced using the {\tt makeindex} utility.

\item[{\tt -N}] For RTF documents this option is identical to the {\tt
    -n} option. For \LaTeX\ documents this option works as {\tt -n}
  but also inserts the macros around all applications of functions,
  operations, types and values. 
#endif ENG

#ifdef JPN
\item[{\tt -r}]
  テストカバレッジファイルから得られた追加のカバレッジ情報を挿入して清書機能を実行する。
  \LaTeX\ 文書には、テストスイートによってどの部分が実行されたかされていないかを示すための特別な
  マクロが使用される。現在のバージョンでは、テストカバレッジファイル\index{テストカバレッジ!ファイル}は
  {\tt vdm.tc}という名前でワーキングディレクトリ（\texttt{pwd}コマンドで表示される）になくてはならない。
  テストカバレッジファイルは構文チェック機能を{\tt -R}オプションつきで実行すると生成される
  （セクション~\ref{sec:parser}を参照）。
  
  セクション~\ref{sec:latexANDvdm} でこのコマンドで生成される\LaTeX\ ファイルからテストカバレッジレポートを
  生成する方法の詳細を記述している。

\item[{\tt -n}]
  RTF文書に対してはこのオプションは、すべての関数･操作の定義に
  索引をつける。生成された{\tt .rtf} ファイル内に\texttt{VDM\_TC\_TABLE} 形式で
  書かれた
  \ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} 名を
  含めることですべての索引つきのテーブルを好きな箇所に挿入する
  ことができる。\LaTeX\ 文書に対しては索引を生成するために使われるすべての
  関数、操作、型、状態モジュールの定義にはたらく\LaTeX\ マクロを挿入する。
  そうすると{\tt makeindex}ユーティリティを使って索引を生成することができる。

\item[{\tt -N}]
  RTF文書に対しては、{\tt -n}オプションと同様。\LaTeX\ 文書に対しては{\tt -n}オプションと
  同じように働くが、すべてのアプリケーションの関数、操作、型、値に対してはたらくマクロも挿入する。
#endif JPN

\end{description}

#ifdef ENG
\subsubsection{The Emacs interface}
#endif ENG
#ifdef JPN
\subsubsection{Emacsインターフェース}
#endif JPN

#ifdef ENG
In the Emacs interface there is only one command for the pretty
printer. This command is, for historical reasons, called \textbf{latex}
and, as for all other commands in the Emacs interface, it must be given at
the command prompt.
#endif ENG
#ifdef JPN
Emacsインターフェースでは、清書機能向けのコマンドは1つしかない。
このコマンドは歴史的な理由から\textbf{latex}と呼ばれており、Emacsインターフェースで使える
ほかのコマンドと同様コマンドプロンプトから入力しなくてはならない。
#endif JPN

\begin{description} 

#ifdef ENG
\item[latex (l) \mbox{[{\tt -nNr}]} {\tt file}] \index{latex command}\mbox{}\\
  The pretty printer is invoked with {\tt file}.  If the \LaTeX\ format is
  used the \vdmslpp\ 
  parts are typeset in the mathematical font with the \VdmSlPp\ 
  macros.  If text parts exist, these and the \vdmslpp\ parts
  (\VdmSlPp\ macros) are merged in the same order as in {\tt file}.
  By using the {\tt -n} or {\tt -N} option indexes for defined and
  used occurrences will be generated (see
  Appendix~\ref{sec:latexANDvdm}).
  
  The option {\tt -r} inserts coverage information collected in the
test coverage file {\tt vdm.tc}. For RTF documents
the styles {\tt VDM\_COV} and {\tt VDM\_NCOV} must be defined in the
input document.  For \LaTeX\ documents this option inserts colours in
the \VdmSlPp\ macros such that all specification parts which have not
been covered by the test suites are marked.
#endif ENG

#ifdef JPN
\item[latex (l) \mbox{[{\tt -nNr}]} {\tt file}] \index{latexコマンド}\mbox{}\\
  清書機能が{\tt file}とともに起動する。\LaTeX\ フォーマットが使われていた場合、
  \vdmslpp\ の部分が\vdmslpp\ の\VdmSlPp\ マクロで数学的なフォントとして表示される。
  テキストの部分があった場合、それらと\vdmslpp\ の部分（\vdmslpp\ の\VdmSlPp\ マクロ）は
  {\tt file}中と同じ順番でファイルにマージされる。{\tt -n}または{\tt -N}オプションを使うと定義され使用
  された発生事象に索引が振られる（付録~\ref{sec:latexANDvdm}を参照）。
  
{\tt -r}オプションはテストカバレッジファイルである{\tt vdm.tc}に集められたカバレッジ情報を
挿入する。RTF形式のドキュメントでは {\tt VDM\_COV} や{\tt VDM\_NCOV} 形式が入力文書で
定義されていなくてはならない。\LaTeX\ 文書ではこのオプションはすべてのテストスイートで
まだカバーできていないすべての仕様書の部分に印がつくように\VdmSlPp\ マクロで
色をつける。
#endif JPN

\end{description}


\newpage
#ifdef ENG
#ifdef VDMSL
\subsection{The VDM-SL to C++ Code Generator}\label{sec:cg}
#endif VDMSL
#ifdef VDMPP
\subsection{The VDM++ to C++ Code Generator}\label{sec:cg}
#endif VDMPP
#endif ENG

#ifdef JPN
#ifdef VDMSL
\subsection{VDM-SLからC++コード生成}\label{sec:cg}
#endif VDMSL
#ifdef VDMPP
\subsection{VDM++からC++コード生成}\label{sec:cg}
#endif VDMPP
#endif JPN

#ifdef ENG
If you have a license \index{License} for the \vdmslpp\ to C++
Code Generator you can have your specification automatically 
translated into C++ code by the \Toolbox. Here we only explain how the
code generator is invoked and what options it has; further details can
be found in \ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}.

The C++ code generator can be accessed either from the GUI, from the
command line version of the \Toolbox, or from the Emacs interface.
#endif ENG

#ifdef JPN
\vdmslpp\  からC++ へのコード生成のライセンス\index{ライセンス} を持っていれば、\Toolbox\ を
使って仕様書から自動的にC++のコードへ変換させることができる。ここではコードジェネ
レータの起動方法とどんなオプションがあるかについてのみ記述し、詳細は%
\ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}で説明する。

C++ へのコード生成機能はGUI、コマンドライン、Emacsの各インターフェースを使ってアクセスすることができる。
#endif JPN

#ifdef ENG
\subsubsection{The graphical user interface}
#endif ENG
#ifdef JPN
\subsubsection{GUI}
#endif JPN

#ifdef ENG
In order to invoke the C++ code generator from the graphical user
interface, first use the \guicmd{Manager} to select the files or
classes you want the \Toolbox\ to translate, then invoke the
translator by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cplusplus.png}}
(\guicmd{Generate C++}) button. More than one file/class can be
selected, in which case all of them are translated to C++.

The following options for the code generator can be set via the
\guicmd{C++ code generator} pane of the \guicmd{Project Options} window
which is shown in Figure~\ref{fig:optccg}:
#endif ENG

#ifdef JPN
GUIでC++へのコード生成機能は、まずマネージャで
ツールボックスに変換させたいファイルまたはクラスを選択し、 
(\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{cplusplus.png}}
(\guicmd{C++生成}) ボタンを押すことで起動する。
ファイル/クラスが複数選択されていた場合、それらすべてがC++に変換される。

以下のコード生成向けオプションは、図~\ref{fig:optccg}で示す\guicmd{プロジェクトオプション} ウインドウの
\guicmd{C++コード生成} タブで設定することができる。
#endif JPN

\begin{description}

#ifdef ENG
\item[Output position information] Causes the code
  generator to generate code containing position information for
  run-time errors. \\
  Default: \texttt{off}. 
\item[Check pre and post conditions] Causes the code
  generator to generate code containing in-line checks of
  preconditions and postconditions of functions and of preconditions
  of operations. \\
  Default: \texttt{on}. 
#endif ENG

#ifdef JPN
\item[位置情報を出力する]
  ランタイムエラーのための位置情報を含むコードを生成させる。 \\
  デフォルト：\texttt{off}
\item[事前／事後条件をチェックする]
  関数の事前条件と事後条件、操作の事前条件のインラインチェックを含むコードを生成させる。 \\
  デフォルト：\texttt{on}
#endif JPN

\end{description}

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=12cm]{ccgOptions-sl.png}
#endif VDMSL
#ifdef PPONLY
\includegraphics[width=12cm]{ccgOptions-pp.png}
#endif PPONLY
#ifdef VICEMAN
\includegraphics[width=12cm]{ccgOptions-vice.png}
#endif VICEMAN
#ifdef ENG
\caption{Setting Options for the C++ Code Generator}
#endif ENG
#ifdef JPN
\caption{C++コード生成オプション設定}
#endif JPN
\label{fig:optccg}
\index{Options!C++ Code Generator}
\end{center}
\end{figure}

#ifdef ENG
\subsubsection{The command line interface}
\index{Command Line Interface!C++ code generator}
#endif ENG
#ifdef JPN
\subsubsection{コマンドラインインターフェース}
\index{コマンドラインインターフェース!C++コードせいせい@C++コード生成}
#endif JPN

{\tt \vdmde\ -c [-r] specfile, ...}

#ifdef ENG
With the {\tt -c} option {\tt \vdmde} generates code from the given
{\tt specfile}(s). The specification is first parsed. Then, if no syntax
errors are detected, the specification is type checked for possible
well-formedness.\index{Possible Well-formedness} Finally, if no type
errors are detected, the specification is translated into a number of
C++ files.\index{C++ Files} The structure of the generated code and
how to interface it are described in
\ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}.

One additional option can be used with the \vdmslpp\ to C++ Code
Generator:
#endif ENG

#ifdef JPN
{\tt vdmde}コマンドに{\tt -c}オプションをつけると、{\tt specfile}からコードを生成する。
仕様書はまず解析され、構文エラーがなければ'pos''タイプの
型チェック\index{posがた@pos型} がされる。最後に、型エラーが見つからなければ仕様書がたくさんの
C++ファイル\index{C++ファイル} に変換される。生成されたコードの構造とその結び付け方は
\ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}に記述されている。

\vdmslpp\ からC++へのコード生成では追加のオプションがひとつ使用可能である。
#endif JPN

\begin{description}
#ifdef ENG
\item[{\tt -r}] Includes run-time position information in the
  generated C++ code (for a detailed description see
  \ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}).
#endif ENG
#ifdef JPN
\item[{\tt -r}]
  ランタイム位置情報を生成したC++コードに含める（詳細は
  \ifthenelse{\boolean{VDMsl}}{\cite{CGMan-CSK}}{\cite{CGManPP-CSK}}参照）
#endif JPN
\end{description}

#ifdef ENG
\subsubsection{The Emacs interface}
#endif ENG
#ifdef JPN
\subsubsection{Emacsインターフェース}
#endif JPN

#ifdef ENG
In the Emacs interface there is only one command for the code generator.
This command is called \textbf{codegen}
and, as for all other commands in the Emacs interface, it must be given at
the command prompt.
#endif ENG
#ifdef JPN
Emacsインターフェースではコード生成向けに使えるコマンドは1つしかない。
このコマンドは\textbf{codegen}と呼ばれEmacsインターフェースで使えるほかのコマンドと
同様コマンドプロンプトから入力しなくてはならない。
#endif JPN

\begin{description}
#ifdef ENG
\item[*codegen (cg) \ifthenelse{\boolean{VDMsl}}{{[}{\tt
      module}{]}}{{\tt class}} {[}{\tt rti}{]}] \index{codegen command}  \mbox{}\\
  This command generates C++ code for the
  \ifthenelse{\boolean{VDMsl}}{module {\tt module}. If no module is
    supplied code is generated for the current module}{class {\tt class}}.
  If the option {\tt rti} is used run-time
  position information is included in the generated code.
#endif ENG
#ifdef JPN
\item[*codegen (cg) \ifthenelse{\boolean{VDMsl}}{{[}{\tt
      module}{]}}{{\tt class}} {[}{\tt rti}{]}] \index{codegenコマンド}
  \mbox{}\\
  \ifthenelse{\boolean{VDMsl}}
  {モジュール {\tt module}.(何も指定されていない場合、現在のモジュール) }
  {クラス {\tt class}}.  
  のC++コードを生成する。rtiオプションが使われるとランタイム位置情報が生成したC++コードに含まれる。
#endif JPN
\end{description}

\newpage
#ifdef VDMPP
#ifdef ENG
\subsection{The VDM++ to Java Code Generator}\label{sec:cgjava}
#endif ENG
#ifdef JPN
\subsection{VDM++からJavaへのコード生成}\label{sec:cgjava}
#endif JPN

#ifdef ENG
If you have a license \index{License} for the \vdmslpp\ to Java
Code Generator you can have your specification automatically 
translated into Java code by the \Toolbox. Here we only explain how the
code generator is invoked and what options it has; further details can
be found in~\cite{CGJavaManPP-CSK}.

The Java code generator can be accessed either from the GUI, from the
command line version of the \Toolbox, or from the Emacs interface.
#endif ENG

#ifdef JPN
\vdmslpp\ からJava へのコード生成のライセンス\index{ライセンス}を持っていれば、\Toolbox\ を
使って仕様書から自動的にJavaのコードへ変換させることができる。ここではコード生成の
起動方法とどんなオプションがあるかについてのみ記述し、詳細は\cite{CGJavaManPP-CSK}で説明する。

Javaへのコード生成機能はGUI、\Toolbox\ のコマンドライン版、Emacsの各インターフェースを使って
アクセスすることができる。
#endif JPN

#ifdef ENG
\subsubsection{The graphical user interface}
#endif ENG
#ifdef JPN
\subsubsection{GUI}
#endif JPN

#ifdef ENG
In order to invoke the Java code generator from the graphical user
interface, first use the \guicmd{Manager} to select the files or
classes you want
the \Toolbox\ to translate, then invoke the translator by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java.png}}
(\guicmd{Generate Java}) button. More than one file/class can be
selected, in which case all of them are translated to Java.

The following options for the code generator can be set via the
\guicmd{Java code generator} pane of the \guicmd{Project Options} window
which is shown in Figure~\ref{fig:optjcg}:
#endif ENG

#ifdef JPN
Javaのコード生成をGUIで起動するためには、まず\guicmd{マネージャー} を使って
\Toolbox\ に変換させたいファイルまたはクラスを選択し、
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java.png}}
(\guicmd{Java生成}) ボタンを押して生成を起動させる。
複数ファイル/クラスを選択することもでき、すべてJavaに変換される。

以下のコード生成向けオプションは図~\ref{fig:optjcg}で示す\guicmd{プロジェクトオプション} ウインドウの
\guicmd{Javaコード生成} タブで設定できる。
#endif JPN

\begin{description}

#ifdef ENG
\item[Generate only skeletons, except for types] Causes the code
  generator to generate only skeleton classes, i.e.\ classes which
  contain full definitions of types, values and instance variables but
  empty definitions of functions and operations. \\
  Default: \texttt{off}.
\item[Generate only types] Causes the code generator to generate only
  code corresponding to VDM++ type definitions, i.e.\ values, instance
  variables, functions and operations are ignored. \\
  Default: \texttt{off}.
\item[Generate integers as longs] Causes the code generator to convert
  VDM++ integer values and variables to Java longs instead of Java
  integers. \\
  Default: \texttt{off}.
\item[Generate code with concurrency constructs] Causes the code
  generator to generate code which includes support for concurrency. \\
  Default: \texttt{on}.
\item[Generate pre and post functions/operations] Causes the code
  generator to generate code corresponding to preconditions,
  postconditions. \\
  Default: \texttt{on}.
\item[Check pre and post conditions] Causes the code
  generator to generate code containing in-line checks of
  preconditions and postconditions of functions and of preconditions
  of operations. \\
  Default: \texttt{on}.
\item[Disable generate ``vdm\_'' prefix] Causes the code
  generator to generate code without the ``\texttt{vdm\_}'' prefix in
  front of the user defined operations and functions. This can be
  convenient if for example one wishes to overload operations already
  defined in Java.
\item[Selection of interface] in case multiple inheritance is present in
  a VDM++ model it is necessary to reduce this for the Java code
  generation to single inheritance. This must be done by turning some
  of the classes to be translated to interfaces in Java. If that
  cannot be done it may be necessary to restructure the VDM++ model
  before it can be generated to Java.
\item[Package for generated code] can be used in case the user wishes
  the selected classes to be generated to a particular Java package.
#endif ENG

#ifdef JPN
\item[型以外は骨組みのみ生成する]
  コード生成にクラスのスケルトンのみを生成させる（型、値、インスタンス
  変数の定義をフルに含むが関数や操作の定義は何もないクラス）。 \\
  デフォルト：\texttt{off}
\item[型のみ生成する]
  VDM++の型定義に相当するコードのみ生成する。（値、インスタンス変数、関数、操作は無視される） \\
  デフォルト：\texttt{off}
\item[整数はlong型で生成する]
  VDM++のinteger値と変数をJavaのintegerの代わりにlongに変換する。 \\
  デフォルト：\texttt{off}
\item[並列構成でコードを生成する]
  並行処理のサポートを含むコードを生成する。 \\
  デフォルト：\texttt{on}
\item[事前／事後条件函数を生成する]
  事前条件、事後条件に相当するコードを生成する。 \\
  デフォルト：\texttt{on}
\item[事前／事後条件をチェックする]
  関数の事前条件と事後条件、操作の事前条件のインラインチェックを含むコードを生成させる。 \\
  デフォルト：\texttt{on}
\item[名前の前に ``vdm\_'' を付加しないで生成する]
  ユーザが定義した操作と関数の名前の前に ``\texttt{vdm\_}'' を追加しないでコード生成をする。
  これは、もしJavaで定義済みの関数をオーバーロードするような時に便利である場合がある。
\item[インターフェースの選択]
  VDM++モデルにおいて多重継承されている時に、それをJavaコード生成用に単一継承にさせるために必要。
  もしそれができない場合は、Javaコード生成する前にVDM++モデルを再構築する必要がある場合がある。
\item[パッケージ]
  選択されたクラスを特定のJavaパッケージに生成したい場合に使用することができる。
#endif JPN
\end{description}

#ifdef ENG
In addition it is possible to select which classes in the
specification are to be converted to Java interfaces, and to give the
name for the package which the code generator creates to hold the Java
code it generates.
#endif ENG

#ifdef JPN
加えて、仕様書のどのクラスをJavaインターフェースに変換するか選択し、コード生成が
Javaコードを保存するために生成したパッケージに名前をつけることができる。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VICEMAN
\includegraphics[width=12cm]{jcgOptions-vice.png}
#else
\includegraphics[width=12cm]{jcgOptions.png}
#endif VICEMAN
#ifdef ENG
\caption{Setting Options for the Java Code Generator}
#endif ENG
#ifdef JPN
\caption{Javaコード生成のオプション設定}
#endif JPN
\label{fig:optjcg}
\index{Options!Java Code Generator}
\end{center}
\end{figure}

#ifdef ENG
\subsubsection{The command line interface}
\index{Command Line Interface!Java code generator}
#endif ENG
#ifdef JPN
\subsubsection{コマンドラインインターフェース}
\index{コマンドラインインターフェース!Javaコードせいせい@Javaコード生成}
#endif JPN

{\tt \vdmde\ -j [options] specfile, ...}

#ifdef ENG
With the {\tt -j} option {\tt \vdmde} generates code from the given
{\tt specfile}(s). The specification is first parsed. Then, if no
syntax errors are detected, the specification is type checked for
possible well-formedness.\index{Possible Well-formedness} Finally,
if no type errors are detected, the specification is translated into a
number of Java files.\index{Java Files} The structure of the generated
code and how to interface it are described in~\cite{CGJavaManPP-CSK}. The
different options available are also listed there.
#endif ENG

#ifdef JPN
{\tt -j}オプションをつけると {\tt \vdmde} コマンドは{\tt specfile}からJavaのコードを生成する。
仕様書はまず解析される。構文エラーがみつからなければ、'pos''タイプの \index{posがた@pos型}
型チェックがされる。型エラーが見つからなければ、最後に仕様書が多くのJava
ファイルに変換される。生成されたコードの構造とその結び付け方は~\cite{CGJavaManPP-CSK}に
記述されている。他の利用可能なオプションの一覧もそちらにある。
#endif JPN

#ifdef ENG
\subsubsection{The Emacs interface}
#endif ENG
#ifdef JPN
\subsubsection{Emacsインターフェース}
#endif JPN

#ifdef ENG
In the Emacs interface there is only one command for the Java code generator.
This command is called \textbf{javacg}
and, as for all other commands in the Emacs interface, it must be given at
the command prompt.
#endif ENG
#ifdef JPN
Emacsインターフェースからは、Javaコード生成向けのコマンドは1つしかない。
このコマンドは\textbf{javacg}と呼ばれ、他のEmacsインターフェースのコマンドと同じように
コマンドプロンプトから入力しなくてはならない。
#endif JPN

\begin{description}
#ifdef ENG
\item[*javacg (jcg) {\tt class} {[}{\tt options}{]}] \index{javacg command}  \mbox{}\\
  This command generates Java code for the class {\tt class}.
#endif ENG
#ifdef JPN
\item[*javacg (jcg) {\tt class} {[}{\tt options}{]}] \index{javacgコマンド}
  \mbox{}\\
  クラス{\tt class}のJavaコードを生成する。
#endif JPN
\end{description}
#endif VDMPP

\newpage
#ifdef ENG
\subsection{Systematic Testing of VDM models}\label{sec:testing}
\label{vdmtc}\index{Testing|see {\\ Test Coverage}}\index{Test Coverage} 
#endif ENG
#ifdef JPN
\subsection{VDMモデルの体系的テスト}\label{sec:testing}
\label{vdmtc}\index{テスト|see{\\ テストカバレッジ}}\index{テストカバレッジ} 
#endif JPN

#ifdef ENG
As part of its support for validation, the \Toolbox\ provides a
facility for testing \vdmslpp\ specifications, including test
  coverage measurement.  Test coverage measurement helps you to see
how well a given test suite\index{Test Suite|see {\\ Test Coverage, \\ 
Test suite}}\index{Test Coverage!Test suite} covers the
specification. This is done by collecting together in a special 
test coverage file\index{Test Coverage!File} information  about which
statements and expressions are 
evaluated during the execution of the test suite. The approach
described here is a script-based one and is intended for application
involving a large number of test cases. The approach described in
Section~\ref{sec:guidedtour} using the \texttt{tcov} command is better
suited to a small number of test cases.
#endif ENG

#ifdef JPN
評価をサポートするものの一部として、\Toolbox\ は\vdmslpp\ 仕様書のテストの
便利ツールを提供する。これにはテストカバレッジの計測も含まれる。
テストカバレッジの計測は与えられたテストスイート\index{テストスイート|see {\\ テストカバレッジ, \\ テストスイート}}
\index{テストカバレッジ!テストスイート} がどのくらい仕様書をカバーできているか
を見る手助けになる。これはテストスイートの実行中に評価された命令文や式についての
特別なテストカバレッジファイル\index{テストカバレッジ!ファイル} 情報を集めたことによってなされる。
ここで記述されるアプローチはスクリプトベースのものであり、アプリケーションに多くのテストケースをさせる
ことを意図したものである。セクション~\ref{sec:guidedtour} で記述された\texttt{tcov}コマンドを
使ったアプローチはテストケースが少ないとき向けである。
#endif JPN

\begin{figure}[tbh]
\begin{center}
\includegraphics[width=10cm]{testenv.png}
#ifdef ENG
\caption{Systematic test of VDM models}
#endif ENG
#ifdef JPN
\caption{VDMモデルの体系的テスト}
#endif JPN
\label{fig:testenv}
\end{center}
\end{figure}

#ifdef ENG
There are three steps involved in producing a test coverage
report~(see Figure~\ref{fig:testenv}):
#endif ENG
#ifdef JPN
テストカバレッジリポートを作成するには3つのステップがある（図~\ref{fig:testenv}参照）
#endif JPN

\begin{enumerate}

#ifdef ENG
\item Prepare a {\em test coverage file}\index{Test Coverage!File}.
  \vdmslpp\ files in one of the input formats are first given to the
  \vdmslpp\ parser with a special option. This produces a test
  coverage file which contains information about the specification's
  structure but with none of the  definitions covered yet.

\item The \vdmslpp\ interpreter is called with a number of arguments
   which are placed in small {\em argument files\/}. The interpreter is used
  with all the specification files and the test coverage file and
  then, in addition to returning the result of evaluating the argument
  file, it updates the test coverage file with information about how
  often the different constructs have been exercised. The call of the
  interpreter is repeated with all the arguments in the test
  environment one wishes to take into account.
  
\item Finally the pretty printer is used with a special option which
  takes all the specification files and the test coverage file as
  input and 
  produces a pretty printed version of the specification showing the
  detailed test coverage information from the test coverage file.
  Note that in the input \vdmslpp\ specification files only the
  textual parts which do not contain \vdmslpp\ definitions can be
  updated while this process is going on. If changes to the \vdmslpp\ 
  parts happen the test coverage file does not know how to map its
  information back to the \vdmslpp\ specification files. Note also that on
  Windows the current version of the \Toolbox\ requires that the test
  coverage file must be called \texttt{vdm.tc} and must be
  placed in the working directory.
#endif ENG

#ifdef JPN
\item
  {\em test coverage file}\index{テストカバレッジ!ファイル}を用意する。片方の入力フォーマットの
  \vdmslpp\ のファイルはまず特別なオプションつきの\vdmslpp\ 構文解析ツールに渡される。
  これが仕様書の構造についての情報は含むが何の定義も含まないテストカバレッジ
  ファイルを生成する。

\item
  \vdmslpp\ インタープリタがたくさんの小さいファイルを引数として呼ばれる。
  インタープリタはすべての仕様書ファイルとテストカバレッジファイル、それに加えて
  評価結果を返す引数ファイルに使用され、テストカバレッジファイルの異なる構成物が
  どれぐらいの頻度で実行されたかについての情報を更新する。インタープリタはテスト環境で
  考慮の対象となる程度まで繰り返し呼び出される。
  
\item
  最後に、すべての仕様書ファイルとテストカバレッジファイルを入力して、テスト
  カバレッジ情報の詳細を示す仕様書の清書版を生成する
  特別なオプションつきで清書機能が使用される。\vdmslpp\ 仕様書の入力
  ファイルでは\vdmslpp\ の定義を含まないテキスト形式の部分だけがこのプロセス
  実行中に更新されることに注意。もし\vdmslpp\ 部分の変更があっても、テストカ
  バレッジファイルはその情報をどのように\vdmslpp\ の仕様書ファイルに反映したら
  よいかわからない。ウインドウズ上、ツールボックスの現在のバージョンではテスト
  カバレッジファイルが\texttt{vdm.tc} という名前にしておかなくてはならず、ワーキングディ
  レクトリにおいておかなくてはならない。
#endif JPN

\end{enumerate}


#ifdef ENG
\subsubsection{Preparing the test coverage file}
#endif ENG
#ifdef JPN
\subsubsection{テストカバレッジファイルの準備}
#endif JPN

#ifdef ENG
The generation of the test coverage information must be performed in a
command prompt (under Windows this can be obtained by selecting the
command prompt in the programs entry in the Windows setup; under
Unix this is done in a normal shell). The parser must be invoked with
 the {\tt -R} option. See
Section~\ref{subsec:parcom} for details of the parameters to be used.
#endif ENG
#ifdef JPN
テストカバレッジ情報を生成するにはコマンドプロンプトから実行しなければならない
（ウインドウズ上ではウインドウズセットアップのプログラム一覧からコマンドプロンプトを
選択、Unixでは通常のシェル）。構文解析ツールは{\tt -R} オプションで起動する。
パラメータの詳細についてはセクション~\ref{subsec:parcom}を参照のこと。
#endif JPN

#ifdef ENG
Example:
#endif ENG
#ifdef JPN
例：
#endif JPN
#ifdef VDMSL
\begin{verbatim}
 "vdmhome/bin/vdmde" -p -R vdm.tc sort.rtf
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
 "vpphome/bin/vppde" -p -R vdm.tc Sorter.rtf DoSort.rtf ExplSort.rtf
 ImplSort.rtf MergeSort.rtf SortMachine.rtf
\end{verbatim}
#endif VDMPP

#ifdef ENG
\subsubsection{Updating the test coverage file}
#endif ENG
#ifdef JPN
\subsubsection{テストカバレッジファイルの更新}
#endif JPN

#ifdef ENG
A test suite is normally structured into a hierarchy of directories
where small argument files are placed in different categories
depending upon what they are meant to test.  In a development project
you will wish to set up such a test environment and also make
a small script file which will automate the testing process and even
compare the actual results against expected results. In
Appendix~\ref{sec:testscript} 
there is an example of such a script file for both Windows and Unix.
The test script must then call the command line interface of the
\Toolbox\ with the {\tt -R} option. See Section~\ref{subsec:intercom}
for details of the parameters to be used.
#endif ENG
#ifdef JPN
テストスイートは通常ディレクトリ階層で構成され、これは小さい引数となるファイルが
テストされることになっているものに依存する異なるカテゴリーに置かれている。
開発中のプロジェクトでは、このようなテスト環境を構築し、テストプロセスを自動化する
スクリプトファイルを作成し、期待される結果と実際の結果を比較することが
望ましい。付録~\ref{sec:testscript} には、ウインドウズおよびUnix両方に向けたこのようなスクリプトファイルの
例がある。テストスクリプトはツールボックスのコマンドラインインターフェースから{\tt -R}オプション
つきで呼ばれなくてはならない。使用可能な引数の詳細はセクション~\ref{subsec:intercom}を参照のこと。
#endif JPN

#ifdef ENG
Example:
#endif ENG
#ifdef JPN
例：
#endif JPN
#ifdef VDMSL
\begin{verbatim}
  "vdmhome/bin/vdmde" -i -R vdm.tc -O sort.res sort.arg sort.rtf
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
  "vpphome/bin/vppde" -i -R vdm.tc -O dosort.res sort.arg 
  Sorter.rtf DoSort.rtf ExplSort.rtf ImplSort.rtf MergeSort.rtf 
  SortMachine.rtf 
\end{verbatim}
#endif VDMPP

#ifdef ENG
\subsubsection{Producing the test coverage statistics}
#endif ENG
#ifdef JPN
\subsubsection{テストカバレッジの統計データ作成}
#endif JPN

#ifdef ENG
The result of running such a test suite can be displayed by using the
pretty printer with appropriate options enabled.  The pretty printer
can be accessed from the graphical user interface, the command
line interface and the Emacs interface. The important thing to
remember is to use the option which enables coverage information to be
incorporated. See Section~\ref{sec:pp} for details of the
parameters to be used.
#endif ENG
#ifdef JPN
このようなテストスイートの実行結果は適切なオプションを有効にしていれば清書機能を
使って表示することができる。清書機能はGUIおよびコマンドライン、Emacsの各インター
フェイスを使ってアクセス可能である。組み込まれているカバレッジ情報を有効にするオプションを
使うことが大切である。　利用可能な引数の詳細については、セクション~\ref{sec:pp}を参照のこと。
#endif JPN

#ifdef ENG
Example:
#endif ENG
#ifdef JPN
例：
#endif JPN
#ifdef VDMSL
\begin{verbatim}
  "vdmhome/bin/vdmde" -lr sort.rtf
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
  "vpphome/bin/vppde" -lr Sorter.rtf DoSort.rtf
  ExplSort.rtf ImplSort.rtf MergeSort.rtf SortMachine.rtf
\end{verbatim}
#endif VDMPP

#ifdef ENG
In the pretty printed version of the files which are generated it is
possible to see tables of the percentage coverage of the functions
and operations in the specification. In addition detailed test
coverage information showing how parts of functions and operations
have been covered by the tests is available.

The \textbf{rtinfo} command, which can be input either through the command
line interface or in the \guicmd{Dialog} pane of the interpreter in  the
graphical user interface, displays test coverage information as
explained below:
#endif ENG

#ifdef JPN
生成された清書版のファイルでは、仕様書の関数および操作の
カバレッジのパーセンテージのテーブルを表示することができる。加えて、そのテストでどのぐらいの
関数と操作がカバーできているかを示す詳細なテストカバレッジ情報も利用できる。

コマンドラインインターフェースからでもGUIのインタープリタの\guicmd{Dialog} 画面からでも
入力できる\textbf{rtinfo}コマンドは、下記で説明するようにテストカバレッジ情報を表示する。
#endif JPN

\begin{description}

#ifdef ENG
\item[rtinfo {\tt vdm.tc}] \index{rtinfo command}\mbox{}\\ Before
  applying this command run-time information must have been collected
  in the test suite {\tt vdm.tc}. The test suite is read and an
  overview of all functions and operations is displayed. For
  each element in this list, the number of times that element has been
  evaluated and the percentage coverage of its definition are
  shown. (This percentage is the  
  number of covered expressions in the function/operation divided by the
  total number of expressions.)  The total coverage of the
  test coverage file, which is the average of all the percentages in
  the list, is also shown.
#endif ENG

#ifdef JPN
\item[rtinfo {\tt vdm.tc}] \index{rtinfoコマンド}\mbox{}\\
  このコマンドを適用する前に、テストスイートの {\tt vdm.tc}にランタイム情報が収集されて
  いなくてはならない。テストスイートは読み込まれ、すべての関数と操作の
  概要が表示される。リストの項目それぞれに対して、評価の回数と定義のカバレッジの
  パーセンテージが表示される（このパーセンテージは、評価済みの関数/操作
  の式の数を式の数すべてで割ったもの）。リストのすべてのパーセンテージの平均だが、
  テストカバレッジファイルの全部のカバレッジも表示される。
#endif JPN

\end{description}

#ifdef ENG
\subsubsection{Test coverage example using \LaTeX\ }
\label{sec:testcoverage}
%\index{run-time information|see{test coverage information}}
\index{Test Coverage} \index{Test Coverage!Examples}
#endif ENG
#ifdef JPN
\subsubsection{\LaTeX\ を使ったテストカバレッジ例}
\label{sec:testcoverage}
%\index{run-time information|see{test coverage information}}
\index{テストカバレッジ} \index{テストカバレッジ!れい@例}
#endif JPN

#ifdef ENG
The way the different parts of the \vdmslpp\ input files differ with
respect to test coverage depends on the input format. An example
illustrating how to incorporate test coverage information into RTF
files was presented in Section~\ref{tour:testing}. The process for \LaTeX\
files is quite different and is illustrated here for one of the sorting
algorithms specified in the sorting example used throughout this
manual.  The specification can be found in the
\ifthenelse{\boolean{VDMsl}}{{\tt {\vdmhome}/examples/sort/sort.vdm}
  file}{{\tt {\vdmhome}/examples/sort/*.vpp} files}.

In this small example
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort([-12,0,45])}}{{\tt new
    DoSort().Sort([-12,5,45])}} will be evaluated 
    to show how well this small test covers the specification of
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}}{the {\tt DoSort} class}.

The first step is to generate a test suite file using the parser:
#endif ENG

#ifdef JPN
入力フォーマットに依存するテストカバレッジについて、\vdmslpp\ 入力ファイルの異なる部分のやり方が違う。
テストカバレッジ情報のRTFファイルへの組み込み方を示す例がセクション~\ref{tour:testing}にある。
\LaTeX\ ファイルのプロセスは全く異なり、ここではこのマニュアルを通じて使用されているSortingの
例であらわあされうソートのアルゴリズムのひとつで説明する。仕様書は
\ifthenelse{\boolean{VDMsl}}{{\tt {\vdmhome}/examples/sort/sort.vdm}
  ファイル}{{\tt {\vdmhome}/examples/sort/*.vpp} ファイル}.にある。

この例では、
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort([-12,0,45])}}{{\tt new
    DoSort().Sort([-12,5,45])}} 
が
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}}{{\tt DoSort} クラス}
の仕様書のどの程度をカバーするかを示すため評価される

まずは構文解析ツールを使ってテストスイートを生成する。
#endif JPN

#ifdef VDMSL
\begin{alltt}
prompt> \vdmde\ -p -R vdm.tc sort.vdm
Parsing and installing "./sort.vdm" ...
prompt>
\end{alltt}
#endif VDMSL
#ifdef VDMPP
\begin{alltt}
prompt> \vdmde\ -p -R vdm.tc sorter.vpp dosort.vpp
Parsing "sorter.vpp" ... done
Parsing "dosort.vpp" ... done
prompt>
\end{alltt}
#endif VDMPP

#ifdef ENG
It is now possible to evaluate the argument file {\tt sort.arg},
which contains a call to the \ifthenelse{\boolean{VDMsl}}{{\tt
    DoSort}}{{\tt DoSort.Sort}} \vdmslpp\ 
\ifthenelse{\boolean{VDMsl}}{function}{operation}:
#endif ENG

#ifdef JPN
これでargumentファイル {\tt sort.arg}を評価することができるようになった。
このファイルには\vdmslpp\
\ifthenelse{\boolean{VDMsl}}{関数}{操作}:
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}}{{\tt DoSort.Sort}}
の呼び出しが含まれている。
#endif JPN

#ifdef VDMSL
\begin{alltt}
prompt> \vdmde\ -i -R vdm.tc sort.arg sort.vdm
Evaluating the arguments ...

The expression evaluates to :
[ -12,0,45 ]
prompt>
\end{alltt}
#endif VDMSL
#ifdef VDMPP
\begin{alltt}
prompt> \vdmde\ -i -R vdm.tc sort.arg sorter.vpp dosort.vpp
Initializing specification ... 
[ -12,5,45 ]
prompt>
\end{alltt}
#endif VDMPP

#ifdef ENG
When the interpreter is called with the {\tt 
-R} option, it updates the test coverage file named {\tt vdm.tc}.

Now the level of coverage of the \ifthenelse{\boolean{VDMsl}}{sorting
  specification}{{\tt DoSort} class} which has just been recorded in
  the file {\tt vdm.tc} can be shown in the \Toolbox.  A
table listing all the functions and operations in the specification
together with the number of times they have been called and the
percentage of coverage can be shown using the {\cmd rtinfo} command.

Each percentage is the number of covered expressions in the
  corresponding function/operation 
divided by the total number of expressions it contains.  The total
coverage of the whole test coverage file, which is the average of the
percentages for the individual functions/operations, is also
shown. Figure~\ref{fig:rtinfo} illustrates this.
#endif ENG

#ifdef JPN
インタープリタが{\tt -R}オプションとともに呼ばれると、テストカバレッジファイル{\tt vdm.tc}を更新する。

ファイル{\tt vdm.tc}に記録されたばかりの\ifthenelse{\boolean{VDMsl}}{sorting
  仕様書}{{\tt DoSort}クラス}のカバレッジレベルは\Toolbox\ で
表示される。{\cmd rtinfo}コマンドを使うと仕様書のすべての関数と操作を一覧にした
テーブルが、関数・操作が呼び出された回数とカバレッジのパーセンテージと一緒に
表示される。

パーセンテージはそれぞれ、相当する関数/操作内で評価済みの式の数を当該関数/操作内の式
の総数で割ったものである。テストカバレッジファイル全体の合計カバレッジも
（個々の関数/操作のパーセンテージの平均であるが）表示される。図~\ref{fig:rtinfo} 
はこれを示したものである。
#endif JPN

\begin{figure}[tbh]
\begin{center}
#ifdef VDMSL
\includegraphics[width=\textwidth]{guitcov-sl.png}
#endif VDMSL
#ifdef VDMPP
\includegraphics[width=\textwidth]{guitcov-pp.png}
#endif VDMPP
\caption{Showing test coverage information in the \protect\Toolbox}
\label{fig:rtinfo}
\end{center}
\end{figure}

#ifdef ENG
Now we call the pretty printer with an input file in \LaTeX\ format:
#endif ENG
#ifdef JPN
この\LaTeX\ フォーマットの入力ファイルと一緒に清書機能を呼び出してみる。
#endif JPN

#ifdef VDMSL
\begin{alltt}
prompt> \vdmde\ -lr sort.vdm 
Generating latex
Latex generated to file sort.vdm.tex
prompt>
\end{alltt}
#endif VDMSL

#ifdef VDMPP
\begin{alltt}
prompt> \vdmde -lr sorter.vpp dosort.vpp 
Parsing "sorter.vpp" ... done
Parsing "dosort.vpp" ... done
Generating latex to file sorter.vpp.tex ... done
Generating latex to file dosort.vpp.tex ... done
prompt>
\end{alltt}
#endif VDMPP

#ifdef ENG
When the pretty printer is called with the {\tt -r} option it will
mark all those parts of the \ifthenelse{\boolean{VDMsl}}{{\tt DoSort}
  and {\tt InsertSorted} functions}{{\tt DoSort}, {\tt InsertSorted}
  and {\tt Sort} operations and functions} which have not been covered by our small
test. Note that the option {\tt -r} should only be used with
\LaTeX2$\varepsilon$ because older versions of \LaTeX\ do not
support colours. After running \LaTeX\ on
\ifthenelse{\boolean{VDMsl}}{{\tt sort.vdm.tex}}{{\tt sorter.vpp.tex}}
the result will appear as shown in Figure~\ref{fig:tc-sort}.
#endif ENG
#ifdef JPN
清書機能が{\tt -r}オプションつきで呼び出されると先ほどのテストでカバーできていない
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}
 、 {\tt InsertSorted} 関数}{{\tt DoSort}、{\tt InsertSorted} 、{\tt Sort}といった関数や
  操作} の部分にマークがつく。
古いバージョンのLATEX は色付けをサポートしていないため、{\tt -r}オプションは\LaTeX2$\varepsilon$ に対してのみ
使われることに注意。
\ifthenelse{\boolean{VDMsl}}{{\tt sort.vdm.tex}}{{\tt sorter.vpp.tex}}ファイル上で\LaTeX\ を走らせると
図~\ref{fig:tc-sort}のように結果が表示される。
#endif JPN

\begin{figure}[tbh]
#ifdef VDMSL
\small{
\begin{vdm}
\begin{fn}[e]{DoSort}%
\signature{\seqof*{\Real } \To \seqof*{\Real }}
\parms*{\Lp l\Rp }
\annlab[o]{DoSort}
\If l = \seq{}
\Then\\ \seq{}
\Else\\ \begin{letexpr}
\patdef{sorted}{\fnapply{DoSort}{ \Tl l}}
\end{letexpr}\\
\fnapply{InsertSorted}{ \Hd l,sorted}
\Fi;
\end{fn}

\begin{fn}[e]{InsertSorted}%
\signature{PosReal \times \seqof*{PosReal} \To \seqof*{PosReal}}
\parms*{\Lp i,l\Rp }
\annlab[o]{InsertSorted}
\begin{Cases}{\True }
\alt{\pex{l = \seq{}}}{\seq{i}}
\alt{\pex{i \Le  \Hd l}}{\seq{i} \Sconc l}
\others{\color{not_covered}\seq{ \Hd l} \Sconc \fnapply{InsertSorted}{i, \Tl l}\color{covered}}
\end{Cases}
\end{fn}
\end{vdm}}
#endif VDMSL
#ifdef VDMPP
\small{
\begin{vdm}
\begin{fn}[e]{DoSort}%
\signature{\seqof*{\Real } \To \seqof*{\Real }}
\parms*{\Lp l\Rp }
\annlab[o]{DoSort}
\If l = \seq{}
\Then\\ \seq{}
\Else\\ \begin{letexpr}
\patdef{sorted}{\fnapply{DoSort}{ \Tl l}}
\end{letexpr}\\
\fnapply{InsertSorted}{ \Hd l,sorted}
\Fi;\\
\end{fn}
\begin{fn}[e]{InsertSorted}%
\signature{PosReal \times \seqof*{PosReal} \To \seqof*{PosReal}}
\parms*{\Lp i,l\Rp }
\annlab[o]{InsertSorted}
\begin{Cases}{\True }
\alt{\pex{l = \seq{}}}{\seq{i}}
\alt{\pex{i \Le  \Hd l}}{\seq{i} \Sconc l}
\others{\color{not_covered}\seq{ \Hd l} \Sconc \fnapply{InsertSorted}{i, \Tl l}\color{covered}}
\end{Cases}
\end{fn}
\end{vdm}}
#endif VDMPP
#ifdef ENG
\caption{Test coverage of sorting example}
#endif ENG
#ifdef JPN
\caption{Sorting exampleのテストカバレッジ}
#endif JPN
\label{fig:tc-sort}
\end{figure}

#ifdef ENG
Note that the {\tt others} clause of the {\tt cases} expression in
\ifthenelse{\boolean{VDMsl}}{{\tt InsertSorted}}{{\tt
    DoSort`InsertSorted}} is not covered because
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}}{{\tt DoSort`Sort}} was
called with an already sorted sequence.

Appendix~\ref{sec:latexANDvdm} gives a detailed description of how to
combine \vdmslpp\ specifications with \LaTeX.
#endif ENG

#ifdef JPN
\ifthenelse{\boolean{VDMsl}}{{\tt InsertSorted}}{{\tt
    DoSort`InsertSorted}} の{\tt case}文の{\tt others}節が、まだ
カバーできていないが、これはすでにソート済みの列を引数にして
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}}{{\tt DoSort`Sort}} を
呼んでいるためである。

付録~\ref{sec:latexANDvdm} に、\vdmslpp\ 仕様書と \LaTeX\ 部分の
分け方について詳細な記述がある。
#endif JPN

#ifdef ENG
\subsubsubsection{Format of input file for \LaTeX\ test coverage}
#endif ENG
#ifdef JPN
\subsubsubsection{\LaTeX\ テストカバレッジ向け入力ファイルフォーマット}
#endif JPN

#ifdef ENG
This section describes how to include colouring of parts of the
specification not covered by the test suites and tables showing
coverage percentages in the \LaTeX\ format. We illustrate this using
the same sorting example used above. We discuss the generation of test
coverage tables and the generation of colouring in turn.
#endif ENG
#ifdef JPN
このセクションでは、仕様書のテストスイートでカバーできていない色つきの部分
と\LaTeX\ 形式でカバレッジのパーセンテージを示すテーブルをどのように組み込むか
を記述する。上で使用されたソートの例と同じものを使ってあらわすこととする。
テストカバレッジテーブルの生成と色の生成について順に議論する。
#endif JPN

#ifdef ENG
\subsubsubsection{Test coverage tables and the \LaTeX\ test coverage environment}
#endif ENG
#ifdef JPN
\subsubsubsection{テストカバレッジテーブルと\LaTeX\ テストカバレッジ環境}
#endif JPN

#ifdef ENG
To insert tables that describe the number of calls and the coverage
percentage of functions and operations the \LaTeX\ environment {\tt
  rtinfo} must be used.  We first give an example illustrating the use
of this environment, then we give part of a formal BNF-like definition
of the usage.

In the sorting example \ifthenelse{\boolean{VDMsl}}{a flat
  specification is defined, so the {\tt rtinfo} environment
  is defined for the {\tt DefaultMod} module}{the {\tt rtinfo}
  environment is defined for the class {\tt DoSort}}.  The {\tt
  rtinfo} environment looks like:
#endif ENG

#ifdef JPN
\LaTeX\ 環境で関数・操作の呼び出し回数およびカバレッジのパーセンテージを
記述するテーブルを挿入するには、{\tt rtinfo}コマンドを使用する。まずこの環境の使用を表す
例を示し、形式BNFライクな定義の使用の部分を示す。
  
ソートの例で
\ifthenelse{\boolean{VDMsl}}{フラット形式の仕様書が定義されており、
{\tt rtinfo}環境は{\tt DefaultMod}モジュール向けに定義されている}{{\tt rtinfo}
  環境は{\tt DoSort}クラス向けに定義されている}.
rtinfo環境は以下のようになっている：
#endif JPN

#ifdef VDMSL
\begin{verbatim}
\begin{rtinfo}
[TotalxCoverage]{vdm.tc}[DefaultMod]
DoSort
InsertSorted
\end{rtinfo}
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
\begin{rtinfo}
[TotalxCoverage]{vdm.tc}[DoSort]
DoSorting
InsertSorted
Sort
\end{rtinfo}
\end{verbatim}
#endif VDMPP

#ifdef ENG
The first argument in the {\tt rtinfo} environment ({\tt
  TotalxCoverage} in the example) is optional. 
It is used to define the width of the column in the table which
contains the function/operation names -- the width will be the width
of the argument.  The second argument
(\ifthenelse{\boolean{VDMsl}}{{\tt vdm.tc}}{{\tt vdm.tc}} in the example) is the  
name of the test coverage file.  This argument is mandatory.  The third
(optional) argument (\ifthenelse{\boolean{VDMsl}}{{\tt DefaultMod}}{{\tt
    DoSort}} in the example) is the name of the
\ifthenelse{\boolean{VDMsl}}{module}{class} if the table is to be
restricted to a  particular
\ifthenelse{\boolean{VDMsl}}{module}{class}. If this argument is
omitted all \ifthenelse{\boolean{VDMsl}}{modules}{classes} in the test
coverage file are listed in the table.

Within the {\tt rtinfo} environment, specific function and
operation names can be written, in which case only those
functions and operations are listed in the table. Otherwise all
functions and operations are listed.  In our example only the 
\ifthenelse{\boolean{VDMsl}}{functions {\tt DoSort}
  and {\tt InsertSorted}}{functions/operations {\tt DoSort`DoSorting}, {\tt 
    DoSort`InsertSorted} and {\tt DoSort`Sort}} are listed.

The resulting table is shown in Figure~\ref{fig:examble-tctable}.
#endif ENG

#ifdef JPN
 {\tt rtinfo} 環境の最初の引数（例ではTotalxCoverage）はオプションである。
関数・操作名のテーブルの欄の幅を指定するのに使われる。
幅は引数で指定したものになる。第2引数（例では\ifthenelse{\boolean{VDMsl}}{{\tt vdm.tc}}{{\tt vdm.tc}} ）は
テストカバレッジファイル名になる。
この引数は必須である。第3引数はオプションで、テーブルを特定のクラスのものに制限したい
場合その（例では\ifthenelse{\boolean{VDMsl}}{{\tt DefaultMod}}{{\tt
    DoSort}}）\ifthenelse{\boolean{VDMsl}}{モジュール}{クラス} 名となる。この引数が省略された場合、す
べてのテストカバレッジファイル中のクラスがテーブルに一覧表示される。

{\tt rtinfo}環境下では、特定の関数･操作名が記述されるが、
これはテーブル内に一覧表示されている場合だけである。
そうでない場合はすべての関数・操作が一覧表示される。
例では\ifthenelse{\boolean{VDMsl}}{関数 {\tt DoSort}
  ,{\tt InsertSorted}}{関数/操作 {\tt DoSort`DoSorting}, {\tt 
    DoSort`InsertSorted} ,{\tt DoSort`Sort}} のみが一覧表示されている。

実行結果のテーブルは図~\ref{fig:examble-tctable}に示す。
#endif JPN

\begin{figure}
#ifdef VDMSL
\begin{tabular}{p{25mm}l}
{\bf Test Suite :} & vdm.tc \\ 
{\bf Module :} & DefaultMod \\ 
\end{tabular}

\begin{longtable}{|l|r|r|}\hline
{\bf InsertSorted} & {\bf \#Calls} & {\bf Coverage} \kill
{\bf Name} & {\bf \#Calls} & {\bf Coverage} \\ \hline\hline
\endhead
DoSort & 4 & $\surd$ \\ \hline
InsertSorted & 3 & 62\% \\ \hline
\hline
{\bf Total Coverage} & & {\bf 76\%} \\ \hline
\end{longtable}
#endif VDMSL
#ifdef VDMPP
\begin{tabular}{p{25mm}l}
{\bf Test Suite :} & vdm.tc \\ 
{\bf Class :} & DoSort \\ 
\end{tabular}

\begin{longtable}{|l|r|r|}\hline
{\bf InsertSorted} & {\bf \#Calls} & {\bf Coverage} \kill
{\bf Name} & {\bf \#Calls} & {\bf Coverage} \\ \hline\hline
\endhead
DoSort`DoSorting & 4 & $\surd$ \\ \hline
DoSort`InsertSorted & 3 & 62\% \\ \hline
DoSort`Sort & 1 & $\surd$ \\ \hline
\hline
{\bf Total Coverage} & & {\bf 79\%} \\ \hline
\end{longtable}
#endif VDMPP
#ifdef ENG
\caption{Example of a test coverage table}
#endif ENG
#ifdef JPN
\caption{テストカバレッジテーブルの例}
#endif JPN
\label{fig:examble-tctable}
\end{figure}



#ifdef ENG
\index{Test Coverage!Environments}
The syntax of a test coverage environment is defined as follows:
#endif ENG
#ifdef JPN
\index{テストカバレッジ!かんきょう@環境}
テストカバレッジ環境の構文は以下のように定義されている：
#endif JPN

\Rule{test coverage environment}{ \Lop{$\backslash$begin\{rtinfo\}},
  test coverage section, \lfeed
  \Lop{$\backslash$end\{rtinfo\}}}

\Rule{test coverage section}{ \OptPt{long name}, test suite file,
  \OptPt{\ifthenelse{\boolean{VDMsl}}{module}{class} name}, \lfeed
  \OptPt{function list}}

\Rule{long name}{
  \Lit{[}, string, \Lit{]}}

\Rule{test suite file}{
  \Lit{\{}, file identifier, \Lit{\}}}

\Rule{file identifier}{
  identifier, \SeqPt{\Lit{.}, identifier}}

\Rule{\ifthenelse{\boolean{VDMsl}}{module}{class}}{  
  \Lit{[}, identifier, \Lit{]}}

\Rule{function list}{  
  \SeqPt{identifier}}


\subsubsubsection{Colouring}

#ifdef ENG
Colouring of the parts of a specification not covered by a test suite
can only be shown if \LaTeX2$\varepsilon$ is used.  The \LaTeX\  
file must be generated from the \vdmslpp\ specification to include test
coverage colouring information, which is done by setting the
\guicmd{Enable test coverage colouring} option in the graphical user
interface or by using the {\tt -r} option in the command line
interface and the {\tt emacs} interface.

The following example shows the extra style files and definitions
which are necessary to show the colouring:
#endif ENG

#ifdef JPN
テストスイートでカバーできていない仕様書の部分を色つきで示す機能は\LaTeX2$\varepsilon$ を
使っていれば使える。テストカバレッジの色つき情報を入れるには\LaTeX\ ファイルは
\vdmslpp\ の仕様書から生成されたものでなくてはならない。GUIではテストカバレッジの
色付けオプションを有効にするか、コマンドラインまたは{\tt emacs}で{\tt -r}オプションをつける必要もある。

以下の例では、色つけを説明するのに必要な拡張スタイルのファイルと定義を示す。
#endif JPN

\newpage
#ifdef VDMSL
\begin{verbatim}
\documentclass[dvips]{article}
\usepackage[dvips]{color}                       <--- extra style
\usepackage{vdmsl-2e}

\definecolor{covered}{rgb}{0,0,0}      %black   <--- extra 
                                       %             definition
\definecolor{not-covered}{gray}{0.5}   %gray    <--- extra 
                                       %             definition

\begin{document}
...
\end{document}
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
\documentclass[dvips]{article}
\usepackage[dvips]{color}                       <--- extra style
\usepackage{vpp}

\definecolor{covered}{rgb}{0,0,0}      %black   <--- extra 
                                       %             definition
\definecolor{not-covered}{gray}{0.5}   %gray    <--- extra 
                                       %             definition

\begin{document}
...
\end{document}
\end{verbatim}
#endif VDMPP


#ifdef ENG
In the generated \LaTeX\ code the macros \path|\color{covered}| and
\path|\color{not-covered}| are inserted in front of the specification
parts that respectively have and have not been covered by the test
suite.  The \verb|\definecolor| macros define that covered parts will
be printed in black while the parts which were not covered will be
grey. The result is shown in Figure~\ref{fig:tc-sort} above.

The fact that the {\tt others} clause of the {\tt cases} expression in 
\ifthenelse{\boolean{VDMsl}}{{\tt InsertSorted}}{{\tt
    DoSort`InsertSorted}} is coloured grey in the \LaTeX\ output means
that this clause has not been covered (because
\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}}{{\tt 
    DoSort`Sort}} has only been called with an already sorted sequence). On
the basis of such information, the test suite can be improved
to cover more of the specification.

For colour screens and colour printers red can also be used for
not covered parts.  In that case the definition macro should look like:
#endif ENG

#ifdef JPN
生成された\LaTeX\ コードには、マクロ\path|\color{covered}|と\path|\color{not-covered}| 
が仕様書のテストスイートでカバーされた/されていない部分の前にそれぞれに挿入されている。
\verb|\definecolor| マクロはカバーされたところは黒で、カバーされていないところはグレーで表すよう
定義されている。結果は上記図\ref{fig:tc-sort} に示す。

\ifthenelse{\boolean{VDMsl}}{{\tt InsertSorted}}{{\tt
    DoSort`InsertSorted}} の{\tt case}式の{\tt others}節が\LaTeX\ の出力結果でグレーになっているということは、
その部分がカバーされていないことを表す（\ifthenelse{\boolean{VDMsl}}{{\tt DoSort}}{{\tt
    DoSort`Sort}} はすでにソート済みの列からしか
呼ばれていないため）。この情報をもとに、テストスイートは仕様書のより多くの部分をカバーすることができるようになる。

カラー画面･カラープリンタのためにカバーされていない箇所は赤を使うこともできる。その場合の定義マクロは
以下のようになる：
#endif JPN

\begin{verbatim}
\definecolor{not-covered}{rgb}{1,0,0}  %red
\end{verbatim}


#ifdef ENG
The {\cmd rtinfo} environment must also be included in order to use
colouring, because the information used to generate the colouring is
stored in the test coverage file.
#endif ENG
#ifdef JPN
色付け機能を使うために、{\cmd rtinfo}環境も入っていなくてはならない。これは色をつけるのに
使われる情報はテストカバレッジファイルに保存されているからである。
#endif JPN


\newpage
\bibliographystyle{iptes}
#ifdef VDMSL
\bibliography{user_man}
#endif VDMSL
#ifdef VDMPP
%\bibliography{user_manpp}
\bibliography{user_man}
#endif VDMPP


\newpage

#ifdef ENG
\section*{Glossary}
\addcontentsline{toc}{section}{Glossary}

\input{glossary_en.tex}
#endif ENG

#ifdef JPN
\section*{用語集}
\addcontentsline{toc}{section}{用語集}

\input{glossary_jp.tex}
#endif JPN

\appendix

\newpage
#ifdef ENG
\section{Information Resources on VDM Technology}\label{sec:vdmlinks}
#endif ENG
#ifdef JPN
\section{VDM技術の情報源}\label{sec:vdmlinks}
#endif JPN

#ifdef ENG
This short appendix contains pointers to information resources that
you may find helpful as you use VDM and the \Toolbox.
#endif ENG
#ifdef JPN
この短い付録にはVDMや\Toolbox\ を使う上で参考になる情報源を記述する。
#endif JPN

#ifdef ENG
\subsection*{Tutorial Books on VDM with close links to VDMTools}
For \Toolbox\ users, the following textbooks are certainly
the most appropriate for tutorial purposes. They introduce concepts
such as abstraction and analysis of formal models using a subset of
the ISO Standard VDM-SL notation that is supported by the \Toolbox\
and the object-oriented extension VDM++ respectively.
In both books the ASCII notation, rather than the more arcane
mathematical notation, is used and the presentation is guided by a
series of examples based on industrial applications of the VDM
technology. Most importantly, both books include many exercises which can be
tackled using the \Toolbox.

The two books are:

\begin{quote}
  John Fitzgerald and Peter Gorm Larsen, \\
  ``Modelling Systems: Practical Tools and Techniques in Software
  Development'', \\
  Cambridge University Press 1998, \\
  ISBN 0-521-62348-0 \\
  \texttt{http://uk.cambridge.org/order/Webbook.asp?ISBN=0521623480}\\
  (but since the book is now out of print you will need to find it second hand now)
\end{quote}
% PGL In the Japanese version I would like to suggest making a reference to the Japanese version of this book!!!

\noindent and

\begin{quote}
  John Fitzgerald, Peter Gorm Larsen, Paul Mukherjee, Nico Plat and Marcel Verhoef\\
  ``Validated Designs for Object--oriented Systems''\\
  Springer, New York, 2005\\
  ISBN 1-85233-881-4 \\
  \texttt{http://www.springer.com/east/home/generic/- \\
  search/results?SGWID=5-40109-22-33837368-0}
\end{quote}
#endif ENG 

#ifdef JPN 
\subsection*{モデリングの本}
\Toolbox\ を使うのであれば下記のテキストがほぼ適切だ。抽象化やISO
標準VDM-SLの記法のサブセットを使った形式モデルの分析は
\Toolbox\ に
サポートされている。\ifthenelse{\boolean{VDMpp}}{VDM++言語であっても同様である。}{}
より難解な数学的記法よりもASCII記法が使われ、内容もVDM技術の産業アプリケー
ションの例に基づいて解説されている。より重要なのは、それが
\Toolbox\ あるいは \Toolbox\
の特別なチュートリアル版（本に付属のCD-ROMに含まれている）を使って取り組む
  たくさんの演習を含んでいることである。
#endif JPN

#ifdef ENG
Supporting information (additional exercises, slides, web links, etc.) for both books can be
found on the world-wide web at \\

\begin{quote}
{\tt http://www.vdmbook.com/twiki/bin/view}.
\end{quote}
#endif ENG
#ifdef JPN
サポート情報（追加の演習、スライド、Webサイトへのリンクなど）が\\
{\tt http://www.csr.ncl.ac.uk/modelling-book/}にある。\\

下記のような本が存在する：

\begin{quote}
  J.フィッツジェラルド・P.G.ラーセン / 著, \\
  荒木 啓二郎・張 漢明・荻野 隆彦・佐原 伸・染谷 誠 / 訳, \\
  ``ソフトウェア開発のモデル化技法'', \\
  岩波書店 2003, \\
  ISBN 4-00-005609-3
\end{quote}

\begin{quote}
  佐原 伸 / 著, \\
  ``～ソフトウェアトラブルを予防する～ 形式手法の技術講座'', \\
  ソフト・リサーチ・センター 2008, \\
  ISBN 978-4-88373-258-6
\end{quote}

\begin{quote}
  John Fitzgerald and Peter Gorm Larsen, \\
  ``Modelling Systems: Practical Tools and Techniques in Software
  Development'', \\
  Cambridge University Press 1998, \\
  ISBN 0-521-62348-0 \\
  \texttt{http://uk.cambridge.org/order/Webbook.asp?ISBN=0521623480} \\
  (本書は絶版となっている)
\end{quote}

\begin{quote}
  John Fitzgerald, Peter Gorm Larsen, Paul Mukherjee, Nico Plat and Marcel Verhoef\\
  ``Validated Designs for Object--oriented Systems''\\
  Springer, New York, 2005\\
  ISBN 1-85233-881-4\\
  \texttt{http://www.springer.com/east/home/generic/- \\
  search/results?SGWID=5-40109-22-33837368-0}
\end{quote}
#endif JPN


#ifdef ENG
\subsection*{World-wide Web Sites}
The World-wide web contains a vast amount of information on formal
methods in general and VDM in particular. Here it is only necessary to
give a few sites because these contain links to the many
others available. \\
#endif ENG
#ifdef JPN
\subsection*{Webサイト}
Webサイトには一般的な形式手法やVDMについてのたくさんの情報が載っている。
ここでは他に使えるサイトへのリンクを含むものをいくつかあげる。\\
#endif JPN

\begin{description}

#ifdef ENG
\item[The VDM Portal] A web page containing basic
  information about VDM, including a bibliography,
  information on the VDM mailing list and a link to the VDM examples
  repository.\\ {\tt http://www.vdmportal.org/twiki/bin/view/Main/WebHome/}

\item[The VDM book site] A web page with information about the VDM++
  book and linked to varios other VDM books. \\
{\tt http://www.vdmbook.com/twiki/bin/view}

%\item[The VDM Bibliography] A searchable bibliography of papers and
%  books on VDM theory, practice and experience.\\ {\tt
%http://liinwww.ira.uka.de/bibliography/SE/vdm.html}\\
%VDM theory, practice and experience.

%\item[The VDM++ Bibliography] \mbox{}\\{\tt
%http://liinwww.ira.uka.de/bibliography/SE/vdm.plus.plus.html}

%\item[The NASA Formal Methods Page] Good source of introductory
%  material on formal methods in general.\\ {\tt
%http://shemesh.larc.nasa.gov/fm.html}

\item[Formal Methods Europe] The web pages for this organisation
includes an applications database which is particular
interesting. This in an indexed database of
  applications of formal techniques, mostly in commercial or
  industrial contexts. \\{\tt http://www.fmeurope.org/}

\item[The Formal Methods Archive] A huge source of information on
  research and application in formal methods. Links to companies and
  organisations in formal methods, recommended introductory papers, and
  books. \\{\tt http://www.comlab.ox.ac.uk/archive/formal-methods/}
  
\item[VDMTools information Web site]
  A web page containing the information about VDMTools. \\
{\tt http://fmvdm.org/}

\item[Overture Web site] 
  A web page containing information about the open-source initiative
  called Overture on top of the Eclipse platform. \\
  {\tt http://www.overturetool.org/twiki/bin/view}\\
#endif ENG

#ifdef JPN
\item[The VDM Web Site]
  VDMに関する基本的な情報を含むWebページ。参考文献、
  VDMメーリングリストの情報、VDMの例題の置き場へのリンクなどが含まれる。
  \\ {\tt http://www.csr.ncl.ac.uk/vdm/}

\item[The VDM Bibliography]
VDM理論、実践、体験などの論文や文献の検索可能な参考文献。
{\tt http://liinwww.ira.uka.de/bibliography/SE/vdm.html}

\item[The VDM++ Bibliography] \mbox{}\\{\tt
http://liinwww.ira.uka.de/bibliography/SE/vdm.plus.plus.html}

\item[The NASA Formal Methods Page]
一般的な形式手法の良い導入教材\\
{\tt http://shemesh.larc.nasa.gov/fm.html}

\item[Formal Methods Europe]
  この組織のWebページには特に興味深いアプリケーションのデータベースがある。
 形式技術のアプリケーションが一覧になっているデータベースだが、そのほとんどが商用または産業用の内容である。\\
 {\tt http://www.fmeurope.org/}\\

\item[The Formal Methods Archive]
  かなり大きな形式手法のアプリケーションや研究についての情報源。
形式手法の会社や組織へのリンク、導入として推奨される論文や本など。\\
{\tt http://www.comlab.ox.ac.uk/archive/formal-methods/}

\item[VDM information Web site]
  VDM・VDMToolsに関する情報発信、意見交換などを行なうためのサイト。 \\
{\tt http://fmvdm.org/index-ja.html}
#endif JPN

\end{description}

\newpage
#ifdef VDMSL
#ifdef ENG
\section{Combining VDM-SL and \LaTeX\ }
#endif ENG
#ifdef JPN
\section{VDM-SLと \LaTeX\ の結合}
#endif JPN
#endif VDMSL
#ifdef VDMPP
#ifdef ENG
\section{Combining VDM++ and \LaTeX\ }
#endif ENG
#ifdef JPN
\section{VDM++と \LaTeX\ の結合}
#endif JPN
#endif VDMPP

#ifdef ENG
\index{Pretty Printing!Example}\label{sec:latexANDvdm}\label{tex-description}
#endif ENG
#ifdef JPN
\index{せいしょ@清書!れい@例}\label{sec:latexANDvdm}\label{tex-description}
#endif JPN

#ifdef ENG
In this section a general description of how to construct a
\LaTeX\ document that contains \vdmslpp\ specification parts is given.
#endif ENG
#ifdef JPN
このセクションでは、\vdmslpp\ の仕様部分を含む\LaTeX\ 文書の構築の仕方について、
一般的なことを記述する。
#endif JPN

#ifdef ENG
\subsection{Format of a Specification File}
#endif ENG
#ifdef JPN
\subsection{仕様書ファイルのフォーマット}
#endif JPN

#ifdef ENG
If one wishes to use the \LaTeX\ text processing system two different
input formats can be used: one contains pure \vdmslpp\ ASCII
specification, the other contains ASCII specification mixed with
textual documentation.  The latter type can be
distinguished by the specification parts being enclosed within
``\verb+\begin{vdm_al}+'' and ``\verb+\end{vdm_al}+''. The text-parts
outside the specification blocks are ignored by the parser (but used
by the pretty-printer). The ``\verb+\begin{vdm_al}+'' cannot be placed
arbitrarily in a specification, but only in front of the keywords {\tt 
\ifthenelse{\boolean{VDMsl}}{module, state}{class, instance variables}, functions,
operations, values} and {\tt types} and in 
front of definitions of {\tt functions, operations, types and
values}. This means for instance that a text-part cannot be inserted
\ifthenelse{\boolean{VDMsl}}{into the import section of a module or}{}
in the middle of the body of a function. The file:
#endif ENG

#ifdef JPN
システムを処理するのに \LaTeX\ 文書を使用したい場合、2つの異なる入力フォーマットを
使うことができる：ひとつは純粋な\vdmslpp\ のASCII仕様書であり、もうひとつは原文の混ざった
ASCII仕様書である。後者は仕様書の部分とそうでない部分が
``\verb+\begin{vdm_al}+'' と ``\verb+\end{vdm_al}+''. 
に囲まれているかそうでないかで区別される。仕様書ブロックの外側にあるテキスト
部分は解析ツールには無視される（清書機能は使う）。``\verb+\begin{vdm_al}+''は仕様書中の
任意の箇所に置くことはできず、{\tt \ifthenelse{\boolean{VDMsl}}{module, state}{class, instance variables}, functions, operations, 
values , types} といったキーワードの前か{\tt functions, operations, types, values}の定義の前にしかおくことができない。
これは例えば\ifthenelse{\boolean{VDMsl}}{インポートされたモジュールのセクションや}{}関数の中にテキスト部分を
挿入することができないということを意味している。ファイル
#endif JPN

#ifdef VDMSL
\begin{verbatim}
  vdmhome/examples/sort/sort.vdm
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
  vdmhome/examples/sort/mergesort.vpp
\end{verbatim}
#endif VDMPP

#ifdef ENG
gives an example of how specification and text can be mixed.
#endif ENG
#ifdef JPN
にどのように仕様部分とテキスト部分が混ざっているかの例がある。
#endif JPN


#ifdef ENG
\subsection{Setting up a \LaTeX\ Document}
\index{Pretty Printing!Setting up \LaTeX\ document}
#endif ENG
#ifdef JPN
\subsection{ \LaTeX\ 文書のセットアップ}
\index{せいしょ@清書! \LaTeX\ ぶんしょのセットアップ@\LaTeX\ 文書のセットアップ}
#endif JPN

#ifdef ENG
The general combination of \vdmslpp\ and \LaTeX\ can be used both with
the original \LaTeX\ program and with the newer \LaTeX2$\varepsilon$,
whereas the incorporation of test coverage is possible only when using
\LaTeX2$\varepsilon$ because some features, such as colouring within
documents, are only available with \LaTeX2$\varepsilon$.

The following example of \LaTeX\ code shows the \LaTeX\ style files
that must be included to generate a general \LaTeX\ document which
includes \vdmslpp\ parts:
#endif ENG

#ifdef JPN
\vdmslpp\ と\LaTeX\ を結合するとき、通常の機能は\LaTeX\ でも\LaTeX2$\varepsilon$ でも使うことができるが、
テストカバレッジとの結合は\LaTeX2$\varepsilon$ を使わないとできない。
文書の色付け機能など\LaTeX2$\varepsilon$ でのみ使用できる機能がいくつかあるからだ。

以下の\LaTeX\ コードの例は\vdmslpp\ の部分を含む一般的な\LaTeX\ 文書を生成する
ためには含まれていなくてはならない\LaTeX\ 形式のファイルを示す：
#endif JPN

#ifdef ENG
#ifdef VDMSL
%\fbox{\begin{minipage}[t]{8cm}
\begin{figure}[tbh]
\begin{verbatim}
                \documentstyle[vdmsl]{article}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{Example of original \LaTeX\ Document}
\end{figure}

\begin{figure}[tbh]
\begin{verbatim}
                \documentclass{article}
                \usepackage{vdmsl-2e}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{Example of \LaTeX2$\varepsilon$ Document}
\end{figure}
#endif VDMSL

#ifdef VDMPP
\begin{figure}[tbh]
\begin{verbatim}
                \documentstyle[vpp]{article}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{Example of an original \LaTeX\ Document}\label{fig:example-orig-latex}
\end{figure}

\begin{figure}[tbh]
\begin{verbatim}
                \documentclass{article}
                \usepackage{vpp}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{Example of a \LaTeX2$\varepsilon$ Document}\label{fig:example-latex2e}

\end{figure}
#endif VDMPP

The \ifthenelse{\boolean{VDMsl}}{{\tt vdmsl-2e}}{{\tt vpp}} style file
is included in the \Toolbox\ distribution.

The \LaTeX\ heading can either be inserted into one of the \vdmslpp\ 
specification files or it can be put in an isolated file that includes
the \vdmslpp\ specification files.  In either case the specification
files must be translated into \LaTeX\ files by the \Toolbox, either by
pressing the \guicmd{Pretty Print} button in the graphical user
interface, by using the {\cmd latex} command in the {\tt Emacs}
interface, or by using the {\tt -l} option in a command line call to {\tt
  \vdmde}.  For the sorting example the heading has been inserted into
the \ifthenelse{\boolean{VDMsl}}{{\tt sort.vdm} file.}{{\tt sort.tex} file.}
#endif ENG

#ifdef JPN
#ifdef VDMSL
%\fbox{\begin{minipage}[t]{8cm}
\begin{figure}[tbh]
\begin{verbatim}
                \documentstyle[vdmsl]{article}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{旧バージョン \LaTeX\ 文書の例}
\end{figure}

\begin{figure}[tbh]
\begin{verbatim}
                \documentclass{article}
                \usepackage{vdmsl-2e}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{ \LaTeX2$\varepsilon$ 文書の例}
\end{figure}
#endif VDMSL

#ifdef VDMPP
\begin{figure}[tbh]
\begin{verbatim}
                \documentstyle[vpp]{article}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{旧バージョン \LaTeX\ 文書の例}
\label{fig:example-orig-latex}
\end{figure}

\begin{figure}[tbh]
\begin{verbatim}
                \documentclass{article}
                \usepackage{vpp}

                \begin{document}
                ...
                \end{document}
\end{verbatim}
\caption{ \LaTeX2$\varepsilon$ 文書の例}
\label{fig:example-latex2e}
\end{figure}
#endif VDMPP

\ifthenelse{\boolean{VDMsl}}{{\tt vdmsl-2e}}{{\tt vpp}} スタイルファイルは \Toolbox\ に含まれている。

\LaTeX\ の見出しは\vdmslpp\ 仕様書ファイルのひとつか\vdmslpp\ の仕様を含む単独の
ファイルのどちらにも挿入できる。どちらのケースでも仕様書のファイルは\Toolbox\ 
により\LaTeX\ ファイルに変換されていなくてはならないが、これはGUIから\guicmd{清書} 
ボタンを押すか{\tt Emacs}インターフェースで{\cmd latex} コマンドを使うかコマンドラインから{\tt \vdmde}を
{\tt -l} オプションつきで使うかのどれかで可能である。ソートの例では見出しは
\ifthenelse{\boolean{VDMsl}}{{\tt sort.vdm} }{{\tt sort.tex}} 
ファイルに挿入されている。
#endif JPN


#ifdef ENG
\subsubsection*{Line numbering}
#endif ENG
#ifdef JPN
\subsubsection*{行番号つけ}
#endif JPN

#ifdef ENG
All definitions in the generated \LaTeX\ are by default given 
definition numbers and line numbers. These numbers can
be suppressed using the following commands:
#endif ENG
#ifdef JPN
生成された\LaTeX\ ファイルにあるすべての定義はデフォルトで定義番号と行番号が与えられる。
これらの番号は以下のコマンドを使えば削除することができる。
#endif JPN

\begin{verbatim}
\nolinenumbering
\setindent{outer}{\parindent}
\setindent{inner}{0.0em}
\end{verbatim}

#ifdef ENG
For further information see \cite{Dickinson&95}.
#endif ENG
#ifdef JPN
詳細は\cite{Dickinson&95}を参照のこと。
#endif JPN

#ifdef ENG
\subsubsection*{Indexes}\index{Pretty Printing!Indexes}
#endif ENG
#ifdef JPN
\subsubsection*{インデックス}\index{せいしょ@清書!インデックス}
#endif JPN

#ifdef ENG
Macros to generate index numbers can be generated as part of the
\LaTeX\ pretty printing output.  The index numbers refer to pages in
the final \LaTeX\ document.  Indexes can be generated at two levels:
indexes for all definitions of \ifthenelse{\boolean{VDMsl}}{functions,
  operations, types, states and modules}{classes, functions, operations,
  types and instance variables}, and indexes for all uses of
\ifthenelse{\boolean{VDMsl}}{functions, operations, and
  types}{functions, types, and classes}. Index macros for
definitions only are generated in the graphical interface by enabling
the \guicmd{Output index of definitions} option, and in the command line
and emacs interfaces by using the {\tt -n} option.
Index macros for both definitions and uses are generated in
the graphical interface by enabling the \guicmd{Output index of
  definitions and uses} option, and in the command line and
emacs interfaces by using the {\tt -N} option.

The index numbers are automatically inserted into different \LaTeX\ 
macros to clarify which kind of construct an index refers to. The
macros for definitions are:
#endif ENG

#ifdef JPN
インデックス番号をつくるマクロは清書出力の\LaTeX\ 文書の一部として生成される。
インデックス番号は最終的な\LaTeX\ 文書のページを参照する。インデックスは2つのレベルで
生成することができる：\ifthenelse{\boolean{VDMsl}}{関数、操作、型、状態、モジュール}
{クラス、関数、操作、型、インスタンス変数}の定義すべてに対する
インデックスと\ifthenelse{\boolean{VDMsl}}{関数、操作、型}{関数、型、クラス}のすべての
使用に対するインデックスである。定義に対する
インデックスマクロはGUIで\guicmd{定義の索引を出力} オプションを有効にするか、コマンドライン
またはEmacsインターフェースで{\tt -n}オプションを使うかで生成される。定義または使用に対する
インデックスマクロいずれもGUIで定義のインデックスを出力するオプションを有効にするか、
コマンドラインまたはEmacsインターフェースで-Nオプションを使うかで生成される。

インデックス番号はインデックスがどんな種類の構成物を参照するかを分類するため、
自動的に異なる\LaTeX\ マクロに挿入される。定義に対するマクロは：
#endif JPN

\begin{itemize}

#ifdef ENG
#ifdef VDMSL
\item{{\tt StateDef}} indicating where a state is defined.
#endif VDMSL
#ifdef VDMPP
\item{{\tt InstVarDef}} indicating where an instance variable is defined.
#endif VDMPP
\item{{\tt TypeDef}} indicating where a type is defined.
\item{{\tt FuncDef}} indicating where a function or operation is defined.
#ifdef VDMSL
\item{{\tt ModDef}}  indicating where a module is defined.
#endif VDMSL
#ifdef VDMPP
\item{{\tt ClassDef}} indicating where a class is defined.
#endif VDMPP
#endif ENG

#ifdef JPN
#ifdef VDMSL
\item{{\tt StateDef}}
状態の定義されている箇所を示す。
#endif VDMSL
#ifdef VDMPP
\item{{\tt InstVarDef}}
インスタンス変数が定義されている箇所を示す。
#endif VDMPP
\item{{\tt TypeDef}}
型が定義されている箇所を示す。
\item{{\tt FuncDef}}
関数または操作が定義されている箇所を示す。
#ifdef VDMSL
\item{{\tt ModDef}}
モジュールが定義されている箇所を示す。
#endif VDMSL
#ifdef VDMPP
\item{{\tt ClassDef}}
クラスが定義されている箇所を示す。
#endif VDMPP
#endif JPN

\end{itemize}

#ifdef ENG
The macros for uses are:
#endif ENG
#ifdef JPN
使用するマクロは：
#endif JPN

\begin{itemize}

#ifdef ENG
\item{{\tt TypeOcc}} indicating where a type is used.
\item{{\tt FuncOcc}} indicating where a function
  \ifthenelse{\boolean{VDMsl}}{or operation}{} is used.  Only the
  use of functions\ifthenelse{\boolean{VDMsl}}{/operations}{}
  that are explicitly defined in the document will be indexed.
  
#ifdef VDMPP
\item{{\tt ClassOcc}} indicating where a class is used.
#endif VDMPP
#endif ENG

#ifdef JPN
\item{{\tt TypeOcc}}
型が使用されている箇所を示す。
\item{{\tt FuncOcc}}
  関数\ifthenelse{\boolean{VDMsl}}{または操作}{} が使用されている箇所を示す。
  ドキュメントで明確に定義されている
  関数\ifthenelse{\boolean{VDMsl}}{/操作}{}の仕様についてのみインデックスが振られる。
  
#ifdef VDMPP
\item{{\tt ClassOcc}}
クラスが使用されている箇所を示す。
#endif VDMPP
#endif JPN
\end{itemize}


#ifdef ENG
These \LaTeX\ macros must be defined at the beginning of
the \LaTeX\ document in order to use indexing.  An example of this is:
#endif ENG
#ifdef JPN
これらの\LaTeX\ マクロはインデックス付けを使用するためには\LaTeX\ 文書の最初で
定義されていなくてはならない。例を以下に示す：
#endif JPN

#ifdef VDMSL
\begin{verbatim}
\newcommand{\StateDef}[1]{{\bf #1}}
\newcommand{\TypeDef}[1]{{\bf #1}}
\newcommand{\TypeOcc}[1]{{\it #1}}
\newcommand{\FuncDef}[1]{{\bf #1}}
\newcommand{\FuncOcc}[1]{#1}
\newcommand{\ModDef}[1]{{\tiny #1}}
\end{verbatim}
#endif VDMSL
#ifdef VDMPP
\begin{verbatim}
\newcommand{\InstVarDef}[1]{{\bf #1}}
\newcommand{\TypeDef}[1]{{\bf #1}}
\newcommand{\TypeOcc}[1]{{\it #1}}
\newcommand{\FuncDef}[1]{{\bf #1}}
\newcommand{\FuncOcc}[1]{#1}
\newcommand{\ClassDef}[1]{{\sf #1}}
\newcommand{\ClassOcc}[1]{#1}
\end{verbatim}
#endif VDMPP

#ifdef ENG
Four additional parts have to be included in the \LaTeX\ document in
which you want to include the index:
#endif ENG
#ifdef JPN
インデックスに入れておきたい場合は4つの追加箇所を \LaTeX\ 文書に含めておく必要がある。
#endif JPN

\begin{enumerate}

#ifdef ENG
\item Include the {\tt makeidx} style option in $\backslash${\tt
    documentstyle} if using the original \LaTeX, or include it as a
  package if using \LaTeX2$\varepsilon$..
\item Include $\backslash${\tt makeindex} in the preamble of the
  document.
\item Define the macros {\tt InstVarDef, TypeDef, ...}.
\item Include $\backslash${\tt printindex} at the position where you
  would like to have the index included in the document.
#endif ENG

#ifdef JPN
\item
  {\tt makeidx} スタイルオプションをインクルードする（\LaTeX\ なら$\backslash${\tt
    documentstyle} 、\LaTeX2$\varepsilon$.. ならパッケージに含まれる）
\item
  文書の序文に$\backslash${\tt makeindex}をインクルードする 
\item
  マクロ{\tt InstVarDef, TypeDef}などを定義する
\item
  $\backslash${\tt printindex}を文書のインデックスを入れたい箇所に含める
#endif JPN

\end{enumerate}


#ifdef ENG
\subsubsection*{Unsupported constructs}
#endif ENG
#ifdef JPN
\subsubsection*{サポート外構成物}
#endif JPN

#ifdef ENG
There is one syntactical construct that is not supported currently
by the \LaTeX\ pretty printer: at present it is not possible to typeset
comments.\index{Pretty Printing!Comments} These will simply be ignored
by the \LaTeX\ pretty printer. It is recommended to mix specifications
and text instead of using \vdmslpp\ comments.
#endif ENG
#ifdef JPN
現状、\LaTeX\ の清書機能ではサポートしていない構文の構成物が1つある：
コメントを活字に組むことができないのだ\index{せいしょ@清書!コメント} 。\LaTeX\ の
清書機能では単に無視されるだけである。\vdmslpp\ コメントを使用する代わりに、
仕様とテキストを混ぜて使うことを推奨する。
#endif JPN

% #ifdef VDMPP
% \newpage
% \section{A Simple Example Illustrating Inheritance in \vdmslpp}\label{sec:inheritex} 

% The example here is used in Sections~\ref{sec:inherit-ref}
% and~\ref{sec:depend-ref}.

% \verbatiminput{inherit-ex.vpp}
% #endif VDMPP

\newpage
#ifdef ENG
\section{Setting up your \protect\VDMTools{} Environment}\label{sec:set_env}
#endif ENG
#ifdef JPN
\section{\protect\VDMTools{}環境の設定}\label{sec:set_env}
#endif JPN

#ifdef ENG
A number of environment variables and other options for the \Toolbox\
as a whole can be set according to your personal preferences. These
are described below.
#endif ENG
#ifdef JPN
個人の好みによって、ツールボックス向けに多くのオプションを
設定することができる。これらについて以下で記述する。
#endif JPN

#ifdef ENG
%\subsection{Environment Variables}
%
%The following environment variables can be set for the \Toolbox:\\
#endif ENG

#ifdef JPN
%\subsection{環境変数}
%
%\Toolbox\ では以下の環境変数が設定できる。
#endif JPN

%\begin{description}

#ifdef ENG
%\item[EDITOR] This defines the editor used when invoking an editor
%  from within the \Toolbox. \\
%  
%  For Windows the default editor is \keyw{Notepad}. If you prefer to
%  use, say, \keyw{Word} instead, you should define the EDITOR environment
%  variable in your user profile (for 2000 and NT; in the \keyw{autoexec.bat}
%  file for 98) to the path to \keyw{winword.exe}.\\
%  
%  For UNIX the default editor is \keyw{vi}. To change this, set the
%  EDITOR environment variable, say to \keyw{emacs}.\\
%
%\item[TMPDIR] When you are using the \Toolbox\ some temporary
%    files \index{Temporary
%    Files} are written on your file system during syntax checking and
%  pretty printing. These files are written in \verb+/tmp+ or
%  \verb+/usr/tmp+ (depending on your architecture). However, the
%  environment variable \verb+TMPDIR+\index{TMPDIR} can be used to
%  change this: set its value to the name of the directory in
%  which you want the temporary files to be written.\\

#ifdef VDMPP
%\item[VDMPPROOT] Points to the directory where the \Toolbox\ is installed.
%#endif //VDMPP
%#ifdef VDMSL
%\item[VDMSLROOT] Points to the directory where the \Toolbox\ is installed.
%#endif
%
%#ifdef VDMPP
%\item[OMNIORB\_USEHOSTNAME] Not normally required, but in some
%  circumstances may be required under Windows. If used, its value
%  should be 127.0.0.1. See \cite{InstallPPMan-CSK} for details.\\
#endif //VDMPP
#endif ENG

#ifdef JPN
%\item[EDITOR]
%  \Toolbox\ 内からエディタを起動したときに使うエディタを定義する。\\
%  
%  ウインドウズではデフォルトエディタは\keyw{Notepad}である。もし変わりに\keyw{Word}を使いたい場合は
%  ユーザープロファイルで（Windows2000,NT向け。Windows98の場合は\keyw{autoexec.bat}を編集）
%  環境変数EDITORを定義して、\keyw{winword.exe}.のパスを設定する。\\
%  
%  UNIXだとデフォルトのエディタは\keyw{vi}である。変更したければEDITOR環境変数を\keyw{emecs}など
%  に設定する。\\
%
%\item[TMPDIR]
%  \Toolbox\ を使用する際、構文チェック中や清書中にファイルシステムに
%  いくつかテンポラリのファイル\index{テンポラリファイル}が書き込まれる。これらのファイルは
%  \verb+/tmp+ または \verb+/usr/tmp+
%  （アーキテクチャに依存）に書き込まれるが、環境変数\verb+TMPDIR+\index{TMPDIR} を使うと
%  これを変更することができる：値をテンポラリファイルを保存したいディレクトリ名に変更すればよい。\\
%
%#ifdef VDMPP
%\item[VDMPPROOT] Points to the directory where the \Toolbox\ is installed.
%#endif //VDMPP
%#ifdef VDMSL
%\item[VDMSLROOT] Points to the directory where the \Toolbox\ is installed.
%#endif
%
%#ifdef VDMPP
%\item[OMNIORB\_USEHOSTNAME]
%  通常は設定する必要はない。ウインドウズ環境の下では必要かもしれない。
%  もし使用するならば値は127.0.0.1である。詳細は\cite{InstallPPMan-CSK} を参照のこと。
%
%#endif //VDMPP
#endif JPN
  
%\end{description}


#ifdef ENG
\subsection{Interface Options}
#endif ENG
#ifdef JPN
\subsection{インターフェースオプション}
#endif JPN

#ifdef ENG
The following interface options can be set through the \guicmd{Edit
  and Print} pane of the \guicmd{Tool Options} window which is
  opened by selecting the \guicmd{Tool Options} 
(\raisebox{-1.1mm}{\includegraphics[width=0.03\textwidth]{tooloptions.png}})
  item from the
  \guicmd{Project} toolbar/menu and which is shown
  in Figure~\ref{fig:toolopts-ep}:
#endif ENG

#ifdef JPN
  以下のインターフェースオプションは、\guicmd{ツールオプション} ウインドウの\guicmd{編集と印刷
  } タブで設定可能である。この画面は図~\ref{fig:toolopts-ep}に示す\guicmd{プロジェクト} ツールバー/メニュー
  から \guicmd{ツールオプション} 
(\raisebox{-1.1mm}{\includegraphics[width=0.03\textwidth]{tooloptions.png}})の項目を選択することで起動する。
#endif JPN

\begin{description}

#ifdef ENG
\item[External Editor:] Options to define the external editor that can be
  invoked from within the \Toolbox.
  \begin{list}{}{}
  \item[{\sf Editor Name}:] The name of te external editor to
    use. Unix default value: emacsclient. Windows default value:
    notepad. Note that it is not yet possible to use Microsoft Word
    here directly. 
  \item[{\sf Format to load single file}:] default value: \verb|+%l| \verb|%f| 
  \item[{\sf Format to load multiple files}:]  default value: \verb+%f+ 
  \end{list}
\item[Print command:] default: \verb+lpr+ \textbf{Note:} on
  the Windows platform it is not possible to use this at all because
  the pipe and print icons are not present at all. 
#endif ENG

#ifdef JPN
\item[外部エディタ:]
  \Toolbox\ から起動することができる外部エディタを定義するオプション
  \begin{list}{}{}
  \item[{\sf エディタ名}:]
    使用する外部エディタの名前。Unixでのデフォルト値はemacsclient。
    Windowsではnotepad。MS Wordを直接起動することはできない。
  \item[{\sf ファイルを開く方法}:]
  デフォルト値: \verb|+%l| \verb|%f| 
  \item[{\sf 複数のファイルを開く方法}:]
  デフォルト値: \verb+%f+
  \end{list}
\item[印刷命令:]
  デフォルト:  \verb+lpr+ \textbf{Note:} 
  Windowsプラットフォームでは使用不可能。
  WindowsではパイプやPrintアイコンは出現しない。
#endif JPN

\end{description}

\begin{figure}[H]
\begin{center}
#ifdef JPN
\includegraphics[width=\textwidth]{toolOptions-ep.png}
#endif JPN
#ifdef ENG
\includegraphics[width=\textwidth]{toolOptions-epENG.png}
#endif ENG
#ifdef ENG
\caption{Setting Editor and Print Options}
#endif ENG
#ifdef JPN
\caption{エディタと印刷オプションの設定}
#endif JPN
\label{fig:toolopts-ep}
\index{Options!Editor and Print}
\end{center}
\end{figure}


#ifdef ENG
\subsection{Multilingual Support}\label{sec:multiling}
#endif ENG
#ifdef JPN
\subsection{多言語サポート}\label{sec:multiling}
#endif JPN

#ifdef ENG
The \Toolbox\ supports a range of fonts which allow a corresponding
range of scripts to be used both in the specification itself (i.e.\ in
the names of the identifiers used in the specification) and in the
more general text accompanying the specification. The relevant
language support should first be installed appropriately at the level
of the basic operating system (Windows or Unix) within which the
\Toolbox\ is running, then the \Toolbox\ can be configured to use this
through the \guicmd{Font} pane of the \guicmd{Tool Options} window 
(see Figure~\ref{fig:toolopts-font}) which is 
invoked via the \guicmd{Tool Options} item 
(\raisebox{-1.1mm}{\includegraphics[width=0.03\textwidth]{tooloptions.png}})
on the \guicmd{Project} toolbar/menu. Press the \guicmd{Select Font}
button in the \guicmd{Font} pane of the \guicmd{Tool Options} window
to open a browser containing a list of available fonts (at the level
of the operating system) and select the font you want. Finally, select
the appropriate encoding from the \guicmd{Text Encoding} menu in the
same pane. 

On the font pane it is also possible to select whether one wish to
have {\sf syntax coloring}\index{syntax coloring} and wish to use 
{\sf auto syntax checking}\index{auto syntax checking} (both are
selected by default). When {\sf syntax coloring} is selected the VDM
keywords will be highlighted in the {\sf source window}. When {\sf
auto syntax checking} is selected files will automatically be syntax
checked when they are saved in a newer version to the file system.
#endif ENG

#ifdef JPN
\Toolbox\ は、たくさんのフォントをサポートしているが、これにより対応する
範囲の活字が仕様書自体（仕様書で使われる識別子の名前など）とそれに
伴う一般的なテキスト形式の両方で使用できるようになる。関連する言語の
サポートは\Toolbox\ の実行されるOS（Windows またはUnix）のレベルで
まず適切にインストールされ、それから\guicmd{ツールオプション} ウインドウの \guicmd{フォント} タブ
（図~\ref{fig:toolopts-font}参照）で\Toolbox\ に設定することができる。この画面は\guicmd{プロジェクト}
ツールバー/メニューの\guicmd{ツールオプション}  
(\raisebox{-1.1mm}{\includegraphics[width=0.03\textwidth]{tooloptions.png}})の項目を選択すると
起動する。\guicmd{ツールオプション} の\guicmd{フォント} タブでフォントの選択ボタンを押すと利用できるフォントの
一覧（OSレベルで）を含むブラウザが開き、好きなフォントを選択することがで
きる。最後に、同じ画面の\guicmd{Text Encoding} メニューから適切なエンコー
ディングを選択する。

また、フォントタブでは、{\sf 構文の色付け}\index{こうぶんのいろつけ@構文の色付け}と
{\sf 自動構文チェック}\index{じどうこうぶんちぇっく@自動構文チェック}をするかどうかを選択することも可能である。
（両方ともデフォルトで選択されている。）
{\sf 構文の色付け}が選択されている時に、VDMの構文が持つキーワードは{\sf ソースウィンドウ}で強調表示される。
{\sf 自動構文チェック}が選択されている場合、ファイルはファイルシステム上で新たに保存された時に
自動で構文チェックされる。
#endif JPN

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{toolOptions-font.png}
#ifdef ENG
\caption{Setting Font Options}
#endif ENG
#ifdef JPN
\caption{フォントオプションの設定}
#endif JPN
\label{fig:toolopts-font}
\end{center}
\end{figure}

#ifdef ENG
Note that the range of scripts available in the \Toolbox\ is limited
to those which are supported by the general Qt interface. The possible
selections offered when setting the text encoding represent those
currently supported.
#endif ENG
#ifdef JPN
 \Toolbox\ で利用可能な活字の範囲は一般的なQtインターフェースでサポート
されているものに比べると限られている。
テキストエンコーディングの設定が現在サポートされているものを表している場合、
選択が可能になる。
#endif JPN

#ifdef VDMPP
#ifdef ENG
\subsection{UML Link support}\label{sec:UMLlinkoptions}
% PGL: This should really NOT be at this place, but since this appendix is
% about tool options I have placed it here. I think that the UML pane
% should be with the other project options...
% However I also see that the support for Rational Rose now has been
% entirely removed!!! This means that LOTS of other changes are
% necessary!!! For example the link to UML should no longer be called
% the Rose link!!! 

At this pane it is possible to select the desired interface to UML and
the external UML tool. At the moment there is support to JUDE:
\begin{quote}
  \texttt{http://jude.change-vision.com/jude-web/index.html} 
\end{quote}
\noindent and
Enterprice Architect:
\begin{quote}
  \texttt{http://www.sparxsystems.com.au/products/ea/downloads.html}
\end{quote}
Both
of these links are made using the XMI exchange standard between UML
tools. Here is is also possible to state the preferred file type at
the VDM level as well as the template one wish to use for such files.  
#endif ENG
#ifdef JPN
\subsection{UMLリンクオプション}\label{sec:UMLlinkoptions}
このタブは、外部のUMLツールとの希望のインターフェースを選択することが可能である。
現在は、サポートされている外部のUMLツールは、JUDE：
\begin{quote}
  \texttt{http://jude.change-vision.com/jude-web/index.html} 
\end{quote}
\noindent と
Enterprice Architect:
\begin{quote}
  \texttt{http://www.sparxsystems.com.au/products/ea/downloads.html}
\end{quote}
である。

これらへのリンクは両方とも、UMLツール間のXMIインターフェース規格を用いることで実現されている。
ここにある、また、テンプレートと同様にVDMレベルにおけるタイプがそのようなファイルに使用したがっている都合のよいファイルを述べるのにおいて可能です。
#endif JPN
#endif VDMPP

\newpage
#ifdef ENG
\section{The Emacs Interface}
\label{getting-started}
\index{Emacs Interface}
#endif ENG
#ifdef JPN
\section{Emacsインターフェース}
\label{getting-started}
\index{Emacsインターフェース}
#endif JPN


#ifdef ENG
The Emacs Interface is only supported on the different Unix platforms
where the \Toolbox\ is available. The file {\tt \vdmdeNineteenEl}
contains the Emacs macros which enable one to get access to the
\Toolbox\ functionality directly from Emacs. The guided tour from
Section~\ref{guistart} can be followed by using the file
\ifthenelse{\boolean{VDMsl}}{{\tt sort.init}}{{\tt mergesort.init}}
instead of the \ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf}}{{\tt
    mergesort-init.rtf}} file.

After installing the \Toolbox\ and updating your {\tt .emacs} file
\index{.emacs file} as described in the document
\ifthenelse{\boolean{VDMsl}}{\cite{InstallMan-CSK}}{\cite{InstallPPMan-CSK}}
you can run the Emacs editor.

%\index{\vdmde\!command line   options}
From the Emacs editor call the \vdmslpp\ Development Environment
  ({\tt \vdmde})\index{\vdmde} by typing {\tt M-x \vdmde} (Press
  the meta-key and 
the x-key and give {\tt \vdmde} as the argument). This can be done
from any Emacs buffer. You will now be prompted for a file name which
must contain a \vdmslpp\ specification. Type
\ifthenelse{\boolean{VDMsl}}{{\tt sort.vdm}}{{\tt mergesort.vpp}} and
press RETURN.

When {\tt \vdmde} is started it will parse the input file and if some
syntax errors \index{Syntax Errors} are discovered the Emacs window will be split
into two. One half will contain the \ifthenelse{\boolean{VDMsl}}{{\tt
    sort.vdm}}{{\tt mergesort.vpp}} file (from now on called the specification
window) and the other will be the command window for {\tt \vdmde}
(from now on called the command window). The syntax errors are
indicated directly in the specification window by the marker {\tt =>}.

This is similar to the explanation given in Section~\ref{guistart} and
you can continue the guided tour following that example. By typing {\tt
help} on the command line in the command window you will also be able
to get an overview of how the different features can be accessed.
#endif ENG

#ifdef JPN
Emacsインターフェースは \Toolbox\ の利用可能な異なるUnixプラットフォームで
のみサポートされている。ファイル{\tt \vdmdeNineteenEl}はEmacsから直接\Toolbox\ の機能に
アクセスすることを可能するEmacsマクロを含む。セクション~\ref{guistart}からのガイドツアーは
\ifthenelse{\boolean{VDMsl}}{{\tt sort-init.rtf}}{{\tt mergesort-init.rtf}} ファイルの変わりに
\ifthenelse{\boolean{VDMsl}}{{\tt sort.init}}{{\tt mergesort.init}}ファイルを使うことにより以下に従う。

\Toolbox\ をインストールし、ドキュメント\ifthenelse{\boolean{VDMsl}}{\cite{InstallMan-CSK}}{\cite{InstallPPMan-CSK}}
に記述されているように{\tt .emacs} file\index{.emacs ファイル}ファイルを更新すると、
Emacsエディタを使うことができる。

%\index{\vdmde\!command line   options}
 {\tt M-x \vdmde} ({\tt \vdmde} の引数としてメタキーとxキーを押す)とタイプすることで
Emacsエディタから
\vdmslpp\ 開発環境 ({\tt \vdmde})\index{\vdmde} を起動する。これはどのEmacs バッファからでもできる。
これで\vdmslpp\ 形式の仕様を含むと思われるファイルの名前にプロンプトが表示されている
はずだ。
\ifthenelse{\boolean{VDMsl}}{{\tt sort.vdm}}{{\tt mergesort.vpp}} とタイプしてリターンキーを押す。

{\tt \vdmde}コマンドは入力ファイルを解析し、構文エラー\index{こうぶんエラー@構文エラー} が見つかった場合は
Emacsウインドウが2つに分かれる。半分（以後仕様書ウインドウと呼ぶ）は\ifthenelse{\boolean{VDMsl}}{{\tt
    sort.vdm}}{{\tt mergesort.vpp}}ファイルを表示しており、
もう半分は{\tt \vdmde}のコマンドウインドウとなる（以後コマンドウインドウと呼ぶ）。構文エラーは仕様書
ウインドウでは{\tt =>}マークで示される。

これはセクション~\ref{guistart} での説明と似ており、以下の例でガイドツアーの続きをすることができる。コマンド
ウインドウのコマンドラインで{\tt help}とタイプすれば、異なる特性へのアクセス方法の概要を見ることができる。
#endif JPN


\newpage
#ifdef ENG
\section{Test Scripts for the Sorting Example}\label{sec:testscript}
#endif ENG
#ifdef JPN
\section{Sort例題向けテストスクリプト}\label{sec:testscript}
#endif JPN

#ifdef ENG
The test scripts shown here consist of two scripts:
#endif ENG
#ifdef JPN
ここで示すテストスクリプトは2つのスクリプトから構成されている。
#endif JPN

\begin{itemize}

#ifdef ENG
\item The specific test script that tests a single argument. It takes
the name of an argument file as parameter.

\item The top level test script that loops over a number of arguments
files. These argument files can be organised in an entire directory
hierarchy. For each argument file it calls the specific test script
with that file name.
#endif ENG

#ifdef JPN
\item
単独のargumentをテストする特別なスクリプト。パラメータにargumentファイル名を取る。

\item
いくつものargumentファイルをループするトップレベルのテストスクリプト。これらのargumentファイル
はディレクトリ階層で構成される。
各々のargumentファイルはファイル名とともに特別なテストスクリプトを呼び出す。
#endif JPN

\end{itemize}

#ifdef ENG
The test scripts depend on the platform and thus this appendix is
divided into different parts depending upon the platform. More
advanced test scripts can be made. Those presented here are simple
ones intended to demonstrate the basic approach.
#endif ENG
#ifdef JPN
テストスクリプトはプラットフォームに依存するため、この付録はプラットフォームに
よって2つの部分に分かれる。より高度なテストスクリプトを作成することもできる。
ここで示されているものは基本的なアプローチを実演することを意図した単純なものである。
#endif JPN

#ifdef ENG
\subsection{The Windows/DOS Platform}
#endif ENG
#ifdef JPN
\subsection{Windows/DOSプラットフォーム}
#endif JPN

#ifdef ENG
The top level test script is called {\tt vdmloop.bat} and can be
executed in a DOS command prompt. This file is available in the
\Toolbox\ distribution in the \path+examples/sort/test+ directory.  It
looks like:
#endif ENG

#ifdef JPN
トップレベルのテストスクリプトは{\tt vdmloop.bat} という名前であり、DOSプロンプトから実行することができる。
このファイルは\Toolbox\ からも利用可能であり、\path+examples/sort/test+ ディレクトリにある。以下のようになる：
#endif JPN

#ifdef VDMSL
\verbatiminput{sort-ex/test/vdmloop.bat}
#endif VDMSL
#ifdef VDMPP
\verbatiminput{sort-expp/test/vdmloop.bat}
#endif VDMPP

#ifdef ENG
The test script, which takes one argument file, is called {\tt
  vdmtest.bat}.  This file is also available in the \Toolbox\ 
distribution. It looks like:
#endif ENG
#ifdef JPN
argumentファイルをひとつだけとるテストスクリプトは{\tt vdmtest.bat}と
呼ばれる。このファイルも\Toolbox\ から利用可能であり以下のようである。
#endif JPN

#ifdef VDMSL
\verbatiminput{sort-ex/test/vdmtest.bat}
#endif VDMSL
#ifdef VDMPP
\verbatiminput{sort-expp/test/vdmtest.bat}
#endif VDMPP

#ifdef ENG
\ifthenelse{\boolean{VDMpp}}{The reason for defining both
  \texttt{SPEC1} and \texttt{SPEC2} instead of simply one variable is
  to avoid one very long line.}{} 
#endif ENG
#ifdef JPN
\ifthenelse{\boolean{VDMpp}}{単純なひとつの変数の変わりに\texttt{SPEC1}、\texttt{SPEC2}%
と2つの変数が定義されているのは、長い行になるのを避けるためである。}{}
#endif JPN
  
#ifdef ENG
\subsection{The UNIX Platforms}
#endif ENG
#ifdef JPN
\subsection{UNIXプラットフォーム}
#endif JPN

#ifdef ENG
The top level test script is called {\tt vdmloop} and can be executed
in a normal shell. This file is available in the \Toolbox\
distribution in the \path+examples/sort/test+ directory.  It looks
like:
#endif ENG
#ifdef JPN
トップレベルのテストスクリプトは{\tt vdmloop}と呼ばれ通常のシェルから実行することができる。
このファイルは\Toolbox\ で利用でき、\path+examples/sort/test+ ディレクトリにある。以下参照：
#endif JPN

#ifdef VDMSL
\verbatiminput{sort-ex/test/vdmloop}
#endif VDMSL
#ifdef VDMPP
\verbatiminput{sort-expp/test/vdmloop}
#endif VDMPP

#ifdef ENG
The test script, which takes one argument file, is called {\tt
  vdmtest.bat}.  This file is also available in the \Toolbox\ 
distribution. It looks like:
#endif ENG
#ifdef JPN
argumentファイルをひとつだけとるテストスクリプトは{\tt vdmtest.bat}と
呼ばれる。このファイルも\Toolbox\ から利用可能であり以下のようである。
#endif JPN

#ifdef VDMSL
\verbatiminput{sort-ex/test/vdmtest}
#endif VDMSL
#ifdef VDMPP
\verbatiminput{sort-expp/test/vdmtest}
#endif VDMPP

#ifdef VDMPP
\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}
#endif VDMPP

\newpage
#ifdef ENG
\section{Troubleshooting Problems with Microsoft Word}\label{sec:trouble}
#endif ENG
#ifdef JPN
\section{Microsoft Wordについてのトラブルシューティング問題}\label{sec:trouble}
#endif JPN

\begin{description}

#ifdef ENG
\item[Breakpoints on lines] \mbox{} \\
The {\tt VDM.dot}\index{VDM.dot file} Word template file
included in the \VDMTools\ 
distribution includes a special macro enabling the setting of breakpoints on
lines inside functions and operations. However this has only been
included from version \vdmtoolsver\ of the \ToolboxName. The macro
can be activated by pressing
\texttt{Control-Alt-spacebar} %\index{Control-Alt-Spacebar}
 when the cursor is placed on the desired line in an RTF file which is
 included in the current project.
#endif ENG

#ifdef JPN
\item[行を指定してブレイクポイントを設定する] \mbox{} \\
 \VDMTools\ に含まれるテンプレートファイル{\tt VDM.dot}\index{VDM.dotファイル} には、
関数や操作内部の行にブレイクポイントを設定することを可能にする特別なマクロが入っている。
しかしこの機能は\ToolboxName\ のバージョン\vdmtoolsver\ 以降でないと入っていない。
このマクロはカーソルを現在のプロジェクトに含まれるRTFファイルのブレイクポイントを
設定したい行にカーソルをあて\texttt{Control-Alt-スペース}キーを押すことで有効になる。
#endif JPN

 % In case you find that this does not
 %work for you in the way described in this document, there are a
 %number of simple fixes that you can try before contacting IFAD for
% support:
\begin{enumerate}
#ifdef ENG
\item Before activating the macro the Toolbox interpreter must
be initialised  by pressing the \guicmd{Init} button.

\item Maybe you have forgotten to move the {\tt VDM.dot} file into the
template directory used by Word; usually this is
#endif ENG

#ifdef JPN
\item
このマクロを有効にする前に \guicmd{処理系を初期化} ボタンを押してツールボックスのインタープリタを初期化していなくてはならない
\item
{\tt VDM.dot}ファイルをテンプレートディレクトリに移すのを忘れないように。通常テンプレートディレクトリは
#endif JPN

\begin{quote}
\verb+C:\Program Files\Microsoft Office\Templates+
\end{quote}

#ifdef ENG
\item The document you are using may not have VDM.dot as its
template. This can be checked using the \guicmd{Files-$>$Properties}
facility inside Microsoft Word. If you are not using \texttt{VDM.dot}
make sure that the macro is copied over to the template you wish to
use instead.
#endif ENG
#ifdef JPN
\item
使用中の文書にはおそらくテンプレートとしてのVDM.dotがないと思われる。
これはMicrosoft Word内の\guicmd{ファイル-$>$プロパティ}機能を使ってチェックすることができる。
もし\texttt{VDM.dot}がなかったらマクロは代わりに使用したいテンプレートにコピーされることを確認
しなくてはならない。
#endif JPN
\end{enumerate}

#ifdef ENG
\item[Finding the test coverage file]  \mbox{} \\
If the test coverage file cannot be included correctly it could be
because you are using files which are placed on a Unix server which is
accessed from Windows via Samba. In this situation it is currently not
possible to correctly distinguish between upper and lower case letters
used in file names, so you should make sure that all file names are
using lower case.
#endif ENG
#ifdef JPN
\item[テストカバレッジファイルの発見]  \mbox{} \\
テストカバレッジファイルが正しくincludeされていない場合は、おそらく原因は
Samba経由でウインドウズからアクセスされるUnixサーバ上におかれているファイルを
使用しているためである。この場合、ファイル名に使用されている大文字･小文字の
区別をつけることが現状正しくできないため、すべてのファイル名を小文字にするべきである。
#endif JPN

\end{description}


#ifdef VICEMAN
\newpage
#ifdef ENG
\section{Format for Time File}\label{sec:timefile}
#endif ENG
#ifdef JPN
\section{Timeファイルのフォーマット}\label{sec:timefile}
#endif JPN

#ifdef ENG
The time file should follow the syntax given below. Note that the file
is free format, so line breaks are not significant, except in
relation to comments, which may be included using the \texttt{\#}
symbol. Any text after this symbol until the end of the line is then
ignored.

The file should not contain any repeated entries. That is, no typed
instruction should appear more than once with the same type. Similarly
no typed instruction should appear more than once.
#endif ENG

#ifdef JPN
Timeファイルは以下のような構文になる。ファイルはフリーフォーマットなので、改行はコメント内のもの
（\texttt{\#}内）を除き必ずしも重要ではないことに注意。この記号（\texttt{\#}）の後行末までは無視される。

ファイルは何度もエントリを含むべきでない。これは、同じ型についての命令は1度だけ
書かれるべきだということである。
#endif JPN

\Ruledef{time file}{
  time entry \SeqPt{ \Lit{;}, \Ruleref{time entry}} \Lit{;}
}

\Ruledef{time entry}{ 
  \Ruleref{simple entry} \dsep
  \Ruleref{typed entry}
}

\Ruledef{simple entry}{
  \Ruleref{instruction},
  \Ruleref{time expression}
}

\Ruledef{typed entry}{
  \Ruleref{instruction},
  \Lit{:},
  \Ruleref{basic type},
  \Ruleref{time expression}
}

\Ruledef{basic type}{
  \Lop{bool} \dsepl
  \Lop{nat} \dsepl
  \Lop{nat1} \dsepl
  \Lop{int} \dsepl
  \Lop{rat} \dsep
  \Lop{real} \dsepl
  \Lop{char} \dsepl
  \Lop{token} 
}

\Ruledef{instruction}{
  \Lop{AddEnv} \dsep
  \Lop{Addset} \dsep
  \Lop{AllorExists} \dsep
  \Lop{Always} \dsep
  \Lop{Appendmap} \dsep
  \Lop{Appendseq} \dsep
  \Lop{Appendtup} \dsep
  \Lop{Apply} \dsep
  \Lop{BindList} \dsep
  \Lop{BlockStmt} \dsep
  \Lop{Br} \dsep
  \Lop{Call} \dsep
  \Lop{Cbr} \dsep
  \Lop{Exit} \dsep
  \Lop{Fieldsel} \dsep
  \Lop{Guard} \dsep
  \Lop{History} \dsep
  \Lop{Iota} \dsep
  \Lop{Isexpr} \dsep
  \Lop{Isofbaseclass} \dsep
  \Lop{Isofclass} \dsep
  \Lop{LambdaExpr} \dsep
  \Lop{LetBeST} \dsep
  \Lop{Lookup} \dsep
  \Lop{Loop} \dsep
  \Lop{MapInverse} \dsep
  \Lop{MatchPattern} \dsep
  \Lop{Newobj} \dsep
  \Lop{NonDet} \dsep
  \Lop{Pattern} \dsep
  \Lop{Polyinst} \dsep
  \Lop{Reccons} \dsep
  \Lop{Recmod} \dsep
  \Lop{RecTrap} \dsep
  \Lop{Return} \dsep
  \Lop{Samebaseclass} \dsep
  \Lop{Sameclass} \dsep
  \Lop{Selfexpr} \dsep
  \Lop{Seqlen} \dsep
  \Lop{Seqmapover} \dsep
  \Lop{Setcard} \dsep
  \Lop{Setrng} \dsep
  \Lop{Start} \dsep
  \Lop{Subseq} \dsep
  \Lop{Threadid} \dsep
  \Lop{Trap} \dsep
  \Lop{Tupsel} \dsep
  \Lop{Update} \dsep
  \Lop{+ } \dsep
  \Lop{- } \dsep
  \Lop{* } \dsep
  \Lop{/ } \dsep
  \Lop{rem } \dsep
  \Lop{mod } \dsep
  \Lop{intdiv } \dsep
  \Lop{and } \dsep
  \Lop{or } \dsep
  \Lop{= } \dsep
  \Lit{$>$} \dsep
  \Lit{$>=$} \dsep
  \Lop{abs } \dsep
  \Lop{floor } \dsep
  \Lop{not }
}

\Ruledef{time expression}{
  \Ruleref{assembly instruction} \dsep
  \Ruleref{numeral} \dsep
  \Ruleref{time expression} \Lit{+} \Ruleref{time expression} \dsep
  \Ruleref{time expression} \Lit{*} \Ruleref{time expression} \dsep
  \Lit{(} \Ruleref{time expression} \Lit{)}
}

\Ruledef{assembly instruction}{
  \Lop{add} \dsep
  \Lop{branch} \dsep
  \Lop{call} \dsep
  \Lop{compare} \dsep
  \Lop{return} \dsep
  \Lop{sub} \dsep
  \Lop{div} \dsep
  \Lop{mul} \dsep
  \Lop{neg} \dsep
  \Lop{fsqrt} \dsep
  \Lop{logic} \dsep
  \Lop{cas} \dsep
  \Lop{push} \dsep
  \Lop{pop}
}


\Ruledef{numeral}{
  \Ruleref{digit}, \SeqPt{\Ruleref{digit}}
}

\Ruledef{digit}{
  \Lop{0} \dsepl
  \Lop{1} \dsepl 
  \Lop{2} \dsepl 
  \Lop{3} \dsepl 
  \Lop{4} \dsepl 
  \Lop{5} \dsepl 
  \Lop{6} \dsepl 
  \Lop{7} \dsepl 
  \Lop{8} \dsepl 
  \Lop{9}
}
#endif VICEMAN

#ifdef VDMPP
\newpage
#ifdef ENG
\section{Format for Priority File}\label{sec:priorityfile}\index{Priority File!Format of}
#endif ENG
#ifdef JPN
\section{プライオリティファイルのフォーマット}\label{sec:priorityfile}\index{プライオリティファイル!フォーマット}
#endif JPN

#ifdef ENG
Priority files should have the following format:
#endif ENG
#ifdef JPN
プライオリティファイルのフォーマットは以下のとおり
#endif JPN

\Ruledef{priority file}{
  priority entry \SeqPt{ \Lit{;}, \Ruleref{priority entry}} \Lit{;}
}

\Ruledef{priority entry}{
  class name \Lit{:} numeral
}
#endif VDMPP

#ifdef VICEMAN
where \textit{numeral} is the same as for a time file.
#else 
#ifdef VDMPP
\Ruledef{numeral}{
  \Ruleref{digit}, \SeqPt{\Ruleref{digit}}
}
#endif VDMPP
#endif VICEMAN

#ifdef VDMPP
\Ruledef{digit}{
  \Lop{0} \dsepl
  \Lop{1} \dsepl 
  \Lop{2} \dsepl 
  \Lop{3} \dsepl 
  \Lop{4} \dsepl 
  \Lop{5} \dsepl 
  \Lop{6} \dsepl 
  \Lop{7} \dsepl 
  \Lop{8} \dsepl 
  \Lop{9}
}

#endif VDMPP

\newpage
#ifdef ENG
\addcontentsline{toc}{section}{Index}
#endif ENG
#ifdef JPN
\addcontentsline{toc}{section}{索引}
#endif JPN
\printindex
\end{document}

