//
// THIS FILE IS AUTOMATICALLY GENERATED!!
//
// Generated at Thu 25-Sep-97 by the VDM++toC++ Code Generator
// (v6.0 - Thu 25-Sep-97)
//
// Supported compiler: g++ version 2.7.2
//



#include "WorkSpace.h"
#include "Parallelogram.h"
#include "Quadrilateral.h"

vdm_WorkSpace::vdm_WorkSpace() {
  RegisterAsDerived(vdm_GetId());
  vdm_screen = Map();
}

ObjectRef vdm_WorkSpace::vdm_LookUp(Int vdm_qid) { return (ObjectRef) vdm_screen[vdm_qid]; }

Real vdm_WorkSpace::vdm_GetAngle(Int vdm_qid) {
  ObjectRef tmpVal_2;
  tmpVal_2 = (ObjectRef) vdm_screen[vdm_qid];
  ObjectRef vdm_scrn;
  vdm_scrn = tmpVal_2;
  {
    Real tmpVal_6 = ObjGet_vdm_Parallelogram(vdm_scrn)->vdm_GetAngle();
    Real vdm_angle;
    vdm_angle = tmpVal_6;
    return vdm_angle;
  }
}

void vdm_WorkSpace::vdm_Display(Int vdm_qid, ObjectRef vdm_q) {
  Map rhs_1;
  {
    Map m1_10 = vdm_screen;
    Map m2_11 = Map().Insert(vdm_qid, vdm_q);
    Set com_6 = m1_10.Dom();
    com_6.ImpIntersect(m2_11.Dom());
    int all_applies_7 = 1;
    Generic d_8;
    for (int bb_9 = com_6.First(d_8); bb_9 && all_applies_7; bb_9 = com_6.Next(d_8)) 
      all_applies_7 *= m1_10[d_8] == m2_11[d_8];
    if (all_applies_7) 
      m1_10.ImpOverride(m2_11);
    else 
      RunTime("EvalMapMerge Duplicates not equal");
    rhs_1 = m1_10;
  }
  vdm_screen = rhs_1;
  ObjGet_vdm_Quadrilateral(vdm_q)->vdm_Display();
}

void vdm_WorkSpace::vdm_UnDisplay(Int vdm_qid) {
  Map rhs_1;
  Set var1_2;
  var1_2 = Set().Insert(vdm_qid);
  rhs_1 = vdm_screen;
  {
    Map tmpMap_5;
    Set domM_6 = rhs_1.Dom();
    Generic elm_7;
    for (int bb_8 = domM_6.First(elm_7); bb_8; bb_8 = domM_6.Next(elm_7)) 
      if (!var1_2.InSet(elm_7)) 
        tmpMap_5.Insert(elm_7, rhs_1[elm_7]);
    rhs_1 = tmpMap_5;
  }
  vdm_screen = rhs_1;
}

void vdm_WorkSpace::vdm_Move(Int vdm_qid, Tuple vdm_p1, Tuple vdm_p2) {
  ObjectRef vdm_scrn = (ObjectRef) vdm_screen[vdm_qid];
  vdm_UnDisplay(vdm_qid);
  ObjGet_vdm_Quadrilateral(vdm_scrn)->vdm_Move(vdm_p1, vdm_p2);
  vdm_Display(vdm_qid, vdm_scrn);
}
