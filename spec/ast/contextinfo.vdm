%--------------------------------------------------------------------------------
% $Id: contextinfo.vdm,v 1.23 2002/12/19 12:46:20 mikhail Exp $
% Implemented in: contextinfo.w, tokenlist.h
%--------------------------------------------------------------------------------
\section{Module CI}

It is possible to attached context information on every node in the
Abstract Syntax Tree (AST). An example of this is position information and
type information. 

The context information is modelled as a pointer mechanism: Every node in
the AST has an abstract field containing a context identifier. This
identifier points into a table containing the context information of the
node. The context information is described in this module.

\insertfig{cntxt.idr}{12cm}{The overall structure of the context information and token list}{\label{fig:cntxt}}

\begin{vdm_al}
module CI


imports
#ifdef JSS
  from JSSREP all,
#endif JSS
  from REP all,
  from AS all

exports 
    all

definitions
\end{vdm_al}


The {\em ContextId} is the context identifier being placed on every node in
the AST. The {\em ContextId} is an int (but only -1 is allowed in the
negative range). The first 10 bits of the context identifier models the
module identifier, and the next 22 bits models the node identfier.

\begin{vdm_al}
 types
     ContextId = int;   -- was nat, but changed because of NilContextId

     NodeId = nat
     inv nid == nid < MaxNid -1;

     FileId = nat
     inv fid == fid < MaxFid -1;

#ifdef JSS
     TypeInfo = REP`TypeRep | JSSREP`TypeRep;
#else
     TypeInfo = REP`TypeRep;
#endif JSS
values

--   MaxNid: nat = 2**22;
   MaxNid: nat = 2**24;
   MaxFid: nat = 2**10;

   NilContextId: int = -1;
\end{vdm_al}

During interpretation of the dynamic semantics, type checking in the static
checker and code generation in the code generator, there is a need for
constructing temporary AST parts and thereby to construct temporary
context id's. Therefore for each component (intepreter, code generator and
type checker) a special entry is reserved:
\begin{vdm_al}

   CGEntry: nat = 1;
   IPEntry: nat = 2;
   TCEntry: nat = 3;
\end{vdm_al}


\begin{vdm_al}
state Sigma of
  tll_ci : seq of TokenContextInfo
  fid_m : FileIdMap
init s == s = mk_Sigma([],{|->})
end

types 
TokenContextInfo::
  tll : TokenList
  ci  : ContextInfo;

ContextInfo = seq of ContextNodeInfo;
FileIdMap = map FileId to seq of char;
\end{vdm_al}

The state of the context information consists of:

\begin{itemize}
\item tll\_ci: The context information and token-list for each file. This
  sequence is index with the \emph{FileId}. It is a sequence where each
  element corresponds to one file and these elements contain the following
  sub elements:
  \begin{itemize}
  \item A sequence of {\em TokenInfo}, i.e.\ the tokens from the input
    file. The order of the elements in the sequence is equal to the order
    of the tokens in the input file.
  \item A sequence of {\em ContextNodeInfo}, i.e.\ all necessary
    context information for each node in the AST. The key to the
    sequence is the {\em NodeId}.
  \end{itemize}
\item fid\_m: The mapping from file identifiers, {\em FileId}, to the
  file name.
\end{itemize}

For every file a sequence of the VDM tokens is generated, the {\em
  TokenList} describes the data type of this sequence.

\begin{vdm_al}
TokenList = seq of TokenInfo;
\end{vdm_al}

A {\em TokenInfo} consists of:

\begin{itemize}
\item lexid: The token identifier as given by the lex scanner (maybe
  used by the pretty printer).
\item text: The text of an identifier (used only by the pretty printer).
\item pos\_st: Position of the first char in the token.
\item pos\_end: Position of the last char in the token.
\end{itemize}

\begin{vdm_al}
TokenInfo ::
  lexid   : LexId
  text    : TextId
  pos_st  : TokenPos
  pos_end : TokenPos;

LexId = int;

TextId = seq of char;
\end{vdm_al}

The token position contains the section position and the line and
column positions. For \LaTeX\ documents the section position will
always be one. The section field is used for RTF documents.

The \texttt{relAbs\_line} is an absolute line, except that line information
is not counted. That is lines of the kind \texttt{-- Line }. These lines
are generated by the RTF parser, but are not located in the input RTF
file. This is a semi hack to get breakpoints on lines working (see TB54).

\begin{vdm_al}
TokenPos ::
  section: Section
  abs_line : Line
  relAbs_line : Line
  sec_line : Line
  column : Column;

Section = nat;
Line = nat;
Column = nat;
\end{vdm_al}


The token span, {\em TokenSpan}, describes which tokens a node
consists of: described by the start token and the end token in the
token list, and the \emph{middle} token (named \texttt{token\_ast}).

\begin{vdm_al}
TokenSpan ::
  token_st  : TokenRef
  token_ast : TokenRef
  token_end : TokenRef;

TokenRef = int;
\end{vdm_al}


The {\em ContextInfo} is the information that can be related to a node
in the AST:
\begin{itemize}
\item tokenpos: The token span, i.e.\ a link to the tokens in the
  token list that the node consists of.
\item coverage: The test coverage information.
\item typeinfo: Type information. This is inserted by the type
  checker, and used by the code generator.
\item pid-m: type information for patterns in comprehensions. This
  information is also inserted by the type checker and used by the
  code generator.  
\item index: Index information. Used to generate index information by
  the pretty printer.
\item isBreakable: This flag is true if it is possible to berak at this
context id. It is possible to vreak at a context id, if the id is located
in a program table.
\end{itemize}

\begin{vdm_al}

     ContextNodeInfo ::
        tokenpos : [TokenSpan]
        coverage : TestCoverageInfo
        typeinfo : [TypeInfo]
        pid_m    : [ map AS`Name to REP`TypeRep ]
        index    : [IndexInfo]
        isBreakable : bool
        breakpoint  : bool ;

     TestCoverageInfo = int;
     IndexInfo = nat

values
  InitCntxtNodeInfo: ContextNodeInfo = mk_ContextNodeInfo( nil, -1, nil, nil, nil, false, false)

\end{vdm_al}

The functions {\em ConvCid2Mid} and {\em ConvCid2Nid} are used to
convert context identifiers to module and node identifiers respectively.
\begin{vdm_al}
functions

  ConvCid2Fid: ContextId -> FileId
  ConvCid2Fid(cid) ==
    cid div MaxNid;

  ConvCid2Nid: ContextId -> NodeId
  ConvCid2Nid(cid) ==
    cid mod MaxNid;

  SplitCid: ContextId -> FileId * NodeId
  SplitCid(cid) ==
    mk_(ConvCid2Fid(cid), ConvCid2Nid(cid));

\end{vdm_al}

The functions {\em IsAValidFileId\/} and {\em IsAValidContextId\/} test whether a {\em FileId\/} and
 {\em ContextId\/} respectively is defined in {\em tll\_ci}.

\begin{vdm_al}
operations
  IsAValidFileId: FileId ==> bool
  IsAValidFileId (fid) ==
    return fid in set inds tll_ci;

  IsAValidContextId: ContextId ==> bool
  IsAValidContextId (cid) ==
    if cid <> NilContextId
    then let mk_(fid,nid) = SplitCid(cid)
         in
           return fid in set inds tll_ci and nid in set inds tll_ci(fid).ci
    else return false
\end{vdm_al}


\subsection{Initialisation}
The operation {\em UseContextTab} initializes the information for a file identifier.

\begin{vdm_al}
operations

  UseContextTab: FileId * bool ==> ()
  UseContextTab(fid, reset) ==
   (if len tll_ci < fid
    then 
       tll_ci := tll_ci ^ [mk_TokenContextInfo([],[]) | - in set {len tll_ci + 1,...,fid}];
    if reset
    then 
      tll_ci(fid) := mk_TokenContextInfo([],[])
   );

\end{vdm_al}

The operation {\em Push} adds an entry in the context table for
a file id and returns a new corresponding {\em ContextId}.

\begin{vdm_al}
  Push: FileId ==> ContextId
  Push(fid) ==
    let mk_TokenContextInfo(tll,ci) = tll_ci(fid)
    in
     (tll_ci(fid) := mk_TokenContextInfo(tll, ci ^ [ InitCntxtNodeInfo ]);
      return  fid*MaxNid + len ci + 1)
  pre IsAValidFileId(fid);

\end{vdm_al}

\subsection{Type Information}

The operation {\em GetTypeInfo} extracts the type information for a given context identifier. 

\begin{vdm_al}
operations
  GetTypeInfo: ContextId ==> [REP`TypeRep]
  GetTypeInfo(cid) ==
    let mk_(fid,nid) = SplitCid(cid),
        mk_TokenContextInfo(-,ci) = tll_ci(fid) in
    return ci(nid).typeinfo
  pre HasTypeInfo(cid) and IsAValidContextId(cid);

\end{vdm_al}
#ifdef VDMPP
The operation {\em GetJSSTypeInfo} extracts the Java Static Semantics type information 
for a given context identifier. 

\begin{vdm_al}
  GetJSSTypeInfo: ContextId ==> [TypeInfo]
  GetJSSTypeInfo(cid) ==
    let mk_(fid,nid) = SplitCid(cid),
        mk_TokenContextInfo(-,ci) = tll_ci(fid) in
    return ci(nid).typeinfo
  pre HasTypeInfo(cid) and IsAValidContextId(cid);

\end{vdm_al}
#endif VDMPP

The opeation {\em SetTypeInfo} sets the type information for a given context identifier.

\begin{vdm_al}
SetTypeInfo: ContextId * REP`TypeRep ==> ()
SetTypeInfo(cid, type) ==
  let mk_(fid, nid) = SplitCid(cid) in
      tll_ci(fid).ci(nid).typeinfo := type
  pre IsAValidContextId(cid);

\end{vdm_al}
#ifdef VDMPP

The opeation {\em SetJSSTypeInfo} sets the Java Static Semantics type information 
for a given context identifier.

\begin{vdm_al}
SetJSSTypeInfo: ContextId * [TypeInfo] ==> ()
SetJSSTypeInfo(cid, type) ==
  let mk_(fid, nid) = SplitCid(cid) in
      tll_ci(fid).ci(nid).typeinfo := type
  pre IsAValidContextId(cid);
\end{vdm_al}
#endif VDMPP

The operation {\em HasTypeInfo} determines if type information is
available for a given context identifier. The operation is used in
invariant functions for the nodes that should contain type
information. 

\begin{vdm_al}
 HasTypeInfo: ContextId ==> bool
 HasTypeInfo(cid) ==
 return 
   IsTypeChecked() => let mk_(fid, nid) = SplitCid(cid)
                      in tll_ci(fid).ci(nid).typeinfo <> nil;
\end{vdm_al}


The operation {\em GetPidM} extracts type information for pattern
names for a given context identifier.
\begin{vdm_al}
 GetPidM: ContextId ==> map AS`Name to REP`TypeRep
 GetPidM(cid) ==
   let mk_(fid, nid) = SplitCid(cid)
   in return tll_ci(fid).ci(nid).pid_m
 pre IsAValidContextId(cid) and HasPidMInfo(cid);
\end{vdm_al}

The operation {\em SetPidM} sets type information for pattern names
for a given context identifier:

\begin{vdm_al}
SetPidM: ContextId * map AS`Name to REP`TypeRep ==> ()
SetPidM(cid, pidm) ==
  let mk_(fid,nid) = SplitCid(cid)
  in tll_ci(fid).ci(nid).pid_m := pidm
pre IsAValidContextId(cid);
\end{vdm_al}

The operation {\em HasPidMInfo} determines if type information for
pattern name is available for a given context identifier. The
operation is used in invariant functions for the nodes that should
contain type information for pattern name.

\begin{vdm_al}
 HasPidMInfo: ContextId ==> bool
 HasPidMInfo(cid) ==
   return
     IsTypeChecked() => let mk_(fid, nid) = SplitCid(cid)
                        in tll_ci(fid).ci(nid).pid_m <> nil
pre IsAValidContextId(cid);
\end{vdm_al}


The operation {\em IsTypeChecked} determines if the specification has
been type checked, and thus, if type information for the node on AST
has been generated. 

For testing at the specification level this operation have been set to
return false in order to allow pre-consition checking of the specification.
\begin{vdm_al}
IsTypeChecked: () ==> bool
IsTypeChecked() ==
  return false;

\end{vdm_al}


\subsection{Position Information}

\begin{vdm_al}
  GetFileLineColPos: ContextId ==> seq of char * Line * Column
  GetFileLineColPos(cid) ==
    def mk_(found, fid, -, pos_ast, -) = GetFilePos(cid)
    in if found
       then let fileName = fid_m(fid),
            mk_TokenPos(-, abs_line,-,-,column) = pos_ast
            in return mk_(fileName, abs_line, column)
       else error;
        
\end{vdm_al}

The operation {\em GetPos} extracts the token span of a given node
(represented by its context identifier), i.e.\ the first and the last
token that the node consists of.

\begin{vdm_al}
 GetPos: ContextId ==> [TokenSpan]
 GetPos(cid) ==
   let mk_(fid, nid) = SplitCid(cid) in
   return tll_ci(fid).ci(nid).tokenpos
 pre IsAValidContextId(cid);

\end{vdm_al}


The operation {\em SetPosInfo} sets the token span for a specific node
(represented by its context identifier).

\begin{vdm_al}
 SetPos: ContextId * TokenSpan ==> ()
 SetPos(cid, pos) ==
   let mk_(fid, nid) = SplitCid(cid)
   in tll_ci(fid).ci(nid).tokenpos := pos
 pre IsAValidContextId(cid);
\end{vdm_al}

Note the boolean is used in the implementation to signal an internal error if the
element was not found.

\begin{vdm_al}
  GetFilePos: ContextId ==> bool * FileId * TokenPos * TokenPos * TokenPos
  GetFilePos(cid) ==
   let mk_(fid, nid) = SplitCid(cid),
       mk_TokenSpan(sta,ast,en) = tll_ci(fid).ci(nid).tokenpos,
       mk_TokenInfo(-,-,tst,-) = tll_ci(fid).tll(sta),
       mk_TokenInfo(-,-,-,ten) = tll_ci(fid).tll(en),
       mk_TokenInfo(-,-,ast_start,-)   = tll_ci(fid).tll(ast)
   in
   return mk_(true, fid, tst, ast_start, ten)
  pre IsAValidContextId(cid) and 
      let mk_(fid,nid) = SplitCid(cid)
      in tll_ci(fid).ci(nid).tokenpos <> nil;

  GetLocation : ContextId ==> nat * nat
  GetLocation (cid) ==
    def mk_(-,-,-,ast,-) = GetFilePos(cid);
        line = ast.abs_line;
        col  = ast.column 
     in 
        return mk_(line,col); 
\end{vdm_al}


\subsection{Inverse position information}

\begin{vdm_al}

types
  Point :: x: nat
           y: nat;

operations

  GetCidAtPos: seq of char * int * int ==> bool * seq of char * [ContextId]
  GetCidAtPos(file, line, col) ==
    def fid = GetFidForFile(file)
    in if fid = nil
       then return mk_(false, "No such file", nil)
       else def ci : ContextInfo = tll_ci(fid).ci;
                tll : TokenList = tll_ci(fid).tll;
                mk_(found, nodeId) = FindPosInContextInfo(ci, tll, line, col)
            in if found
               then return mk_(true, "", CreateCid(fid, nodeId))
               else return mk_(false, "Position beyond end of file", NilContextId);


  GetFidForFile: seq of char ==> [FileId]
  GetFidForFile(file) ==
    --let m = inverse fid_m
    --in if file in set dom m
    --   then return m(file)
    --   else return nil;
    return 
      cases fid_m:
        { fid |-> (file) } munion - -> fid,
        others                      -> nil
      end;

  FindPosInContextInfo: ContextInfo * TokenList * int * int ==> bool * [NodeId]
  FindPosInContextInfo(ci, tll, line, col) ==
  ( dcl closestPoint  : Point := mk_Point(2**32, 2**32),
        minNid  : NodeId := 0;
    for index = 1 to len(ci) do
      let cni = ci(index),
          tokenpos : [TokenSpan] = cni.tokenpos
      in if tokenpos = nil or tokenpos.token_ast = -1
            or not cni.isBreakable
         then skip
         else let token_ast : TokenRef = tokenpos.token_ast,
                  token_info : TokenInfo = tll(token_ast),
                  token_st : TokenPos = token_info.pos_st,
                  token_len : nat = len(token_info.text),
                  curLine : Line = token_st.relAbs_line,
                  curCol : Column = token_st.column
              in if PointCloser(mk_Point(col,line), closestPoint, mk_Point(curCol+token_len-1, curLine))
                 then ( closestPoint := mk_Point(curCol, curLine);
                        minNid := index );
     if minNid = 0
     then return mk_(false, 0)
     else return mk_(true, minNid));

  PointCloser: Point * Point * Point ==> bool
  PointCloser(searchPoint, closestPoint, candidate) ==

    if candidate.y < searchPoint.y or 
       (candidate.y = searchPoint.y and candidate.x < searchPoint.x)
    then return false -- Candidate is before the point we search for.

    else return candidate.y < closestPoint.y or
                candidate.y = closestPoint.y and candidate.x < closestPoint.x;
             
  -- implemented as `cid' in contextinfo.w
  CreateCid: FileId * NodeId ==> ContextId
  CreateCid(fid,nid) ==
    return fid*MaxNid + nid;

\end{vdm_al}

\subsection{Breakpoint Handling}


\begin{vdm_al}

  IsCidBreakable: ContextId ==> bool
  IsCidBreakable(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in return tll_ci(fid).ci(nid).isBreakable;

  SetBreakable: ContextId ==> ()
  SetBreakable(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in tll_ci(fid).ci(nid).isBreakable := true;

  SetBreakpoint: ContextId ==> ()
  SetBreakpoint(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in tll_ci(fid).ci(nid).breakpoint := true;

  RemoveBreakpoint: ContextId ==> ()
  RemoveBreakpoint(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in tll_ci(fid).ci(nid).breakpoint := false;
            
  IsBreakpointAtCid: ContextId ==> bool
  IsBreakpointAtCid(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in return tll_ci(fid).ci(nid).breakpoint;


\end{vdm_al}


\subsection{Test Coverage Information}

The operation {\em GetTestCoverageInfo} extracts the test coverage
information for a give context identifier.

\begin{vdm_al}

GetTestCoverageInfo: ContextId ==> TestCoverageInfo
GetTestCoverageInfo(cid) ==
let mk_(fid,nid) = SplitCid(cid)
in return tll_ci(fid).ci(nid).coverage
pre IsAValidContextId(cid);
\end{vdm_al}


\begin{vdm_al}
IncTestCoverageInfo: ContextId  ==> ()
IncTestCoverageInfo(cid) ==
let mk_(fid,nid) = SplitCid(cid)
in tll_ci(fid).ci(nid).coverage := tll_ci(fid).ci(nid).coverage + 1
pre IsAValidContextId(cid)

\end{vdm_al}

\subsection{Construction of temporary Context Information}

In the dynamic semantics, the type checker and the interpreter
temporary subparts of the AST is constructed. As a consequence
temporary context information should also be constructed. Three
reserved file identifiers in the {\em ContextInfo} table have been
reserved for storing temporary context information. 

The operations in this subsection all works on these temporary context
information.

\begin{vdm_al}
operations

ResetCGTable: () ==> ()
ResetCGTable() ==
UseContextTab(CGEntry,true);

ResetIPTable: () ==> ()
ResetIPTable() ==
UseContextTab(IPEntry,true);

ResetTCTable: () ==> ()
ResetTCTable() ==
UseContextTab(TCEntry,true);
 
\end{vdm_al}

\begin{vdm_al}
PushCGPosType: [TokenSpan ] * [REP`TypeRep] ==> ContextId
PushCGPosType(pos, type) ==
  def cid = Push(CGEntry)
  in
   (SetTypeInfo(cid, type);
    SetPos(cid, pos);
    return cid;
   );

PushCGType: [REP`TypeRep] ==> ContextId
PushCGType(type) ==
  def cid = Push(CGEntry)
  in
   (SetTypeInfo(cid, type);
    return cid;
   );
\end{vdm_al}


\subsection{Updating the State}


\begin{vdm_al}
UpdateStateSigma: seq of TokenContextInfo * FileIdMap ==> ()
UpdateStateSigma(tllci,fidm) ==
( if (exists i in set (inds tll_ci inter inds tllci) & 
           tllci(i) <> mk_TokenContextInfo([],[]) and
           tll_ci(i) <> mk_TokenContextInfo([],[])) or
     (exists fid in set dom fidm inter dom fid_m & fidm(fid) <> fid_m(fid))
  then error
  else
  ( let tllci_indexset = { i | i in set inds tllci & i <= len tll_ci and 
                               tllci(i) <> mk_TokenContextInfo([],[]) } in
    for all i in set tllci_indexset do
      tll_ci(i) := tllci(i);
    for i = len tll_ci + 1 to len tllci do
      tll_ci := tll_ci ^ [ tllci(i) ];
    fid_m := fid_m ++ fidm )
)

end CI
\end{vdm_al}
