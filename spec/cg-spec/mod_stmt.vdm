%--------------------------------------------------------------------------------
% WHAT
%    Module providing functions generating code corresponding to
%    both VDM++ and VDM-SL statements.
%      C preprocessor macroes:
%        VDMPP  -> VDM++ abstract syntax.
%        VDMSL  -> VDM-SL abstract syntax.
%      Note: #ifdef VDMPP => #include "ppstmt.vdm"
% $Id: mod_stmt.vdm,v 1.86 2001/12/19 08:40:36 richard Exp $
% Implemented in: ???
%--------------------------------------------------------------------------------
\section{Module CGSTMT - Code Generating Statements}

The module provides a function generating code corresponding to vdm
statements.

\begin{vdm_al}
module CGSTMT

imports
    from CONC all,
    from CPP all,
    from CGEXPR all,
    from AS all,
    from PM all,
    from BC all,
    from DS all,
    from CGMAIN all,
    from CGAUX all,
    from REP all,
    from CI all,
    from ENV all,
    from TYPE all,

    from FD operations
            PushEnv:() ==> ();
            PopEnv:() ==> ();
            GenLocalFcts: seq of AS`FnDef ==> (),
    from TPGEN all,
    from UTIL all,
    from VD all

exports all

definitions

operations

GenStmt: AS`Stmt * bool ==> seq of CPP`Stmt
GenStmt( stmt, isLast ) ==
   cases true:
     (is_AS`AssignStmt(stmt))        -> (dcl stmts : seq of CPP`Stmt := CGAssignStmt(stmt);
#ifdef VDMPP
                                         if not CGAUX`GetAtomic() and not CGAUX`GetConstr() and
                                            CGAUX`GetHasInv() and CGMAIN`get_testpreandpost_option()
                                         then stmts := stmts ^ [GenInvCall(CGAUX`GiveCurCASName(),false)];
#endif VDMPP
                                         return stmts;),
     (is_AS`AtomicAssignStmt(stmt))  -> CGAtomicAssignStmt(stmt, isLast),
     (is_AS`IfStmt(stmt))            -> CGIfStmt(stmt, isLast),
     (is_AS`IdentStmt(stmt))         -> CGIdentStmt(),
     (is_AS`CasesStmt(stmt))         -> CGCasesStmt(stmt, isLast),
     (is_AS`ReturnStmt(stmt))        -> CGReturnStmt(stmt),
     (is_AS`BlockStmt(stmt))         -> CGBlockStmt(stmt, isLast),
     (is_AS`LetStmt(stmt))           -> CGLetStmt(stmt, isLast),
     (is_AS`WhileLoopStmt(stmt))     -> CGWhileLoopStmt(stmt, isLast),
     (is_AS`SeqForLoopStmt(stmt))    -> CGSeqForLoopStmt(stmt, isLast),
     (is_AS`SetForLoopStmt(stmt))    -> CGSetForLoopStmt(stmt, isLast),
     (is_AS`IndexForLoopStmt(stmt))  -> CGIndexedForLoopStmt(stmt, isLast),
     (is_AS`LetBeSTStmt(stmt))       -> CGLetBeSTStmt(stmt, isLast),
     (is_AS`DefStmt(stmt))           -> CGDefStmt(stmt, isLast),
     (is_AS`NonDetStmt(stmt))        -> CGNonDetStmt(stmt, isLast),
     (is_AS`CallStmt(stmt))          -> CGCallStmt(stmt),
     (is_AS`ErrorStmt(stmt))         -> CGErrorStmt(),
     (is_AS`AlwaysStmt(stmt))        -> CGAlwaysStmt(stmt, isLast),
     (is_AS`ExitStmt(stmt))          -> CGExitStmt(stmt),
     (is_AS`TrapStmt(stmt))          -> CGTrapStmt(stmt, isLast),
     (is_AS`RecTrapStmt(stmt))       -> CGRecTrapStmt(stmt, isLast),
     (is_AS`SpecificationStmt(stmt)) -> GenSpecTopStmt(stmt),
#ifdef VDMPP
     (is_AS`StartStmt(stmt))         -> if CPP`isJAVA() and CGMAIN`get_conc_option()
                                        then return CONC`GenStartStmt(stmt, isLast)
                                        else (if CPP`isJAVA()
                                              then CGAUX`SetNotSupportedException(true);
                                              return GenNotSupported("start statement", isLast)),
     (is_AS`StartListStmt(stmt))     -> if CPP`isJAVA() and CGMAIN`get_conc_option()
                                        then return CONC`GenStartlistStmt(stmt, isLast)
                                        else (if CPP`isJAVA()
                                              then CGAUX`SetNotSupportedException(true);
                                              return GenNotSupported("start list statement", isLast)),
     (is_AS`StopStmt(stmt))          -> if CPP`isJAVA() and CGMAIN`get_conc_option()
                                        then return CONC`GenStopStmt(stmt, isLast)
                                        else (if CPP`isJAVA()
                                              then CGAUX`SetNotSupportedException(true);
                                              return GenNotSupported("stop statement", isLast)),
     (is_AS`StopListStmt(stmt))      -> if CPP`isJAVA() and CGMAIN`get_conc_option()
                                        then return CONC`GenStoplistStmt(stmt, isLast)
                                        else (if CPP`isJAVA()
                                              then CGAUX`SetNotSupportedException(true);
                                              return GenNotSupported("stop list statement", isLast)),
#endif VDMPP
#ifdef VICE
     (is_AS`DurationStmt(stmt))      -> (CGAUX`SetNotSupportedException(true);
                                         return GenStmt(stmt.stmt, isLast)),
     (is_AS`CycleStmt(stmt))         -> (CGAUX`SetNotSupportedException(true);
                                         return GenStmt(stmt.stmt, isLast)),
#endif VICE
      others -> error
   end;

GenNotSupported : seq of char * bool ==> seq of CPP`Stmt
GenNotSupported(msg, isLast) ==
  if isLast
  then
    def retStmt = BC`GenReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))
    in
      return [BC`GenIfStmt(BC`GenBoolLit(true), BC`GenBlock([CGAUX`NotSupported(msg), retStmt]), nil)]
  else
    return [CGAUX`NotSupported(msg)];

\end{vdm_al}


\subsection{Assign Statement}\label{sec:asgnstmt}

The specification of the code generation of assign statement it is
listed in this section.  The assignment statement can change the value
of a global or local state. The left hand side of an assignment can
be:

\begin{enumerate}
\item name: An example of a VDM assignment is listed below:
  \begin{verbatim}
  a := 3;
  \end{verbatim}

  The corresponding pseudo code of this VDM statement is listed below:
  \begin{verbatim}
  vdm_var_a = (Int) 3;
  \end{verbatim}

  Notice, that it is not investigated if the variable $a$ denotes
  a local or global state, this is not necessary since we use the C++
  scope to model the VDM scope.

\item field reference: An example of a VDM assignment is listed below:
  \begin{verbatim}
  a.First := 3;
  \end{verbatim}
  where the variable $a$ is supposed to be of a record type
  containing the field selector $First$.

  The corresponding pseudo code is listed below:

  \TBW

\item map reference: An example of a VDM assignment is listed below:
  \begin{verbatim}
  a(3) := 4;
  \end{verbatim}
  where the variable $a$ is supposed to be of type : $\Nat \Gmap \Nat$

  The corresponding pseudo code is listed below:

  \begin{verbatim}
  Int tmpVar; // Declaration of a temporary variable to contain
              // the result of the evaluation of "3".
  ...CGExpr( "3", mk_CGMAIN`VT( tmpVar, "Int") );
  Int rhs;    // Declaration of a temporary variable to contain
              // the result of the evaluation of the right hand
              // side expression "4".
  ...CGExpr( "4", mk_CGMAIN`VT( rhs, "Int" ) );
  if ( vdm_var_a.DomExists( tmpVar) )
    vdm_var_a.ImpModify( tmpVar, rhs )
  else
    RunTimeError()
  \end{verbatim}

  Notice that the variable \verb+vdm_var_a+ is not neccessarily
  declared as a map, it could be also be declared as a union type or
  optional type. This means, that in some cases it is necessary to
  cast \verb+vdm_var_a+ to the corresponding implemenation of a map.
  This has not been shown in the example.

\item sequence reference: An example of a VDM assignment is listed
  belos:
  \begin{verbatim}
  a(3) := 4;
  \end{verbatim}
  where the variable $a$ is supposed to be of type : {\bf seq of nat}.

  The corresponding pseudo code is listed below:

  \begin{verbatim}
  Int tmpVar; // Declaration of a temporary variable to contain
              // the result of the evaluation of "3".
  ...CGExpr( "3", mk_CGMAIN`VT( tmpVar, "Int") );
  Int rhs;    // Declaration of a temporary variable to contain
              // the result of the evaluation of the right hand
              // side expression "4".
  ...CGExpr( "4", mk_CGMAIN`VT( rhs, "Int" ) );
  if ( vdm_var_a.Length() >= tmpVar.GetValue() ) {
    vdm_var_a.ImpModify( tmpVar.GetValue(), rhs );
  }
  else
    RunTimeError()
  \end{verbatim}

  Notice, that also in this example it is assumed that the variable
  \verb+vdm_var_a+ is declared as a sequence. If this is not the case
  it is necessary to cast the variable.

\end{enumerate}

In this version of the code generator, the code generator only
supports assignment statement where the state designator is a {\tt AS`Name}.


\begin{vdm_al}
CGAssignStmt: AS`AssignStmt ==> seq of CPP`Stmt
CGAssignStmt( mk_AS`AssignStmt(sd, expr, cid) ) ==
  def mk_(isit, stmt) = GenCommonAsgnStmt(sd, expr)
  in
    if isit
    then return stmt
    else
      def rhsType = CGAUX`FindType(expr);
          mk_(e_v, rhs_stmt) = CGEXPR`CGExprExcl(expr, "rhs", rhsType);
          gtp = CGAUX`FindType(sd)
      in
        (dcl rb : seq of CPP`Stmt := rhs_stmt,
             rhs_v : CPP`Expr := e_v;

         if not CGAUX`IsSubType(rhsType, gtp)
         then
           (rhs_v := BC`GiveName("rhs");
            rb := rb ^ [ BC`GenDecl(DS`GenType(rhsType), rhs_v, BC`GenAsgnInit(e_v)) ]);

         cases true:
          (is_AS`Name(sd)) ->
            if CPP`isCPP()
            then
#ifdef VDMSL
              (def tp = ENV`LookUpStateEnv(sd)
               in
                 if not (is_REP`CompositeTypeRep(tp) and CGAUX`UnqualiName(tp.nm) = sd)
                 then
                   if not CGAUX`IsSubType(rhsType, gtp)
                   then rb := rb ^ [BC`GenIfStmt(DS`GenAuxType(rhs_v, gtp),
                                       BC`GenBlock([BC`GenAsgnStmt(BC`Rename(sd), rhs_v)]),
                                       BC`GenBlock([CGAUX`RunTime("Incompatible type")]))]
                   else rb := rb ^ [BC`GenAsgnStmt(BC`Rename(sd), rhs_v)]
                 else
                   if is_REP`CompositeTypeRep(tp)
                   then
                     for i = 1 to len tp.fields do
                       rb := rb ^ [BC`GenAsgnStmt(BC`Rename(tp.fields(i).sel),
                                                  DS`GenRecGetField(rhs_v,BC`GenIntegerLit(i),
                                                                    tp.fields(i).tp))]
                   else rb := rb ^ [BC`GenAsgnStmt(BC`Rename(sd), rhs_v)];)


#endif VDMSL
#ifdef VDMPP
              (if not CGAUX`IsSubType(rhsType, gtp)
               then rb := rb ^ [BC`GenIfStmt(DS`GenAuxType(rhs_v, gtp),
                                   BC`GenBlock([BC`GenAsgnStmt(BC`Rename(sd), rhs_v)]),
                                   BC`GenBlock([CGAUX`RunTime("Incompatible type")]))]
               else rb := rb ^ [BC`GenAsgnStmt(BC`Rename(sd), rhs_v)];)
#endif VDMPP
            else -- java
              if len sd.ids > 1
              then
                def expr = BC`GenObjectMemberAccess(DS`GenThis(), BC`GenIdentifier(CGAUX`GiveLastName(sd)))
                in
                  rb := rb ^ [BC`GenAsgnStmt(expr, DS`GenExplicitCast(gtp, rhs_v, nil))]
              else
               (dcl cast : CPP`Expr;
                cases rhs_v:
                  mk_CPP`ClassInstanceCreationExpr(-,-,-,-,-) ->
                      if CGAUX`IsSubType(rhsType, gtp)
                      then cast := rhs_v
                      else cast := DS`GenExplicitCast(gtp, rhs_v, nil),
                  mk_CPP`ObjectMemberAccess((DS`GenBoolType().tp), (BC`GenIdentifier("TRUE")), -),
                  mk_CPP`ObjectMemberAccess((DS`GenBoolType().tp), (BC`GenIdentifier("FALSE")), -) ->
                                 cast := rhs_v,
                  mk_CPP`FctCall((BC`GenIdentifier("Arrays.asList")),-,-) ->
                          cast := DS`GenSeqExpr(rhs_v),
                  others -> cast := DS`GenExplicitCast(gtp, BC`GenFctCall(BC`GenIdentifier("UTIL.clone"),
                                                       [rhs_v]),nil)
                end;
                if not CGAUX`IsSubType(rhsType, gtp)
                then
                  let e = if is_REP`UnionTypeRep(rhsType)
                          then rhs_v
                          else BC`GenBracketedExpr(BC`GenCastExpr(BC`GenGeneric(), rhs_v))
                  in rb := rb ^ [BC`GenIfStmt(BC`GenNot(DS`GenAuxType(e, gtp)),
                                   BC`GenBlock([CGAUX`RunTime("Incompatible type")]), nil)];
                rb := rb ^ [BC`GenAsgnStmt(BC`Rename(sd), cast)]),
          (is_AS`NarrowRef(sd)) -> return CGAssignStmt(mk_AS`AssignStmt(sd.var,expr,cid)),
          (is_AS`FieldRef(sd)) -> if is_AS`NarrowRef(sd.var)
                                  then
                                   (dcl sd2 : AS`Expr;
                                    if CPP`isCPP()
                                    then sd2 := mu(sd.var.var, cid |-> CI`PushCGType(CGAUX`FindType(sd.var)))
                                    else sd2 := sd.var.var;
                                    rb := rb ^ CGStateDesignator(mk_AS`FieldRef(sd2,sd.sel,sd.cid), rhs_v))
                                  else rb := rb ^ CGStateDesignator(sd, rhs_v),
          (is_AS`MapOrSeqRef(sd)) -> if is_AS`NarrowRef(sd.var)
                                     then rb := rb ^ CGStateDesignator(
                                                      mk_AS`MapOrSeqRef(sd.var.var,sd.arg,sd.cid), rhs_v)
                                     else rb := rb ^ CGStateDesignator(sd, rhs_v)
         end;
         return rb;);

CGAtomicAssignStmt: AS`AtomicAssignStmt * bool ==> seq of CPP`Stmt
CGAtomicAssignStmt( mk_AS`AtomicAssignStmt(atm, cid), isLast ) ==
  (dcl as_l : seq of AS`AssignStmt := [],
       value_l : seq of (AS`PatternBind * AS`Expr) := [];
   for i = 1 to len atm do
     let mk_AS`AssignStmt(lhs, rhs, cid) = atm(i),
         tmpnm = mk_AS`Name(["atom_" ^ CGAUX`StringNumber(i)], rhs.cid)
     in
       (value_l := value_l ^ [mk_(mk_AS`PatternName(tmpnm, nil, rhs.cid), rhs)];
        as_l := as_l ^ [mk_AS`AssignStmt(lhs, tmpnm, cid)];);
   let ds = mk_AS`DefStmt(value_l, mk_AS`BlockStmt([], as_l, cid), cid)
   in
     (dcl rb : seq of CPP`Stmt;
      CGAUX`SetAtomic();
      rb := CGDefStmt(ds, isLast);
      CGAUX`UnsetAtomic();
#ifdef VDMPP
      if not CGAUX`GetConstr() and CGAUX`GetHasInv() and CGMAIN`get_testpreandpost_option()
      then rb := rb ^ [GenInvCall(CGAUX`GiveCurCASName(),false)];
#endif VDMPP
      return rb;);
  );
\end{vdm_al}

Consider the map below:

\begin{verbatim}
m := { 1 |-> [ 1, mk_A("a", {3 |-> 5, 4|->6})], 2 |-> 9}
\end{verbatim}

where:

\begin{verbatim}
A::
 a: seq of char
 b: map nat to nat
\end{verbatim}


Consier the assign statement below;
\begin{verbatim}
m(1)(2).b(3) := 49
\end{verbatim}


The abstract syntax of the assign statement:

\begin{verbatim}
mk_AS`AssignStmt(
   mk_AS`MapOrSeqRef(
      mk_AS`FieldRef(
         mk_AS`MapOrSeqRef(
            mk_AS`MapOrSeqRef(
               mk_AS`Name(
                  [ "m" ],
                  type ),
               mk_AS`RealLit( 1 ) ),
            mk_AS`RealLit( 2 ) ),
         mk_AS`Name(
            [ "b" ],
            nil ) ),
      mk_AS`RealLit( 3 ) ),
   mk_AS`RealLit( 49 ) )
\end{verbatim}

where
\begin{verbatim}
type =
 mk_UnionTypeRep(
    { mk_EmptyMapTypeRep(  ),
      mk_GeneralMapTypeRep(
         mk_NumericTypeRep( <NAT> ),
         mk_UnionTypeRep(
            { mk_EmptySeqTypeRep(  ),
              mk_NumericTypeRep( <NAT> ),
              mk_SeqTypeRep(
                 mk_UnionTypeRep(
                    { mk_NumericTypeRep( <NAT> ),
                      mk_TypeNameRep(mk_AS`Name( [ "A" ], nil ) ) } ) ) } ) ) } ) )
\end{verbatim}

A straightforward way to implement this assign statement by hand is:
The corresponding parts of the abstract syntax part is listed in the
left hand side:

\begin{verbatim}
Sequence level2 = m(1);
Record   level3 = level2(2);
Map      level4 = level3.GetField(b_Index);
level4.ImpModify(3, (Int) 49);
level3.SetField(b_Index, level4);
level2.ImpModify(2, level3);
m.ImpModify(1, level2);
\end{verbatim}

Below is the parts of the abstract syntax that represents the information used
for each line of the hand implemented code.

\begin{verbatim}
mk_MOSR(mk_Name("m"), 1)  :  Sequence level2 = m(1);
mk_MOSR(mk_MOSR(...), 2)  :  Record   level3 = level2(2);
mk_FieldRef(mk_M(..), "b"):  Map      level4 = level3.GetField(b_Index);
mk_MOSR(mk_Fi..(...), 3)  :  level4.ImpModify(3, (Int) 49);
mk_FieldRef(mk_M(..), "b"):  level3.SetField(b_Index, level4);
mk_MOSR(mk_MOSR(...), 2)  :  level2.ImpModify(2, level3);
mk_MOSR(mk_Name("m"), 1)  :  m.ImpModify(1, level2);
\end{verbatim}


The strategy above is used by the operation {\em CGStateDesignator}:

\begin{vdm_al}
CGStateDesignator: AS`StateDesignator * CPP`Expr==> seq of CPP`Stmt
CGStateDesignator(sd, rhs_v) ==
  def level_nm = BC`GiveName("level")
  in
    cases sd:
      mk_AS`FieldRef(sd1, sel, -) ->
         (dcl rb1 : seq of CPP`Stmt := [],
              rb2 : seq of CPP`Stmt := [],
              type_of_level : [REP`TypeRep],
              level_cgvt : CGMAIN`VT;
          if is_AS`Name(sd1)
          then type_of_level := CGAUX`FindType(sd1)
#ifdef VDMPP
          elseif is_AS`SelfExpr(sd1)
          then type_of_level := CGAUX`FindType(sd1)
#endif VDMPP
          else
            def mk_(r1, r2, t1) = CGSDUpperLevel(sd1, level_nm)
            in
             (rb1 := r1;
              rb2 := r2;
              type_of_level := t1);

          if is_AS`Name(sd1)
          then level_cgvt := mk_CGMAIN`VT(CGEXPR`CGName(sd1), type_of_level)
#ifdef VDMPP
          elseif is_AS`SelfExpr(sd1)
          then level_cgvt := mk_CGMAIN`VT(DS`GenThis(), type_of_level)
#endif VDMPP
          else level_cgvt := mk_CGMAIN`VT(level_nm, type_of_level);
          def recmodify = GenRecImpModify(sel, level_cgvt, rhs_v)
          in return rb1 ^ recmodify ^ rb2
         ),
      mk_AS`MapOrSeqRef(sd1, e, -) ->
         (dcl etp : [REP`TypeRep] := nil;
          def ftp = CGAUX`FindType(sd1)
          in
            if ftp <> nil
            then
              if CGAUX`IsMapType(ftp)
              then etp := CGAUX`FindMapDomType(ftp)
              elseif CGAUX`IsSeqType(ftp)
              then etp := mk_REP`NumericTypeRep(<NATONE>)
              else skip;
          
          --def mk_(e_v, e_stmt) = CGEXPR`CGExprExcl(e, "e", nil);
          def mk_(e_v, e_stmt) = CGEXPR`CGExprExcl(e, "e", etp);
              e_tp = CGAUX`FindType(e);
          in
           (dcl rb1 : seq of CPP`Stmt := [],
                rb2 : seq of CPP`Stmt := [],
                tp_of_level_nm : [REP`TypeRep] := nil,
                cg_vt : CGMAIN`VT;    
            if not is_AS`Name(sd1)
            then
              def mk_(r1, r2, t1) = CGSDUpperLevel(sd1, level_nm)
              in
               (rb1 := r1;
                rb2 := r2;
                tp_of_level_nm := t1);
            if is_AS`Name(sd1)
            then cg_vt := mk_CGMAIN`VT(CGEXPR`CGName(sd1), CGAUX`FindType(sd1))
            else cg_vt := mk_CGMAIN`VT(level_nm, tp_of_level_nm);
            def modify =  [ DS`GenSeqOrMapImpModify(cg_vt, e_v, e_tp, rhs_v) ]
            in let inner_stmt = e_stmt ^ modify
               in return rb1 ^ inner_stmt ^ rb2
           )
         ),
      others -> return undefined
    end;
\end{vdm_al}


\begin{vdm_al}
CGSDUpperLevel: AS`StateDesignator * CPP`Name ==> seq of CPP`Stmt * seq of CPP`Stmt * REP`TypeRep
CGSDUpperLevel(sd, i_lvl_nm) ==
  def level_nm = BC`GiveName("level")
  in
    cases sd:
      mk_AS`MapOrSeqRef(sd1, e,-) -> if is_AS`Name(sd1)
                                     then CGSDMapOrSeqRef_Name(sd1, e, i_lvl_nm)
                                     else CGSDMapOrSeqRef_SD(sd1, e, i_lvl_nm, level_nm),
      mk_AS`FieldRef(sd1, sel, -) -> if is_AS`Name(sd1)
                                     then CGSDFieldRef_Name(sd1, sel, i_lvl_nm)
                                     else CGSDFieldRef_SD(sd1, sel, i_lvl_nm, level_nm),
      mk_AS`NarrowRef(sd1,-,-)    -> if CPP`isCPP()
                                     then
                                       def sd2 = mu(sd1, cid |-> CI`PushCGType(CGAUX`FindType(sd)))
                                       in CGSDUpperLevel(sd2, i_lvl_nm)
                                     else CGSDUpperLevel(sd1, i_lvl_nm),
      others -> error
    end;
\end{vdm_al}

\begin{vdm_al}
CGSDMapOrSeqRef_Name: AS`Name * AS`Expr * CPP`Name ==> seq of CPP`Stmt * seq of CPP`Stmt * REP`TypeRep
CGSDMapOrSeqRef_Name(sd1, e, i_lvl_nm) ==
  def type = CGAUX`FindType(sd1);
      tp_i_lvl_nm = CGAUX`posRngMapOrIndsSeqType(type);
      pos_sd1 = CI`GetPos(sd1.cid);
      cid_i_lvl_nm = CI`PushCGPosType(pos_sd1, tp_i_lvl_nm);
      name = BC`Rename(sd1);
      ASapplyexpr = mk_AS`ApplyExpr(sd1, [e], cid_i_lvl_nm);
      cg_vt = mk_CGMAIN`VT(i_lvl_nm, tp_i_lvl_nm);
      ae = CGEXPR`CGApplyExpr(ASapplyexpr, cg_vt, nil, nil, true);
      mk_(e_v, e_stmt) = CGEXPR`CGExprExcl(e, "e", nil);
      e_tp = CGAUX`FindType(e);
      cg_vt2 = mk_CGMAIN`VT(name, type);
      rb2 = e_stmt ^ [DS`GenSeqOrMapImpModify(cg_vt2, e_v, e_tp, i_lvl_nm)]
  in
   (dcl rb1 : seq of CPP`Stmt;
    if CGAUX`IsSeqOfCPPStmt(ae)
    then rb1 := DS`GenDecl(tp_i_lvl_nm, i_lvl_nm, nil) ^ ae
    else rb1 := DS`GenDeclInit(tp_i_lvl_nm, i_lvl_nm, ae);
    return mk_(rb1, rb2, tp_i_lvl_nm);
   );
\end{vdm_al}

\begin{vdm_al}
CGSDMapOrSeqRef_SD: AS`StateDesignator * AS`Expr * CPP`Name * CPP`Name==>
                seq of CPP`Stmt * seq of CPP`Stmt * REP`TypeRep
CGSDMapOrSeqRef_SD(sd1, e, i_lvl_nm, level_nm) ==
  def mk_(rb_up1, rb_up2, tp_level_nm) = CGSDUpperLevel(sd1, level_nm);
      tp_i_lvl_nm = CGAUX`posRngMapOrIndsSeqType(tp_level_nm);
      cid_tp_level_nm = CI`PushCGType(tp_level_nm);
      asname_dummy = mk_AS`Name([""], cid_tp_level_nm);
      cid_tp_i_lvl_nm = CI`PushCGType(tp_i_lvl_nm);
      ASapplyexpr= mk_AS`ApplyExpr(asname_dummy, [e], cid_tp_i_lvl_nm);
      ae = CGEXPR`CGApplyExpr(ASapplyexpr, mk_CGMAIN`VT(i_lvl_nm, tp_i_lvl_nm), level_nm, tp_level_nm, true);
      mk_(e_v, e_stmt) = CGEXPR`CGExprExcl(e, "e", nil);
      e_tp = CGAUX`FindType(e);
      rb2 = [DS`GenSeqOrMapImpModify(mk_CGMAIN`VT(level_nm, tp_level_nm), e_v, e_tp, i_lvl_nm)]
  in
   (dcl rb1 : seq of CPP`Stmt;
    if CGAUX`IsSeqOfCPPStmt(ae)
    then rb1 := e_stmt ^ DS`GenDecl(tp_i_lvl_nm, i_lvl_nm, nil) ^ ae
    else rb1 := e_stmt ^ DS`GenDeclInit(tp_i_lvl_nm, i_lvl_nm, ae);
    return mk_(rb_up1 ^ rb1, rb2 ^ rb_up2, tp_i_lvl_nm);
   );
\end{vdm_al}

\begin{vdm_al}
CGSDFieldRef_Name: AS`Name * AS`Expr * CPP`Name ==> seq of CPP`Stmt * seq of CPP`Stmt * REP`TypeRep
CGSDFieldRef_Name(sd1, sel, i_lvl_nm) ==
  def name = BC`Rename(sd1);
      type = CGAUX`FindType(sd1);
      tp_i_lvl_nm = CGAUX`posFieldApplyTypes(type, sel);
      cid_tp_i_lvl_nm = CI`PushCGType(tp_i_lvl_nm);
      ASFieldSelExpr = mk_AS`FieldSelectExpr(sd1, sel, cid_tp_i_lvl_nm);
      fse = CGEXPR`CGFieldSelectExpr( ASFieldSelExpr, mk_CGMAIN`VT(i_lvl_nm, tp_i_lvl_nm), nil, nil);
      l_decl_nil = DS`GenDecl(tp_i_lvl_nm, i_lvl_nm, nil);
      level_cgvt = mk_CGMAIN`VT(name, type);
      rb1 = l_decl_nil ^ fse;
      rb2 = GenRecImpModify(sel, level_cgvt, i_lvl_nm)
   in return mk_(rb1, rb2, tp_i_lvl_nm);
\end{vdm_al}

\begin{vdm_al}
CGSDFieldRef_SD: AS`StateDesignator * AS`Expr * CPP`Name * CPP`Name ==>
                  seq of CPP`Stmt * seq of CPP`Stmt * REP`TypeRep
CGSDFieldRef_SD(sd1, sel, i_lvl_nm, level_nm) ==
def mk_(rb_upper1, rb_upper2, tp_level_nm)= CGSDUpperLevel(sd1, level_nm);
    cid_tp_level_nm = CI`PushCGType(tp_level_nm);
    tp_i_lvl_nm = CGAUX`posFieldApplyTypes(tp_level_nm, sel);
    cid_tp_i_lvl_nm = CI`PushCGType(tp_i_lvl_nm);
    as_nm_dummy = mk_AS`Name([""], cid_tp_level_nm);
    ASFSelExpr = mk_AS`FieldSelectExpr(as_nm_dummy, sel, cid_tp_i_lvl_nm);
    fse = CGEXPR`CGFieldSelectExpr( ASFSelExpr, mk_CGMAIN`VT(i_lvl_nm, tp_i_lvl_nm), level_nm, tp_level_nm);
    l_decl_nil = DS`GenDecl(tp_i_lvl_nm, i_lvl_nm, nil);
    level_cgvt = mk_CGMAIN`VT(level_nm, tp_level_nm);
    rb1 = l_decl_nil ^ fse;
    rb2 = GenRecImpModify(sel, level_cgvt, i_lvl_nm)
in return mk_(rb_upper1 ^ rb1, rb2 ^ rb_upper2, tp_i_lvl_nm);
\end{vdm_al}


The operation {\em GenRecImpModify} is an auxiliary operation to the
state designator operations. It computes modifications of record
taking the parameters:

\begin{description}
\item[rectypes:] set of possible composite types of the record that
  should be modified.
\item[fsnm:] The field of the record that should be modified.
\item[mk\_CGMAIN`VT(level, level\_type):] The name of the record and its
  type.
\item[val:] The value that should be inserted.
\end{description}


\begin{vdm_al}
GenRecImpModify: AS`Name * CGMAIN`VT * CPP`Expr ==> seq of CPP`Stmt
GenRecImpModify(fsnm, mk_CGMAIN`VT(level, level_type' ), val ) ==
  def level_type = CGAUX`RemoveNil(level_type');
      rectypes = CGEXPR`FindAllRecTypes(level_type);
      posRecTypes = CGEXPR`FindPossibleRecTypes( rectypes, fsnm );
#ifdef VDMPP
      oreftypes = CGEXPR`FindAllObjRefTypes(level_type);
      posORefTypes = CGEXPR`FindPossibleObjRefTypes( oreftypes, fsnm );
#endif VDMPP
#ifdef VDMSL
      rti = BC`GenBlock([CGAUX`RunTime("A record was expected")])
#endif VDMSL
#ifdef VDMPP
      rti = BC`GenBlock([CGAUX`RunTime("An object or record was expected")])
#endif VDMPP
  in
   (dcl alt : [CPP`Stmt] := if is_REP`UnionTypeRep( level_type ) and
                               let tps = level_type.tps
                               in
#ifdef VDMSL
                                 (tps = posRecTypes)
#endif VDMSL
#ifdef VDMPP
                                 (tps = posRecTypes union posORefTypes)
#endif VDMPP
                            then nil
                            else rti;

-- The ifdef VDMPP is to avoid the type checker complaining about the missing
-- 'else' in the case where VDMSL is defined (java cannot be generated from VDMSL)

    if is_REP`CompositeTypeRep( level_type ) and card posRecTypes = 1
    then
      def { ctr } = posRecTypes;
          rec_nm = ctr.nm;
      in
       (dcl rec : CPP`Expr,
            setfield : CPP`Stmt;
        if is_REP`CompositeTypeRep( level_type )
        then
          if CPP`isCPP()
          then rec := level
          else
            if is_CPP`CastExpr(level)
            then rec := BC`GenBracketedExpr(level)
            else rec := level
        else
          if CPP`isCPP()
          then rec := DS`GenCastRecordTypeForModify( level, rec_nm )
          else rec := BC`GenBracketedExpr(DS`GenCastType(ctr, level));
        if CPP`isCPP()
        then setfield := DS`GenRecSetField(rec, BC`GenPosName(rec_nm, fsnm), val)
        else setfield := BC`GenAsgnStmt(BC`GenQualifiedName(rec, BC`Rename2(fsnm)), val);
        alt := BC`GenBlock([setfield])
       )
    else
      for all ctr in set posRecTypes do
        def rec_nm = ctr.nm;
        in
         (dcl rec : CPP`Expr,
              setfield : CPP`Stmt;
          if CPP`isCPP()
          then rec := DS`GenCastRecordTypeForModify( level, rec_nm )
          else rec := BC`GenBracketedExpr(DS`GenCastType(ctr, level));
          if CPP`isCPP()
          then setfield := DS`GenRecSetField(rec, BC`GenPosName(rec_nm, fsnm), val)
          else setfield := BC`GenAsgnStmt(BC`GenQualifiedName(rec, BC`Rename2(fsnm)), val);
          def isRecord = DS`GenIsThisRecord( ctr, level )
          in
            if alt = nil
            then alt := BC`GenBlock([setfield])
            else alt := BC`GenIfStmt(isRecord, BC`GenBlock([setfield]), alt);
         );

#ifdef VDMPP
    if posORefTypes <> {}
    then
      if is_REP`ObjRefTypeRep(level_type) and card posORefTypes = 1
      then
        let { mk_REP`ObjRefTypeRep(clnm) } = posORefTypes
        in
          if CPP`isCPP()
          then
            def l_ptr = DS`CastToClassPtr(clnm, level);
                l_memacc = BC`GenPointerToObjectMemberAccess(l_ptr, BC`Rename(fsnm));
                l_asgn = BC`GenAsgnStmt(l_memacc, val)
            in
              alt := l_asgn
          else -- java
            def tp = ENV`LookUpInstanceVar(CGAUX`Combine2Names(clnm, fsnm));
                rec = if is_CPP`CastExpr(level)
                      then BC`GenBracketedExpr(level)
                      else level;
                l_asgn = BC`GenAsgnStmt(BC`GenQualifiedName(rec, BC`Rename(fsnm)),
                                                                 DS`GenExplicitCast(tp, val, nil))
            in
              alt := l_asgn
      else
        for all otr in set posORefTypes do
          let clnm = otr.nm
          in
            if CPP`isCPP()
            then
              def if_cond = DS`GenAuxType(level, otr);
                  l_ptr = DS`CastToClassPtr(clnm, level);
                  l_memacc = BC`GenPointerToObjectMemberAccess(l_ptr, BC`Rename(fsnm));
                  l_asgn  = BC`GenBlock([BC`GenAsgnStmt(l_memacc, val)])
              in
                if alt = nil
                then alt := l_asgn
                else alt := BC`GenIfStmt(if_cond, l_asgn, alt)
            else -- java
              def if_cond = BC`GenTypeComp(BC`Rename(clnm), level);
                  tp = ENV`LookUpInstanceVar(CGAUX`Combine2Names(clnm, fsnm));
                  cast = BC`GenBracketedExpr(DS`GenCastType(otr, level));
                  l_asgn = BC`GenBlock([BC`GenAsgnStmt(BC`GenQualifiedName(cast, BC`Rename(fsnm)),
                                                                DS`GenExplicitCast(tp, val, nil))])
              in
                if alt = nil
                then alt := l_asgn
                else alt := BC`GenIfStmt(if_cond, l_asgn, alt);
#endif VDMPP
      return CGAUX`StripCompoundStmt(alt);
    );
\end{vdm_al}


The operation {\em GenCommonAsgnStmt} generates {\em "common"} assign
statements that can be generated in a more direct way. The operation
generates special code for assignstatements of the type:

\begin{verbatim}
s := s union {e};
l := l ^ [e];
m := m ++ { d |-> r}
\end{verbatim}

The corresponding code to be generated is:

\begin{verbatim}
s.Insert(...CGExpr(e));
l.ImpAppend(..CGExpr(e));
m.Insert(..CGExpr(d), ..CGExpr(r))
\end{verbatim}

\begin{vdm_al}
GenCommonAsgnStmt: AS`StateDesignator * AS`Expr  ==>  bool * [seq of CPP`Stmt]
GenCommonAsgnStmt(sd, expr) ==
  if is_AS`Name(sd)
  then
    let mk_AS`Name(ids, -) = sd
    in
      cases true:
        (is_AS`SeqModifyMapOverrideExpr(expr)) -> CGCommonMapOverrideExpr(sd, expr),
        (is_AS`BinaryExpr(expr))               -> let mk_AS`BinaryExpr(e1, opr, e2,-) = expr
                                                  in
                                                    if is_AS`Name(e1) and e1.ids = ids
                                                    then
                                                      cases opr:
                                                         <SEQCONC> -> CGCommonAsgnSeqConc(sd, e2),
                                                         <SETUNION> -> CGCommonAsgnSetUnion(sd, e2),
                                                         others -> return mk_(false, nil)
                                                      end
                                                    else return mk_(false, nil),
        (is_AS`NilLit(expr))                   -> if CPP`isCPP()
                                                  then return mk_(false, nil)
                                                  else return mk_(true,[BC`GenAsgnStmt(BC`Rename(sd), DS`GenNilLit())]),
        others                                 -> return mk_(false, nil)
      end
  else
    return mk_(false, nil);
\end{vdm_al}

\begin{vdm_al}
CGCommonMapOverrideExpr: AS`StateDesignator * AS`SeqModifyMapOverrideExpr ==> bool * [seq of CPP`Stmt]
CGCommonMapOverrideExpr(sd, mk_AS`SeqModifyMapOverrideExpr(seqmap, map_exp,-)) ==
  def type = CGAUX`FindType(seqmap)
  in
    if is_AS`Name(seqmap) and
       let mk_AS`Name(seqmap_ids, -) = seqmap,
           mk_AS`Name(sd_ids, -) = sd
       in sd_ids = seqmap_ids and
       CGAUX`IsMapType(type) and
       is_AS`MapEnumerationExpr(map_exp) and
       let mk_AS`MapEnumerationExpr( ml, -) = map_exp
       in len ml = 1
    then
      def mk_AS`MapEnumerationExpr([ mk_AS`Maplet(md, mr,-)],-) = map_exp;
          mk_(md_v, md_stmt) = CGEXPR`CGExprExcl(md, "md", nil);
          mk_(mr_v, mr_stmt) = CGEXPR`CGExprExcl(mr, "mr", nil);
          name = BC`Rename(sd);
          insert = DS`GenMapImpModify(name, md_v, mr_v)
      in if md_stmt = [] and mr_stmt = []
         then return mk_(true, [insert])
         else let stmts = md_stmt ^ mr_stmt ^ [insert]
              in return mk_(true, stmts)
    else return mk_(false, nil);
\end{vdm_al}

\begin{vdm_al}
CGCommonAsgnSeqConc: AS`StateDesignator * AS`Expr ==> bool * [seq of CPP`Stmt]
CGCommonAsgnSeqConc(sd, e2) ==
  cases e2:
    mk_AS`SeqEnumerationExpr([e],-) ->
      def mk_(e_v, e_stmt) = CGEXPR`CGExprExcl(e,"e", nil);
          type = CGAUX`FindType(sd);
          casting = not CGAUX`IsSeqType(type);
          isstring = CGAUX`IsPossibleStringType(type);
      in
       (dcl name : CPP`Expr,
            impapp : CPP`Stmt;
        if CPP`isCPP()
        then if casting
             then name := DS`GenCastSeq(BC`Rename(sd), nil)
             else name := BC`Rename(sd)
        else if isstring
             then if CGAUX`IsStringType(type)
                  then name := BC`Rename(sd)
                  else name := DS`GenCastString(BC`Rename(sd))
             else if casting
                  then name := DS`GenCastSeq(BC`Rename(sd), nil)
                  else name := BC`Rename(sd);
        if CPP`isCPP()
        then if casting
             then impapp := BC`GenAsgnStmt( BC`Rename(sd), DS`GenImpAppendExpr(name, e_v))
             else impapp := DS`GenImpAppend(name, e_v)
        else if isstring
             then impapp := BC`GenAsgnStmt( BC`Rename(sd), BC`GenPlus(name,e_v))
             else impapp := DS`GenImpAppend(name, e_v);
        if e_stmt = []
        then return mk_(true, [impapp])
        else return mk_(true, e_stmt ^ [impapp]);
       ),
    others -> return mk_(false, nil)
  end;
\end{vdm_al}

\begin{vdm_al}
CGCommonAsgnSetUnion: AS`StateDesignator * AS`Expr ==> bool * [seq of CPP`Stmt]
CGCommonAsgnSetUnion(sd, e) ==
  cases e:
    mk_AS`SetEnumerationExpr([elem],-) ->
        def mk_(e_v, e_stmt) = CGEXPR`CGExprExcl(elem, "elem", nil);
            type = CGAUX`FindType(sd);
            casting = not CGAUX`IsSetType(type);
        in
         (dcl name : CPP`Expr,
              ins : CPP`Stmt;
          if casting
          then name := DS`GenCastSetType(BC`Rename(sd))
          else name := BC`Rename(sd);
          if casting and CPP`isCPP()
          then ins := BC`GenAsgnStmt( BC`Rename(sd), DS`GenSetInsertExpr(name, e_v) )
          else ins := DS`GenSetInsert(name, e_v);
          if e_stmt = []
          then return mk_(true, [ins])
          else return mk_(true, e_stmt ^ [ins]);
         ),
    others -> return mk_(false, nil)
  end;
\end{vdm_al}


\subsection{Return Statement}

Two examples of VDM return statements are listed below:

\begin{verbatim}

  return {a |-> 4}

  return
\end{verbatim}

Thus, a return statement does not necessarily return an expression.

The corresponding pseudo code is listed below:

\begin{verbatim}
Map rexpr;
...CGEXPR`CGExpr( "{a|->4}", mk_CGMAIN`VT( rexpr, "Map" ) );
return rexpr;
\end{verbatim}

and the corresponding pseudo code of the last return statement:

\begin{verbatim}
return;
\end{verbatim}

\begin{vdm_al}
CGReturnStmt: AS`ReturnStmt ==> seq of CPP`Stmt
CGReturnStmt(mk_AS`ReturnStmt(val,-)) ==
#ifdef VDMPP
  if CGAUX`GetConstr()
  then return []
  else
#endif VDMPP
  if val = nil
  then
    if CPP`isCPP()
    then
      if CGAUX`IsInAlways()
      --then return [BC`GenReturnStmt( nil )]
      then return [BC`GenExpressionStmt(BC`GenThrowExpression(BC`GenIntegerLit(0)))]
      else return [BC`GenReturnStmt( nil )]
    else return [BC`GenReturnStmt( nil )]
  else
    def mk_(rexpr_v, val_stmt) = CGEXPR`CGExprExcl(val, "rexpr", CGAUX`GiveCurrentRType())
    in
      if CPP`isCPP()
      then
        if CGAUX`IsInAlways()
        then return val_stmt ^ [BC`GenExpressionStmt(BC`GenThrowExpression(rexpr_v))]
        else return val_stmt ^ [BC`GenReturnStmt(rexpr_v)]
      else
        def rtp = CGAUX`RemoveNil(TPGEN`RemoveInvType(CGAUX`GiveCurrentRType()));
        in
         (dcl cast : CPP`Expr;
          if CGAUX`IsStringType(rtp) and
             is_CPP`ClassInstanceCreationExpr(rexpr_v) and
             rexpr_v.classtype = DS`GenStringType().tp
          then cast := hd rexpr_v.arg
          else cast := rexpr_v;
          return val_stmt ^ [ BC`GenReturnStmt(cast)];
         );
\end{vdm_al}

\subsection{Nondeterministic Statement}

In this section the code generation of nondeterministic stataments are
described. Consider the nondeterministic statement:

\begin{verbatim}
|| ( l := l ^ ['a'],
     l := l ^ ['b'],
     l := l ^ ['c'],
     l := l ^ ['d'] )
\end{verbatim}

The statements in the nondeterministic statement are code generated in
arbitrary  order:

\begin{verbatim}
...GenStmt("l := l ^ ['a']");
...GenStmt("l := l ^ ['b']");
...GenStmt("l := l ^ ['c']");
...GenStmt("l := l ^ ['d']");
\end{verbatim}


The operation $CGNonDetStmt$ generates the code corresponding to
a nondeterministic statement.

\begin{vdm_al}
IsReturnStmtAtLast: CPP`Stmt ==> bool
IsReturnStmtAtLast(stmt) ==
  cases stmt:
    mk_CPP`Return(-,-)           -> return true,
    mk_CPP`CompoundStmt(stmts,-) -> if stmts = []
                                    then return false
                                    else return IsReturnStmtAtLast(stmts(len stmts)),
    mk_CPP`IfStmt(-,alt1,alt2,-) -> if alt2 = nil
                                    then return false
                                    else return IsReturnStmtAtLast(alt1) and IsReturnStmtAtLast(alt2),
    others                       -> return false
  end;

CGNonDetStmt: AS`NonDetStmt * bool ==> seq of CPP`Stmt
CGNonDetStmt(mk_AS`NonDetStmt(stmt_l,-), isLast) ==
  def e = BC`GenIntegerLit(len stmt_l);
      numSeq = BC`GiveName("numSeq");
      i_v = BC`GiveName("i");
      max_v = DS`GenLen_int(numSeq);
  in
   (dcl fc : CPP`Expr,
        ini_v : CPP`AsgnInit,
        case_l : seq of CPP`CaseStmt := [],
        seqApply : CPP`Expr;
    if CPP`isCPP()
    then fc := BC`GenFctCall(BC`GenIdentifier("CGUTIL::GetRandomSequence"), [e])
    else fc := BC`GenFctCall(BC`GenIdentifier("UTIL.GetRandomSequence"), [e]);
    if CPP`isCPP()
    then ini_v := BC`GenAsgnInit(BC`GenIntegerLit (1))
    else ini_v := BC`GenAsgnInit(BC`GenIntegerLit (0));
    for i = 1 to len stmt_l do
     (dcl stmts : seq of CPP`Stmt := GenStmt(stmt_l(i), false);
      if stmts <> [] and IsReturnStmtAtLast(stmts(len stmts))
      then skip
      else stmts := stmts ^ [BC`GenBreakStmt(nil)];
      case_l := case_l ^ [BC`GenCaseStmt(BC`GenIntegerLit (i), BC`GenBlock(stmts))];
     );

--      in
--      case_l = [def stmts = GenStmt(stmt_l(i), false)
--                in
--                  BC`GenCaseStmt(BC`GenIntegerLit (i),
--                                 BC`GenBlock(stmts ^
--                                 (if stmts <> [] and IsReturnStmtAtLast(stmts(len stmts))
--                                  then []
--                                  else [BC`GenBreakStmt(nil)])))
--                  | i in set inds stmt_l];
    if CPP`isCPP()
    then seqApply := BC`GenArrayApply(numSeq, i_v)
    else seqApply := BC`GenFctCallObjMemAcc(numSeq, "get", [i_v]);
    --def inner = BC`GenBlock([BC`GenSwitchStmt(DS`GenGetValue(BC`GenCastExpr(DS`GenIntType(), seqApply),
    --                                                       mk_REP`NumericTypeRep(<INTEGER>)),
    --                                        case_l)])
    def cast = BC`GenCastExpr(DS`GenIntType(), seqApply);
    in
     (dcl val : CPP`Expr;
      if CPP`isCPP()
      then val := DS`GenGetValue(cast, mk_REP`NumericTypeRep(<INTEGER>))
      else val := BC`GenFctCallObjMemAcc(cast, "intValue", []);
      def inner = BC`GenBlock([BC`GenSwitchStmt(val, case_l)])
        
    in
     (dcl cond : CPP`Expr,
          rb_l : seq of CPP`Stmt;
      if CPP`isCPP()
      then cond := BC`GenLeq (i_v, max_v)
      else cond := BC`GenLt (i_v, max_v);
      rb_l := [BC`GenDecl(DS`GenSeq0Type(), numSeq, BC`GenAsgnInit(fc)),
                                     BC`GenForStmt (BC`GenDecl (DS`GenSmallIntType (), i_v, ini_v),
                                                    cond,
                                                    [BC`GenPostPlusPlus(i_v)],
                                                    inner)];
      if isLast and not is_REP`UnitTypeRep(CGAUX`GiveCurrentRType())
      then rb_l := rb_l ^ [BC`GenReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))];
      return rb_l);
     );
   );
\end{vdm_al}

\subsection{Call Statement}

In this section the code generation of call stataments are described.
Consider the call statements:

\begin{verbatim}
Op1()
Op2()
\end{verbatim}

Assume that the signature of $Op1$ is $Op1: () \Oto SomeType$ and the
signature of $Op2$ is $Op2: () \Oto ()$. In this case code
corresponding to the two call statements will become:

\begin{verbatim}
return Op1();
Op2();
\end{verbatim}

The code genetation of paramaters is very much like parameters in
function apply expressions. We therefore refer to section
\ref{sec:apply} for further information.

The operation $CGCallStmt$ generates the code corresponding to
call statements.

\begin{vdm_al}
#ifdef VDMSL
CGCallStmt: AS`CallStmt ==> seq of CPP`Stmt
CGCallStmt(mk_AS`CallStmt(-, nm, arg_l, cid)) ==
 (dcl rbtmp_l : seq of CPP`Stmt := [],
      var_l : seq of CPP`Expr := [],
      fndom : seq of REP`TypeRep := [];

  def nmtp = CGAUX`FindType(nm);
  in
    cases nmtp:
      mk_REP`PartialFnTypeRep(d,-) -> fndom := d,
      mk_REP`TotalFnTypeRep(d,-)   -> fndom := d,
      mk_REP`OpTypeRep(d,-)        -> fndom := d
    end;

  let gtype = BC`GenGeneric()
  in
    for i = 1 to len arg_l do
      def mk_(tmpArg_v, arg_stmt) = CGEXPR`CGExprExcl(arg_l(i), "tmpArg_v", nil)
      in
       (if CPP`isCPP()
        then
          def lti = CGAUX`FindType(arg_l(i))
          in
            if CGAUX`IsSubType(lti, fndom(i))
            then
             (var_l := var_l ^ [tmpArg_v];
              rbtmp_l := rbtmp_l ^ arg_stmt)
            elseif DS`GenType(lti) = gtype
            then
             (var_l := var_l ^ [tmpArg_v];
              rbtmp_l := rbtmp_l ^ arg_stmt)
            else
             (var_l := var_l ^ [BC`GenCastExpr(gtype, tmpArg_v)];
              rbtmp_l := rbtmp_l ^ arg_stmt)
        else
         (var_l := var_l ^ [tmpArg_v];
          rbtmp_l := rbtmp_l ^ arg_stmt);
       );

  def fcall = BC`GenFctCall(BC`Rename(nm), var_l);
      ti = CI`GetTypeInfo(cid);
  in
   (dcl rb_l : seq of CPP`Stmt := rbtmp_l;
    if is_REP`UnitTypeRep(ti)
    then rb_l := rb_l ^ [BC`GenExpressionStmt(fcall)]
    else 
      if CPP`isCPP()
      then
        if TYPE`IsOverlapping(ti, CGAUX`GiveCurrentRType(), {})
        then rb_l := rb_l ^ [BC`GenReturnStmt(fcall)]
        elseif TPGEN`GenCppTpDecl(ti,{}) = TPGEN`GenCppTpDecl(CGAUX`GiveCurrentRType(), {})
        then rb_l := rb_l ^ [BC`GenReturnStmt(fcall)]
        else rb_l := rb_l ^ [BC`GenGenericReturnStmt(fcall)]
      else rb_l := rb_l ^ [BC`GenReturnStmt(fcall)];
    return rb_l;
   )
 );
#endif VDMSL

#ifdef VDMPP
CGCallStmt: AS`CallStmt ==> seq of CPP`Stmt
CGCallStmt(mk_AS`CallStmt(obj,nm,arg_l,cid)) ==
  def rettp = CGAUX`GiveCurrentRType();
      nmtp   = CGAUX`FindType (nm);
      ti     = CI`GetTypeInfo (cid);
  in
  if obj = nil
  then
    let mk_(fdom,fntype) : [seq of REP`TypeRep] * [REP`TypeRep] =
                                  cases nmtp:
                                    mk_REP`PartialFnTypeRep(fndom,fnrng),
                                    mk_REP`TotalFnTypeRep(fndom,fnrng),
                                    mk_REP`OpTypeRep(fndom,fnrng) -> mk_(fndom, fnrng),
                                    others-> mk_(nil, nil)
                                   end
    in
     (dcl rb_l : seq of CPP`Stmt := [],
          var_l : seq of CPP`Expr := [];
      for index = 1 to len arg_l do
        def mk_(tmpArg_v, arg_stmt) = CGEXPR`CGExprExcl(arg_l(index), "tmpArg_v", nil)
        in
          if CPP`isJAVA()
          then
            cases nmtp:
              mk_REP`PartialFnTypeRep(fndom,-),
              mk_REP`TotalFnTypeRep(fndom,-),
              mk_REP`OpTypeRep(fndom,-) -> def tp1 = fndom(index);
                                               tp2 = CGAUX`FindType(arg_l(index))
                                           in
                                           (var_l := var_l ^[DS`GenExplicitCast(tp1,tmpArg_v,tp2)];
                                             rb_l := rb_l ^ arg_stmt),
              others                        -> (var_l := var_l ^[tmpArg_v];
                                                rb_l := rb_l ^ arg_stmt)
            end
          else
           (var_l := var_l ^ [tmpArg_v];
            rb_l := rb_l ^ arg_stmt);

      if CPP`isCPP() and len nm.ids > 1
      then CGAUX`IncludeClass(mu(nm, ids |-> [hd nm.ids]));
      if CPP`isCPP() and fdom <> nil
      then
        for t in fdom do
          if is_REP`ObjRefTypeRep(t)
          then CGAUX`IncludeClass(t.nm);

      def ti = CI`GetTypeInfo(cid);
      in
       (dcl nmobj : CPP`Expr;
        if CPP`isCPP() and len nm.ids > 1
        then nmobj := BC`GenQualifiedName(BC`Rename(mk_AS`Name([nm.ids(1)], nm.cid)),
                              BC`Rename(mk_AS`Name([nm.ids(2)], nm.cid)))
        elseif CPP`isCPP() -- len nm.ids = 1
        then nmobj := BC`Rename(nm)
        elseif len nm.ids > 1 -- CPP`isJava()
        then
          let l_clnm = mu(nm, ids |-> [hd nm.ids]),
              l_mnm =  mu(nm, ids |-> tl nm.ids)
          in
            if ((hd nm.ids) = CGAUX`GiveCurCName())
            then nmobj := BC`Rename(l_mnm)
            elseif l_clnm in set elems
                   CGAUX`GetOrderedSupers(CGAUX`GiveCurCASName()) and
                   not CGMAIN`isInterface(l_clnm)
            then nmobj := BC`GenQualifiedName(DS`GenSuper(), BC`Rename(l_mnm))
            else nmobj := BC`GenQualifiedName(BC`Rename(l_clnm), BC`Rename(l_mnm))
        elseif CGAUX`IsClass(nm) and nm = CGAUX`GiveCurCASName()
        then nmobj := DS`GenThis()
        elseif CGAUX`IsClass(nm) -- len nm.ids = 1
        then nmobj := DS`GenSuper()
        else nmobj := BC`Rename(nm);

        def fc = BC`GenFctCall(nmobj, var_l);
        in
         (dcl fcall1 : CPP`Expr,
              fcall2 : CPP`Expr;
          if CPP`isCPP()
          then fcall1 := BC`GenFctCall(nmobj, var_l)
          else fcall1 := DS`GenExplicitCast(rettp,fc,fntype);
          if CPP`isCPP()
          then fcall2 := BC`GenGenericFctCall(nmobj, var_l)
          else fcall2 := fc;
          if is_REP`UnitTypeRep(ti)
          then return rb_l ^ [BC`GenExpressionStmt(fcall2)]
          elseif CPP`isJAVA() and CGAUX`IsClass(nm)
          then return rb_l ^ [BC`GenExpressionStmt(fcall2)]
          else if CPP`isCPP()
          then
            if TYPE`IsOverlapping(ti, rettp, {})
            then return rb_l ^ [BC`GenReturnStmt(fcall1)]
            else return rb_l ^ [BC`GenGenericReturnStmt(fcall1)]
          else return rb_l ^ [BC`GenReturnStmt(fcall1)];
         )
       )
    )
  else -- obj <> nil
    def objnm  = BC`GiveName ("objnm");
        pos    = CI`GetPos (nm.cid);
        ap_cid = CI`PushCGPosType (pos,nmtp);
        applexpr = mk_AS`ApplyExpr (mk_AS`FieldSelectExpr (obj,nm,ap_cid), arg_l,cid);
    in
      if is_REP`UnitTypeRep (ti)
      then
        def apptp = mk_CGMAIN`VT(objnm, ti);
            cgexpr = CGEXPR`CGExpr' (applexpr, apptp)
        in
          if CGAUX`IsSeqOfCPPStmt( cgexpr )
          then return cgexpr
          else return [BC`GenExpressionStmt (cgexpr)]
      else -- erstatte evt. nil med ti
        def mk_(tmpobj,cgexpr) = CGEXPR`CGExprExcl (applexpr, "tmpObj", CGAUX`FindType(applexpr))
        in
          if CPP`isCPP()
          then
            if TYPE`IsOverlapping(ti, rettp, {})
            then return cgexpr ^ [BC`GenReturnStmt(tmpobj)]
            else return cgexpr ^ [BC`GenGenericReturnStmt(tmpobj)]
          else return cgexpr ^ [BC`GenReturnStmt(DS`GenExplicitCast(rettp,tmpobj,CGAUX`FindType(applexpr)))];
#endif VDMPP

\end{vdm_al}

\subsection{Block Statement}

The block statement consists of a sequence of assign definitions and
sequence of statements.

Consider the following VDM examples of a block statement:

\begin{verbatim}
( dcl a : nat;
  a := 3 )
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Int vdm_a;  // Declaration of "a";
...GenStmt( "a := 3" );
\end{verbatim}

Another VDM example:

\begin{verbatim}
( dcl a : map nat to nat := { 1 |-> 3};
  a := a munion { 2 |-> 4}
)
\end{verbatim}

The corresponding pseudo code of this block statement is listed below:

\begin{verbatim}
Map vdm_a;
...CGEXPR`CGExpr( "{ 1|-> 3 }", mk_CGMAIN`VT( vdm_a, "Map" ) );
...GenStmt( "a := a munion { 2 |-> 4 } " )
\end{verbatim}

#ifdef VDMPP
In VDM++ the right hand side of an assign definition can be either an
expression, an invoke statement or a new statement.
#endif

\begin{vdm_al}
CGBlockStmt: AS`BlockStmt * bool ==> seq of CPP`Stmt
CGBlockStmt(mk_AS`BlockStmt(dcls, stmts,-), isLast) ==
 (dcl rb : seq of CPP`Stmt := [];
  CGAUX`PushEnv();
  for mk_AS`AssignDef(var, tp, dclinit,-) in dcls do
    (def - = CGAUX`InsertName(var);
         varname = BC`Rename(var);
         type = CGAUX`RemoveNil(CGAUX`FromAS2RepType( tp ));
         var_decl = DS`GenDecl( type, varname, nil )
     in
       cases true :
         (nil = dclinit) -> rb := rb ^ var_decl,
         others -> def dclinit_type = CGAUX`FindType(dclinit)
                   in
                   if CGAUX`IsSubType(dclinit_type, type) and
                      not (CPP`isJAVA() and CGAUX`IsStringType(dclinit_type) and not CGAUX`IsStringType(type))
                   then
                     def mk_(var_v, var_stmt) = CGEXPR`CGExprExcl(dclinit, varname, type)
                     in if var_stmt = []
                        then 
                          if CPP`isCPP()
                          then
                            def ainit_v = BC`GenAsgnInit(var_v);
                                init_v = cases dclinit:
                                    mk_AS`NilLit(-)                -> BC`GenAsgnInit(var_v),
                                    mk_AS`SeqEnumerationExpr([],-) -> if CGAUX`IsSeqType(type)
                                                                      then nil
                                                                      else ainit_v,
                                    mk_AS`SetEnumerationExpr([],-) -> if CGAUX`IsSetType(type)
                                                                      then nil
                                                                      else ainit_v,
                                    mk_AS`MapEnumerationExpr([],-) -> if CGAUX`IsMapType(type)
                                                                      then nil
                                                                      else ainit_v,
                                    others -> ainit_v
                                  end
                            in rb := rb ^ DS`GenDecl( type, varname, init_v)
                          else rb := rb ^ DS`GenDeclInit( type, varname, var_v)
                        else
                          cases var_stmt:
                            [mk_CPP`ExpressionStmt(mk_CPP`AssignExpr(varname, mk_CPP`AssignOp(<ASEQUAL>,-),v,-),-)]
                                -> rb := rb ^ DS`GenDeclInit( type, varname, v),
                            others -> rb := rb ^ var_decl ^ var_stmt
                          end
                   else
                     if CPP`isCPP()
                     then
                       def mk_(var_v, var_stmt) = CGEXPR`CGExprExcl(dclinit, "varname", type);
                           ainit_v = BC`GenAsgnInit(var_v);
                           init_v = cases dclinit:
                                    mk_AS`SeqEnumerationExpr([],-) -> if CGAUX`IsSeqType(type)
                                                                      then nil
                                                                      else ainit_v,
                                    mk_AS`SetEnumerationExpr([],-) -> if CGAUX`IsSetType(type)
                                                                      then nil
                                                                      else ainit_v,
                                    mk_AS`MapEnumerationExpr([],-) -> if CGAUX`IsMapType(type)
                                                                      then nil
                                                                      else ainit_v,
                                    others -> ainit_v
                                  end;
                           var_decl = DS`GenDecl(type, varname, init_v)
                       in rb := rb ^ var_stmt ^ var_decl
                     else
                       def mk_(var_v, var_stmt) = CGEXPR`CGExprExcl(dclinit, varname, type)
                       in if var_stmt = []
                          then
                            if is_CPP`ClassInstanceCreationExpr(var_v)
                            then
                              if CGAUX`IsSubType(CGAUX`FindType(dclinit), type)
                              then rb := rb ^ DS`GenDeclInit(type, varname, var_v)
                              elseif CGAUX`IsStringType(type) and var_v.classtype = DS`GenStringType().tp
                              then rb := rb ^ DS`GenDeclInit(type, varname, var_v)
                              else rb := rb ^ DS`GenDeclInit(type, varname,
                                                          DS`GenExplicitCast(type,var_v,CGAUX`FindType(dclinit)))
                            else rb := rb ^ DS`GenDeclInit(type, varname,
                                                        DS`GenExplicitCast(type,var_v,CGAUX`FindType(dclinit)))
                          else
                            cases var_stmt:
                              [mk_CPP`ExpressionStmt(mk_CPP`AssignExpr(varname, mk_CPP`AssignOp(<ASEQUAL>,-),v,-),-)]
                                  -> rb := rb ^ DS`GenDeclInit( type, varname, v),
                              others -> rb := rb ^ var_decl ^ var_stmt
                            end
       end);
  CGAUX`PushEnv();
  for i = 1 to len stmts do
    rb := rb ^ GenStmt( stmts(i), isLast and i = len stmts );

  CGAUX`PopEnv(); -- 20130305
  CGAUX`PopEnv();

  if dcls = []
  then return rb
  else return [CGAUX`GenCPPStmt(rb)]);
\end{vdm_al}

\subsection{Let Statement}

The code generation of a let statement is very similar to the code
generation of a let expression. Therefore, we refer to Section
\ref{letexpr} for further details on the code generation of let statements.

\begin{vdm_al}
CGLetStmt: AS`LetStmt * bool ==> seq of CPP`Stmt
CGLetStmt(mk_AS`LetStmt(ld_l, In, -), isLast) ==
 (dcl rb_l : seq of CPP`Stmt := [];
  FD`PushEnv();
  CGAUX`PushEnv();
  let vindex_s = { i | i in set inds ld_l & is_AS`ValueDef(ld_l(i)) },
      lvd_l = [ ld_l(i) | i in set vindex_s ],
      lfd_l = [ ld_l(i) | i in set inds ld_l \ vindex_s ]
  in
    (FD`GenLocalFcts(lfd_l);
     PM`InitState();
     rb_l := rb_l ^ VD`GenLocalValDef(lvd_l));

  if not is_AS`IdentStmt(In)
  then rb_l := rb_l ^ GenStmt(In, isLast);

  FD`PopEnv();
  CGAUX`PopEnv();
  VD`DeleteLoc();

  let existsDecl = exists e in set elems rb_l & is_CPP`DeclarationStmt(e)
  in
    return if len rb_l > 1 and existsDecl
           then [ BC`GenBlock(rb_l) ]
           else rb_l;
 );

\end{vdm_al}


\subsection{Let-Be-Such-That Statement}
\label{letbestmt}

The code generation of a {\em let-be-st statement\/} is very similar
to the code generation of a {\em let-be-st expression}. Therefore,
we refer to section \ref{letbeexpr} for further details on the code
generation of let statements.

\begin{vdm_al}
CGLetBeSTStmt: AS`LetBeSTStmt * bool ==> seq of CPP`Stmt
CGLetBeSTStmt(mk_AS`LetBeSTStmt(bind, St, In,-), isLast) ==
  if exists e in set elems bind & is_AS`MultTypeBind(e)
  then
   (CGAUX`SetNotSupportedException(true);
    def stmts = GenNotSupported("type bind", isLast)
    in 
      if CPP`isCPP()
      then return stmts ^ [BC`GenGenericReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))]
      else return stmts ^ [BC`GenReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))]
   )
  else
   (CGAUX`PushEnv();
    def rb_l = CGEXPR`GenBindListVariables(bind, St) ^ GenStmt(In, isLast)
    in
     (CGAUX`PopEnv();
      return [BC`GenBlock(rb_l)])
   );
\end{vdm_al}

\subsection{Define Statement}

The pseudo code of the define statement is very much a like the pseudo
code of let statements. Therefore we refer to the code generation of
let statements for further information.

Notice, that type binds are ignored, and that set binds are not
supported by the code generator (and the VDM parser as well).

\begin{vdm_al}
CGDefStmt: AS`DefStmt * bool ==> seq of CPP`Stmt
CGDefStmt(mk_AS`DefStmt(def_l, body,-), isLast) ==
 (dcl lvd_l : seq of AS`ValueDef := [],
      rb_l : seq of CPP`Stmt;
  FD`PushEnv();
  CGAUX`PushEnv();

  for mk_(patb, expr) in def_l do
    cases patb:
      mk_AS`TypeBind(pat, tp, cid) ->
            lvd_l := lvd_l ^ [mk_AS`ValueDef(pat, tp, expr,<NOT_INITIALISED_AS>, false, cid)],
      mk_AS`SetBind(pat, Set, cid) ->
            def pcid = CI`PushCGType(mk_REP`SetTypeRep(CGAUX`FindType(pat)));
                ecid = CI`PushCGType(mk_REP`SetTypeRep(CGAUX`FindType(expr)));
                iscid = CI`PushCGType(mk_REP`UnionTypeRep({CGAUX`FindType(Set),
                                                           mk_REP`SetTypeRep(CGAUX`FindType(pat))}));
                iset = mk_AS`BinaryExpr(Set, <SETINTERSECT>, mk_AS`SetEnumerationExpr([expr], ecid), iscid);
                sep = mk_AS`SetEnumPattern([pat], pcid)
             in
               lvd_l := lvd_l ^ [mk_AS`ValueDef(sep, nil, iset, <NOT_INITIALISED_AS>, false, cid) ],
      others -> lvd_l := lvd_l ^ [ mk_AS`ValueDef(patb, nil, expr, <NOT_INITIALISED_AS>, false, patb.cid) ]
    end;
    rb_l := VD`GenLocalValDef(lvd_l);
    if not is_AS`IdentStmt(body)
    then rb_l := rb_l ^ GenStmt(body, isLast);

    CGAUX`PopEnv();
    FD`PopEnv();
    VD`DeleteLoc();
    return [BC`GenBlock(rb_l)];
 );
\end{vdm_al}

\subsection{While Loop Stmt }

Consider the following VDM statement:

\begin{verbatim}
while i < 0 and j > 10 do
  (  i := i + 1;
     j := j - 1
  )
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Bool whCtrl;
While (true)
 { ...CGEXPR`CGExpr( "i < 0 and j > 10", mk_CGMAIN`VT( whCtrl, "Bool" ) );
   if (whCtrl )
        ...CGSTMT`GenStmt(" i := i + 1;
                          j := j - 1 " );
   else
      break;
 }
\end{verbatim}

\begin{vdm_al}
CGWhileLoopStmt: AS`WhileLoopStmt * bool ==> seq of CPP`Stmt
CGWhileLoopStmt(mk_AS`WhileLoopStmt(test, body, -), isLast) ==
  def whCrtlType = CGAUX`FindType( test );
      btype = mk_REP`BooleanTypeRep();
      mk_(whCrtl_v, eval_stmt) = CGEXPR`CGExprExcl(test, "whCrtl", nil);
      bodystmt = CGAUX`GenCPPStmt(GenStmt( body, isLast ));
  in
   (dcl whCrtlval : CPP`Expr,
        cond : CPP`Expr,
        isbool : seq of CPP`Stmt := [];
    if CGAUX`IsBoolType(whCrtlType)
    then whCrtlval := DS`GenGetValue( whCrtl_v, btype )
    else whCrtlval := DS`GenGetValue( BC`GenCastExpr( DS`GenBoolType(), whCrtl_v ), btype );
    if eval_stmt = [] and CGAUX`IsBoolType(whCrtlType)
    then cond := whCrtlval
    else cond := BC`GenBoolLit(true);
    if not CGAUX`IsBoolType(whCrtlType)
    then isbool := [ BC`GenIfStmt( BC`GenNot( DS`GenIsBool( whCrtl_v ) ),
                                   CGAUX`RunTime("A boolean was expected in while loop" ),
                                   nil ) ];
    def ifstmt = BC`GenIfStmt(whCrtlval, bodystmt, BC`GenBreakStmt(nil));
    in
     (dcl block : CPP`Stmt,
          rb : seq of CPP`Stmt := [];
      if eval_stmt = [] and CGAUX`IsBoolType(whCrtlType)
      then block := bodystmt
      else block := BC`GenBlock (eval_stmt ^ isbool ^ [ifstmt]);
      rb := rb ^ [ BC`GenWhileStmt( cond, block ) ];
      return rb);
   );
\end{vdm_al}

\subsection{Sequence For Loop Statement}

In this section the code generation of sequence for loop statements
are described. Set and type binds are ignored by this version of the
code generator. Consider the following statement:

\begin{verbatim}
for mk_(a,b) in set { mk_(i,j) | i,j in set {1,2,3} } in
                                      reverse [ mk_(1,2), mk_(1,1) ] do
  UpDate(a,b)
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Sequence sq;
...CGEXPR`CGExpr("[ mk_(1,2), mk_(1,1) ]", CGMAIN`VT(sq, "Sequence"));
Int a;
Int b;
bool succ;
...DS`GenIterSeq(mk_CGMAIN`VT(sq, "Sequence"),
                 nil,
                 mk_CGMAIN`VT(elem, "Tuple"),
                 "{ ...PM`CGPatternMatch("mk_(a,b)",
                                         mk_CGMAIN`VT(elem,"Tuple"),
                                         {}, succ);
                    if (succ)
                      ...GenStmt("UpDate(a,b));
                    else
                      RunTimeError("Pattern did not match in sequence for loop"");
                  }"),
                 <REVERSE>)
\end{verbatim}

The operation $CGSeqForLoopStmt$ generates the code corresponding to
sequence for loops.

\begin{vdm_al}
CGSeqForLoopStmt: AS`SeqForLoopStmt * bool ==> seq of CPP`Stmt
CGSeqForLoopStmt(mk_AS`SeqForLoopStmt(cv, fseq, body,-), isLast) ==
  def pid_cv_s = CGAUX`FindAllNamesInPatternBind(cv);
      pid_expr_s = CGAUX`FindAllNamesInExpr(fseq);
      sqt = CGAUX`FindType(fseq);
      mk_(sq1, sq_stmt) = CGEXPR`CGExprExcl(fseq, "sq", nil)
  in
   (dcl rb_l : seq of CPP`Stmt := sq_stmt,
        sq : CPP`Expr := BC`GiveName("sq");
    if (pid_cv_s inter pid_expr_s) <> {} or not is_AS`Name(fseq)
    then rb_l := rb_l ^ DS`GenDeclInit(sqt, sq, sq1)
    else sq := sq1;

    CGAUX`PushEnv();
    CGAUX`InsertNamesinEnv2(pid_cv_s);
    def mk_(decl_l, pat) = DeclareVars(cv)
    in
     (if not CGAUX`IsSeqType(sqt)
      then
        def sq' = BC`GiveName("tmpSeq");
            cond = DS`GenIsSeq(sq);
            rti = CGAUX`RunTime("A sequence was expected in sequence for loop")
        in
         (rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(cond), rti, nil)];
          if CPP`isCPP()
          then rb_l := rb_l ^ [BC`GenDecl(DS`GenSeq0Type(), sq', BC`GenObjectInit([sq]))]
          else rb_l := rb_l ^ [BC`GenDecl(DS`GenSeq0Type(), sq', BC`GenAsgnInit(DS`GenCastSeq(sq, nil)))];
          sq := sq');
      def elem = BC`GiveName("elem");
          succ = BC`GiveName("succ");
          vt1 = mk_CGMAIN`VT(sq, sqt);
          vt2 = mk_CGMAIN`VT(elem, CGAUX`FindSeqElemType(sqt));
          stmt = GenStmt(body, isLast);
          rti = CGAUX`RunTime("Pattern did not match in sequence for loop");
          mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(pat, vt2, {}, succ, nil, stmt, false);
          pm1 = if Is_Excl
                then pm
                else [BC`GenDecl(DS`GenSmallBoolType(), succ, BC`GenAsgnInit(BC`GenBoolLit(false)))]
                     ^ pm ^ [BC`GenIfStmt(BC`GenNot(succ), rti, nil)];
          stmt_l = CGEXPR`MergeStmts( decl_l, pm1 );
      in
       (rb_l := rb_l ^ DS`GenIterSeq(vt1, nil, vt2, stmt_l);
       );
     );
    CGAUX`PopEnv();
    return [BC`GenBlock(rb_l)]
   );

DeclareVars: AS`PatternBind ==> seq of CPP`Stmt * AS`Pattern
DeclareVars(p) ==
  cases p:
    mk_AS`SetBind(pat, -, -),
    mk_AS`TypeBind(pat, -, -) -> return mk_(CGEXPR`DeclarePatVars(pat), pat),
    pat                       -> return mk_(CGEXPR`DeclarePatVars(pat), pat),
    others -> return undefined
  end;
\end{vdm_al}


\subsection{Set For Loop Statement}

In this section the code generation of set for loop statements are
described. Consider the following statement:

\begin{verbatim}
for all var in set f(10) do
  res_l := res_l ^ [elem]
\end{verbatim}

The corresponding pseudo code is listed below, if it is assumed that
the signature of {\tt f} is {\tt f: nat -> nat | set of (nat | char)}:


\begin{verbatim}
Generic iset;
Set tmpSet;
...CGEXPR`CGExpr("f(10)", CGMAIN`VT(iset, "Generic"));
if (iset.IsSet())
  tmpSet = iset;
else
  RunTimeError("A set was expected in set for loop");
Generic var;
bool succ;
...DS`GenIterSet(mk_CGMAIN`VT(tmpSet, "Set"), nil,
                 mk_CGMAIN`VT(elem, "Generic"),
                 "{ ...PM`CGPatternMatch("var",
                                         mk_CGMAIN`VT(elem,"Generic"),
                                         {}, succ);
                    if (succ)
                      ...GenStmt("UpDate(a,b));
                    else
                      RunTimeError("Pattern did not match in set for loop"");
                  }")
\end{verbatim}


The operation $CGSetForLoopStmt$ generates the code corresponding to
set for loops.

\begin{vdm_al}
CGSetForLoopStmt: AS`SetForLoopStmt * bool ==> seq of CPP`Stmt
CGSetForLoopStmt(mk_AS`SetForLoopStmt(pat, fset, body,-), isLast) ==
  def elem = BC`GiveName("elem");
      succ = BC`GiveName("succ");
      pid_pat_s = dom CGEXPR`FindPatternId(pat);
      pid_expr_s = CGAUX`FindAllNamesInExpr(fset);
      settp = CGAUX`FindType(fset);
      mk_(iset1, set_stmt) = CGEXPR`CGExprExcl(fset, "iset", nil)
  in
   (dcl rb_l : seq of CPP`Stmt := set_stmt,
        iset : CPP`Expr := BC`GiveName("iset");
    if (pid_pat_s inter pid_expr_s) <> {} or not is_AS`Name(fset)
    then rb_l := rb_l ^ DS`GenConstDeclInit(settp, iset, iset1)
    else iset := iset1;
    if not CGAUX`IsSetType(settp)
    then
      def iset' = BC`GiveName("tmpSet");
          cond = DS`GenIsSet(iset);
          rti = CGAUX`RunTime("A set was expected in set for loop")
      in
       (rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(cond), rti, nil)];
        if CPP`isCPP()
        then rb_l := rb_l ^ [BC`GenDecl(DS`GenSetType(), iset', BC`GenAsgnInit(iset))]
        else rb_l := rb_l ^ [BC`GenDecl(DS`GenSetType(), iset', BC`GenAsgnInit(DS`GenCastSetType(iset)))];
        iset := iset');
    def vt1 = mk_CGMAIN`VT(iset, settp);
    in
     (dcl vt2 : CGMAIN`VT := mk_CGMAIN`VT(elem, CGAUX`FindSetElemType(settp));
      CGAUX`PushEnv();
      if is_AS`PatternName(pat)
      then
        let mk_AS`PatternName(name,-,-) = pat
        in
          def seqindices = CGAUX`IsSeqIndicesSet(fset)
          in
           (dcl seqapply_s : set of (CPP`Expr * CPP`Expr) := {},
                stmt_l : seq of CPP`Stmt := [];
            if name <> nil
            then
              def - = CGAUX`InsertName(name);
              in
               (vt2.name := BC`Rename(name);  
                if seqindices
                then seqapply_s := seqapply_s union {mk_(BC`Rename(fset.arg), BC`Rename(name))};
               );
            CGAUX`AddNoCheckSeqApply(seqapply_s);
            stmt_l := GenStmt(body, isLast);
            CGAUX`RemNoCheckSeqApply(seqapply_s);
            rb_l := rb_l ^ DS`GenIterSet(vt1, nil, vt2, stmt_l);
           )
      else
        def decl_l = CGEXPR`DeclarePatVars(pat); -- first
            stmt = GenStmt(body, isLast);        -- second
            mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(pat, vt2, {}, succ, nil, stmt, true); -- third
            pm1 = if Is_Excl
                  then pm
                  else
                    def rti = CGAUX`RunTime("Pattern did not match in set for loop");
                    in [BC`GenDecl(DS`GenSmallBoolType(), succ, BC`GenAsgnInit(BC`GenBoolLit(false)))]
                       ^ pm ^ [BC`GenIfStmt(BC`GenNot(succ), rti, nil)];
            stmt_l = CGEXPR`MergeStmts( decl_l, pm1 );
        in
         (rb_l := rb_l ^ DS`GenIterSet(vt1, nil, vt2, stmt_l);
         );
      CGAUX`PopEnv();
     );
    return [BC`GenBlock(rb_l)]
   );
\end{vdm_al}

\subsection{Indexed For Loop Statement}

In this section the code generation of indexed for loop statements are
described. Consider the following statement:

\begin{verbatim}
for var = 0 to f(10) by 2
  res_l := res_l ^ [var]
\end{verbatim}

It is assumed that the signature of {\tt f} is {\tt f: nat -> nat |
  char}. The corresponding pseudo code is listed below:

\begin{verbatim}
Int lb;
...CGEXPR`CGExpr("0", mk_CGMAIN`VT(lb, "Int"));
int ilb = lb.GetValue;
Generic ub;
...CGEXPR`CGExpr("f(10)", mk_CGMAIN`VT(lb, "Generic"));
if (!ub.IsInt())
  RunTimeError("An integer was expected in indexed for loop");
int iub = ((Int) ub).GetValue();
Int by;
...CGEXPR`CGExpr("2", mk_CGMAIN`VT(by, "Int"));
int iby = by.GetValue();
if (iby == 0)
  RunTimeError("Step length in indexed for loop was 0");
if (iby < 0 ? ilb >= iub : ilb <= iub)
  for (; ilb <= iub; ilb += iby) {
    Int val = (int) ilb;
    ...GenStmt("res_l := res_l ^ [var]")
}
\end{verbatim}


The operation $CGIndexedForLoopStmt$ generates the code corresponding to
indexed for loops.

\begin{vdm_al}
CGIndexedForLoopStmt: AS`IndexForLoopStmt * bool ==> seq of CPP`Stmt
CGIndexedForLoopStmt(mk_AS`IndexForLoopStmt(nm, lb, ub, By, body, -), isLast) ==
  def mk_(st1_l, val1) = GenBoundAndValue("lb", lb);
      mk_(st2_l, val2) = GenBoundAndValue("ub", ub);
      ilb = BC`GiveName("ilb");
      idcl = DS`GenSmallNumType();
  in
   (dcl iub : CPP`Expr := val2;
    if st2_l <> []
    then iub := BC`GiveName("iub");
    def mk_(st3_l, inc, cont) = GenByPart(By, ilb, iub);
        - = CGAUX`InsertName(nm);
        decl = DS`GenDeclInit(mk_REP`NumericTypeRep(<INTEGER>), BC`Rename(nm), ilb);
        stmt = GenStmt(body, isLast);
        fb = BC`GenBlock(decl ^ stmt);
        fs = BC`GenForStmt(BC`GenDecl(idcl, ilb, BC`GenAsgnInit(val1)), cont, [inc], fb)
    in
     (dcl rb_l : seq of CPP`Stmt := st1_l;
      if st2_l <> []
      then rb_l := rb_l ^ st2_l ^ [BC`GenDecl(idcl, iub, BC`GenAsgnInit(val2))];
      rb_l := rb_l ^ st3_l;
      rb_l := rb_l ^ [fs];
      return rb_l);
   );

GenBoundAndValue: seq of char * AS`Expr ==> seq of CPP`Stmt * CPP`Expr
GenBoundAndValue(var, expr) ==
  def mk_(var_v, var_stmt) = CGEXPR`CGExprExcl(expr, var, nil);
      tp = CGAUX`FindType(expr)
  in
    if not CGAUX`IsIntType(tp)
    then
     (dcl rb_l : seq of CPP`Stmt := var_stmt,
          tmp : CPP`Expr := var_v;
      if not is_CPP`Identifier(var_v)
      then
        def v1 = BC`GiveName("tmp")
        in
         (rb_l := rb_l ^ DS`GenDecl(tp, v1, BC`GenAsgnInit(var_v));
          tmp := v1);
        
      def cond = BC`GenNot(DS`GenIsInt(tmp));
          rti = CGAUX`RunTime("An integer was expected in indexed for loop");
      in
       (dcl val : CPP`Expr;
        if CPP`isCPP()
        then val := DS`GenGetValue(BC`GenCastExpr(DS`GenIntType(), tmp), nil)
        else val := DS`GenGetValue(BC`GenCastExpr(DS`GenNumType(), tmp), mk_REP`NumericTypeRep(<INTEGER>));
        rb_l := rb_l ^ [BC`GenIfStmt(cond, rti, nil)];
        return mk_(rb_l, val)
       )
     )
    elseif is_AS`RealLit(expr) or is_AS`NumLit(expr)
    then
      return mk_([], BC`GenIntegerLit(expr.val))
    else
      def rb_l = var_stmt;
          val = DS`GenGetValue(var_v, mk_REP`NumericTypeRep(<INTEGER>))
      in
        return mk_(rb_l, val);

GenByPart: [AS`Expr] * CPP`Name * CPP`Expr ==> seq of CPP`Stmt * CPP`Expr * CPP`Expr
GenByPart(By, ilb, iub) ==
  if By <> nil
  then
    def mk_(st_l, val) = GenBoundAndValue("by", By);
    in
      if is_CPP`IntegerLit(val) and val.val <> 0
      then
        def inc = if val.val <> -1 
                  then BC`GenAsgnPlusExpr(ilb, val)
                  else BC`GenPostMinusMinus(ilb)
        in return mk_(st_l, inc, if val.val > 0 then BC`GenLeq(ilb, iub) else BC`GenGeq(ilb, iub))
      else
        def iby = BC`GiveName("iby");
            zero = BC`GenIntegerLit(0);
            rti = CGAUX`RunTime("Step length in indexed for loop was 0");
            inc = BC`GenAsgnPlusExpr(ilb, iby);
        in
          (dcl rb_l : seq of CPP`Stmt := st_l;
           --rb_l := rb_l ^ [BC`GenDecl(DS`GenSmallIntType(), iby, BC`GenAsgnInit(val))];
           rb_l := rb_l ^ [BC`GenDecl(DS`GenSmallNumType(), iby, BC`GenAsgnInit(val))];
           rb_l := rb_l ^ [BC`GenIfStmt(BC`GenEq(iby, zero), rti, nil)];
           def cont = BC`GenCondExpr(BC`GenBracketedExpr(BC`GenLt(iby, zero)),
                                     BC`GenBracketedExpr(BC`GenGeq(ilb,iub)),
                                     BC`GenBracketedExpr(BC`GenLeq(ilb,iub)));
           in 
             return mk_(rb_l, inc, cont)
          )
  else
   return mk_([], BC`GenPostPlusPlus(ilb), BC`GenLeq(ilb, iub));
\end{vdm_al}

\subsection{Cases Statement}

The overall structure of the corresponding code generated to a cases
statement and a cases expression is the same.
Consider the following cases statement:

\begin{verbatim}
cases e:
   a, { 1, a} -> s1
   [1, b ]    -> s2,
   others     -> s3
end
\end{verbatim}

Where {\bf s{\tt n} } denotes some statement. The corresponding pseudo
code of the cases statement is listed below:

\begin{verbatim}
Generic tmpE; // Declaration of a temporary variable to store
              // the resul of the evaluation of the expression "e".
...CGEXPR`CGExpr( e, mk_CGMAIN`VT( tmpE, "Generic" ) )
bool succ = false; // boolean indicating if a pattern has succeeded.
//Pattern match of first branch:
{ Generic vdm_var_a;     // Declaration of variables corresponding to
                         // the pattern identifiers appearing in the patterns.

  ...CGPatternMatch( "a", tmpE, {}, succ);
                         // Code corresponding to the pattern match
                         // of the expression "e" against the pattern "a":

  if ( ! succ )
    ...CGPatternMatch( "{1,a}", tmpE, {}, succ )
  if ( succ )   // If either pattern match succeeded with the expression "e"
                // against either "a" or "{1,a}".
   {
     ...GenStmt( s1 );  // Notice, that since the declaration of the variable
                        // a is done in an outer block the scope of "a" also
                        // apply in this block.
   }
}
if ( ! succ )           // No pattern match succeeded in the first guard.
 { Generic vdm_var_b;   // Declaration of variables corresponding to the
                        // pattern identifiers appearing in the patterns.
   ...CGPatternMatch( "[1,b]", tmpE, {}, succ )
   if ( succ )
    {
      ...GenStmt(s2, resVar );
    }
 }
else // No pattern match succeeded
 {
   ...GenStmt(s3);
 }
\end{verbatim}


As for cases expression the cases statement can yield the same complexity in sense of :
\begin{enumerate}
\item identifiers which are bound to the same value:
\begin{verbatim}
cases e:
  {a, { a }, 1} -> b1,
  others  -> b2
end;
\end{verbatim}

\item branches which consists of alternative patterns which do not
share a common set of pattern identifiers:
\begin{verbatim}
cases e:
  {1,a}, {2, b} -> s1,
  others        -> s2
end
\end{verbatim}
\end{enumerate}

The problem on how to deal with the case expression in item number 1 is
solved in the pattern match which statically detects if it is
necessary to generate code checking that identically pattern
identifiers are bound to equal values.


The second problem on how to deal with the cases statement in item number 2
is solved by generating code as if the cases expression was written:
\begin{verbatim}
cases e:
  {1,a}  -> s1,
  {2,b}  -> s1,
  others -> s2
end
\end{verbatim}

The main operation $CGCasesStmt$ describing the code generation of
a cases statement is listed below.  It takes one input parameter:

\begin{description}

\item{ mk-CasesStmt(sel, altns, Others): }
The abstract syntax of the the cases statement.

\end{description}

\begin{vdm_al}
CGCasesStmt: AS`CasesStmt * bool ==> seq of CPP`Stmt
CGCasesStmt(mk_AS`CasesStmt(sel, altns, Others, -), isLast) ==
  def succ_v = BC`GiveName( "succ" );
      selResType = CGAUX`FindType( sel );
      mk_(selRes1_v, sel_stmt) = CGEXPR`CGExprExcl(sel, "selRes", nil);
      all_pat_ids = CGEXPR`FindAllPatIdInCasesAlt(altns);
      all_nm_in_expr = CGAUX`FindAllNamesInExpr(sel);
      pat_in_expr = all_nm_in_expr inter all_pat_ids <> {};
      sel_v = BC`GiveName("selRes");
      need_decl = pat_in_expr and sel_stmt = [] or
#ifdef VDMPP
                 exists n in set all_nm_in_expr & is_REP`ObjRefTypeRep(CGAUX`FindType(n)) or
#endif
                 cases true:
                   (is_AS`TupleConstructorExpr(sel)),
                   (is_AS`RecordConstructorExpr(sel)),
                   (is_AS`SetEnumerationExpr(sel)),
                   (is_AS`SeqEnumerationExpr(sel))    -> true,
                   others                             -> false
                 end;

      selRes_v = if need_decl
                 then sel_v
                 else selRes1_v
  in
   (dcl rb : seq of CPP`Stmt := sel_stmt;
    if need_decl
    --then rb := rb ^ DS`GenDeclInit(selResType, sel_v, selRes1_v);
    then rb := rb ^ DS`GenConstDeclInit(selResType, sel_v, selRes1_v);
    rb := rb ^ [ BC`GenDecl(DS`GenSmallBoolType(), succ_v, BC`GenAsgnInit(BC`GenBoolLit(false))) ];
    rb := rb ^ CGCasesStmtAltn( altns, mk_CGMAIN`VT(selRes_v, selResType), succ_v, Others, isLast ) ;
    if Others = nil
    then
      if isLast and not is_REP`UnitTypeRep(CGAUX`GiveCurrentRType())
      then
       (rb := rb ^ [CGAUX`RunTime ("The operation did not return a value")];
        if CPP`isCPP()
        then rb := rb ^ [BC`GenGenericReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))]
        else rb := rb ^ [BC`GenReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))]
       );
    return rb);
\end{vdm_al}


The next operation $CGCasesStmtAltn$ is an auxiliary operation of
$CGCasesStmt$. It generates code corresponding to all the alternative
branches in a cases statement. The three input parameters are
described below:

\begin{description}

\item{altns:} The alternative branches in a cases statement.

\item{selRes-v:} This parameter is of type $CG`VT$, it is a record
  with two fields. The first field is contains the C++ variable name
  of the variable in which the evaluation of the selector expression
  in the cases statement is store. The second field contains the type
  of the selector expression.

\item{succ-v:} Is a temporary variable which is assigned to true if
  one of the pattern match in the branches succeeds and otherwise to
  false.

\end{description}


\begin{vdm_al}
CGCasesStmtAltn: seq1 of AS`CasesStmtAltn * CGMAIN`VT * CPP`Name * [AS`Stmt] * bool ==> seq of CPP`Stmt
CGCasesStmtAltn( altns, selRes_v, succ_v, Others, isLast ) ==
  (dcl rb : seq of CPP`Stmt := [];
   --CGAUX`PushEnv();
   for i = 1 to len altns do
    (CGAUX`PushEnv();
     def stmt = CGAltnStmt ( altns (i), selRes_v, succ_v, nil, isLast)
     in
       if i = 1
       then rb := rb ^ [stmt]
       else rb := rb ^ [ BC`GenIfStmt(BC`GenNot(succ_v), stmt, nil) ];
     CGAUX`PopEnv();
    );
   if Others <> nil
   then
     def othersStmt = GenStmt(Others, isLast)
     in
       if isLast and not is_REP`UnitTypeRep(CGAUX`GiveCurrentRType())
       then rb := rb ^ othersStmt
       else rb := rb ^  [ BC`GenIfStmt(BC`GenNot(succ_v), BC`GenBlock(othersStmt), nil) ];
   --CGAUX`PopEnv();
   return rb);
\end{vdm_al}

The operation $CGAltnStmt$ is an auxiliary function to
$CGCasesStmtAltn$. It generates code corresponding to one branch in
the cases statement. The operation takes four input parameters:

\begin{description}

\item{mk-AS`CasesStmtAltn(p-l, s):} Is the abstract syntax of the
  branch in the cases expression.

\item{selRes-v:} This parameter is of type $CG`VT$, it is a record of
  with two fields. The first field is contains the C++ variable name
  of the variable in which the evaluation of the selector expression
  in the cases expression is store. The second field contains the type
  of the selector expression.

\item{succ-v:} Is a temporary variable which is assigned to true if
  one of the pattern match in the branches succeeds and otherwise to
  false.

\end{description}

Remember the example where the alternative patterns do not share a
common set of pattern identifiers:

\begin{verbatim}
cases e:
  {1,a}, {2, b} -> s1,
  others        -> s2
end
\end{verbatim}

As it was described previously we have chosen to solve this problem by
generating code as if the cases statement was written:

\begin{verbatim}
cases e:
  {1,a}  -> s1,
  {2,b}  -> s1,
  others -> s2
end
\end{verbatim}

It is the operation $CGAltnStmt$ that it is investigated if the
alternative patterns in the branch do not share a common set of
pattern identifiers, this is, as it appears in the specification, done
by calling the operation $CGEXPR`SamePatternIds$. This operation returns
a tuple, which is --- in this case --- bound to the identifiers
$samepatternIds$ and $pid-m$. The identifier $samepatternIds$ is
assigned to true if the alternative patterns share a common set of
identifiers and false otherwise. The identifier $pid-m$ is --- if
the alternative patterns share common set of identifiers - assigned to
a map from the identifiers in the pattern alternatives to a sequence
of types which they could be bound to.

\begin{vdm_al}
CGAltnStmt: AS`CasesStmtAltn * CGMAIN`VT * CPP`Name * [CPP`Stmt] * bool ==> CPP`Stmt
CGAltnStmt(mk_AS`CasesStmtAltn(p_l, s, cid), selRes_v, succ_v, elseStmt, isLast) ==
  def mk_(samepatternIds, pid_m) = CGEXPR`SamePatternIds( p_l )
  in
    if samepatternIds
    then -- each pattern in the pattern list contains the same set of PatternId.
     (DS`RememberPid_m(pid_m);
      def decl = CGEXPR`DeclarePatterns( pid_m );
      in
       (dcl rb : seq of CPP`Stmt := [];
        if len p_l > 1
        then rb := rb ^ decl;
        for i = 1 to len p_l do
          def mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(p_l(i), selRes_v, {}, succ_v, nil, nil, false);
              pm1 = (if Is_Excl
                     then [BC`GenAsgnStmt(succ_v, BC`GenBoolLit(true))]
                     else []) ^ pm
          in
            if pm1 <> []
            then
              if i = 1
              then
                if len p_l > 1 
                then rb := rb ^ pm1
                else rb := rb ^ CGEXPR`MergeStmts( decl, pm1 )
              else rb := rb ^ [BC`GenIfStmt(BC`GenNot(succ_v), BC`GenBlock(pm1), nil)];
        def stmt = BC`GenBlock(GenStmt(s, isLast))
        in
         (DS`DeletePid_m();
          rb := rb ^ [ BC`GenIfStmt( succ_v, stmt, elseStmt) ]);
        return BC`GenBlock(rb)))
    else
     (dcl elseStmt1 : [CPP`Stmt] := elseStmt;
       for i = 0 to len p_l -1 do
         (if (i > 0) then CGAUX`PushEnv();
          let c_stmt = mk_AS`CasesStmtAltn([p_l(len p_l - i)], s, cid)
          in elseStmt1 := CGAltnStmt( c_stmt, selRes_v, succ_v, elseStmt1, isLast);
          if (i > 0) then CGAUX`PopEnv());
      return elseStmt1);
\end{vdm_al}

#ifdef VDMSL
\subsection{Identity Statement}

The identitity statement:
\begin{verbatim}
 skip
\end{verbatim}

is translated into an empty C++ expression statement.
#endif

#ifdef VDPP
\subsection{Identity and Delay Statements}

The identitity and delay statements:
\begin{verbatim}
 skip
 delay(20)
\end{verbatim}

are translated into an empty C++ expression statement.
#endif

\begin{vdm_al}
CGIdentStmt: () ==> seq of CPP`Stmt
CGIdentStmt() ==
return [BC`GenExpressionStmt(nil)];
\end{vdm_al}


\subsection{If Statement}

Consider the if statement below:


\begin{verbatim}
if b= 5
then a := 1
elseif c= 6
  then a := 2
  else a := 3;
\end{verbatim}

The {\em elseif then\/} branch can be omitted or it can be repeated
several times, furthermore, the last $else$ branch can contain a
$skip$ statement.

Consider the corresponding pseudo code of the VDM example below:

\begin{verbatim}
  Bool cond;
  ...CGExpr( "b=5", mk_CGMAIN`VT( cond, "Bool" );
  if ( cond.GetValue() )
     ...GenStmt( "a := 1" )
  else
     {
       ...CGExpr( "c=6", mk_CGMAIN`VT( cond, "Bool" ) )
       if ( cond.GetValue() )
          ...GenStmt( "a :=2 " )
       else
          ...GenStmt( "a :=3 " )
     }
\end{verbatim}



\begin{vdm_al}
CGIfStmt: AS`IfStmt * bool ==> seq of CPP`Stmt
CGIfStmt(mk_AS`IfStmt(test, cons, elif, altn,-), isLast) ==
  def condType = CGAUX`FindType( test );
      mk_(cond1_v, cond_stmt) = CGEXPR`CGExprExcl(test, "cond", nil);
      btype = mk_REP`BooleanTypeRep();
  in
   (dcl cond_v : CPP`Expr := cond1_v,
        rb : seq of CPP`Stmt := cond_stmt,
        tmpb : [seq of CPP`Stmt] ;
    if not CGAUX`IsBoolType(condType)
    then cond_v := DS`GenCastType(btype, cond1_v);
    if not CGAUX`IsBoolType(condType)
    then
      rb := rb ^ [ BC`GenIfStmt(BC`GenNot(DS`GenIsBool(cond1_v)), CGAUX`RunTime ("A boolean was expected"), nil) ];
    if altn = nil
    then
     (tmpb := nil;
      if isLast and not is_REP`UnitTypeRep(CGAUX`GiveCurrentRType())
      then
        (dcl lrb : [seq of CPP`Stmt] := [CGAUX`RunTime ("The operation did not return a value")];
         if CPP`isCPP()
         then lrb := lrb ^ [BC`GenGenericReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))]
         else lrb := lrb ^ [BC`GenReturnStmt(DS`GenEmptyValue(CGAUX`GiveCurrentRType()))];
         tmpb := lrb;))
    elseif is_AS`IdentStmt(altn)
    then tmpb := nil
    else tmpb := GenStmt( altn, isLast );
    for i = len elif to 1 by -1 do
      let mk_AS`ElseifStmt(elif_test, elif_cons, -) = elif(i)
      in
       (dcl body : seq of CPP`Stmt;
        def mk_(elif_cond1_v, elif_cond_stmt) = CGEXPR`CGExprExcl(elif_test, "cond", nil);
            elif_condType = CGAUX`FindType(elif_test);
        in
         (dcl elif_cond_v : CPP`Expr := elif_cond1_v;
          if not CGAUX`IsBoolType(elif_condType)
          then elif_cond_v := DS`GenCastType(btype, elif_cond1_v);

          body := elif_cond_stmt;
          if not CGAUX`IsBoolType(elif_condType)
          then
            body := body ^ [ BC`GenIfStmt(BC`GenNot(DS`GenIsBool(elif_cond1_v)),
                                                CGAUX`RunTime ("A boolean was expected"), nil) ];
          def elif_cons_stmt = def stmt = GenStmt(elif_cons, isLast)
                               in GenIfConsCPPStmt(stmt);
              elif_cons2_stmt = if tmpb = nil
                                then nil
                                else BC`GenBlock(tmpb);
              ifstmt = BC`GenIfStmt(DS`GenGetValue( elif_cond_v, btype ), elif_cons_stmt, elif_cons2_stmt);
              ifseq = if tmpb = nil
                      then BC`GenBlock([ifstmt])
                      else ifstmt
          in
            body := body ^ [ifseq];
          tmpb := body)
       );
    def cons_stmt = GenIfConsCPPStmt(GenStmt(cons, isLast))
    in
      rb := rb ^ [BC`GenIfStmt(DS`GenGetValue( cond_v, btype ), cons_stmt, if tmpb = nil
                                                                           then nil
                                                                           else CGAUX`GenCPPStmt( tmpb ))];
    return rb);
\end{vdm_al}

\begin{vdm_al}
GenIfConsCPPStmt: seq of CPP`Stmt ==> CPP`Stmt
GenIfConsCPPStmt(s_l) ==
--cases s_l:
--  [ mk_CPP`IfStmt(-,-,nil,-) ] -> return BC`GenBlock(s_l),
--  [ stmt ]                   -> return stmt,
--  others                     -> return BC`GenBlock(s_l)
--end;
  return BC`GenBlock(s_l);
\end{vdm_al}

\subsection{Specification and Topology Statements}

The operation $GenSpecTopStmt$ generates code corresponding to both
specification and topology statements. The resulting code will always
be a preprocessor on the following form:

\begin{quote}
{\tt \#include "vdm\_CLASS\_METHOD-NUMBER.cc"}
\end{quote}

There:

\begin{itemize}
\item {\tt CLASS} is the name of the class currently being code
  generated.
\item {\tt METHOD} is the name of the method currently being code
  generated.
\item {\tt NUMBER} is the specification / topology statement number in
  then current method. The specification / topology statements are
  numbered in the order in which they are defined in the method,
  starting at one.
\end{itemize}

\begin{vdm_al}
operations

  GenSpecTopStmt: AS`SpecificationStmt ==> seq of CPP`Stmt
  GenSpecTopStmt(-) ==
  if CPP`isCPP() then
    def mk_(mthd,num) = CGAUX`GiveCurMName();
        cls = CGAUX`GiveCurCName() in
      let numId = CGAUX`StringNumber(num) in
        return [BC`GenInclStmt(CGAUX`GenFileExt("vdm_"^cls^"_"^mthd^"-"^numId))]
  else
  ( CGAUX`SetNotSupportedException(true);
    return[CGAUX`NotSupported("specification statement")]);
\end{vdm_al}

\subsection{Exception Handling Statements}
\begin{vdm_al}
operations

CGAlwaysStmt : AS`AlwaysStmt * bool ==> seq of CPP`Stmt
CGAlwaysStmt(mk_AS`AlwaysStmt(Post,body,-), p_isLast) ==
  if CPP`isCPP()
  then
    def --tppost          = CGAUX`RemoveExitType(CI`GetTypeInfo(Post.cid));
        tpbody          = CGAUX`RemoveExitType(CI`GetTypeInfo(body.cid));
        l_excName       = BC`GiveName("exc");
        l_excValNm      = BC`GiveName("excVal");
        l_excRaisedNm   = BC`GiveName("exceptionRaised");
        l_excId         = BC`GenIdentifier("VDMSpecException");
        l_getMethod     = BC`GenFctCallObjMemAcc(l_excName, "getValue", []);
        l_excValAsgn    = BC`GenAsgnStmt(l_excValNm, l_getMethod);
        l_excRaisedAsgn = BC`GenAsgnStmt(l_excRaisedNm, BC`GenBoolLit(true));
        l_excType       = BC`GenTypeSpecifier(l_excId);
        l_exDecl        = BC`GenExceptionDeclaration([l_excType], l_excName);
        l_excObj        = BC`GenFctCall(l_excId, [l_excValNm]);
        l_excHandlerBlock = BC`GenBlock([l_excValAsgn, l_excRaisedAsgn]);

        l_retValNm      = BC`GiveName("retVal");
        l_retCalledNm   = BC`GiveName("returnCalled");
        l_retId         = BC`GenIdentifier("Common");
        l_retValAsgn    = BC`GenAsgnStmt(l_retValNm, l_excName);
        l_retCalledAsgn = BC`GenAsgnStmt(l_retCalledNm, BC`GenBoolLit(true));
        l_retType       = BC`GenTypeSpecifier(l_retId);
        l_rtDecl        = BC`GenExceptionDeclaration([l_retType], l_excName);
        handler_inner   = (if not CGAUX`NoReturnValue(tpbody)
                           then [l_retValAsgn]
                           else []) ^
                          (if not p_isLast and not is_REP`UnitTypeRep(tpbody)
                           then [l_retCalledAsgn]
                           else []);
        l_retHandlerBlock  = BC`GenBlock(handler_inner);
        handlers        = [BC`GenHandler(l_exDecl, l_excHandlerBlock)] ^
                          if is_REP`RetTypeRep(tpbody) or is_REP`UnitTypeRep(tpbody)
                          then [BC`GenHandler(mk_CPP`All(CI`NilContextId), l_retHandlerBlock)]
                          else [BC`GenHandler(l_rtDecl, l_retHandlerBlock)];
    in
     (dcl bodyStmt : seq of CPP`Stmt := [],
          handlerStmt : seq of CPP`Stmt := [],
          rb_l : seq of CPP`Stmt := [];
      CGAUX`UpAlwaysLevel();
      bodyStmt := GenStmt(body, p_isLast);
      CGAUX`DownAlwaysLevel();
      if is_AS`IdentStmt(Post)
      then handlerStmt := [BC`GenIfStmt(l_excRaisedNm, BC`GenExpressionStmt(BC`GenThrowExpression(l_excObj)), nil)]
      else handlerStmt := [BC`GenIfStmt(BC`GenBoolLit(true), BC`GenBlock(GenStmt(Post, false)), nil),
                           BC`GenIfStmt(l_excRaisedNm, BC`GenExpressionStmt(BC`GenThrowExpression(l_excObj)), nil)];
      if not is_REP`UnitTypeRep(tpbody)
      then
       (dcl stmt : CPP`Stmt;
        if CGAUX`IsInAlways()
        then
          if CGAUX`NoReturnValue(tpbody)
          then stmt := BC`GenExpressionStmt(BC`GenThrowExpression(BC`GenIntegerLit(0)))
          else stmt := BC`GenExpressionStmt(BC`GenThrowExpression(l_retValNm))
        else
          if CGAUX`NoReturnValue(tpbody)
          then stmt := BC`GenReturnStmt(nil)
          else stmt := BC`GenReturnStmt(l_retValNm);
        if (p_isLast)
        then handlerStmt := handlerStmt ^ [stmt]
        else handlerStmt := handlerStmt ^ [BC`GenIfStmt(l_retCalledNm, stmt, nil)]);

      rb_l := DS`GenDecl(nil, l_excValNm, nil);
      if not CGAUX`NoReturnValue(tpbody)
      then rb_l := rb_l ^ DS`GenDecl(nil, l_retValNm, nil);
      rb_l := rb_l ^ [BC`GenDecl(DS`GenSmallBoolType(), l_excRaisedNm, 
                           BC`GenAsgnInit(BC`GenBoolLit(false)))];
      if not p_isLast and not is_REP`UnitTypeRep(tpbody)
      then rb_l := rb_l ^ [BC`GenDecl(DS`GenSmallBoolType(), l_retCalledNm,
                           BC`GenAsgnInit(BC`GenBoolLit(false)))];
      rb_l := rb_l ^ [BC`GenTryBlock(bodyStmt, handlers, nil)] ^ handlerStmt;
      return rb_l;
     )
  else
    def handlerStmt = BC`GenBlock(GenStmt(Post, false));
        bodyStmt    = GenStmt(body, p_isLast)
    in
      cases bodyStmt:
        [mk_CPP`TryBlock(mk_CPP`CompoundStmt(stms,-),hdl,nil,-)] -> return [BC`GenTryBlock(stms, hdl, handlerStmt)],
        others                                                   -> return [BC`GenTryBlock(bodyStmt, [], handlerStmt)]
      end;

CGExitStmt : AS`ExitStmt ==> seq of CPP`Stmt
CGExitStmt(p_es) ==
 (dcl l_cppast : seq of CPP`Stmt := [],
      l_excArgs : seq of CPP`Expr := [];
  if p_es.expr <> nil
  then
    def mk_(l_exName, l_exStmts) = CGEXPR`CGExprExcl(p_es.expr, "exceptionValue", nil)
    in
     (l_cppast := l_exStmts;
      l_excArgs := [l_exName]);
  def id = BC`GenIdentifier("VDMSpecException");
      l_excCls = BC`GenTypeSpecifier(id);
  in
   (dcl l_excObj : CPP`Expr;
    if CPP`isCPP()
    then l_excObj := BC`GenFctCall(id, l_excArgs)
    else
      def l_cause = CGAUX`GetCause();
          l_excArgs' = if l_cause <> nil
                       then l_excArgs ^ [l_cause]
                       else l_excArgs
      in
        l_excObj := BC`GenNewExpr(l_excCls, l_excArgs');
    if CPP`isJAVA()
    then CGAUX`InsertImport("jp.vdmtools.VDM.VDMSpecException");
    return l_cppast ^ [ BC`GenExpressionStmt(BC`GenThrowExpression(l_excObj))]);
 );

--
-- tixe {
--   pat1 : t      |-> stmt1,
--   pat2 in set s |-> stmt1,
--   pat3          |-> stmt3
-- } in body
--
-- trap mk_(-,x) with exit x in
--   tixe {
--     mk_((is_(x, t)), pat1)  |-> trap x in exit mk_(true, x) in stmt1,
--     mk_((x in set s), pat2) |-> trap x in exit mk_(true, x) in stmt2,
--     mk_(-, pat3)            |-> trap x in exit mk_(true, x) in stmt3
--   } in trap x with exit mk_(true, x) in body
--

ConvertBind : AS`PatternBind * AS`Name * CPP`Expr ==> AS`Pattern * CGMAIN`VT
ConvertBind( match, name, l_excValNm ) ==
  cases match:
    mk_AS`TypeBind(-,-,-),
    mk_AS`SetBind(-,-,-) ->
      def bcid = CI`PushCGType( mk_REP`BooleanTypeRep() );
          scid = CI`PushCGType( mk_REP`ProductTypeRep( [mk_REP`BooleanTypeRep(), mk_REP`AllTypeRep()] ) );
          mk_( pat, cond ) = cases match:
                               mk_AS`TypeBind(p,tp,-) -> mk_(p, mk_AS`TypeJudgementExpr( name, tp, bcid )),
                               mk_AS`SetBind(p,Set,-) -> mk_(p, mk_AS`BinaryExpr( name, <INSET>, Set, bcid )),
                               others -> undefined
                             end;
          mval = mk_AS`MatchVal( cond, bcid );
          spat = mk_AS`TuplePattern( [ mval, pat ], scid );
      in
       (dcl fnm : CPP`Identifier;
        if CPP`isCPP()
        then fnm := BC`GenIdentifier("mk_")
        else fnm := BC`GenIdentifier("Tuple.mk_");
        def tpl = BC`GenFctCall(fnm, [ DS`GenBoolLit(true), l_excValNm ]);
            rtp = mk_REP`ProductTypeRep( [mk_REP`BooleanTypeRep(), mk_REP`AllTypeRep()] );
        in return mk_( spat, mk_CGMAIN`VT(tpl, rtp) )
       ),
    others -> return mk_(match, mk_CGMAIN`VT(l_excValNm, mk_REP`AllTypeRep()))
  end;

CGRecTrapStmt : AS`RecTrapStmt * bool ==> seq of CPP`Stmt
CGRecTrapStmt(mk_AS`RecTrapStmt(traps,body,-), p_isLast) ==
  def acid = CI`PushCGType( mk_REP`AllTypeRep() );
      l_excValAsNm  = mk_AS`Name([ "_excVal" ], acid);
      l_excValNm    = BC`Rename(l_excValAsNm);
      l_matchNm     = BC`GiveName("matched");
      l_excRaisedNm = BC`GiveName("exceptionRaised");
      l_bodyStmts   = GenStmt(body, p_isLast);
      l_traps       = [ GenRecTrapTrap(traps(i).trappost, false)
                      | i in set inds traps]
  in
   (dcl rb : seq of CPP`Stmt := [BC`GenAsgnStmt(l_matchNm, BC`GenBoolLit(false))],
        l_excVal : seq of CPP`Stmt;
    for l_idx = 1 to len traps do
      def mk_AS`Trap(l_pat,-,-) = traps(l_idx);
          mk_(pat, vt) = ConvertBind( l_pat, l_excValAsNm, l_excValNm );
          decls = CGEXPR`DeclarePatVars(pat); -- must be before CGPatternMatchExcl
          mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(pat, vt, {}, l_matchNm, nil, nil, false);
          inner_rb = decls ^ pm ^ (if Is_Excl
                                   then [BC`GenAsgnStmt(l_matchNm, BC`GenBoolLit(true))]
                                   else [])
                           ^ (if len l_traps(l_idx) = 1 and is_CPP`CompoundStmt(hd l_traps(l_idx))
                              then [BC`GenIfStmt(l_matchNm, hd l_traps(l_idx), nil)]
                              else [BC`GenIfStmt(l_matchNm, BC`GenBlock(l_traps(l_idx)), nil)]);
      in
        rb := rb ^ (if l_idx = 1
                    then inner_rb
                    else [BC`GenIfStmt(BC`GenNot(l_matchNm), BC`GenBlock(inner_rb), nil)]);-- end of for loop
    rb := rb ^ [BC`GenIfStmt(BC`GenNot(l_matchNm), BC`GenAsgnStmt(l_excRaisedNm, BC`GenBoolLit(false)), nil)];

#ifdef VDMSL
    l_excVal := DS`GenDecl(nil, l_excValNm, nil);
#endif VDMSL
#ifdef VDMPP
    if CPP`isCPP()
    then l_excVal := DS`GenDecl(nil, l_excValNm, nil)
    else l_excVal := DS`GenObjRefDecl(nil, l_excValNm, nil);
#endif VDMPP
    def l_match        = BC`GenDecl(DS`GenSmallBoolType(), l_matchNm, BC`GenAsgnInit(BC`GenBoolLit(true)));
        l_excRaised    = BC`GenDecl(DS`GenSmallBoolType(), l_excRaisedNm, BC`GenAsgnInit(BC`GenBoolLit(false)));
        l_handler      = GenRecTrapHandler(l_excValNm, l_excRaisedNm);
        l_finally      = GenRecTrapFinally(l_matchNm, l_excValNm, l_excRaisedNm, p_isLast);
        l_tryBlockBody = [BC`GenIfStmt(l_excRaisedNm, BC`GenBlock(rb), BC`GenBlock(l_bodyStmts))];
        l_tryBlock     = BC`GenTryBlock(l_tryBlockBody, [l_handler], l_finally);
        l_whileStmt    = BC`GenWhileStmt(BC`GenBoolLit(true), BC`GenBlock([l_tryBlock]))
    in
     (dcl cppast : seq of CPP`Stmt := l_excVal ^ [l_match, l_excRaised, l_whileStmt];
      return cppast);
  );

FlowBrokenSwitchLabels : [CPP`SwitchLabels] ==> bool
FlowBrokenSwitchLabels(lbls) ==
  if lbls = nil
  then return true
  else return FlowBrokenSwitchLabels(lbls.labels) and lbls.stmt.stmt <> nil => FlowBroken(lbls.stmt.stmt);

FlowBroken : CPP`Stmt ==> bool
FlowBroken(cppstmt) ==
  cases cppstmt:
    mk_CPP`LabelStmt(-, s,-)       -> FlowBroken(s),
    mk_CPP`ExpressionStmt(e,-)     -> return is_CPP`ThrowExpression(e),
    mk_CPP`CompoundStmt(stms,-)    -> FlowBroken(stms(len stms)),
    --mk_CPP`IfStmt(-, s1, s2,-)     -> return FlowBroken(s1) and FlowBroken(s2),
    mk_CPP`IfStmt(-, s1, s2,-)     -> if s2 = nil
                                      then return FlowBroken(s1)
                                      else return FlowBroken(s1) and FlowBroken(s2),
    mk_CPP`SwitchStmt(-, sb,-)     ->
      return
      ( forall gp in set elems sb.groups &
          FlowBrokenSwitchLabels(gp.labels) and
          gp.stmt <> nil => FlowBroken(gp.stmt)) and
      FlowBrokenSwitchLabels(sb.labels),
    mk_CPP`WhileStmt(-, s,-)       -> FlowBroken(s),
    mk_CPP`DoWhileStmt(s,-,-)      -> FlowBroken(s),
    mk_CPP`ForStmt(-,-,-,s,-)      -> FlowBroken(s),
    mk_CPP`Return(-,-)             -> return true,
    mk_CPP`SynchronizedStmt(-,s,-) -> FlowBroken(s),
    mk_CPP`TryBlock(s, hdls, -,-)  -> return
                                        FlowBroken(s) and
                                        forall hdl in set elems hdls &
                                          FlowBroken(hdl.stmt),
    others -> return false
  end;

operations

GenRecTrapTrap : AS`Stmt * bool ==> seq of CPP`Stmt
GenRecTrapTrap(p_stmts, -) ==
  def l_trap = GenStmt(p_stmts, false)
  in
    if not FlowBroken(l_trap(len l_trap))
    then return l_trap ^ [BC`GenBreakStmt(nil)]
    else return l_trap;

GenRecTrapHandler : CPP`Identifier * CPP`Identifier ==> CPP`Handler
GenRecTrapHandler(p_val, p_raised) ==
def l_excName       = BC`GiveName("exc");
    l_getMethod     = BC`GenFctCallObjMemAcc(l_excName, "getValue", []);
    l_excValAsgn    = BC`GenAsgnStmt(p_val, l_getMethod);
    l_excRaisedAsgn = BC`GenAsgnStmt(p_raised, BC`GenBoolLit(true));
    l_handlerBlock  = BC`GenBlock([l_excValAsgn, l_excRaisedAsgn, BC`GenContinueStmt(nil)]);
    l_excType       = BC`GenTypeSpecifier(BC`GenIdentifier("VDMSpecException"));
    l_exDecl        = BC`GenExceptionDeclaration([l_excType], l_excName)
in
  (if CPP`isJAVA()
   then CGAUX`InsertImport("jp.vdmtools.VDM.VDMSpecException");
   return BC`GenHandler(l_exDecl, l_handlerBlock));

GenRecTrapFinally : CPP`Identifier * CPP`Identifier * CPP`Identifier * bool ==> CPP`CompoundStmt
GenRecTrapFinally(p_matched, p_val, p_raised, p_isLast) ==
 (dcl l_excObj : CPP`Expr;
  if CPP`isCPP()
  then l_excObj := BC`GenFctCall(BC`GenIdentifier("VDMSpecException"), [p_val])
  else
    let l_excCls = BC`GenTypeSpecifier(BC`GenIdentifier("VDMSpecException"))
    in l_excObj := BC`GenNewExpr(l_excCls, [p_val]);
  def l_throwStmt = BC`GenExpressionStmt(BC`GenThrowExpression(l_excObj));
      l_innerTest = BC`GenNot(p_raised);
      l_outerTest = BC`GenNot(p_matched);
      l_innerIf = BC`GenIfStmt(l_innerTest, BC`GenBreakStmt(nil), nil);
      l_outerIf = BC`GenIfStmt(l_outerTest, BC`GenBlock([l_throwStmt]), nil)
  in
   (if CPP`isJAVA() then CGAUX`InsertImport("jp.vdmtools.VDM.VDMSpecException");
    return BC`GenBlock([l_outerIf] ^ (if p_isLast then [] else [l_innerIf])));
 );

--
-- trap p : t with stmt in body
-- trap x with cases mk_(true, x):
--               mk_((is_(x, t)), p) -> stmt,
--               others              -> exit x
--             end
--
-- trap p in set s with stmt in body
-- trap x with cases mk_(true, x):
--               mk_((x in set s), p) -> stmt,
--               others              -> exit x
--             end
--
ConvertHandler : AS`Bind * AS`Stmt ==> AS`PatternName * AS`CasesStmt
ConvertHandler(bind, stmt) ==
  def bcid = CI`PushCGType( mk_REP`BooleanTypeRep() );
      acid = CI`PushCGType( mk_REP`AllTypeRep() );
      scid = CI`PushCGType( mk_REP`ProductTypeRep( [mk_REP`BooleanTypeRep(), mk_REP`AllTypeRep()] ) );
      name = mk_AS`Name( ["_tmp"], acid );
      pnm  = mk_AS`PatternName( name, nil, acid );
      sel  = mk_AS`TupleConstructorExpr( [ mk_AS`BoolLit( true, bcid ), name ], scid );
      oths = mk_AS`ExitStmt( name, CI`NilContextId );
      mk_(pat,cond) = cases bind:
                        mk_AS`TypeBind(p,tp,-) -> mk_(p, mk_AS`TypeJudgementExpr( name, tp, bcid )),
                        mk_AS`SetBind(p,Set,-) -> mk_(p, mk_AS`BinaryExpr( name, <INSET>, Set, bcid )),
                        others                 -> undefined
                      end;
      mval = mk_AS`MatchVal( cond, bcid );
      spat = mk_AS`TuplePattern( [ mval, pat ], scid );
      altn = mk_AS`CasesStmtAltn( [ spat ], stmt, CI`NilContextId );
      cstm = mk_AS`CasesStmt( sel, [ altn ], oths, CI`NilContextId );
  in
    return mk_( pnm, cstm );

CGTrapStmt : AS`TrapStmt * bool ==> seq of CPP`Stmt
CGTrapStmt(mk_AS`TrapStmt(l_pat, l_handler, l_body, -), p_isLast) ==
 (dcl pat : AS`Pattern,
      handler : AS`Stmt;
  cases true:
    (is_AS`TypeBind(l_pat)),
    (is_AS`SetBind(l_pat))  -> def mk_(p,h) = ConvertHandler(l_pat, l_handler)
                               in
                                (pat := p;
                                 handler := h),
    others                  -> (pat := l_pat;
                                handler := l_handler)
  end;
  def l_excName   = BC`GiveName("exc");
      l_excValNm  = BC`GiveName("excVal");
      l_matchNm   = BC`GiveName("matched");
      l_getMethod = BC`GenFctCallObjMemAcc(l_excName, "getValue", []);
      l_excType   = BC`GenTypeSpecifier(BC`GenIdentifier("VDMSpecException"));
      decls       = CGEXPR`DeclarePatVars(pat); -- must be before CGPatternMatchExc
      vt          = mk_CGMAIN`VT(l_excValNm, mk_REP`AllTypeRep());
      mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(pat, vt, {}, l_matchNm, nil, nil, false);
      pm1         = if Is_Excl
                    then pm
                    else [BC`GenDecl(DS`GenSmallBoolType(), l_matchNm,
                                      BC`GenAsgnInit(BC`GenBoolLit(false)))] ^
                         pm ^
                         [BC`GenIfStmt(BC`GenNot(l_matchNm),
                     BC`GenBlock([BC`GenExpressionStmt(BC`GenThrowExpression(l_excName))]),
                                       nil)];
  in
   (dcl rb : seq of CPP`Stmt := DS`GenConstDeclInit(nil, l_excValNm, l_getMethod) ^
                                CGEXPR`MergeStmts( decls, pm1 ),
        exDecl : CPP`ExceptionDeclaration := BC`GenExceptionDeclaration([l_excType], l_excName);
#ifdef VDMSL
    rb := rb ^ GenStmt(handler, p_isLast);
#endif VDMSL
#ifdef VDMPP
    if CPP`isJAVA()
    then
     (dcl l_cause : CPP`Expr := l_excName,
          importNeeded : bool := true;
      cases l_pat:
        mk_AS`TypeBind(mk_AS`PatternName(nm,-,-),tp,-)
                  -> def l_patRepType = CGAUX`FromAS2RepType(tp);
                     in
                       cases l_patRepType:
                         mk_REP`ObjRefTypeRep(clnm) ->
                            def jexcnm = mk_AS`Name(["JDK_Exception"], CI`NilContextId);
                                jthrnm = mk_AS`Name(["JDK_Throwable"], CI`NilContextId);
                                super_s = elems CGAUX`GetOrderedSupers(clnm)
                            in
                              if clnm = jexcnm or jexcnm in set super_s or jthrnm in set super_s
                              then
                                def l_patCppType = TPGEN`Rep2CppTypeSpecifier(l_patRepType,tp)
                                in
                                 (dcl e : CPP`Expr;
                                  if nm = nil
                                  then e := BC`GiveName ("cause")
                                  else e := BC`Rename(nm);
                                  rb := [];
                                  exDecl := BC`GenExceptionDeclaration([l_patCppType], e);
                                  l_cause := e;
                                  importNeeded := false),
                         others -> skip
                      end,
        others -> skip
      end;
      if importNeeded
      then CGAUX`InsertImport("jp.vdmtools.VDM.VDMSpecException");
      CGAUX`PushCause(l_cause);
      rb := rb ^ GenStmt(handler, p_isLast);
      CGAUX`PopCause();
     )
    else rb := rb ^ GenStmt(handler, p_isLast);
#endif VDMPP

    def handlerBlock = BC`GenBlock(rb);
        bodyStmt     = GenStmt(l_body, p_isLast);
        handlers     = [BC`GenHandler(exDecl, handlerBlock)]
    in
      return [BC`GenTryBlock(bodyStmt, handlers, nil)]
   );
 );

\end{vdm_al}

\subsection{Error Statement}

The code corresponding to an error statement simply causes a
run-time error:

\begin{verbatim}
RunTimeError("Can not evaluate 'error' statement")
\end{verbatim}

The operation $CGErrorStmt$ generates the code corresponding to an
undefined expression.

\begin{vdm_al}
operations

CGErrorStmt: () ==> seq of CPP`Stmt
CGErrorStmt() ==
  def r_tp = CGAUX`GiveCurrentRType();
      rti  = CGAUX`RunTime("Can not evaluate 'error' statement");
  in
   (dcl r_stmt : CPP`Stmt;
    if CPP`isCPP()
    then r_stmt := BC`GenGenericReturnStmt(DS`GenEmptyValue(r_tp))
    else r_stmt := BC`GenReturnStmt(DS`GenEmptyValue(r_tp));
    return [ rti, r_stmt ];
   );
\end{vdm_al}

\begin{vdm_al}
#ifdef VDMPP
operations
GenInvCall : AS`Name * bool ==> CPP`Stmt
GenInvCall(nm, stat) ==
  def invname = BC`Rename(mu(nm, ids |-> ["inv_" ^ hd nm.ids]))
  in
   (dcl invref : CPP`Expr;
    if stat
    then invref := BC`GenFctCall(invname, [])
    elseif CPP`isCPP()
    then invref := BC`GenFctCallPtrToObjMemAcc(DS`GenThis(), invname, [])
    else invref := BC`GenFctCall(BC`GenObjectMemberAccess(DS`GenThis(), invname), []);
    return BC`GenIfStmt(BC`GenNot(DS`GenGetValue(invref,mk_REP`BooleanTypeRep())),
                        CGAUX`RunTime("Instance invariant failure in " ^ hd nm.ids), nil);
   );
#endif VDMPP
end CGSTMT
\end{vdm_al}

\subsection{Test Coverage}

\begin{rtinfo}[CGIndexedForLoopStmt]
{rtinfo.ast}[CGSTMT]
\end{rtinfo}



