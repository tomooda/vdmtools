\begin{vdm_al}
class StatusInfo is subclass of ToolColleague

instance variables
  rep : Repository;
  repdb : RepDatabase

 -- Note: rep not used in this version
\end{vdm_al}
Note: $rep$ is not used in this version
\begin{vdm_al}

operations

public Init: Repository * RepDatabase * ToolMediator ==> ()
  Init (r, db, m) ==
  ( rep := r;
    repdb := db;
    mediator := m
  );

  ---
  --- Methods handling status and values (asts)
  --- 
\end{vdm_al}

\paragraph{Methods handling status and values (asts)}
\mbox { }

\begin{vdm_al}

public Allowed: (ModuleName | FileName) * Action ==> bool * seq of char 
  Allowed (nm, kind)  ==
    def ok = repdb.nameIsDefined(nm)
    in
      cases true:
        (is_FileName (nm))  -> if ok
                               then def stallow = repdb.FileStatusAllowed(nm, kind)
                                    in return mk_(stallow,"")
                               elseif kind = <SYNTAXCHECK>
                               then return mk_(true, "")
                               else return mk_(false, "File " ^ nm.nm ^ " not defined"),
        (is_ModuleName(nm)) -> if ok
                               then def unallow = repdb.UnitStatusAllowed (nm, kind)
                                    in return mk_(unallow,"")
                               else return mk_(false, "Name " ^ nm.nm ^ " not defined"),
        others              -> return mk_(false, "Name not FileName or ModuleName")
      end;

\end{vdm_al}

$Allowed$ returns with a tuple consisting of a boolean value and a
message in a sequence of char. If the boolean value is $true$, the
action is allowed. If the value is $false$, the returned sequence of
char can be empty or not empty. If empty this means that the action is
not allowed. If not empty this indicates that an error has occured and
the string contains a message about this. This will happen if
$Allowed$ is called with an unknown name. However, syntax check is
always allowed, also for filenames not in repository.  The returned
sequence of char is generated by the call to $NameIsDefined$.

\begin{vdm_al}-- Status returns a tuple consisting of status for the module
-- and status for the corresponding file. If called with a filename
-- the status for module is nil. Run-time error if called with an 
-- unknown name.

  --- If called with a module name a set of file names is created consisting of the
  --- names of the files the module is defined in. This is a generel solution - in
  --- case of a structured specification the set will only hold one element and in
  --- case of a flat specification there can be more than one element. The file status
  --- of a module is then computed as the most fundamental status of all involved
  --- files. 

public Status: ModuleName | FileName ==>  [UnitStat] * FileStat 
  Status (nm)  ==
    def ok = repdb.nameIsDefined(nm)
    in
      cases true:
        (is_ModuleName(nm) and ok) -> def us : UnitStat = repdb.GetUnitStat (nm);
                                          st_s : set of FileStat = repdb.GetFileStatSet(nm)
                                      in
                                       ( dcl sc_s : set of Status := {},
                                             pp_s : set of Status := {};
                                         for all mk_FileStat(sc,pp) in set st_s do
                                          (sc_s := sc_s union { sc };
                                           pp_s := pp_s union { pp }
                                          );
                                         let sum_sc = StatusPrio(sc_s) in
                                         let sum_pp = if sum_sc = <OK>
                                                      then StatusPrio(pp_s)
                                                      else <NONE>
                                         in
                                           return mk_(us, mk_FileStat(sum_sc, sum_pp))
                                       ),
        (is_FileName(nm) and ok)   -> def fs : FileStat = repdb.GetFileStat(nm)
                                      in
                                        return mk_(nil,fs),
        others                     -> return mk_(nil, mk_FileStat(<ERROR>,<NONE>))
      end;

\end{vdm_al}
$Status$ returns a tuple consisting of status for the module
and status for the corresponding file. If called with a filename
the status for module is nil. Run-time error if called with an 
unknown name.

If called with a module name a set of file names is created consisting of the
names of the files the module is defined in. This is a generel solution - in
case of a structured specification the set will only hold one element and in
case of a flat specification there can be more than one element. The file status
of a module is then computed as the most fundamental status of all involved
files. 

\begin{vdm_al}

functions

  StatusPrio: set of Status -> Status
  StatusPrio(st_s) ==
    if <NONE> in set st_s
    then <NONE>
    elseif <ERROR> in set st_s
    then <ERROR>
    else <OK>;
  
\end{vdm_al}

\begin{vdm_al}

operations

public IsAllTypeCorrect: () ==>  bool 
  IsAllTypeCorrect ()  ==
--   (def module_s = repdb.AllModules() in
--    for all m in set module_s do
----      def mk_( mk_UnitStat(tc,-,-),-) = self.Status (m) in
--      def mk_UnitStat(tc,-,-) = repdb.GetUnitStat(m) in
--      if not (tc = <OK> or tc = <POS> or tc = <DEF>)
--      then return false;
--    return true);
   (def module_s = repdb.AllModules() in
      return forall m in set module_s & let mk_UnitStat(tc,-,-) = repdb.GetUnitStat(m)
                                        in (tc = <OK> or tc = <POS> or tc = <DEF>));

public IsSyntaxCorrect: FileName ==> bool
  IsSyntaxCorrect(nm) ==
    if repdb.nameIsDefined(nm)
    then
      let mk_FileStat(syntax,-) = repdb.GetFileStat(nm)
      in
        return syntax = <OK>
    else return false;

end StatusInfo
\end{vdm_al}
