%--------------------------------------------------------------------------------
% WHAT
%    Environment manipulating operations for the Static Semantics of VDM++
% $Id: env.vdm,v 1.153 2006/03/15 07:53:32 vdmtools Exp $
% Implemented in: env.cc
%--------------------------------------------------------------------------------

\section{Environment}

This section contains the environment module which
is responsible for maintaining the
state of the static semantics (except for the error messages).
It mainly consists of operations to lookup identifiers, scope
manipulating operations, and operations which expand the
definitions to initialize the state.
The interface of the ENV module can be seen from figure~\ref{env}.

The ENV module exports its
constructs to all the other modules from level 1 to 3 in the
hierarchy. ENV only imports constructs from the VCM module which
is not considered to belong to the hierarchy at all.

%\insertfig{env.ps}{13cm}{Interface for the ENV module}{\label{env}}

\begin{vdm_al}
module ENV

imports

  from AS all,
#ifdef VDMPP
  from MANGLE all,
#endif VDMPP
  from CI all,
  from UTIL all,

  from REP all,

  from ERR all,
  from TYPE
#ifdef VDMPP
    operations
    IsOverlapping : REP`TypeRep * REP`TypeRep * set of (REP`TypeNameRep * REP`TypeNameRep) ==> bool;
    IsSubType : REP`TypeRep * REP`TypeRep * set of (REP`TypeNameRep * REP`TypeNameRep) ==> bool;
    IsCompatible: TYPE`Ind * REP`TypeRep * REP`TypeRep ==> bool;
    IsEquivalent: TYPE`Ind * REP`TypeRep * REP`TypeRep ==> bool
#endif VDMPP
    types Ind = <POS> | <DEF>,

  from AUX functions
#ifdef VDMSL
    InstFn: (<VAR> | <PAR> | <REN>) * REP`TypeRep * map AS`Name to REP`TypeRep -> REP`TypeRep;
    InstFnAS: (AS`Type | AS`TypeDef) * map AS`Name to AS`Type -> (AS`Type | AS`TypeDef);
    RenameTag : REP`TypeRep * map AS`Name to AS`Name -> REP`TypeRep;
    TypeUsedImplicitly: AS`Name * set of REP`TypeRep -> bool;
#endif VDMSL
    MakePreType : REP`FnTypeRep -> REP`FnTypeRep;
    MakePostType : REP`FnTypeRep -> REP`FnTypeRep;
    MakePolyPreType : seq of REP`TypeVarRep * REP`FnTypeRep -> seq of REP`TypeVarRep * REP`FnTypeRep;
    MakePolyPostType : seq of REP`TypeVarRep * REP`FnTypeRep -> seq of REP`TypeVarRep * REP`FnTypeRep;
    MakeOpPreType : [AS`Name] * REP`OpTypeRep * [AS`StateDef] -> REP`TypeRep;
    MakeOpPostType : [AS`Name] * REP`OpTypeRep * [AS`StateDef] -> REP`TypeRep;
    ExtName : AS`Name * AS`Name -> AS`Name;
    IsPrePostFn: AS`Name -> bool;
    Pre: AS`Name -> AS`Name;
    Post: AS`Name -> AS`Name;
    Inv: AS`Name -> AS`Name;
#ifdef VDMPP
    QualifyTypeNames: REP`TypeRep * AS`Name -> REP`TypeRep;
#endif VDMPP
#ifdef VDMSL
    Init: AS`Name -> AS`Name;
#endif VDMSL
    ReservedPrefix : AS`Name -> bool,

  from EXPR operations
#ifdef VDMPP
    CheckOverloadedApply : TYPE`Ind
                         * (set of REP`FnTypeRep | set of REP`OpTypeRep)
                         *  seq of REP`TypeRep
                         * (AS`Expr | AS`StateDesignator)
                         * bool
                         * bool
                       ==> bool * REP`TypeRep;
#endif VDMPP
    wf_Expr : TYPE`Ind * AS`Expr * REP`TypeRep ==> bool * REP`TypeRep,

  from DEF operations
#ifdef VDMSL
    wf_TypeDefs : TYPE`Ind * map AS`Name to AS`TypeDef ==> bool;
#endif VDMSL
    wf_Type: TYPE`Ind * AS`Type ==> bool,

  from PAT operations
    wf_Pattern: TYPE`Ind * AS`Pattern * REP`TypeRep ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    wf_PatternBind: TYPE`Ind * AS`PatternBind * REP`TypeRep ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    Pattern2TypeRep : AS`Pattern ==> REP`TypeRep
    functions
    ExtractPatternName: AS`Pattern -> map AS`Name to nat1,

  from VCM operations
#ifdef VDMPP
    GetClassTypeRep : AS`Name ==> [ParseTypeInfo];
    UpdateValuesInParseEnv: AS`Name * map AS`Name to REP`TypeRep ==> ();
    GetTypes: () ==> set of AS`Name;
    IsClassName: AS`Name ==> bool
  functions
    MakeTpRng : REP`TypeRep * AS`Access * bool +> ENV`AccessTypeRep
#endif VDMPP
#ifdef VDMSL
  GetModuleRep : AS`Name ==> bool * VCM`ExpSigRep
  types
  ExpSigRep:: tps  : map AS`Name to REP`TypeRep
              val  : map AS`Name to REP`TypeRep
              fns  : map AS`Name to REP`FnTypeRep
              polys: map AS`Name to REP`PolyTypeRep
              ops  : map AS`Name to REP`OpTypeRep
              tag : map AS`Name to seq of REP`FieldRep
              fcts: map AS`Name to AS`FnDef
#endif VDMSL

exports
  types
  struct FunctionInfo;
#ifdef VDMPP
  struct AccessType;
  struct AccessTypeRep;
  struct AccessFnTypeRep;
  struct AccessPolyTypeRep;
  struct AccessOpTypeRep;
  struct AccessFieldRep;
  struct ParseTypeInfo;
  struct TagRepElem
#endif VDMPP
  operations
  EnterScope : map AS`Name to (REP`TypeRep * nat1) ==> ();
  LeaveScope : () ==> ();
  UpdateScope : map AS`Name to (REP`TypeRep * nat1) ==> ();
  EnterLocalScope : map AS`Name to (REP`TypeRep * nat1) ==> ();
  LeaveLocalScope : () ==> ();
  UpdateLocalScope : map AS`Name to (REP`TypeRep * nat1) ==> ();
#ifdef VDMPP
  CheckThreadInherit: AS`Name ==> bool;
  LookUpTypeInSuper: AS`Name * AS`Name ==> [AS`Name];
  SetDefClass: AS`Name ==> ();
  UnSetDefClass: () ==> ();
  LookUpDefClassForTypeName : AS`Name ==> [AS`Name];
  LookUpDefClass : () ==> [AS`Name];
  LookUpClass: AS`Name ==> ParseTypeInfo;
  SetCurClass: AS`Name ==> ();
  TransClos: AS`Name ==> set of AS`Name;
  IsLocalSuperSuper : AS`Name ==> bool;
  IsAccessible: AS`Name * AccessType ==> bool;
  IsAccessibleCurClass : AccessType ==> bool;
  CheckTypeAccess: AS`Name * AS`Type ==> bool;
  CheckTypeListAccess: AS`Name * seq of AS`Type ==> bool;
  CheckInstAccess: AS`Access * AS`Name ==> bool;
  CheckDefAccess: AccessType * AS`Name ==> bool;
  CheckTypeDefAccess: AS`Access * AS`Name ==> bool;
  LookUpOpOrFnName: [AS`Name] * AS`Name ==> [REP`TypeRep | set of REP`TypeRep];
  ExpandClassName: AS`Name * set of AS`Name ==> bool * AS`Name;
  IsInstanceVar: AS`Name ==> bool;
  IsStaticInstanceVar: AS`Name ==> bool;
  LookUpInstanceVar: AS`Name ==> [REP`TypeRep];
#endif VDMPP
  setRecMap : map AS`Name to FunctionInfo ==> ();
  getRecMap : () ==> map AS`Name to FunctionInfo;

#ifdef VICE
NotStaticOk:() ==> ();
StaticRequired:() ==> ();
#endif VICE

  CheckTypeVar: REP`TypeVarRep ==> bool;
  UsedStateIds: set of AS`Name ==> set of AS`Name;

#ifdef VDMSL
  LookUp: AS`Name * bool ==> [REP`TypeRep];
  LookUpTag : TYPE`Ind * AS`Name * set of AS`Name ==> [AS`Name * seq of REP`FieldRep];
  LookUpPolyFn: AS`Name ==> [seq of REP`TypeVarRep * REP`FnTypeRep];
  LookUpTypeName : AS`Name ==> [REP`TypeRep];
  LookUpState: AS`Name * bool * (<OLD> | <CUR>) ==> [REP`TypeRep];
  ExpandModule: TYPE`Ind * (AS`Module|AS`DLModule) ==> bool;
  ExpandDLModule: TYPE`Ind * AS`DLModule ==> bool;
  SetCurMod: AS`Name ==> ();
  GetCurMod: () ==> AS`Name;
  LeaveCurModule: AS`Name * [AS`ExportSig] ==> ();
  PushContext: <PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE> ==> ();
  GetContext: () ==> <PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE>;
  LookUpStateEnv: AS`Name ==> [REP`TypeRep];
  PublicLookUpTypeName : AS`Name * AS`Name ==> [REP`TypeRep];
#endif VDMSL

#ifdef VDMPP
  LookUp: AS`Name * bool ==> [REP`TypeRep|AccessType|
                              set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)|
                              set of REP`TypeRep];
  LookUpTag : TYPE`Ind * AS`Name * set of AS`Name ==> [AS`Name * (AccessFieldRep|TagRepElem)];
  LookUpTypeName : AS`Name * bool ==> [REP`TypeRep | AccessType];
  LookUpOperationName : [AS`Name] * AS`Name * [AS`Expr] ==> set of AccessType;
  LookUpInObject: AS`Name * AS`Name * bool * bool
                  ==> [AccessType | set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)];
  LookUpState: AS`Name * bool * (<OLD> | <CUR>) ==> [REP`TypeRep|AccessType];
  ExpandClass: TYPE`Ind * AS`Class ==> bool;
  CheckClassName: AS`Name ==> bool;
  CheckTraceName: AS`Name ==> bool;
  HasThread: AS`Name ==> bool;
  ExpandInstanceVars : seq of AS`InstanceVarDef ==> bool;-- Only in VDM++
  IsSubClass: AS`Name * AS`Name ==> bool; -- only in VDM++
  GetCurClass : () ==> AS`Name; -- only in VDM++
  PushContext: <PURE>|<IMPL>|<ALL>|<PRE>|<POST>|<PUREOP>|<VALUE>|<PERM>|<PTHREAD> ==> ();
  GetContext: () ==> <PURE>|<IMPL>|<ALL>|<PRE>|<POST>|<PUREOP>|<VALUE>|<PERM>|<PTHREAD>;
  CheckAccess: AS`Name * [AccessType|REP`TypeRep|TagRepElem|
                          set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep) |
                          set of REP`TypeRep ]
               ==> [REP`TypeRep |
                   TagRepElem  |
                   set of (REP`FnTypeRep | REP`OpTypeRep  | REP`PolyTypeRep)];
  DefaultConstructorAccessible : AS`Name ==> bool;
  ConstructorExists : TYPE`Ind * AS`Name * seq of REP`TypeRep * AS`Expr
                      ==> bool;
  CheckParmsInHierarchy: AS`Name * seq of REP`TypeRep * AS`Access *
                         bool ==> bool;
  CheckSubRespIsImplemented: TYPE`Ind * AS`Name ==> bool;
  SetStatic : bool ==> ();
  UnsetStatic : () ==> ();
  GetStatic : () ==> bool;
  NormaliseTypeName: REP`TypeRep ==> REP`TypeRep;
  PublicLookUpTypeName : AS`Name * AS`Name ==> [REP`TypeRep|AccessType] * [AS`Name];
  HasInstInv: AS`Name ==> bool;
#endif VDMPP

  ExtractPatterns: TYPE`Ind * seq of (AS`ValueDef | AS`FnDef) ==> bool * map AS`Name to (REP`TypeRep * bool);
  wf_ValueDef : TYPE`Ind * AS`ValueDef ==> bool * map AS`Name to (REP`TypeRep * nat1);
  ExpandTypes : AS`Name * map AS`Name to AS`TypeDef ==> bool;
  CheckTag: AS`Name ==> bool;
  CheckTypeName: AS`Name ==> bool;
  CheckOperationName: AS`Name ==> bool;
  GetCurModOrNil: () ==> [AS`Name];
  InitEnv: () ==> ();
  PushTypeVarContext: seq of REP`TypeVarRep ==> ();
  PopTypeVarContext: () ==> ();
  PopContext: () ==> ();
  SetExtAll: set of AS`Name ==> bool;
  SetExt: seq of AS`ExtInf * set of AS`Name ==> bool;
  TransType: [AS`Name] * AS`Type ==> REP`TypeRep;
  MarkUsedType: AS`Type ==> ();
  TransTypeDef: [AS`Name] * AS`Name * AS`Type * [AS`Invariant] ==> REP`TypeRep;
  TransTypeList: [AS`Name] * seq of AS`Type ==> seq of REP`TypeRep;
#ifdef VDMPP
  GetOperationSignature : AS`OpDef ==> (seq of REP`TypeRep) * REP`TypeRep;
  GetFunctionSignature : AS`FnDef ==> (seq of REP`TypeRep) * REP`TypeRep;
  CheckAccessCurClass : [ AccessType  |
                          REP`TypeRep |
                          TagRepElem  |
                          set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep) |
                          set of REP`TypeRep]
                     ==> [ REP`TypeRep |
                          TagRepElem  |
                          set of (REP`FnTypeRep | REP`OpTypeRep | REP`PolyTypeRep) ];
#endif VDMPP
  ExtractValueBindings : seq of AS`NameType ==> map AS`Name to (REP`TypeRep * nat1)

  functions
  GetMethDom : (REP`OpTypeRep | REP`FnTypeRep) -> seq of REP`TypeRep;
  TransFields : [AS`Name] * seq of AS`Field -> seq of REP`FieldRep;
#ifdef VDMSL
  TransStateType : [AS`Name] * AS`StateDef -> REP`TypeRep;
#endif VDMSL
#ifdef VDMPP
  IsAccessType: [AccessType|REP`TypeRep|TagRepElem|
                 set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)|
                 set of (REP`FnTypeRep | REP`OpTypeRep)] -> bool;
  StripAccessType: [AccessType|REP`TypeRep|TagRepElem] -> [REP`TypeRep|seq of REP`FieldRep];
#endif VDMPP
  PrintName : AS`Name -> seq of char;
  ConstructImplParms : AS`ParameterTypes -> seq of AS`Pattern;
  ConstructImplDomType : AS`ParameterTypes -> seq of AS`Type;
  ConstructImplRngType : seq of AS`NameType -> AS`Type

definitions

  types

    TypeRepEnv     = map AS`Name to TypeRepElem;

    TypeRepElem :: tp : REP`TypeRep
                   used : bool
                   stat : bool;

    OpTypeRepEnv   = map AS`Name to OpTypeRepElem;

    OpTypeRepElem :: tp : REP`TypeRep
                     used : bool
                     stat : bool
                     oppure : bool;

    PolyTypeRepEnv = map AS`Name to PolyTypeRepElem;

    PolyTypeRepElem :: poly : seq of REP`TypeVarRep
                       tp : REP`TypeRep
                       used : bool;

    TagRepElem     = seq of REP`FieldRep ;

    TagRepEnv      = map AS`Name to TagRepElem;

       --AUGUSTO--
  FunctionInfo ::
    rec   : set of AS`Name
    meas  : [AS`Name]
    printPO: bool;
  --AUGUSTO--

#ifdef VDMPP

    AccessType = AccessTypeRep | AccessFnTypeRep  | AccessPolyTypeRep | AccessOpTypeRep | AccessFieldRep;

    AccessTypeRep :: tp : REP`TypeRep
                     a  : AS`Access
                     stat : bool;

    AccessFnTypeRep :: tp : REP`FnTypeRep
                       a  : AS`Access
                       stat : bool;

    AccessPolyTypeRep :: tp : REP`PolyTypeRep
                         a  : AS`Access
                         stat : bool;

    AccessOpTypeRep :: tp : REP`OpTypeRep
                       a  : AS`Access
                       stat : bool
                       oppure : bool;

    AccessFieldRep :: tp : seq of REP`FieldRep
                      a  : AS`Access;

    ParseTypeInfo  :: nm    : AS`Name
                      sys   : bool
                      super : set of AS`Name
                      tps   : map AS`Name to AccessTypeRep
                      vals  : map AS`Name to AccessTypeRep
                      insts : map AS`Name to AccessTypeRep
                      fcts  : map AS`Name to AccessFnTypeRep
                      polys : map AS`Name to AccessPolyTypeRep
                      ops   : map AS`Name to AccessOpTypeRep
                      tags  : map AS`Name to AccessFieldRep
                      overloaded : map AS`Name to set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)
                      thread  : <NONE> | <PER> | <DECL>
                      constructors : set of AccessOpTypeRep
                      fndefs : map AS`Name to AS`FnDef
                      subresps : map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                    set of (ENV`AccessOpTypeRep | ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep))
                      instinv : bool;
#endif VDMPP

\end{vdm_al}


The environment defined in the state is structured by the three
environment types {\it SimpleTypeEnv}, {\it TypeRepEnv}, and {\it TagRepEnv}
which contains the field names for all composite types.



\begin{vdm_al}
  state TypeCheckVals of
#ifdef VICE
   staticrequired : bool                   -- special use for setPriority
#endif VICE
    ValueIds      : set of AS`Name         -- global value identifiers
#ifdef VDMSL
    WhereAmI      : seq of (<PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE>)
#endif VDMSL
#ifdef VDMPP
    WhereAmI      : seq of (<PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE>|<PERM>|<PTHREAD>)
#endif VDMPP
    ExtEnv        : map AS`Name to AS`Mode -- ext info for spec stmt's
    TypeEnv       : TypeRepEnv             -- Typenames
#ifdef VDMSL
    InsideInter   : bool                   -- Checking inside the interface
    RenamedTypes  : map AS`Name to AS`Name -- Renamed types in current module
    TypeParEnv    : map AS`Name to REP`TypeRep -- instantiated type vars
                                           -- at the module level
#endif VDMSL
    TypeVars      : seq of set of REP`TypeVarRep  -- Type variables legal in type defs
    TagEnv        : TagRepEnv              -- Tagged types
#ifdef VDMSL
    LocTagEnv     : TagRepEnv              -- Local Tags for imported
                                           -- type definitions
#endif VDMSL
    ConstEnv      : TypeRepEnv             -- Value ident's in entity
    StateEnv      : TypeRepEnv             -- State ident's in entity
    LocalEnv      : seq of map AS`Name to (REP`TypeRep * nat1)
                                           -- Local dcl variables
    FunctionEnv   : TypeRepEnv             -- fnsig
    PolyEnv       : PolyTypeRepEnv         -- polymorphic functions
    --OperationEnv  : TypeRepEnv             -- opsig
    OperationEnv  : OpTypeRepEnv             -- opsig
#ifdef VDMPP
    OverloadedEnv : map AS`Name to set of TypeRepElem
    SubrespsEnv   : map AS`Name to ((map AS`Name to (ENV`AccessFnTypeRep |
                                                    ENV`AccessPolyTypeRep |
                                                    ENV`AccessOpTypeRep |
                                                    set of (ENV`AccessOpTypeRep |
                                                            ENV`AccessPolyTypeRep |
                                                            ENV`AccessFnTypeRep))) *
                                    (map AS`Name to (ENV`AccessFnTypeRep |
                                                    ENV`AccessPolyTypeRep |
                                                    ENV`AccessOpTypeRep |
                                                    set of (ENV`AccessOpTypeRep |
                                                            ENV`AccessPolyTypeRep |
                                                            ENV`AccessFnTypeRep))))
#endif VDMPP
#ifdef VDMSL
    Renamed       : set of AS`Name         -- all renamed identifiers
    CheckModule   : [AS`Name]              -- current module (only in VDM-SL)
#endif VDMSL
    UsedName      : set of AS`Name         -- keep track of used nm's
    SEnv          : seq of TypeRepEnv      -- used for the analysis process
#ifdef VDMPP
    CheckClass    : [AS`Name]              -- current class (only in VDM++)
    Super         : set of AS`Name         -- current super classes (VDM++)
    SuperSuper    : set of AS`Name         -- all current super classes (VDM++)
    TraceEnv      : set of AS`Name         -- contains all traceid's for
                                           -- current class
    CurrentMethod : [AS`Name]              -- method currently checked
    FoundClass    : [AS`Name]
    DefiningClass : seq of AS`Name         -- Stack of Classes defining the name
                                           -- being looked up
    isStatic      : bool                   -- current env corresponds to
                                           -- a static class member
#endif VDMPP
    RecMap        : map AS`Name to FunctionInfo -- AUGUSTO

    init s
         == s =
             mk_TypeCheckVals(
#ifdef VICE
                           true,
#endif VICE
                           {},    -- ValueIds
                           [<PURE>], -- WhereAmI
                           {|->}, -- ExtEnv
                           {|->}, -- TypeEnv
#ifdef VDMSL
                           false, -- InsideInter
                           {|->}, -- RenamedTypes
                           {|->}, -- TypeParEnv
#endif VDMSL
                           [],    -- TypeVars
                           {|->}, -- TagEnv
#ifdef VDMSL
                           {|->}, -- LocTagEnv
#endif VDMSL
                           {|->}, -- ConstEnv
                           {|->}, -- StateEnv
                           [],    -- LocalEnv
                           {|->}, -- FunctionEnv
                           {|->}, -- PolyEnv
                           {|->}, -- OperationEnv
#ifdef VDMPP
                           {|->}, -- OverloadEnv
                           {|->}, -- SubrespsEnv
#endif VDMPP
#ifdef VDMSL
                           {},    -- Renamed
                           nil,   -- CheckModule (only VDM-SL)
#endif VDMSL
                           {},    -- UsedName
                           [],    -- SEnv
#ifdef VDMPP
                           nil,   -- CheckClass (only VDM++)
                           {},    -- Super classes (VDM++)
                           {},    -- All Super classes (VDM++)
                           {},    -- TraceEnv
                           nil,   -- current method
                           nil,   -- FoundClass
                           [],    -- DefiningClass
                           false,
#endif VDMPP
                           {|->}  -- RecMap AUGUSTO
                           )
  end
\end{vdm_al}


The state contains the environments which will be build up during the
evaluation of the static semantics functions.

\begin{description}
\item[{\it TypeEnv}] is the global type environment for all user
defined types.
\item[{\it TagEnv}] contains the filed names for all composite types.
\item[{\it ConstEnv}] contains the types for all global constant definitions.
\item[{\it StateEnv}] contains the types for all global
 state definitions. (instance variables in VDM++).
\item[{\it LocalEnv}] contains the types for all local state
 (dcl) definitions.
\item[{\it FunctionEnv}] contains all function types (function signatures).
\item[{\it OperationEnv}] contains all operation types
(operation signatures). (only in VDM-SL)
\item[{\it UsedName}] contains all the identifiers which have already
been defined once at the global scope level.
\item[{\it SEnv}] is a stack (corresponding to the scope) of the types
inferred for all locally defined identifiers.
\end{description}

\subsection{Scope Manipulation}

\begin{vdm_al}

  operations
  -- AUGUSTO --
  setRecMap :  map AS`Name to FunctionInfo ==> ()
  setRecMap(rmap) ==
    RecMap := rmap;

  getRecMap : () ==>  map AS`Name to FunctionInfo
  getRecMap() ==
    return RecMap;

    EnterScope : map AS`Name to (REP`TypeRep * nat1) ==> ()
    EnterScope (Bindings) ==
      --SEnv := [{nm |-> mk_TypeRepElem(Bindings(nm).#1, false, false) | nm in set dom Bindings }] ^ SEnv ;
      SEnv := [{nm |-> mk_TypeRepElem(Bindings(nm).#1, Bindings(nm).#2 > 1, false) | nm in set dom Bindings }] ^ SEnv ;

    UpdateScope : map AS`Name to (REP`TypeRep  * nat1) ==> ()
    UpdateScope (Bindings) ==
      SEnv := [hd SEnv ++ {nm |-> mk_TypeRepElem(Bindings(nm).#1,
                                                 if nm in set dom hd SEnv
                                                 then ((hd SEnv)(nm)).used
                                                 else false,
                                                 false)
                          | nm in set dom Bindings }]
              ^ tl SEnv ;

    LeaveScope : () ==> ()
    LeaveScope () ==
      if SEnv = [] then
        error
      else let env = hd SEnv in
        (for all nm in set dom env do
          if not (env(nm)).used and nm <> mk_AS`Name(["RESULT"],CI`NilContextId) and
             not(AUX`IsPrePostFn(nm))
               ----------------------
               -- Error message #33
               -- "%1" is not used
               ----------------------
          then ERR`GenErr(nm, <WARNING>,33,[PrintName(nm)]);
        SEnv := tl SEnv);

    EnterLocalScope : map AS`Name to (REP`TypeRep * nat1) ==> ()
    EnterLocalScope (Bindings) ==
      LocalEnv := [Bindings] ^ LocalEnv ;

    UpdateLocalScope : map AS`Name to (REP`TypeRep * nat1) ==> ()
    UpdateLocalScope (Bindings) ==
      LocalEnv := [hd LocalEnv ++ Bindings] ^ tl LocalEnv ;

    LeaveLocalScope : () ==> ()
    LeaveLocalScope () ==
      if LocalEnv = [] -- or SEnv = []
      then error
      else (LocalEnv := tl LocalEnv;
            --LeaveScope()
           );

\end{vdm_al}

\subsection{Looking up in the Environment}

The writable parameter indicates whether the name nm to be looked up needs
to be writable.

\begin{vdm_al}

#ifdef VDMPP
    LookUpInObject: AS`Name * AS`Name * bool * bool
                    ==> [AccessType|set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)]
    LookUpInObject(obj,nm,writable,reportError) ==
      if len nm.ids = 2
      then
        let ncls = mk_AS`Name([(nm.ids)(1)],CI`NilContextId),
            nnm  = mk_AS`Name([(nm.ids)(len nm.ids)],CI`NilContextId)
        in
          if obj = ncls or IsSubClass(obj,ncls)
          then
           (dcl tp : [AccessType|set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)];
            if writable
            then tp := LookUpInHierarchy(nnm, ncls, <STATE>, <OBJECT>)
            else tp := LookUpInHierarchy(nnm, ncls, <VAL>, <OBJECT>);
            if tp = nil
            then
             (tp := LookUpInHierarchy (nnm, ncls, <STATE>, <LOCAL>);
              if tp = nil
              then
                --------------------------
                -- Error message #34
                -- Unknown identifier "%1"
                --------------------------
               (if reportError
                then ERR`GenErr (nm, <ERROR>,34,[PrintName(nm)]);
                return nil)
              else return tp)
            else return tp)
          else
            def tp = LookUp(nm, false)
            in
              if tp <> nil
              then return tp
              else
                -----------------------------------------
                -- Error message #391
                -- "Class \"%1\" has no static member \"%2\"
                -----------------------------------------
              ( ERR`GenErr(nm, <ERROR>,391,[PrintName(ncls),PrintName(nnm)]);
                return nil
              )
      else
       (dcl valtp : [AccessType|set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)];
        if writable
        then valtp := LookUpInHierarchy(nm, obj, <STATE>, <OBJECT>)
        else valtp := LookUpInHierarchy(nm, obj, <VAL>, <OBJECT>);
        if valtp = nil
        then return LookUpInHierarchy (nm, obj, <STATE>, <LOCAL>)
        else return valtp);
#endif VDMPP

#ifdef VICE
NotStaticOk:() ==> ()
NotStaticOk() ==
  staticrequired := false;

StaticRequired:() ==> ()
StaticRequired() ==
  staticrequired := true;
#endif VICE
#ifdef VDMSL
  LookUp: AS`Name * bool ==> [REP`TypeRep]
#endif VDMSL
#ifdef VDMPP
  LookUp: AS`Name * bool
     ==> [REP`TypeRep | AccessType  |
          set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep) | set of REP`TypeRep]
#endif VDMPP
  LookUp (nm, printErr) ==
#ifdef VDMSL
    if len nm.ids = 2 and mk_AS`Name([(nm.ids)(1)],nm.cid) = GetCurMod ()
    then return LookUp(mk_AS`Name([(nm.ids)(len nm.ids)],nm.cid), printErr)
    else
#endif VDMSL
#ifdef VDMPP
    if len nm.ids = 2
    then
     (dcl tp : [REP`TypeRep|AccessType| set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)] := nil;
      def ncls' = mk_AS`Name([(nm.ids)(1)],nm.cid);
          ncls = def mk_(ok, cl) = ENV`ExpandClassName(ncls',{})
                 in if ok then cl else ncls';
          nnm  = mk_AS`Name([(nm.ids)(len nm.ids)],nm.cid)
      in
       (if ncls = GetCurClass ()
        then LookUp(nnm, printErr)
        elseif IsLocalSuperSuper(ncls)
        then tp := LookUpInHierarchy(nnm, ncls, <VAL>, <LOCAL>)
        else tp := LookUpInHierarchy(nnm, ncls, <VAL>, <GLOBAL>);
        if tp = nil  or
            (
#ifdef VICE
             staticrequired and
#endif VICE
            ((is_(tp,AccessType) and not tp.stat) or
             (not is_(tp,AccessType) and exists t in set tp & not t.stat))) and
              --not IsSubClass(CheckClass,ncls)
              not IsSubClass(GetCurClass(),ncls)
        then
         (
          if printErr
#ifdef VICE
                 and staticrequired
#endif VICE
          then
            -----------------------------------------
            -- Error message #391
            -- "Class \"%1\" has no static member \"%2\"
            -----------------------------------------
           (ERR`GenErr (nm,<ERROR>,391,[PrintName(ncls), PrintName(nnm)]);
            return nil)
          elseif printErr
          then
            -----------------------------------------
            -- Error message #435
            -- "%1 is not defined"
            -----------------------------------------
           (ERR`GenErr (nm,<ERROR>,435,[PrintName(AUX`ExtName(ncls,nnm))]);
            return nil)
          else return nil
         )
        else
          return tp
       )
     )
    else
#endif VDMPP
     (let depth = len SEnv in
      for i=1 to depth do
        let CurrentEnv = SEnv(i) in
          if nm in set dom CurrentEnv
          then
           (SEnv(i)(nm).used := true;
            if CurrentEnv(nm).tp = mk_REP`TmpTypeRep()
            then
             (if printErr
              then
                ------------------------------------
                -- Error message #36
                -- Missing type information for "%1"
                ------------------------------------
              ERR`GenErr(nm,<WARNING>,36,[PrintName(nm)]);
              return mk_REP`AllTypeRep())
            else return CurrentEnv(nm).tp);
    if nm in set dom ConstEnv
    then
     (ConstEnv(nm).used := true;
      if ConstEnv(nm).tp = mk_REP`TmpTypeRep()
      then
       (if printErr
        then
          ------------------------------------
          -- Error message #36
          -- Missing type information for "%1"
          ------------------------------------
          ERR`GenErr(nm,<WARNING>,36,[PrintName(nm)]);
        return mk_REP`AllTypeRep())
      else return ConstEnv(nm).tp)
    elseif nm in set ValueIds
    then return mk_REP`AllTypeRep()
    elseif (nm in set dom StateEnv)
    then
     (
#ifdef VDMPP
      -- Check that no attempt has been made to access a non-static member from a
      -- static one
      CheckLookupStatic(nm, StateEnv(nm).stat);
#endif VDMPP
      def kind = GetContext()
      in
        if (kind = <ALL>) or
#ifdef VDMPP
           (kind = <PERM>) or (kind = <PTHREAD>) or
#endif VDMPP
           ((kind in set {<IMPL>,<PRE>,<POST>}) and (nm in set dom ExtEnv))
        then
         (StateEnv(nm).used := true;
          return StateEnv(nm).tp)
        else
         (if printErr
          then
            -------------------------------------------------
            -- Error message #37
            -- The state component "%1" must not be used here
            -------------------------------------------------
            ERR`GenErr(nm,<ERROR>,37,[PrintName(nm)]);
          return nil)
     )
    elseif nm in set dom FunctionEnv
    then
     (
#ifdef VDMPP
      -- Check that no attempt has been made to access a non-static member from a
      -- static one
      CheckLookupStatic(nm, FunctionEnv(nm).stat);
#endif VDMPP
      FunctionEnv(nm).used := true;
      return FunctionEnv(nm).tp)
#ifdef VDMSL
    elseif nm in set dom PolyEnv
    then
     (PolyEnv(nm).used := true;
      --return PolyEnv(nm).tp
       let mk_PolyTypeRepElem(poly,tp,-) = PolyEnv(nm)
       in return mk_REP`PolyTypeRep(poly,tp);
     )
#endif VDMSL
    elseif nm in set dom OperationEnv
    then
     (
#ifdef VDMPP
      -- Check that no attempt has been made to access a non-static member from a
      -- static one
      CheckLookupStatic(nm, OperationEnv(nm).stat);
#endif VDMPP
      if (GetContext() = <PUREOP> and not OperationEnv(nm).oppure)
      then
        -------------------------------------------------
        -- Error message #460
        -- Impure operation call "%1" in pure operation
        -------------------------------------------------
        ERR`GenErr(nm,<ERROR>,460,[PrintName(nm)]);

      OperationEnv(nm).used := true;
      return OperationEnv(nm).tp)
#ifdef VDMPP
    elseif nm in set dom OverloadedEnv
    then
     (-- Check that no attempt has been made to access a non-static
      -- member from a  static one
      for all b_atr in set OverloadedEnv(nm) do
        CheckLookupStatic(nm, b_atr.stat);
      OverloadedEnv(nm) := { mu(b_atr, used |-> true) | b_atr in set OverloadedEnv(nm) };
      return { b_atr.tp | b_atr in set OverloadedEnv(nm)})
#endif VDMPP
    else
#ifdef VDMPP
     (dcl DefClass : AS`Name,
      tp : [REP`TypeRep | AccessType | (AS`Name * AccessFieldRep) | set of AccessType];
      if DefiningClass = []
      then DefClass := GetCurClass()
      else DefClass := hd DefiningClass;
      tp := LookUpInHierarchy(nm,DefClass,<VAL>,<LOCAL>);
      if tp = nil
      then tp := LookUpInHierarchy(nm,nil,<VAL>,<LOCAL>);

      if tp = nil
      then
#endif VDMPP
       (if printErr
        then
          --------------------------
          -- Error message #34
          -- Unknown identifier "%1"
          --------------------------
          ERR`GenErr (nm,<ERROR>,34,[PrintName(nm)]);
        return nil)
#ifdef VDMPP
      else return tp)
#endif VDMPP
    );

#ifdef VDMPP
\end{vdm_al}
The function \texttt{CheckLookupStatic} is used to ensure that we do
not look up a non static member if we are currently in a static environment.
\begin{vdm_al}
CheckLookupStatic : AS`Name * bool ==> ()
CheckLookupStatic(nm, stat) ==
  if (GetStatic() and not stat)
  then
    -------------------------------------------------
    -- Error message #380
    -- Can not refer to non-static class member %1 in
    -- a static class member
    -------------------------------------------------
    ERR`GenErr(nm, <ERROR>, 380, [PrintName(nm)]);
#endif VDMPP

#ifdef VDMSL
LookUpTypeName : AS`Name ==> [REP`TypeRep]
LookUpTypeName (nm) ==
#endif VDMSL
#ifdef VDMPP
LookUpTypeName : AS`Name * bool ==> [REP`TypeRep|AccessType]
LookUpTypeName (nm,printerr) ==
 (if len nm.ids > 1
  then
    let ncls = mk_AS`Name([(nm.ids)(1)],CI`NilContextId),
        nnm  = mk_AS`Name([(nm.ids)(2)],CI`NilContextId)
    in
      if ncls = GetCurClass ()
      then LookUpTypeName (nnm,true)
      else
        def tp = LookUpInHierarchy(nnm, ncls, <TYPE>,<GLOBAL>)
        in
          if tp = nil
          then
            if CheckClassName(nnm)
            then return mk_REP`ObjRefTypeRep(nnm)
            else
              --------------------------
              -- Error message #34
              -- Unknown identifier "%1"
              --------------------------
             (if printerr
              then ERR`GenErr (nm,<ERROR>,34,[PrintName(nm)]);
                 return nil)
          else
            return tp
  else
#endif VDMPP
#ifdef VDMSL
  if len nm.ids > 1 and mk_AS`Name([(nm.ids)(1)],CI`NilContextId) = GetCurMod()
  then LookUpTypeName(mk_AS`Name([(nm.ids)(2)],CI`NilContextId))
  else
  --if nm in set dom RenamedTypes
  --then LookUpTypeName(RenamedTypes(nm))
  --elseif InsideInter and nm in set rng RenamedTypes
  --      -------------------------------------------------------------
  --      -- Error message #38
  --      -- The renamed type "%1" cannot be used in the interface part
  --      -------------------------------------------------------------
  --then (ERR`GenErr (nm,<ERROR>,38,[PrintName(nm)]);
  --      return nil)
  if nm in set dom RenamedTypes
  then
    if InsideInter
    then
      -------------------------------------------------------------
      -- Error message #38
      -- The renamed type "%1" cannot be used in the interface part
      -------------------------------------------------------------
     (ERR`GenErr (nm,<ERROR>,38,[PrintName(nm)]);
      return nil)
    else LookUpTypeName(RenamedTypes(nm))
  else
#endif VDMSL
    if nm in set dom TypeEnv
    then
      let restp = TypeEnv(nm).tp
      in
       (TypeEnv(nm).used := true;
#ifdef VDMPP
        FoundClass := GetCurClass();
#endif VDMPP
        return restp)
    else
#ifdef VDMPP
     (dcl DefClass : AS`Name,
      tp : [AccessType|set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)];
      if DefiningClass = []
      then DefClass := GetCurClass()
      else DefClass := hd DefiningClass;
      tp := LookUpInHierarchy(nm,DefClass,<TYPE>,<LOCAL>);
      if tp = nil 
      then tp := LookUpInHierarchy(nm,nil,<TYPE>,<LOCAL>);
      if tp = nil
      then
        if CheckClassName(nm)
        then return mk_REP`ObjRefTypeRep(nm)
        elseif nm in set dom TagEnv
        then
          let ctr = mk_REP`CompositeTypeRep(nm, TagEnv(nm))
          in
           (TypeEnv := TypeEnv ++ {nm |-> mk_TypeRepElem(ctr, true, false)};
            return ctr)
        else
          --------------------------
          -- Error message #34
          -- Unknown identifier "%1"
          --------------------------
         (if printerr
          then
            ERR`GenErr (nm,<ERROR>,34,[PrintName(nm)]);
            TypeEnv := TypeEnv ++ {nm |-> mk_TypeRepElem( mk_REP`AllTypeRep(), true, false)};
          return nil)
      else return tp)
     );
#endif VDMPP
#ifdef VDMSL
     (if nm in set dom TagEnv
      then
        let ctr = mk_REP`CompositeTypeRep(nm, TagEnv(nm))
        in
         (TypeEnv := TypeEnv ++ {nm |-> mk_TypeRepElem(ctr, true, false)};
          return ctr)
      else
        --------------------------
        -- Error message #34
        -- Unknown identifier "%1"
        --------------------------
       (ERR`GenErr (nm,<ERROR>,34,[PrintName(nm)]);
        TypeEnv := TypeEnv ++ {nm |-> mk_TypeRepElem(mk_REP`AllTypeRep(), true, false)};
        return nil));
#endif VDMSL

#ifdef VDMPP
    LookUpDefClassForTypeName : AS`Name ==> [AS`Name]
    LookUpDefClassForTypeName (nm) ==
      def - = LookUpTypeName(nm,true) in
        return FoundClass;

    LookUpDefClass : () ==> [AS`Name]
    LookUpDefClass () ==
        return if DefiningClass = []
               --then FoundClass
               then nil
               --else hd DefiningClass;
               else FoundClass;

SetDefClass: AS`Name ==> ()
SetDefClass(clnm) ==
  DefiningClass := [clnm] ^ DefiningClass;

UnSetDefClass: () ==> ()
UnSetDefClass() ==
  DefiningClass := tl DefiningClass;
#endif VDMPP

#ifdef VDMSL
  LookUpTag : TYPE`Ind * AS`Name * set of AS`Name ==> [AS`Name * seq of REP`FieldRep]
  LookUpTag (i,nm,nm_s) ==
    if nm in set nm_s
    then return nil
    elseif len nm.ids > 1 and mk_AS`Name([(nm.ids)(1)],CI`NilContextId) = GetCurMod ()
    then
      let nnm = mk_AS`Name([(nm.ids)(2)],CI`NilContextId)
      in LookUpTag(i,nnm,nm_s union {nm})
    elseif CheckLocalTag(nm)
    then
      if nm in set dom RenamedTypes
      then return mk_(RenamedTypes(nm),TagEnv(nm))
      else return mk_(nm,TagEnv(nm))
    elseif CheckImportedTag(nm)
    then return mk_(nm,LocTagEnv(nm))
    else return nil;
#endif VDMSL

#ifdef VDMPP
  LookUpTag : TYPE`Ind * AS`Name * set of AS`Name ==> [AS`Name * (AccessFieldRep|TagRepElem)]
  LookUpTag (i,nm,nm_s) ==
    if nm in set nm_s
    then return nil
    elseif len nm.ids > 1
    then
      let ncls = mk_AS`Name([(nm.ids)(1)],CI`NilContextId),
          nnm  = mk_AS`Name([(nm.ids)(2)],CI`NilContextId)
      in
        if ncls = GetCurClass ()
        then LookUpTag(i,nnm,nm_s union {nm})
        else LookUpInHierarchy(nnm,ncls,<TAG>,<GLOBAL>)
    else
      if CheckLocalTag(nm)
      then return mk_(nm,TagEnv(nm))
      else return LookUpInHierarchy(nm,nil,<TAG>,<LOCAL>);
#endif VDMPP

#ifdef VDMPP
  LookUpOperationName : [AS`Name] * AS`Name * [AS`Expr] ==> set of AccessType
  LookUpOperationName(classnm, metnm, objnm) ==
   (dcl cls : [AS`Name] := classnm,
        tps : [REP`TypeRep | (set of REP`TypeRep) |
               AccessType | set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)];
    if classnm = nil
    then
      cases metnm:
              mk_AS`Name([cl,-],cid) -> cls := mk_AS`Name([cl],cid),
              others                 -> cls := GetCurClass ()
      end;
    tps := LookUpInObject(cls,metnm,false,true);

    if tps = nil and objnm = nil
    then tps := LookUp(metnm, false);

    if IsAccessType (tps)
    then
      cases true:
        (is_AccessOpTypeRep(tps)) -> (CheckLookupStatic(metnm, objnm = nil => tps.stat);
                                      return {tps};),
        (is_AccessFnTypeRep(tps)) -> return {tps},
        others                    -> return {}
      end
    elseif IsAccessTypeSet(tps)
    then
     (dcl resvals : set of AccessType := {};
      for all b_tp in set tps do
        if is_AccessOpTypeRep(b_tp)
        then
         (CheckLookupStatic(metnm, objnm = nil => b_tp.stat);
          resvals := resvals union {b_tp});
      return resvals
     )
    else return {};
  );
#endif VDMPP

#ifdef VDMSL
  LookUpState: AS`Name * bool * (<CUR>|<OLD>) ==> [REP`TypeRep]
  LookUpState(nm,use,kind) ==
   (if kind = <CUR>
    then let depth = len LocalEnv in
           for i=1 to depth do
             let CurrentEnv = LocalEnv(i) in
              (if nm in set dom CurrentEnv then
                  (for i=1 to len SEnv do
                     if nm in set dom (SEnv(i))
                     then (if use
                           then SEnv(i)(nm).used := true;
                           return CurrentEnv(nm).#1)))
    elseif nm not in set dom ExtEnv
          ---------------------------
          -- Error message #42
          -- "%1" cannot be used here
          ---------------------------
    then (ERR`GenErr(nm,<ERROR>,42,[PrintName(nm)]);
          return nil)
    elseif ExtEnv(nm) = <READ>
          ---------------------------------------------------------
          -- Error message #43
          -- The state component "%1" can only be used in read mode
          ---------------------------------------------------------
    then (ERR`GenErr(nm,<ERROR>,43,[PrintName(nm)]);
          return nil);
    if nm in set dom StateEnv
    then
     (if exists x in set elems SEnv & nm in set dom x
      then
       (if GetContext() <> <PURE>
        then
          ------------------------------------------------------
          -- Error message #18
          -- The scope of the state component "%1" is now hidden
          ------------------------------------------------------
          ERR`GenErr(nm,<ERROR>,18,[PrintName(nm)])
       )
      elseif GetContext() = <PURE>
      then
        -------------------------------------------------
        -- Error message #37
        -- The state component "%1" must not be used here
        -------------------------------------------------
        ERR`GenErr(nm,<ERROR>,37,[PrintName(nm)]);
      StateEnv(nm).used := true;
      return StateEnv(nm).tp
     )
    else
     (-------------------------------
      -- Error message #40
      -- Unknown state reference "%1"
      -------------------------------
      ERR`GenErr (nm,<ERROR>,40,[PrintName(nm)]);
      return nil 
     )
   );
#endif VDMSL

#ifdef VDMPP
  LookUpState: AS`Name * bool * (<CUR>|<OLD>) ==> [REP`TypeRep|AccessType]
  LookUpState(nm,use,kind) ==
    if len nm.ids > 1
    then
     (let ncls = mk_AS`Name([(nm.ids)(1)],CI`NilContextId),
          nnm  = mk_AS`Name([(nm.ids)(2)],CI`NilContextId)
      in
        if ncls = GetCurClass ()
        then
         (if kind = <CUR>
          then
            def tp = LookUpInHierarchy(nnm, ncls, <STATE>, <LOCAL>)
            in
              if tp <> nil
              then return tp;
          return LookUpState(nnm,use,kind))
        elseif IsLocalSuperSuper (ncls)
        then
          def tp = LookUpInHierarchy(nnm, ncls, <STATE>, <LOCAL>)
          in
            if tp = nil
            then
              -------------------------------
              -- Error message #40
              -- Unknown state reference "%1"
              -------------------------------
             (ERR`GenErr (nm,<ERROR>,40,[PrintName(nm)]);
              return nil)
            else
              return tp
        else
         (if IsStaticInstanceVar(nm)
          then
            def tp = LookUpInHierarchy(nnm, ncls, <STATE>, <LOCAL>)
            in
              if tp <> nil
              then return tp;
          ---------------------------------------------------------------------
          -- Error message #44
          -- Instance variables are not visible from class "%1" so "%2" cannot
          -- be used here
          ---------------------------------------------------------------------
          ERR`GenErr(nm,<ERROR>,44,[(nm.ids)(1),(nm.ids)(2)]);
          return nil))
    else
     (if kind = <CUR>
      then
        let depth = len LocalEnv
        in
          for i = 1 to depth do
            let CurrentEnv = LocalEnv(i)
            in
             (if nm in set dom CurrentEnv
              then
               (for i=1 to len SEnv do
                  if nm in set dom (SEnv(i))
                  then return CurrentEnv(nm).#1))

      elseif (GetContext() = <POST>) => nm in set dom ExtEnv
      then
        if nm in set dom StateEnv
        then
         (StateEnv(nm).used := use;
          if kind = <OLD> and ExtEnv(nm) = <READ>
          then
           (---------------------------------------------------------
            -- Error message #43
            -- The state component "%1" can only be used in read mode
            ---------------------------------------------------------
            ERR`GenErr(nm,<ERROR>,43,[PrintName(nm)]);
            return nil);
          return StateEnv(nm).tp)
        else
          def tp = LookUpInHierarchy(nm,nil,<STATE>,<LOCAL>)
          in
            if tp = nil
            then
             (-------------------------------
              -- Error message #40
              -- Unknown state reference "%1"
              -------------------------------
              ERR`GenErr (nm,<ERROR>,40,[PrintName(nm)]);
              return nil)
            else return tp;

      if nm in set dom StateEnv
      then
       (if exists x in set elems SEnv & nm in set dom x
        then
         (if GetContext() <> <PURE>
          then
            ------------------------------------------------------
            -- Error message #18
            -- The scope of the state component "%1" is now hidden
            ------------------------------------------------------
            ERR`GenErr(nm,<ERROR>,18,[PrintName(nm)]);
         )
        elseif GetContext()  = <PURE>
        then
          -------------------------------------------------
          -- Error message #37
          -- The state component "%1" must not be used here
          -------------------------------------------------
          ERR`GenErr(nm,<ERROR>,37,[PrintName(nm)]);
        StateEnv(nm).used := use;
        if isStatic and not StateEnv(nm).stat
        then
         (ERR`GenErr (nm,<ERROR>,422,[PrintName(nm)]);
          return nil)
        else return StateEnv(nm).tp)
      else
        def tp = FoundAsInstanceInSEnv(nm)
        in
          if tp <> nil
          then return tp
          else
            def tp = LookUpInHierarchy(nm,nil,<STATE>,<LOCAL>)
            in
              if tp = nil
              then
               (for i = 1 to len SEnv do
                  if nm in set dom SEnv(i)
                  then
                    let tre = SEnv(i)(nm),
                        tr = tre.tp
                    in
                      if is_REP`ObjRefTypeRep(tr) or
                         is_REP`UnionTypeRep(tr) and exists tp in set tr.tps & is_REP`ObjRefTypeRep(tp)
                      then
                       (SEnv(i)(nm).used := true;
                        return tr);
                -------------------------------
                -- Error message #40
                -- Unknown state reference "%1"
                -------------------------------
                ERR`GenErr (nm,<ERROR>,40,[PrintName(nm)]);
                return nil;
               )
              else return tp
     );

FoundAsInstanceInSEnv: AS`Name ==> [REP`TypeRep]
FoundAsInstanceInSEnv(nm) ==
 (let depth = len SEnv in
    for i=1 to depth do
      let CurrentEnv = SEnv(i) in
        if nm in set dom CurrentEnv and
           is_REP`TypeNameRep(CurrentEnv(nm).tp) and
           VCM`IsClassName(CurrentEnv(nm).tp.nm)
        then (SEnv(i)(nm).used := true;
              return CurrentEnv(nm).tp);
  return nil);

  LookUpClass: AS`Name ==> ParseTypeInfo
  LookUpClass(nm) ==
    def class = VCM`GetClassTypeRep(nm) in
      if class = nil then
        ------------------------------------------
        -- Error message #1
        -- The class "%1" has not been pre-checked
        ------------------------------------------
      ( ERR`GenErr(nm, <ERROR>,1,[PrintName(nm)]);
                 return MakeEmptyClass(nm)
      )
      else return class;
\end{vdm_al}
The operation \texttt{DefaultConstructorAvailable} checks that the
default constructor for the given class is either defined and public,
or is not defined by the user.
\begin{vdm_al}
  DefaultConstructorAccessible : AS`Name ==> bool
  DefaultConstructorAccessible(p_nm) ==
    def l_classInfo = VCM`GetClassTypeRep(p_nm);
        l_constrs   = if l_classInfo = nil
                      then {}
                      else l_classInfo.constructors;
        l_defConstrs = { b_constr | b_constr in set l_constrs & b_constr.tp.Dom = []}
    in
      if l_defConstrs = {}
      then return true
      else
        let {l_defConstr} = l_defConstrs
        in
          if GetCurClass() = p_nm
                    -- inside a class all constructors of the class
                    -- itself are available
          then return true
          elseif IsSubClass(GetCurClass(),p_nm)
                    -- inside a class all protected and and public (and default qualified)
                    -- constructors of super classes are available
                    -- Note that constructors cannot be overwritten in subclasses
                    -- in particular a protected constructor will remain protected
          then return l_defConstr.a <> <PRIVATE_AS>
          else return l_defConstr.a = <PUBLIC_AS>;

--      return l_defConstrs = {} or
--             let {l_defConstr} = l_defConstrs
--             in
--                 if GetCurClass() = p_nm then
--                    -- inside a class all constructors of the class
--                    -- itself are available
--                    true
--                 elseif IsSubClass(GetCurClass(),p_nm) then
--                    -- inside a class all protected and and public (and default qualified)
--                    -- constructors of super classes are available
--                    -- Note that constructors cannot be overwritten in subclasses
--                    -- in particular a protected constructor will remain protected
--                    l_defConstr.a <> <PRIVATE_AS>
--                 else
--                    l_defConstr.a = <PUBLIC_AS>;
\end{vdm_al}
The operation \texttt{ConstructorExists} is used to check whether a
constructor for a given sequence of argument types exists.
\begin{description}
\item[\texttt{p\_i}] Indicates whether it is a pos or def type check.
\item[\texttt{p\_nm}] The name of the class being instantiated.
\item[\texttt{p\_argTps}] The sequence of argument types given.
\item[\texttt{p\_expr}] The actual argument expression.
\end{description}

\begin{vdm_al}
  ConstructorExists : TYPE`Ind * AS`Name * seq of REP`TypeRep * AS`Expr ==> bool
  ConstructorExists(p_i, p_nm, p_argTps, p_expr) ==
    def l_constrs = LookUpConstructors(p_nm); -- map nat to set of set of AccessOpTypeRep
    in
     (dcl l_constrTps : map nat to set of set of REP`TotalFnTypeRep;
      if GetCurClass() = p_nm
      then
              -- inside a class all constructors of the class
              -- itself are available
        l_constrTps := { b_i |->
               {  { mk_REP`TotalFnTypeRep(b_acc.tp.Dom, b_acc.tp.Rng) | b_acc in set b_s}
               | b_s in set l_constrs(b_i) }
              | b_i in set dom l_constrs }
      elseif IsSubClass(GetCurClass(),p_nm)
      then
              -- inside a class all protected and public (and default qualified)
              -- constructors of super classes are available
              -- Note that constructors cannot be overwritten in subclasses
              -- in particular a protected constructor will remain protected
        l_constrTps := { b_i |->
               {  { mk_REP`TotalFnTypeRep(b_acc.tp.Dom, b_acc.tp.Rng) | b_acc in set b_s & b_acc.a <> <PRIVATE_AS>}
               | b_s in set l_constrs(b_i) } | b_i in set dom l_constrs }
      else
              -- outside a class only public constructors are available
        l_constrTps := { b_i |->
               {  { mk_REP`TotalFnTypeRep(b_acc.tp.Dom, b_acc.tp.Rng) | b_acc in set b_s & b_acc.a = <PUBLIC_AS>}
               | b_s in set l_constrs(b_i) } | b_i in set dom l_constrs };
      def l_checkConstrs : map nat to set of set of (bool * REP`TypeRep) =
            { b_i |-> { { EXPR`CheckOverloadedApply(p_i, b_s, p_argTps, p_expr, false,false)}
                      | b_s in set l_constrTps(b_i)} | b_i in set dom l_constrTps }
      in
      let l_matchConstrs : map nat to set of set of (bool * REP`TypeRep) =
            { b_i |-> { { b_tup | b_tup in set b_s & b_tup.#1 } | b_s in set l_checkConstrs(b_i) }
            | b_i in set dom l_checkConstrs }
      in
      let l_nonEmptyMatches : map nat to set of set of (bool * REP`TypeRep) =
            { b_i |-> l_matchConstrs(b_i) | b_i in set dom l_matchConstrs
                              & dunion l_matchConstrs(b_i) <> {}}
      in
        return
          l_nonEmptyMatches <> {|->} and
          exists1 b_rng in set l_matchConstrs(UTIL`minset(dom l_nonEmptyMatches)) & b_rng <> {});
\end{vdm_al}
\texttt{LookUpConstructors} takes the name of a class and returns a
map from naturals to a set of access op type reps. If \texttt{m} is
the result of the function, then for each nat \texttt{i} in the domain
of \texttt{m}, \texttt{m(i)} represents some set \texttt{s}. This set
\texttt{s} consists of the a number of sets. If \texttt{c} is an
element of \texttt{s}, then \texttt{c} consists of the set of types
corresponding to constructors of a superclass of \texttt{p\_nm}, and
\texttt{i} indicates the distance between this superclass and
\texttt{p\_nm}.

\begin{vdm_al}
  LookUpConstructors : AS`Name ==> map nat to set of set of AccessOpTypeRep
  LookUpConstructors(p_nm) ==
    def l_indexedSupers = TransClosIndex(p_nm)
    in
    return { b_i |-> { def l_classInfo = VCM`GetClassTypeRep(b_cl)
                       in
                           if l_classInfo = nil then
                              {}
                           else
                              l_classInfo.constructors
                     | b_cl in set l_indexedSupers(b_i) }
           | b_i in set dom l_indexedSupers }
           munion
           { 0 |-> {def l_classInfo = VCM`GetClassTypeRep(p_nm)
                    in
                       if l_classInfo = nil then
                        {}
                       else
                        l_classInfo.constructors}};

  CheckClassName: AS`Name ==> bool
  CheckClassName(nm) ==
    return VCM`GetClassTypeRep(nm) <> nil;

  HasThread: AS`Name ==> bool
  HasThread(nm) ==
    def class = VCM`GetClassTypeRep(nm) in
      if class = nil then
        return false
      else
        return class.thread <> <NONE> or
               exists cls in set class.super & HasThread(cls);

  CheckTraceName : AS`Name ==> bool
  CheckTraceName (nm) ==
    return nm in set TraceEnv;

  LookUpInHierarchy : AS`Name * [AS`Name] * (<VAL>|<TYPE>|<TAG>|<STATE>) * (<OBJECT>|<LOCAL>|<GLOBAL>)
                      ==> [REP`TypeRep | AccessType | (AS`Name * AccessFieldRep) | set of AccessType]
  LookUpInHierarchy(nm,classid,kind,local) ==
  (dcl binds : map AS`Name to (REP`TypeRep | AccessType | (AS`Name * AccessFieldRep) | set of AccessType)
               := {|->};

   let super = if classid = nil
               then Super
               else {classid}
   in
   (FoundClass := nil;
    for all sup in set super do
      def bd = LookUpInHierarchyAux(nm,sup,kind,local,{})
      in
        binds := binds munion bd;
    if card dom binds = 0
    then return nil
    else if card dom binds = 1
         then ( FoundClass := let {e} = dom binds in e;
                return binds(FoundClass);
              )
         elseif (exists s in set rng binds & is_(s, set of AccessType)) or
                (forall s in set rng binds & is_AccessOpTypeRep(s) or
                                             is_AccessFnTypeRep(s) or
                                             is_AccessPolyTypeRep(s))
         then let l_setBinds = { b_nm |-> if is_(binds(b_nm), set of AccessType)
                                          then binds(b_nm)
                                          else { binds(b_nm) }
                               | b_nm in set dom binds},
                  l_tps = dinter rng l_setBinds
              in
              if l_tps <> {}
              then
               (def l_setBinds' = { b_nm |-> l_setBinds(b_nm) | b_nm in set dom l_setBinds &
                                  def l_pte = VCM`GetClassTypeRep(b_nm);
                                      subresps = l_pte.subresps;
                                      mk_AS`Name(ids,cid) = nm;
                                      mk_AS`Name([modid],-) = b_nm;
                                      nn = mk_AS`Name([modid]^[ids(len ids)], cid)
                                  in
                                    if nn in set dom subresps
                                    then
                                      let atp = subresps(nn),
                                          atps = if is_(atp, set of AccessType) then atp else {atp}
                                      in
                                        l_tps \ atps <> {}
                                    else true }
                in
                  if card dom l_setBinds' = 1
                  then (FoundClass := let {e} = dom l_setBinds' in e;
                        return binds(FoundClass));
                --for all b_d in set dom l_setBinds do
                --------------------------------------------
                -- Error message #45
                -- "%1" is multiple defined in super classes
                --------------------------------------------
                ERR`GenErr(nm,<ERROR>,45,[PrintName(nm)]);
                return nil)
              else
               (def ------------------------------------------------------
                    -- split on polymorphic or not
                    -------------------------------------------------------
                    flatBindsRng = dunion {if is_(b_acc,set of AccessType) then b_acc else {b_acc}
                                       | b_acc in set rng binds};
                    poly      = {b_acc | b_acc in set flatBindsRng & is_AccessPolyTypeRep(b_acc) };
                    non_poly  = {b_acc | b_acc in set flatBindsRng & not is_AccessPolyTypeRep(b_acc) };
                    ------------------------------------------------------
                    -- split polymorphic types on the number of parameters
                    -------------------------------------------------------
                    param_lengths    = {len bd.tp.vars | bd in set poly};
                    overlapping_poly = {{bd | bd in set poly & len bd.tp.vars = ll} | ll in set param_lengths};
                    non_poly_consistency = TypesAreConsistent(non_poly);
                    poly_consistency_set = {TypesAreConsistent(dd) | dd in set  overlapping_poly};
                    consistency_sets = dunion ({non_poly_consistency} union poly_consistency_set)
                in
                  if non_poly = {} or non_poly_consistency <> {}
                  then
                    if poly = {} or forall ss in set poly_consistency_set & ss <> {}
                    then return consistency_sets;

--                return dunion ({non_poly_consistency} union poly_consistency_set);
                --------------------------------------------
                -- Error message #45
                -- "%1" is multiple defined in super classes
                --------------------------------------------
                ERR`GenErr(nm,<ERROR>,45,[PrintName(nm)]);
                return nil)
         else
           --------------------------------------------
           -- Error message #45
           -- "%1" is multiple defined in super classes
           --------------------------------------------
           ( ERR`GenErr(nm,<ERROR>,45,[PrintName(nm)]);
             return nil
           );
   )
  );
\end{vdm_al}

The function \texttt{TypesAreConsistent} is used if when a name is
looked up in the hierarchy, the same name is found in different
classes, due to overloading of functions or operations. This could
occur if the call came from a subclass and two or more superclasses
define the same name. In this case we need to ensure that all
protected or public functions or operations have non-overlapping
parameter types, and the return type is the same for all functions and
operations.
\begin{vdm_al}
operations

  TypesAreConsistent : (set of (REP`TypeRep | AccessType | (AS`Name * AccessFieldRep) | set of AccessType))
                       ==> set of AccessType
  TypesAreConsistent(p_s) ==
    if p_s = {} or  exists b_tp in set p_s & is_(b_tp, REP`TypeRep) or is_(b_tp, AS`Name * AccessFieldRep)
    then return {}
    else
      def l_flatAccs = { NormaliseAccessType(b_acc) | b_acc in set p_s & IsAccessType(b_acc) }
                       union
                       dunion
                       { NormaliseAccessTypeSet(b_accSet) | b_accSet in set p_s & is_(b_accSet, set of AccessType) }
      in
      if exists b_tp in set l_flatAccs &
         not (is_AccessOpTypeRep(b_tp) or is_AccessFnTypeRep(b_tp) or is_AccessPolyTypeRep(b_tp))
      then return {}
      else
        --let l_retTps = { if is_AccessOpTypeRep(b_tp)
        --                 then b_tp.tp.Rng
        --                 elseif is_AccessPolyTypeRep(b_tp)
        --                 then b_tp.tp.tp.fnrng
        --                 else b_tp.tp.fnrng | b_tp in set l_flatAccs }
        --in
        --  if card l_retTps > 1 -- 20121016
        --  then {}
        --  else
        let l_retVal = { b_tp | b_tp in set l_flatAccs
                            --& --p_isLocal =>
                            --    b_tp.a in set {<PUBLIC_AS>, <PROTECTED_AS>}
                            },
            l_paramTps = { if is_AccessOpTypeRep(b_tp)
                           then b_tp.tp.Dom
                           elseif is_AccessPolyTypeRep(b_tp)
                           then b_tp.tp.tp.fndom
                           else b_tp.tp.fndom
                              | b_tp in set l_retVal}
        in if card l_retVal <> card l_paramTps
           then return {} -- A parameter type was repeated
           elseif exists b_tp1, b_tp2 in set l_paramTps &
                             b_tp1 <> b_tp2 and
                             len b_tp1 = len b_tp2 and
                             forall i in set inds b_tp1 &
                               TYPE`IsOverlapping(b_tp1(i), b_tp2(i), {})
           then return {} -- Two parameter types overlapped
           else return l_retVal;

\end{vdm_al}

The operation {\it LookUpInHierarchyAux} takes a name and the
name of a superclass where it could be defined. It looks in the given
superclass and all its superclasses. It then returns a map of places
where the name have been defined (the map goes from class names to
the type representation which have been found).

\begin{vdm_al}

  LookUpInHierarchyAux : AS`Name * AS`Name *
                         (<VAL>|<TYPE>|<TAG>|<STATE>) *
                         (<OBJECT>|<LOCAL>|<GLOBAL>) * set of AS`Name
                         ==> map AS`Name to (REP`TypeRep |
                                             AccessType |
                                             (AS`Name * AccessFieldRep) |
                                              set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
  LookUpInHierarchyAux(nm,sup,kind,where,checked) ==
  (dcl binds : map AS`Name to (REP`TypeRep | AccessType |
                              (AS`Name * AccessFieldRep) |
                              (set of (AccessOpTypeRep|AccessFnTypeRep|AccessPolyTypeRep)))
               := {|->};
    if sup in set checked then
      return binds;
    def classinfo = LookUpClass(sup);
        qname = AUX`ExtName(sup,nm);
        ss = checked union {sup}
    in
      if is_ParseTypeInfo(classinfo)
      then let mk_ParseTypeInfo(-,-,super,tps,vals,insts,fcts,polys,ops,tags, overloads,-,-,-,-,-) = classinfo
           in
           (cases kind:
              <VAL>    -> def valBd = ExtractValue({insts, fcts, polys, ops, overloads}, where=<GLOBAL>, qname, sup)
                                      ++
                                      ExtractValue({vals}, false, qname, sup)
                          in
                          ( for all s in set super do
                              def bd = LookUpInHierarchyAux(nm,s,<VAL>, where,ss)
                              in
                                binds := binds munion bd;
                              return RemoveHidden(valBd, binds)),
              <TYPE>   -> if qname in set dom tps
                          then return {sup |-> tps(qname)}
                          else (for all s in set super do
                                  def bd = LookUpInHierarchyAux(nm,s,<TYPE>,where,ss)
                                  in
                                    binds := binds munion bd),
              <TAG>    -> if qname in set dom tags
                          then return {sup |-> mk_(qname, tags(qname))}
                          elseif qname in set dom tps
                          then
                            let tp = StripAccessType(tps(qname))
                            in
                              if is_REP`TypeNameRep(tp)
                              then
                                let tag = tp.nm,
                                    mk_(ncls, nnm) = if len tag.ids = 2
                                                     then mk_(mk_AS`Name([(tag.ids)(1)],CI`NilContextId),
                                                              mk_AS`Name([(tag.ids)(2)],CI`NilContextId))
                                                     else mk_(sup, tag)
                                in return LookUpInHierarchyAux(nnm, ncls, kind, where, checked)
                              else return binds
                          else (for all s in set super do
                                  def bd = LookUpInHierarchyAux(nm,s,<TAG>,where,ss)
                                  in
                                    binds := binds munion bd;
                                return binds),
              <STATE>   -> if where <> <LOCAL> then
                             return {|->}
                           elseif qname in set dom insts
                           then return {sup |-> insts(qname)}
                           else (for all s in set super do
                                 def bd = LookUpInHierarchyAux(nm,s,<STATE>,where,ss)
                                 in
                                    binds := binds munion bd)
            end;
            return TransBinds(sup,binds))
        else return {|->});
\end{vdm_al}
The function \texttt{ExtractValue} is an auxiliary function used by
\texttt{LookUpInHierarchyAux} to extract all values/instance
variables/functions/operations matching a particular name in a
particular class.
\begin{description}
\item[\texttt{p\_defms}]  A set of maps giving values/instance
variables/functions/operations for names.
\item[\texttt{p\_isGlobal}] Indicates whether we are searching globally
(in VDM++ this means statically).
\item[\texttt{p\_qname}] The qualified name we are searching for.
\item[\texttt{p\_sup}] The unqualified name we are searching for.
\end{description}
\begin{vdm_al}
ExtractValue : set of (map AS`Name to (AccessType | set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)))
             * bool
             * AS`Name
             * AS`Name
             ==> map AS`Name to (AccessType | set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
ExtractValue(p_defms, p_isGlobal, p_qname, p_sup) ==
  let l_matchMaps = { b_m | b_m in set p_defms & p_qname in set dom b_m}
  in
  let l_matchGlobal = { b_m
                      | b_m in set l_matchMaps
                            & (
#ifdef VICE
                               staticrequired and
#endif VICE
                               p_isGlobal) =>
                              if is_(b_m(p_qname), set of (AccessOpTypeRep |
                                                           AccessFnTypeRep |
                                                           AccessPolyTypeRep))
                              then exists b_atr in set b_m(p_qname)
                                     & b_atr.stat
                              else b_m(p_qname).stat }
  in
  if l_matchGlobal = {}
  then
    return {|->}
  else
    let l_match in set l_matchGlobal
    in
      if is_(l_match,map AS`Name to set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
      then return
        { p_sup |-> { mu(b_meth,tp |-> SubSuperClType(p_sup,b_meth.tp))
                    | b_meth in set l_match(p_qname)
                    & (
#ifdef VICE
                       staticrequired and
#endif VICE
                       p_isGlobal) => b_meth.stat }
        }
      else
        let b_meth = l_match(p_qname)
        in return
          { p_sup |-> mu(b_meth,tp |-> SubSuperClType(p_sup,b_meth.tp))};
\end{vdm_al}

The operation \texttt{RemoveHidden} is used during lookup in the class
hierarchy to remove functions and
operations from a superclass which are hidden by a function or
operation in a subclass i.e. the superclass function/operation is
overridden. It also removes from the superclass any functions or
operations not visible from the subclass.
\begin{description}
\item[\texttt{p\_subMap}] A map from names to operations/functions for the
subclass.
\item[\texttt{p\_supMap}] A map from names to operations/functions for the
superclass.
\end{description}
The operation returns the merge of the two maps, subject to the
conditions described above.

\begin{vdm_al}
operations

RemoveHidden : map AS`Name to (AccessType| set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)) *
               map AS`Name to (AccessType| set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
               ==> map AS`Name to (AccessType| set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
RemoveHidden(p_subMap, p_supMap) ==

--   -------------------------------------------------------
--   ------ Remove overridden functions and operations -----
--   -------------------------------------------------------
--   --- Does NOT work because overloaded functions are forced to be of rep TotalFnTypeRep hence trying
--   --- remove functions overridden by partial functions does not make much sense
--   --- as a hack we allow partial functions to override total functions (narrowing)!!
--   ------------------------------------------------------
--   let flat_subMap_tps = dunion {if IsAccessType(l_acc)
--                              then {l_acc.tp}
--                              else {ll_acc.tp | ll_acc in set l_acc}
--                             | l_acc in set rng p_subMap},
--       p_subMap_tps = flat_subMap_tps union
--                      {if is_REP`PartialFnTypeRep(tp) then
--                          mk_REP`TotalFnTypeRep(tp.fndom,tp.fnrng)
--                       else
--                          mk_REP`PartialFnTypeRep(tp.fndom,tp.fnrng)
--                      | tp in set flat_subMap_tps &
--                        is_REP`PartialFnTypeRep(tp) or
--                        is_REP`TotalFnTypeRep(tp)},
--       new_p_supMap = {nm |->
--                         let l_acc = p_supMap(nm)
--                         in
--                           if IsAccessType(l_acc) then
--                             if l_acc.tp not in set p_subMap_tps then
--                                 l_acc
--                               else
--                                 {}
--                             else
--                               {ll_acc | ll_acc in set l_acc & ll_acc.tp not in set p_subMap_tps}
--                      | nm in set dom p_supMap }
--   in
--   let p_supMap = {nm |-> new_p_supMap(nm) | nm in set dom p_supMap &   new_p_supMap(nm) <> {}}
--   in
--   --------------------------------------------------------
( dcl l_subMap : map AS`Name to (AccessType| set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
                 := p_subMap,
      l_supMap : map AS`Name to (AccessType| set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
                 := p_supMap;

  let l_flatSubs = dunion { if IsAccessType(b_atp)
                            then {b_atp}
                            else b_atp
                          | b_atp in set rng p_subMap }
  in
  for all b_nm in set dom p_supMap do
  ( let b_bd = p_supMap(b_nm)
    in
      if IsAccessType(b_bd)
      then
      (
        def l_subOccs = { b_atp | b_atp in set l_flatSubs &
                                -- 20101007
                                -- NormaliseAccessType(b_atp).tp = NormaliseAccessType(b_bd).tp }
                                --TYPE`IsEquivalent(<POS>, NormaliseAccessType(b_atp).tp, NormaliseAccessType(b_bd).tp) }
                                TYPE`IsSubType(NormaliseAccessType(b_atp).tp, NormaliseAccessType(b_bd).tp, {}) }
        in
          if card l_subOccs > 0 or
             b_bd.a not in set { <PUBLIC_AS>, <PROTECTED_AS>}
          then
            l_supMap := {b_nm} <-: l_supMap;
      )
      else
        let l_pubpro = { b_atp | b_atp in set b_bd & b_atp.a in set {<PUBLIC_AS>, <PROTECTED_AS>} }
        in
          if l_pubpro = {}
          then
            l_supMap := {b_nm} <-: l_supMap
          else
            l_supMap(b_nm) := l_pubpro
  );

  for all b_subNm in set dom p_subMap do
  ( let b_bd = l_subMap(b_subNm)
    in
    ( for all b_supNm in set dom l_supMap do
        let b_supBd = l_supMap(b_supNm)
        in
        if is_(b_supBd, set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
        then
         (dcl l_matches : set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep);
          if is_(b_bd, set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
          then l_matches := { b_atp2 | b_atp2 in set b_supBd & exists b_atp1 in set b_bd &
                                    -- 20101007
                                    -- b_atp1.tp = b_atp2.tp }
                                    --TYPE`IsEquivalent(<POS>, b_atp1.tp, b_atp2.tp) }
                                    TYPE`IsSubType(b_atp1.tp, b_atp2.tp, {}) }
          else l_matches := { b_atp | b_atp in set b_supBd &
                                 -- 20101007
                                 -- b_atp.tp = b_bd.tp }
                                 --TYPE`IsEquivalent(<POS>, b_atp.tp, b_bd.tp) };
                                 TYPE`IsSubType(b_bd.tp, b_atp.tp, {}) };
          if l_matches = b_supBd
          then l_supMap := {b_supNm} <-: l_supMap
          else l_supMap(b_supNm) := l_supMap(b_supNm) \ l_matches)
     )
  );
  return l_subMap munion l_supMap;
);
\end{vdm_al}}

\begin{vdm_al}
SubSuperClType: AS`Name * REP`TypeRep ==> REP`TypeRep
SubSuperClType(clsnm,typerep) ==
   cases typerep:
     mk_REP`NilTypeRep(),
     mk_REP`BooleanTypeRep(),
     mk_REP`NumericTypeRep(-),
     mk_REP`TokenTypeRep(),
     mk_REP`CharTypeRep(),
     mk_REP`TypeVarRep(-),
     mk_REP`CompositeTypeRep(-,-),
     mk_REP`QuoteTypeRep(-) -> return typerep,
     mk_REP`TypeNameRep(nm) -> if len nm.ids = 1
                               then
                                 --if VCM`IsClassName(nm)
                                 --then return mk_REP`ObjRefTypeRep(nm)
                                 --else
                                   def newnm = LookUpTypeInSuper(nm,clsnm)
                                   in
                                     if newnm = nil
                                     then return typerep
                                     else return mk_REP`TypeNameRep(newnm)
                               --else return typerep,
                               else
                                 def ncls = mk_AS`Name([(nm.ids)(1)], nm.cid);
                                     nnm  = mk_AS`Name([(nm.ids)(len nm.ids)], nm.cid);
                                     pti = VCM`GetClassTypeRep(ncls)
                                 in
                                   if pti <> nil and nm in set dom pti.tps
                                   then return typerep
                                   elseif VCM`IsClassName(nnm)
                                   then return mk_REP`ObjRefTypeRep(nnm)
                                   else return typerep,
     mk_REP`UnionTypeRep(tps)   -> return mk_REP`UnionTypeRep({SubSuperClType(clsnm,tp) | tp in set tps}),
     mk_REP`ProductTypeRep(tpl) -> return mk_REP`ProductTypeRep([SubSuperClType(clsnm,tpl(i)) | i in set inds tpl]),
     mk_REP`SetTypeRep(tp)      -> return mk_REP`SetTypeRep(SubSuperClType(clsnm,tp)),
     mk_REP`EmptySetTypeRep(tp) -> return mk_REP`EmptySetTypeRep(SubSuperClType(clsnm,tp)),
     mk_REP`SeqTypeRep(tp)      -> return mk_REP`SeqTypeRep(SubSuperClType(clsnm,tp)),
     mk_REP`EmptySeqTypeRep(tp) -> return mk_REP`EmptySeqTypeRep(SubSuperClType(clsnm,tp)),
     mk_REP`GeneralMapTypeRep(dtp,rtp) -> return mk_REP`GeneralMapTypeRep(SubSuperClType(clsnm,dtp),
                                                                          SubSuperClType(clsnm,rtp)),
     mk_REP`InjectiveMapTypeRep(dtp,rtp) -> return mk_REP`InjectiveMapTypeRep(SubSuperClType(clsnm,dtp),
                                                                              SubSuperClType(clsnm,rtp)),
     mk_REP`EmptyMapTypeRep(dtp,rtp) -> return mk_REP`EmptyMapTypeRep(SubSuperClType(clsnm,dtp),
                                                                      SubSuperClType(clsnm,rtp)),
     mk_REP`OpTypeRep(dtpl,rtp) -> return mk_REP`OpTypeRep([SubSuperClType(clsnm,dtpl(i)) | i in set inds dtpl],
                                                           SubSuperClType(clsnm,rtp)),
     mk_REP`PartialFnTypeRep(dtpl,rtp) ->
         return mk_REP`PartialFnTypeRep([SubSuperClType(clsnm,dtpl(i)) | i in set inds dtpl],
                                        SubSuperClType(clsnm,rtp)),
     mk_REP`TotalFnTypeRep(dtpl,rtp) ->
         return mk_REP`TotalFnTypeRep([SubSuperClType(clsnm,dtpl(i)) | i in set inds dtpl],
                                      SubSuperClType(clsnm,rtp)),
     mk_REP`InvTypeRep(name,shape,invariant) -> return mk_REP`InvTypeRep(name,SubSuperClType(clsnm,shape),invariant),
     others -> return typerep
   end;

LookUpTypeInSuper: AS`Name * AS`Name ==> [AS`Name]
LookUpTypeInSuper(tpnm_,clsnm_) ==
  if VCM`IsClassName(tpnm_)
  then return nil
  else
 (dcl tpnm : AS`Name,
      clsnm : AS`Name;
  if len tpnm_.ids = 1
  then
   (tpnm := tpnm_;
    clsnm := clsnm_)
  else
   (tpnm := mk_AS`Name([(tpnm_.ids)(2)],CI`NilContextId);
    clsnm := mk_AS`Name([(tpnm_.ids)(1)],CI`NilContextId));

  def classinfo = LookUpClass(clsnm);
      --extnm = if len tpnm.ids = 1
      --        then AUX`ExtName(clsnm,tpnm)
      --        else tpnm
      extnm = AUX`ExtName(clsnm,tpnm)
  in
    if not is_ParseTypeInfo(classinfo)
    then return nil
    elseif extnm in set dom classinfo.tps
    --then return extnm
    then
      let tps = classinfo.tps
      in
        if CheckAccessCurClass(tps(extnm)) = nil
        then return nil
        else return extnm
    else (let supers = classinfo.super
          in
            for all sup in set supers do
              def nm = LookUpTypeInSuper(tpnm,sup)
              in
                if nm <> nil
                then return nm;
          return nil);
 );

#endif VDMPP
#ifdef VDMSL
    LookUpPolyFn: AS`Name ==> [(seq of REP`TypeVarRep) * REP`FnTypeRep]
    LookUpPolyFn(nm) ==
      (let depth = len SEnv in
         for i=1 to depth do
           let CurrentEnv = SEnv(i) in
             if nm in set dom CurrentEnv and is_REP`PolyTypeRep(CurrentEnv(nm).tp)
             then (SEnv(i)(nm).used := true;
                   return mk_((CurrentEnv(nm).tp).vars, (CurrentEnv(nm).tp).tp));
      if nm in set dom PolyEnv
      then (PolyEnv(nm).used := true;
            return mk_(PolyEnv(nm).poly,PolyEnv(nm).tp))
      else return nil);
#endif VDMSL

    CheckTypeVar: REP`TypeVarRep ==> bool
    CheckTypeVar(tv) ==
      return exists tvs in set elems TypeVars & tv in set tvs;

  CheckTag: AS`Name ==> bool
  CheckTag(nm) ==
    if nm in set dom TagEnv
    then return true
#ifdef VDMPP
    else return (LookUpInHierarchy(nm,nil,<TAG>,<GLOBAL>) <> nil);
#endif VDMPP
#ifdef VDMSL
    else return nm in set dom LocTagEnv;
#endif VDMSL

  CheckLocalTag: AS`Name ==> bool
  CheckLocalTag(nm) ==
    return nm in set dom TagEnv;

#ifdef VDMSL
  CheckImportedTag: AS`Name ==> bool
  CheckImportedTag(nm) ==
    return nm in set dom LocTagEnv;
#endif VDMSL

  CheckTypeName: AS`Name ==> bool
  CheckTypeName(nm) ==
#ifdef VDMPP
    if len nm.ids > 1
    then
      let ncls = mk_AS`Name([(nm.ids)(1)],CI`NilContextId),
          nnm  = mk_AS`Name([(nm.ids)(2)],CI`NilContextId)
      in
        if ncls = GetCurClass ()
        then CheckTypeName (nnm)
        else
          def looktp = LookUpInHierarchy(nnm, ncls, <TYPE>, <GLOBAL>)
          in
            if looktp <> nil
            then
              def acs = CheckAccessCurClass (looktp)
              in
                if acs = nil
                then
                   ------------------------------
                   -- Error message #368
                   -- Access violation
                   ------------------------------
                  (ERR`GenErr (nm,<ERROR>,368,[PrintName (nm)]);
                   return false)
                else
                  return true
            else
              return true
    else
#endif VDMPP
    if (nm in set dom TypeEnv) and (TypeEnv(nm).tp <> mk_REP`AllTypeRep())
    then (TypeEnv(nm).used := true;
          return true)
#ifdef VDMSL
--    elseif nm in set dom TypeParEnv
--    then return true
    elseif nm in set dom RenamedTypes
    then CheckTypeName(RenamedTypes(nm))
#endif VDMSL
    else
#ifdef VDMPP
      def looktp = LookUpInHierarchy(nm,nil,<TYPE>,<GLOBAL>)
      in
        if looktp <> nil
        then
          def acs = CheckAccessCurClass (looktp)
          in
            if acs = nil
            then
              ------------------------------
              -- Error message #368
              -- Access violation
              ------------------------------
             (ERR`GenErr (nm,<ERROR>,368,[PrintName (nm)]);
              return false)
            else
              return true
        else
          return CheckClassName(nm);
#endif VDMPP
#ifdef VDMSL
      return false;
#endif VDMSL

  CheckOperationName: AS`Name ==> bool
  CheckOperationName(nm) ==
    if nm in set dom OperationEnv
    then (OperationEnv(nm).used := true;
          return true)
    else
#ifdef VDMSL
      return false;
#endif VDMSL
#ifdef VDMPP
      return (LookUpOperationName(nil,nm,nil) <> {});
#endif VDMPP

\end{vdm_al}

\subsection{Initialisation of Environment Components}

\begin{vdm_al}
#ifdef VDMSL
  SetCurMod: AS`Name ==> ()
  SetCurMod(modnm) ==
    CheckModule := modnm;

  GetCurMod : () ==> AS`Name
  GetCurMod() ==
    return CheckModule
  pre CheckModule <> nil;
#endif VDMSL

  GetCurModOrNil: () ==> [AS`Name]
  GetCurModOrNil() ==
#ifdef VDMSL
    return CheckModule;
#endif VDMSL
#ifdef VDMPP
    return nil;
#endif VDMPP

#ifdef VDMPP
  InstallCurClass: AS`Name * seq of AS`Name ==> bool
  InstallCurClass(classnm, super) ==
   (SetCurClass(classnm);
    if not CheckClassName(classnm)
    then return false
    else
     ( -- only classes inherited in the header are immediate superclasses
      Super := elems super;
      SuperSuper := TransClos(classnm);
      return true
     )
   );

  SetCurClass: AS`Name ==> ()
  SetCurClass(cls) ==
    CheckClass := cls;

  GetCurClass : () ==> AS`Name
  GetCurClass() ==
    return CheckClass
  pre CheckClass <> nil;

  IsAccessible: AS`Name * AccessType ==> bool
  IsAccessible (cls',acs) ==
    let cls = mk_AS`Name ( [hd cls'.ids],cls'.cid)
    in
      cases acs.a:
        <PUBLIC_AS>          -> return true,
        <PROTECTED_AS>       -> return cls in set Super union SuperSuper or cls = GetCurClass (),
        <PRIVATE_AS>,
        <NOT_INITIALISED_AS> -> return cls = GetCurClass (),
        others -> error
      end;

  IsAccessibleCurClass : AccessType ==> bool
  IsAccessibleCurClass (acs) ==
    return IsAccessible (GetCurClass (), acs);

  CheckAccess: AS`Name * [AccessType|REP`TypeRep|TagRepElem |
               set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep) | set of REP`TypeRep]
               ==> [REP`TypeRep|TagRepElem | set of (REP`FnTypeRep | REP`OpTypeRep  | REP`PolyTypeRep)]
  CheckAccess (cls,tp) ==
    def l_defcl = LookUpDefClass();
    in
    cases true:
      (is_(tp, set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))) ->
                       def l_actcl = if l_defcl = nil
                                     then cls
                                     else l_defcl;
                           l_tps = { b_atp.tp | b_atp in set tp & IsAccessible(l_actcl, b_atp) }
                       in
                          if l_tps = {}
                          then return nil
                          else return l_tps,
      (IsAccessType (tp)) -> (dcl gtp : [REP`TypeRep |
                                          ENV`AccessType |
                                          set of (ENV`AccessOpTypeRep |
                                                  ENV`AccessFnTypeRep |
                                                  ENV`AccessPolyTypeRep) |
                                          set of REP`TypeRep] := nil;
                               if (cls <> GetCurClass ())
                               then
                                (SetDefClass(GetCurClass ());
                                 gtp := LookUp(cls, false);
                                 UnSetDefClass();
                                 if (IsAccessType(gtp))
                                 then CheckLookupStatic(cls, gtp.stat));
                               if
#ifdef VICE
                                  not staticrequired or
#endif VICE
                                  (l_defcl <> nil and IsAccessible (l_defcl,tp)
                                     and (gtp = nil => IsAccessible (cls,tp))) or
                                  (l_defcl = nil and IsAccessible (cls,tp))
                               then return tp.tp
                               else return nil),
      others -> return tp
    end;

\end{vdm_al}
The function \texttt{ConvertAccessMethToRep} is a utility function
which takes either an operation type or a function type and returns
the corresponding function type.
\begin{vdm_al}
operations

--  ConvertAccessMethToRep : (REP`OpTypeRep | REP`FnTypeRep | REP`PolyTypeRep) -> REP`FnTypeRep
--  ConvertAccessMethToRep(p_meth) ==
--    if is_REP`OpTypeRep(p_meth)
--    then mk_REP`TotalFnTypeRep(p_meth.Dom, p_meth.Rng)
--    else p_meth;

  CheckAccessCurClass:[ AccessType  |
                        REP`TypeRep |
                        TagRepElem  |
                        set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep) |
                        set of REP`TypeRep]
                      ==> [ REP`TypeRep | TagRepElem  | set of (REP`FnTypeRep | REP`OpTypeRep | REP`PolyTypeRep) ]
  CheckAccessCurClass (tp) ==
    def defcl = LookUpDefClass ()
    in
      if defcl = nil
      then return CheckAccess (GetCurClass (),tp)
      else return CheckAccess (defcl,tp);

functions
  IsAccessType: [AccessType|REP`TypeRep|TagRepElem|
                 set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep)|
                 set of (REP`OpTypeRep | REP`FnTypeRep)] -> bool
  IsAccessType (a) ==
    is_AccessTypeRep (a) or
    is_AccessFnTypeRep (a) or
    is_AccessPolyTypeRep (a) or
    is_AccessOpTypeRep (a) or
    is_AccessFieldRep (a);

  IsAccessTypeSet: [AccessType|REP`TypeRep|TagRepElem|
                    set of (REP`OpTypeRep |
                            REP`FnTypeRep |
                            REP`PolyTypeRep |
                            AccessOpTypeRep |
                            AccessFnTypeRep |
                            AccessPolyTypeRep)] -> bool
  IsAccessTypeSet (a) ==
    is_(a, set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep));

  StripAccessType: [AccessType|REP`TypeRep|TagRepElem] -> [REP`TypeRep|seq of REP`FieldRep]
  StripAccessType (tp) ==
    if IsAccessType (tp)
    then tp.tp
    else tp
\end{vdm_al}

The operation \texttt{CheckInstAccess} is used to check that the
access permission for an instance variable is consistent with any
instance variables of the same name in a superclass.

\begin{vdm_al}
operations

  CheckInstAccess: AS`Access * AS`Name ==> bool
  CheckInstAccess(p_acc, p_nm) ==
  ( dcl l_res : bool := true;
    for all b_clnm in set Super do
      def l_acs = LookUpInObject(b_clnm, p_nm,true,true)
      in
        if l_acs <> nil and not NotNarrowedAccess(l_acs.a, p_acc)
        then
        ( --------------------------------------
          -- Error 369
          -- Scope narrowed by "%1"
          -------------------------------------
          ERR`GenErr (p_nm, <ERROR>,369,[PrintName (p_nm)]);
          l_res := false
        );
    return l_res
  );

  CheckTypeDefAccess: AS`Access * AS`Name ==> bool
  CheckTypeDefAccess(p_acc, p_nm) ==
  ( dcl l_res : bool := true;
    for all b_clnm in set Super do
      def tp_acs = LookUpTypeName(AUX`ExtName(b_clnm,p_nm),false)
      in
        if tp_acs <> nil and not NotNarrowedAccess(tp_acs.a, p_acc)
        then
        ( --------------------------------------
          -- Error 369
          -- Scope narrowed by "%1"
          -------------------------------------
          ERR`GenErr (p_nm, <ERROR>,369,[PrintName (p_nm)]);
          l_res := false
        );
    return l_res
  );

  CheckDefAccess: AccessType * AS`Name ==> bool
  CheckDefAccess(p_act, p_nm) ==
   (dcl l_res : bool := true;
    dcl p_acc : AS`Access := p_act.a;
    for all b_clnm in set SuperSuper do
      def tp_acs = LookUp(AUX`ExtName(b_clnm,p_nm),false);
          tp_acs_s = { acs | acs in set if is_(tp_acs,REP`TypeRep) or is_(tp_acs,AccessType)
                                        then {tp_acs}
                                        elseif is_(tp_acs,set of REP`TypeRep) or is_(tp_acs,set of AccessType)
                                        then tp_acs
                                        else {} &
                        TYPE`IsCompatible(<POS>, StripAccessType(p_act), StripAccessType(acs)) }
      in
       (if exists acs in set tp_acs_s & not NotNarrowedAccess(acs.a, p_acc)
        then
         (--------------------------------------
          -- Error 369
          -- Scope narrowed by "%1"
          -------------------------------------
          ERR`GenErr (p_nm, <ERROR>,369,[PrintName (p_nm)]);
          l_res := false);
        if exists acs in set tp_acs_s & is_(p_act,AccessOpTypeRep) and not p_act.oppure and acs.oppure
        then
         (--------------------------------------
          -- Error 461
          -- Impure operation "%1" override pure operation
          -------------------------------------
          ERR`GenErr (p_nm, <ERROR>,461,[PrintName (p_nm)]);
          l_res := false);
       );
    return l_res
   );

  CheckPatternBindAccess: AS`Access * map AS`Name to (REP`TypeRep * nat1) ==> bool
  CheckPatternBindAccess(acc,bd) ==
  ( dcl res : bool := true;
    for all nm in set dom bd do
      def tp = bd(nm).#1;
          acs = LookUpInObject (GetCurClass (),nm,false,true);
          acsSet = if is_(acs, set of AccessType) then acs else {acs}
      in
      ( for all b_acs in set acsSet do
        ( cases tp:
            mk_REP`TypeNameRep(asnm),
            mk_REP`CompositeTypeRep(asnm,-) -> res := CheckTypeAccessAux (b_acs.a,
                                                                          mk_AS`TypeName(asnm,CI`NilContextId))
                                                      and res,
            others -> skip
          end;
        );
        for all b_clnm in set Super do
          def acs = LookUpInObject(b_clnm, nm, false,true)
          in
            if acs <> nil
            then if (is_(acs, set of AccessType)
                     and exists b_acs in set acs & not NotNarrowedAccess(b_acs.a, acc)) or
                    not NotNarrowedAccess(acs.a, acc)
            then
            ( --------------------------------------
              -- Error 369
              -- Scope narrowed by "%1"
              -------------------------------------
              ERR`GenErr (nm, <ERROR>,369,[PrintName (nm)]);
              res := false
            )

      );

    return res
  );

  CheckTypeListAccess: AS`Name * seq of AS`Type ==> bool
  CheckTypeListAccess(nm,tp_l) ==
  ( dcl res : bool := true;
    for tp in tp_l do
      res := CheckTypeAccess (nm,tp) and res;
    return res);

  CheckTypeAccess: AS`Name * AS`Type ==> bool
  CheckTypeAccess (nm,tp) ==
    def local_tp = LookUpInHierarchy(nm,GetCurClass(),<TYPE>,<LOCAL>);
    in
     (dcl nm_acs : [REP`TypeRep | AccessType | (AS`Name * AccessFieldRep) | set of AccessType];
      if local_tp = nil
      then nm_acs := LookUpInHierarchy(nm,GetCurClass(),<VAL>,<LOCAL>)
      else nm_acs := local_tp;
      if nm_acs = nil
      then return true
      elseif is_(nm_acs, set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
      then ( dcl reswf : bool := true;
             for all l_atr in set nm_acs do
               reswf := CheckTypeAccessAux(l_atr.a, tp) and reswf;
             return reswf
           )
      else
        CheckTypeAccessAux (nm_acs.a,tp);
     );

  CheckThreadInherit: AS`Name ==> bool
  CheckThreadInherit(clsnm) ==
  ( dcl cl_s : set of AS`Name := {};
    for all b_clnm in set SuperSuper do
      def clrep = VCM`GetClassTypeRep(b_clnm)
      in
        if clrep <> nil and clrep.thread <> <NONE>
        then cl_s := cl_s union {b_clnm};
    let wf = card cl_s <= 1
    in
      (if not wf
       then (dcl nm_l : seq of char := "";
             let cl1 in set cl_s in
             (for all nm in set cl_s \ {cl1} do
                 nm_l := nm_l ^ PrintName (nm) ^", ";
              nm_l := nm_l ^ PrintName(cl1);
              --------------------------------------
              -- Error 427
              -- Multiple threads are inherited from "%1"
              -------------------------------------
              ERR`GenErr (clsnm, <ERROR>,427,[nm_l]))
            );
        return wf
       );
  );

\end{vdm_al}
The functions \texttt{GetMethDom} and \texttt{GetMethRng} are utility
functions which respectively return the domain type or the range type
of a function or an operation type.
\begin{vdm_al}
#endif VDMPP
functions

#ifdef VDMPP
  GetMethRng : (REP`OpTypeRep | REP`FnTypeRep) -> REP`TypeRep
  GetMethRng(p_atr) ==
    cases p_atr:
      mk_REP`OpTypeRep(-,oprng)        -> oprng,
      mk_REP`PartialFnTypeRep(-,fnrng),
      mk_REP`TotalFnTypeRep(-,fnrng)   -> fnrng,
      others -> undefined
    end;
#endif VDMPP

  GetMethDom : (REP`OpTypeRep | REP`FnTypeRep) -> seq of REP`TypeRep
  GetMethDom(p_atr) ==
    cases p_atr:
      mk_REP`OpTypeRep(opdom,-)        -> opdom,
      mk_REP`PartialFnTypeRep(fndom,-),
      mk_REP`TotalFnTypeRep(fndom,-)   -> fndom,
      others -> undefined
    end;

operations
#ifdef VDMPP

  CheckTypeAccessAux: AS`Access * AS`Type ==> bool
  CheckTypeAccessAux (main_acs,tp) ==
  ( dcl reswf : bool := true;

    cases tp:
      mk_AS`BooleanType(-),
      mk_AS`NumericType(-,-),
      mk_AS`TokenType(-),
      mk_AS`CharType(-) -> return true,
      mk_AS`VoidType(-) -> return true,
      mk_AS`QuoteType(-,-) -> return true,
      mk_AS`ProductType(tp_l,-),
      mk_AS`UnionType(tp_l,-) -> (for tp in tp_l do
                                    reswf := CheckTypeAccessAux (main_acs, tp) and reswf;
                                  return reswf),
      mk_AS`CompositeType(-,flds,-) -> (for mk_AS`Field (-, ftp,-,-) in flds do
                                          reswf := CheckTypeAccessAux (main_acs, ftp) and reswf;
                                        return reswf),
      mk_AS`OptionalType(tp,-),
      mk_AS`Seq0Type(tp,-),
      mk_AS`Seq1Type(tp,-),
      mk_AS`BracketedType(tp,-),
      mk_AS`Set0Type(tp,-),
      mk_AS`Set1Type(tp,-) -> return CheckTypeAccessAux(main_acs, tp),
      mk_AS`GeneralMap0Type(dtp, rtp, -),
      mk_AS`GeneralMap1Type(dtp, rtp, -),
      mk_AS`InjectiveMap0Type(dtp, rtp, -),
      mk_AS`InjectiveMap1Type(dtp,rtp, -) -> (reswf := CheckTypeAccessAux(main_acs,dtp);
                                             reswf := CheckTypeAccessAux(main_acs,rtp) and reswf;
                                             return reswf),
      mk_AS`OpType(dtp_l,rtp,-) -> (for dtp in dtp_l do
                                      reswf := CheckTypeAccessAux(main_acs,dtp) and reswf;
                                    reswf := CheckTypeAccessAux(main_acs,rtp) and reswf;
                                    return reswf),
      mk_AS`PartialFnType(dtp_l,rtp,-),
      mk_AS`TotalFnType(dtp_l,rtp,-) -> (for dtp in dtp_l do
                                           reswf := CheckTypeAccessAux(main_acs,dtp) and reswf;
                                         reswf := CheckTypeAccessAux(main_acs,rtp) and reswf;
                                         return reswf),
      mk_AS`TypeName(nm,-) -> def lookup = LookUpTypeName (nm,true)
                              in
                                if is_REP`ObjRefTypeRep(lookup) -- XXXXPMs
                                then
                                  return true
                                else
                                  def acc = CheckAccessCurClass(lookup) in
                                  if acc = nil
                                  then (
                                    ---------------------------------
                                    -- Error 368
                                    ----------------------------------
                                    ERR`GenErr (nm,<ERROR>,368,[PrintName (nm)]);
                                    return false)
                                   else
                                  def tp_acs = LookUpAccessForType (lookup,nm) in
                                  if NotNarrowedAccess (main_acs,tp_acs)
                                  then return true
                                  else (
                                    --------------------------------------
                                    -- Error 369
                                    -- Scope narrowed by "%1"
                                    -------------------------------------
                                    ERR`GenErr (nm, <ERROR>,369,[PrintName (nm)]);
                                    return false),
      mk_AS`TypeVar(-,-) -> return true,-- only in VDM-SL
      others -> error
    end);

  LookUpAccessForType: (AccessType|REP`TypeRep) * AS`Name  ==> AS`Access
  LookUpAccessForType (tp,nm) ==
    if IsAccessType (tp)
    then return tp.a
    else
      def lu = LookUpInHierarchy(nm,GetCurClass(),<TYPE>,<LOCAL>)
      in
        if lu = nil
        then
          def lu' = LookUpInHierarchy(nm,GetCurClass(),<VAL>,<LOCAL>)
          in
            if lu' <> nil
            then
              if is_(lu', set of (AccessOpTypeRep | AccessFnTypeRep | AccessPolyTypeRep))
              -- Can only occur if tp is an obj ref type
              -- In which case return values all have rng type
              -- type name with name corresponding to obj ref type
              -- The one we want has the same cid
              then
                let l_matches = { b_atr | b_atr in set lu' & GetMethRng(b_atr.tp).nm.cid = tp.nm.cid }
                in
                  if l_matches = {}
                  then return <NOT_INITIALISED_AS>
                  else let {l_atr} = l_matches
                       in return l_atr.a
              else return lu'.a
            else return <NOT_INITIALISED_AS>
        else return lu.a;

functions

  NotNarrowedAccess: AS`Access * AS`Access +> bool
  NotNarrowedAccess (master,slave) ==
  if slave = <NOT_INITIALISED_AS> then true
  else
    cases master:
      <PUBLIC_AS>          -> slave = master,
      <PROTECTED_AS>       -> slave = master or slave = <PUBLIC_AS>,
      <PRIVATE_AS>,
      <NOT_INITIALISED_AS> -> true
    end

operations
  CheckSubRespIsImplemented: TYPE`Ind * AS`Name ==> bool
  CheckSubRespIsImplemented(-, nm) ==
  def mk_(notimplemented,-) = GetSubResps(nm)
  in
   (if notimplemented <> {|->}
    then
      for all n in set dom notimplemented do
        ----------------------------------------------
        -- Error message #439
        -- Function/operation "%1" must be implemented
        ----------------------------------------------
        ERR`GenErr(nm,<ERROR>,439,[PrintName(let mk_AS`Name(ids,cid) = n
                                             in mk_AS`Name(tl ids,cid))]);
    return notimplemented = {|->});

  GetSubResps: AS`Name ==> map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                           set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                         * map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                           set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
  GetSubResps(nm) ==
    if nm in set dom SubrespsEnv
    then return SubrespsEnv(nm)
    else
    (def l_pte = VCM`GetClassTypeRep(nm)
     in
       if l_pte = nil
       then return mk_({|->},{|->})
       else
         let super = l_pte.super
         in
          (dcl notimplemented : map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                          set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                      := l_pte.subresps,
               implemented : map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                          set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                      := {|->},
               impl : map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                          set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                      := {|->};
           if super <> {}
           then
            (let fcts = l_pte.fcts
             in for all n in set dom fcts do
               if not n in set dom notimplemented then implemented(n) := fcts(n);
             let polys = l_pte.polys
             in for all n in set dom polys do
               if not n in set dom notimplemented then implemented(n) := polys(n);
             let ops = l_pte.ops
             in for all n in set dom ops do
               if not n in set dom notimplemented then implemented(n) := ops(n);
             let overloaded = l_pte.overloaded
             in for all n in set dom overloaded do
             if not n in set dom notimplemented
               then implemented(n) := overloaded(n)
               else
                 let atp = overloaded(n)
                 in (dcl over : set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep)
                           := overloaded(n);
                      over := over \ if is_(atp, set of (ENV`AccessOpTypeRep |
                                                         ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                                     then atp
                                     else {atp};
                      cases over :
                        {} -> skip,
                        {x} -> implemented(n) := x,
                        others -> implemented(n) := over
                      end;);

             (dcl sb : map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                       set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                     := {|->},
                  mergedimpl : map AS`Name to (ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep | ENV`AccessOpTypeRep |
                                       set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                     := implemented;

              for all clnm in set super do
                def mk_(sb0, impl0) = GetSubResps(clnm)
               in
                 (sb := sb ++ sb0;
                  impl := impl ++ impl0);

              for all ng in set dom impl do
                let mk_AS`Name(ids,cid) = ng,
                    mk_AS`Name([modid],-) = nm,
                    nn = mk_AS`Name([modid]^[ids(len ids)], cid)
                in
                  if nn in set dom mergedimpl
                  then
                    let atp1 = mergedimpl(nn),
                        atp2 = impl(ng),
                        atp = (if is_(atp1, set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                              then atp1 else {atp1})
                              union
                              (if is_(atp2, set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                              then atp2 else {atp2})
                    in
                      mergedimpl := mergedimpl ++ {nn |-> atp}
                  else
                    mergedimpl := mergedimpl ++ {nn |-> impl(ng)};

              SetDefClass(nm);
              for all mnm in set dom sb do
                let mk_AS`Name(ids,cid) = mnm,
                    mk_AS`Name([modid],-) = nm,
                    nn = mk_AS`Name([modid]^[ids(len ids)], cid),
                    atp2 = sb(mnm)
                in
                  (dcl atp2_s : set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep)
                           := if is_(atp2, set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                              then atp2 else {atp2};
                   if nn in set dom mergedimpl
                   then
                     def atp1 = mergedimpl(nn);
                         atp1_s = if is_(atp1, set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                                  then atp1 else {atp1};
                         eqs = { atp2g | atp2g in set atp2_s &
                                       exists atp1g in set atp1_s &
                                         TYPE`IsEquivalent(<POS>, StripAccessType(atp1g), StripAccessType(atp2g)) }
                     in atp2_s := atp2_s \ eqs;

                   cases atp2_s:
                     {}     -> skip,
                     {x}    -> notimplemented := notimplemented ++ { mnm |-> x },
                     others -> notimplemented := notimplemented ++ { mnm |-> atp2_s }
                   end);
              UnSetDefClass()));

             for all n in set dom implemented do
               let atp = implemented(n),
                   atps = if is_(atp, set of (ENV`AccessOpTypeRep | ENV`AccessPolyTypeRep | ENV`AccessFnTypeRep))
                          then atp else {atp},
                   atps2 = { a | a in set atps & a.a = <PUBLIC_AS> or a.a = <PROTECTED_AS> }
               in
                 cases atps2:
                   {}     -> skip,
                   {e}    -> impl := impl ++ { n |-> e },
                   others -> impl := impl ++ { n |-> atps2 }
                 end;
             SubrespsEnv(nm) := mk_(notimplemented, impl);
             return mk_(notimplemented, impl)));

#endif VDMPP
#ifdef VDMSL
--  InstallParEnv: map AS`Name to REP`TypeRep ==> ()
--  InstallParEnv(parenv) ==
--    TypeParEnv := parenv;

  LeaveCurModule: AS`Name * [AS`ExportSig] ==> ()
  LeaveCurModule(modid,exp) ==
   let mk_(tps,val,fns,ops) =
          if exp = nil
          then mk_({|->},{|->},{|->},{|->})
          else mk_(exp.tps,exp.val,exp.fns,exp.ops)
   in
   (for all nm in set (dom val) inter (dom ConstEnv) do
      if not (ConstEnv(nm)).used and nm not in set dom val
           --------------------------------------------
           -- Error message #53
           -- The value "%1" is not used in module "%2"
           --------------------------------------------
      then ERR`GenErr(nm,<WARNING>,53,[PrintName(nm),PrintName(modid)]);

    for all nm in set dom StateEnv do
     if not (StateEnv(nm)).used
          ------------------------------------------------------
          -- Error message #48
          -- The state component "%1" is not used in module "%2"
          ------------------------------------------------------
     then ERR`GenErr(nm,<WARNING>,48,[PrintName(nm),PrintName(modid)]);
    for all nm in set dom TypeEnv do
     if not (TypeEnv(nm)).used and nm not in set dom tps and
        not AUX`TypeUsedImplicitly(nm,{tre.tp | tre in set rng TypeEnv})
          -------------------------------------------
          -- Error message #49
          -- The type "%1" is not used in module "%2"
          -------------------------------------------
     then ERR`GenErr(nm,<WARNING>,49,[PrintName(nm),PrintName(modid)]);
    for all nm in set dom FunctionEnv do
     if not (FunctionEnv(nm)).used and nm not in set dom fns and
            not AUX`IsPrePostFn(nm)
          -----------------------------------------------
          -- Error message #50
          -- The function "%1" is not used in module "%2"
          -----------------------------------------------
     then ERR`GenErr(nm,<WARNING>,50,[PrintName(nm),PrintName(modid)]);
    for all nm in set dom PolyEnv do
     if not (PolyEnv(nm)).used and nm not in set dom fns
          -----------------------------------------------
          -- Error message #50
          -- The function "%1" is not used in module "%2"
          -----------------------------------------------
     then ERR`GenErr(nm,<WARNING>,50,[PrintName(nm),PrintName(modid)]);
    for all nm in set dom OperationEnv do
     if not (OperationEnv(nm)).used and nm not in set dom ops and
        not AUX`IsPrePostFn(nm)
          ------------------------------------------------
          -- Error message #52
          -- The operation "%1" is not used in module "%2"
          ------------------------------------------------
     then ERR`GenErr(nm,<WARNING>,52,[PrintName(nm),PrintName(modid)]);
    for all nm in set dom ConstEnv do
     if not (ConstEnv(nm)).used and nm not in set dom val
          --------------------------------------------
          -- Error message #53
          -- The value "%1" is not used in module "%2"
          --------------------------------------------
     then ERR`GenErr(nm,<WARNING>,53,[PrintName(nm),PrintName(modid)]));
#endif VDMSL
\end{vdm_al}



#ifdef VDMPP
\subsection{Class Expansion}

Expand the definitions from the given class

\begin{vdm_al}
  ExpandClass: TYPE`Ind * AS`Class ==> bool
  ExpandClass(i, mk_AS`Class(nm,sys,super, defs, -, -)) ==
  (-- Initialise environment
   InitEnv();

   -- Initialize current class
   if not InstallCurClass(nm,super) then
    return false;

   if defs = nil then
     return true
   else
   ( dcl expanded: bool := ExpandDefinitions(i,nm,defs);
     if expanded then
       let vals = { AUX`ExtName(nm,vnm) |-> AUX`QualifyTypeNames(ConstEnv(vnm).tp,nm)
                    | vnm in set ValueIds }in
         VCM`UpdateValuesInParseEnv(nm,vals);
      if sys and super <> [] then
        ------------------------------------------
        -- Error message #433
        -- The system class %1 cannot inherit from other classes
      ( ERR`GenErr(nm,<ERROR>, 433, [PrintName(nm)]);
        return false
      )
      else return expanded
    )
  );
\end{vdm_al}

#endif VDMPP
#ifdef VDMSL
\subsection{Module Expansion}

Expansion of a module is started by expanding the types from the
imported and instantiated modules. This is done first because these
types (with their possible renamings) can be used in the signature of
other constructs used in the body of the module being checked or in
the signatures of the constructs from the imported or instantiated
modules. This is followed by an expansion of all definitions in the
module being checked. This initialises all the environment components
which are related to the different kinds of constructs. In this
expansion of the definition will value definitions which have not been
explicitly typed be mapped to a $mk-REP`TmpTypeRep$ value. Then the
interface is expanded in this context and the environment components
are updated withg new constructs. Finally, the well-formedness of the
value definitions is checked and the $mk-REP`TmpTypeRep$'s are
replaced with the types inferred by well-formedness checking of the
defining expressions.

\begin{vdm_al}

  ExpandDLModule: TYPE`Ind * AS`DLModule ==> bool
  ExpandDLModule(i,mk_AS`DLModule(modid,mk_AS`DLInterface(imp_m,exp,-),-,-)) ==
    (dcl reswf: bool := true;
     SetCurMod(modid);
     for all nm in set dom imp_m \ {modid} do
       reswf := ExpandDLImport(nm,imp_m(nm),modid) and reswf;
     let mk_AS`DLExportSig(val,fns,ops,-) = exp
     in
      (for all nm in set dom val do
         reswf := DEF`wf_Type(i,val(nm)) and reswf;
       for all nm in set dom fns do
         reswf := DEF`wf_Type(i,fns(nm)) and reswf;
       for all nm in set dom ops do
         reswf := DEF`wf_Type(i,ops(nm)) and reswf);
     return reswf);

  ExpandDLImport: AS`Name * AS`DLImportSig * AS`Name ==> bool
  ExpandDLImport(fromid,imp,-) ==
    def mk_(-, exp) = VCM`GetModuleRep(fromid);
        mk_VCM`ExpSigRep(tpsr,-,-,-,-,-,-) = exp;
        tp_imps = {if len nm.ids = 1
                   then AUX`ExtName(fromid,nm)
                   else nm |-> (imp.tps)(nm) | nm in set dom (imp.tps)};
        unknowns = dom tp_imps \ (dom tpsr)
      in
        (dcl reswf: bool := true;
         for all tpnm in set unknowns do
           -------------------------------------------------
           -- Error message #55
           -- The type "%1" is not exported from module "%2"
           -------------------------------------------------
          (ERR`GenErr(tpnm, <ERROR>,55,[PrintName(tpnm),PrintName(fromid)]);
           reswf := false);
         TypeEnv := TypeEnv munion {nm |-> mk_TypeRepElem(tpsr(nm),true, false) | nm in set dom tp_imps \ unknowns}
                            munion {nm |-> mk_TypeRepElem(mk_REP`TypeParRep(nm), true, false) | nm in set unknowns};
         return reswf);

  ExpandModule: TYPE`Ind * (AS`Module|AS`DLModule) ==> bool
  ExpandModule(i,m) ==
    cases m:
      mk_AS`Module(nm,intf,defs,-) ->
       (dcl reswf : bool := true;
        SetCurMod(nm);

        InsideInter := true;
        reswf := ExpandTypeImports(i,nm,intf);
        InsideInter := false;
        reswf := ExpandDefinitions(i,nm,defs) and reswf;
        InsideInter := true;
        reswf := ExpandInterface(i,nm,intf) and reswf;
        InsideInter := false;
        reswf := ExtractValueDefs(i,defs.valuem) and reswf;
        return reswf),
      mk_AS`DLModule(-,-,-,-) -> return ExpandDLModule(i,m),
      others -> error
    end;

  ExpandTypeImports: TYPE`Ind * AS`Name * AS`Interface ==> bool
  ExpandTypeImports(i,modid,mk_AS`Interface(imp_m,-,-)) ==
    (dcl reswf : bool := true;
     for all nm in set dom imp_m \ {modid} do
       reswf := ExpandTypeImport(i,nm,imp_m(nm),modid) and reswf;
     return reswf);

  ExpandTypeImport : TYPE`Ind * AS`Name * [AS`ImportSig] * AS`Name ==> bool
  ExpandTypeImport(i,modid,sig,curmod) ==
    def mk_(parsed, exp):bool * VCM`ExpSigRep = VCM`GetModuleRep(modid)
    in
      cases sig:
        nil -> (if parsed
                then
                  let mk_VCM`ExpSigRep(tpsr,-,-,-,-,-,-) = exp
                  in TypeEnv := TypeEnv munion {nm |-> mk_TypeRepElem(tpsr(nm), true, false) | nm in set dom tpsr}
                else skip;
                return true),
        mk_AS`ImportSig(tps,-,-,-,ren,-) -> def tps' = {if len nm.ids = 1
                                                        then AUX`ExtName(modid,nm)
                                                        else nm |-> tps(nm)
                                                                | nm in set dom tps};
                                                mk_(tps'',ren') = CheckTypeRename(tps',ren,modid)
                                            in
                                              return ImportTypes(i,ren',tps'',exp.tps,modid,curmod)
      end;

  CheckImpTypeDef:REP`TypeRep * AS`Name ==> bool
  CheckImpTypeDef(tp,modid) ==
    cases tp:
      mk_REP`AllTypeRep(),
      mk_REP`UnitTypeRep(),
      mk_REP`NilTypeRep(),
      mk_REP`EmptySetTypeRep(-),
      mk_REP`EmptySeqTypeRep(-),
      mk_REP`EmptyMapTypeRep(-,-),
      mk_REP`BooleanTypeRep(),
      mk_REP`NumericTypeRep(-),
      mk_REP`TokenTypeRep(),
      mk_REP`CharTypeRep(),
      mk_REP`QuoteTypeRep(-),
      mk_REP`TypeVarRep(-),
      mk_REP`TypeParRep(-)               -> return true,
      mk_REP`TypeNameRep(nm)             ->
         if nm in set dom TypeEnv or nm in set dom RenamedTypes
         then return true
               ----------------------------------------
               -- Error message #57
               -- The type "%1" is not imported in "%2"
               ----------------------------------------
         else (ERR`GenErr(nm,<ERROR>,57,[PrintName(nm),PrintName(modid)]);
               TypeEnv := TypeEnv munion {nm |-> mk_TypeRepElem(mk_REP`AllTypeRep(),true, false)};
               return false),
      mk_REP`CompositeTypeRep(-, fields) -> (dcl reswf : bool := true;
                                             for mk_REP`FieldRep(-,type,-) in fields do
                                               reswf := CheckImpTypeDef(type,modid) and reswf;
                                             return reswf),
      mk_REP`UnionTypeRep(tp_s)          -> (dcl reswf : bool := true;
                                             for all type in set tp_s do
                                               reswf := CheckImpTypeDef(type,modid) and reswf;
                                             return reswf),
      mk_REP`ProductTypeRep(tp_l)        -> (dcl reswf : bool := true;
                                             for type in tp_l do
                                               reswf := CheckImpTypeDef(type,modid) and reswf;
                                             return reswf),
      mk_REP`InvTypeRep(-,type,-),
      mk_REP`SetTypeRep(type),
      mk_REP`SeqTypeRep(type)            -> CheckImpTypeDef(type,modid),
      mk_REP`GeneralMapTypeRep(d,r),
      mk_REP`InjectiveMapTypeRep(d,r)    -> def wfdom = CheckImpTypeDef(d,modid);
                                                wfrng = CheckImpTypeDef(r,modid)
                                            in
                                              return wfdom and wfrng,
      mk_REP`PartialFnTypeRep(tp_l, tp),
      mk_REP`TotalFnTypeRep(tp_l, tp)    -> (dcl reswf : bool := true;
                                             for type in tp_l do
                                               reswf := CheckImpTypeDef(type,modid) and reswf;
                                             return CheckImpTypeDef(tp,modid) and reswf)
    end;

  CheckTypeRename: (map AS`Name to [AS`TypeDef]) * (map AS`Name to AS`Name) * AS`Name ==>
                   (map AS`Name to [AS`TypeDef]) * (map AS`Name to AS`Name)
  CheckTypeRename(tps,ren,modnm) ==
    (dcl tps' : map AS`Name to [AS`TypeDef] := tps;
     for all nm in set dom ren do
       let fullnm = AUX`ExtName(modnm,ren(nm)) in
        --(RenamedTypes := RenamedTypes ++ {fullnm |-> nm};
        (RenamedTypes := RenamedTypes ++ {nm |-> fullnm};
         if  fullnm in set dom tps
         then  tps' := {fullnm} <-: (tps' ++ {nm |-> tps'(fullnm)}));
    return mk_(tps', {nm |-> AUX`ExtName(modnm,ren(nm)) | nm in set dom ren}));

  ExpandInterface : TYPE`Ind * AS`Name * AS`Interface ==> bool
  ExpandInterface(i,modid,mk_AS`Interface(imp,exp,-)) ==
    (dcl reswf : bool := true;
     reswf := ExpandImports(i,modid,imp) and reswf;
     for all mk_TypeRepElem(tpdef,-,-) in set rng TypeEnv do
       reswf := CheckImpTypeDef(tpdef,modid) and reswf;

     if exp <> nil
     then return ExpandExport(exp) and reswf;
     return reswf);

  ExpandImports : TYPE`Ind * AS`Name * map AS`Name to [AS`ImportSig] ==> bool
  ExpandImports(i,modid,imp_m) ==
    (dcl reswf : bool := true;
     if modid in set dom imp_m
           --------------------------------------------
           -- Error message #56
           -- The module "%1" cannot instantiate itself
           --------------------------------------------
     then (ERR`GenErr(modid,<ERROR>,56,[PrintName(modid)]);
           reswf := false);
     for all nm in set dom imp_m \ {modid} do
       reswf := ExpandImport(i,nm,imp_m(nm),modid) and reswf;
     return reswf);

  ExpandImport : TYPE`Ind * AS`Name * [AS`ImportSig] * AS`Name ==> bool
  ExpandImport(i,modid,sig,curmod) ==
    def mk_(parsed, exp) = VCM`GetModuleRep(modid)
    in
     (if not parsed
      then
        -------------------------------------------------------------------
        -- Error message #63
        -- The interface to module "%1" is not found and will not be tested
        -------------------------------------------------------------------
        ERR`GenErr(modid,<WARNING>,63,[PrintName(modid)]);

      if sig = nil
      then -- import all
        if parsed
        then
          let mk_VCM`ExpSigRep(-,valr,fnsr,polyr,opsr,tag,-) = exp
          in
           (TagEnv := TagEnv munion tag;
--          TypeEnv := TypeEnv munion {nm |-> mk_TypeRepElem(tpsr(nm),true) | nm in set dom tpsr};
            ConstEnv := ConstEnv munion {nm |-> mk_TypeRepElem(valr(nm),true,true) | nm in set dom valr};
            FunctionEnv := FunctionEnv munion {nm |-> mk_TypeRepElem(fnsr(nm),true,false) | nm in set dom fnsr};
            PolyEnv := PolyEnv munion {nm |-> mk_PolyTypeRepElem(polyr(nm).vars,polyr(nm).tp,true)
                           | nm in set dom polyr};
            OperationEnv := OperationEnv munion {nm |-> mk_OpTypeRepElem(opsr(nm),true, false, false) | nm in set dom opsr};
            return true)
        else
          return true
      else
        return ImportExpl(i,sig,exp,parsed,modid,curmod));

  ImportExpl: TYPE`Ind * AS`ImportSig * VCM`ExpSigRep * bool * AS`Name * AS`Name ==> bool
  ImportExpl(i,mk_AS`ImportSig(tps,val,fns,ops,ren,cid),exp,parsed,modid,curmod) ==
    (dcl reswf : bool := true;

     def tps' = {AUX`ExtName(modid,nm) |-> tps(nm) | nm in set dom tps};
         val' = {AUX`ExtName(modid,nm) |-> val(nm) | nm in set dom val};
         fns' = {AUX`ExtName(modid,nm) |-> fns(nm) | nm in set dom fns};
         ops' = {AUX`ExtName(modid,nm) |-> ops(nm) | nm in set dom ops};
         mk_VCM`ExpSigRep(-,expval,expfns,exppolys,expops,exptag,-) = exp;
         newsig = mk_AS`ImportSig(tps',val',fns',ops',ren,cid);
         mk_(mk_AS`ImportSig(tp'',val'',fns'',ops'',-,-),wf_ren,ren') = CheckRename(newsig,modid)
     in
      (LocTagEnv := {(if len (nm.ids)= 2
                      then mu(nm,ids |-> [(nm.ids)(2)])
                      else nm) |-> exptag(nm) | nm in set dom exptag};
--     reswf := ImportTypes(i,ren',tps'',exptps,modid) and reswf and wf_ren;
       for all tpnm in set dom tp'' do
         if tp''(tpnm) <> nil
         then reswf := DEF`wf_TypeDefs(i,{tpnm |-> tp''(tpnm)}) and reswf;
       reswf := ImportValues(i,ren',val'',expval,parsed,modid,curmod) and reswf and wf_ren;
       reswf := ImportFunctions(i,ren',fns'',expfns,exppolys,parsed,modid,curmod) and reswf;
       reswf := ImportOperations(i,ren',ops'',expops,expfns,parsed,modid,curmod) and reswf;
       reswf := ImportTags(exptag,ren') and reswf);
     LocTagEnv := {|->};
     return reswf);

  CheckRename : AS`ImportSig * AS`Name ==> AS`ImportSig * bool * map AS`Name to AS`Name
  CheckRename(mk_AS`ImportSig(tps,val,fns,ops,ren,cid),modnm) ==
    (dcl reswf : bool := true;
     dcl tps' : map AS`Name to [AS`TypeDef] := tps;
     dcl val' : map AS`Name to [AS`Type] := val;
     dcl fns' : map AS`Name to [AS`TypeVarList * AS`FnType] := fns;
     dcl ops' : map AS`Name to [AS`OpType] := ops;
     dcl used : set of AS`Name := {};
     dcl ignorred : set of AS`Name := {};

     Renamed := Renamed union dom ren;
     for all nm in set dom ren do
      if ren(nm) in set used
            ---------------------------
            -- Error message #73
            -- "%1" is multiple defined
            ---------------------------
      then (ERR`GenErr(nm, <ERROR>,73,[PrintName(ren(nm))]);
            reswf := false;
            ignorred := ignorred union {nm})
      else
      (used := used union {nm};
       let fullnm = AUX`ExtName(modnm,ren(nm)) in
       if not CheckName(nm)
             -------------------------------------------------------------------
             -- Error message #66
             -- "%1" cannot be renamed to "%2" because that name is already used
             -- in this module
             -------------------------------------------------------------------
       then (ERR`GenErr(nm,<ERROR>,66,[PrintName(ren(nm)),PrintName(nm)]);
             reswf := false)
       elseif fullnm in set dom tps'
       then tps' := {fullnm} <-: (tps' ++ {nm |-> tps'(fullnm)})
       elseif fullnm in set dom val'
       then val' := {fullnm} <-: (val' ++ {nm |-> val'(fullnm)})
       elseif fullnm in set dom fns'
       then fns' := {fullnm} <-: (fns' ++ {nm |-> fns'(fullnm)})
       elseif fullnm in set dom ops'
       then ops' := {fullnm} <-: (ops' ++ {nm |-> ops'(fullnm)})
       else error);
    return mk_(mk_AS`ImportSig(tps',val',fns',ops',ren,cid),reswf,
               {nm |-> AUX`ExtName(modnm,ren(nm)) | nm in set dom ren \ ignorred}));

  ImportTypes : TYPE`Ind * (map AS`Name to AS`Name) *
                (map AS`Name to [AS`TypeDef]) *
                (map AS`Name to REP`TypeRep) * AS`Name * AS`Name ==> bool
  ImportTypes(-,ren,imptps,exptps,modid,curmod) ==
   (dcl reswf : bool := true,
        exported : bool,
        realnm : AS`Name;

    for all nm in set dom imptps do
     (-- UsedName := UsedName union {nm};
      realnm := if nm in set dom ren
                then ren(nm)
                else nm;
      exported := realnm in set dom exptps;
      if not exported
        -------------------------------------------------
        -- Error message #55
        -- The type "%1" is not exported from module "%2"
        -------------------------------------------------
      then (ERR`GenErr(realnm, <ERROR>,55,[PrintName(realnm),PrintName(modid)]);
            reswf := false)
      else
        if nm <> realnm
        then TypeEnv := TypeEnv ++ {realnm |-> mk_TypeRepElem(exptps(realnm),true,false)};
      if imptps(nm) = nil
       --then TypeEnv := TypeEnv ++ {nm |-> mk_TypeRepElem(mk_REP`TypeParRep(nm),false,false)}
      then TypeEnv := TypeEnv ++ {nm |-> mk_TypeRepElem(exptps(realnm),false,false)}
      else
        let mk_AS`TypeDef(-,tp,Invar,Eq,Ord,-,-) = imptps(nm),
            tpnew = if is_AS`CompositeType(tp) and len (tp.name.ids) = 1
                    then mu (tp, name |-> AUX`ExtName(modid,tp.name))
                    else tp
        in
         (if exported and (TransTypeDef(curmod,nm,tpnew,Invar) <> exptps(realnm))
            ---------------------------------------------
            -- Error message #67
            -- Imported type different from exported type
            ---------------------------------------------
          then (ERR`GenErr(nm, <ERROR>,67,[]);
                reswf := false);
          (dcl trep : TypeRepElem;
            if exported
            then trep := mk_TypeRepElem(AUX`RenameTag(exptps(realnm), inverse ren),false,false)
            else trep := mk_TypeRepElem(TransTypeDef(nil,nm,tp,Invar),false,false);
            -- reswf := DEF`wf_TypeDefs(i,{nm |-> imptps(nm)}) and reswf;
            if Invar <> nil
            then
             (def invfn = mk_REP`TotalFnTypeRep([TransType(modid,tp)], mk_REP`BooleanTypeRep())
              in
                FunctionEnv := FunctionEnv munion {AUX`Inv(nm) |-> mk_TypeRepElem(invfn,true,true)});
                --TypeEnv := TypeEnv ++ {nm |-> trep, AUX`ExtName(curmod,nm) |-> trep };
            TypeEnv := TypeEnv ++ {nm |-> trep};
           )));
    return reswf);

  ImportValues: TYPE`Ind * (map AS`Name to AS`Name) *
                (map AS`Name to [AS`Type]) *
                (map AS`Name to REP`TypeRep) * bool * AS`Name *
                AS`Name ==> bool
  ImportValues(i,ren,impval,expval,parsed,modid,curmod) ==
   (dcl reswf : bool := true;
    dcl exported : bool;
    dcl realnm: AS`Name;

    for all nm in set dom impval do
      (UsedName := UsedName union {nm};
       realnm := if nm in set dom ren
                 then ren(nm)
                 else nm;
       exported := realnm in set dom expval;
       if (not exported) and parsed
             --------------------------------------------------
             -- Error message #68
             -- The value "%1" is not exported from module "%2"
             --------------------------------------------------
       then (ERR`GenErr(realnm,<ERROR>,68,[PrintName(realnm),PrintName(modid)]);
             reswf := false);
       if impval(nm) = nil
       then if exported
            then ConstEnv:= ConstEnv munion {nm |-> mk_TypeRepElem(expval(realnm),true,true)}
            else ConstEnv:= ConstEnv munion {nm |-> mk_TypeRepElem(mk_REP`AllTypeRep(),true, false)}
       else (dcl trep : TypeRepElem;
             if exported and (TransType(curmod,impval(nm)) <> expval(realnm))
                   ---------------------------------------------
                   -- Error message #67
                   -- Imported type different from exported type
                   ---------------------------------------------
             then (ERR`GenErr(nm,<ERROR>,67,[]);
                   reswf := false);
             if exported
             then trep := mk_TypeRepElem(expval(realnm),false,true)
             else trep := mk_TypeRepElem(TransType(nil,impval(nm)),false,true);
             reswf := DEF`wf_Type(i,impval(nm)) and reswf and exported;
             ConstEnv := ConstEnv munion {nm |-> trep}));
    return reswf);

  ImportFunctions: TYPE`Ind * (map AS`Name to AS`Name) *
                   (map AS`Name to [AS`TypeVarList * AS`FnType]) *
                   (map AS`Name to REP`FnTypeRep) *
                   (map AS`Name to REP`PolyTypeRep) * bool * AS`Name *
                   AS`Name ==> bool
  ImportFunctions(i,ren,impfns,expfns,polyfns,parsed,modid,curmod) ==
   (dcl reswf : bool := true;
    dcl exportedfn : bool;
    dcl exportedpoly : bool;
    dcl realnm : AS`Name;

    for all nm in set dom impfns do
     (UsedName := UsedName union {nm};
      realnm := if nm in set dom ren
                then ren(nm)
                else nm;
      exportedfn := realnm in set dom expfns;
      exportedpoly:= realnm in set dom polyfns;
      if (not (exportedfn or exportedpoly)) and parsed
        -----------------------------------------------------
        -- Error message #69
        -- The function "%1" is not exported from module "%2"
        -----------------------------------------------------
      then (ERR`GenErr(realnm,<ERROR>,69,[PrintName(realnm),PrintName(modid)]);
            reswf := false);
      if impfns(nm) = nil
      then
        if exportedfn
        then
         (FunctionEnv:= FunctionEnv munion {nm |-> mk_TypeRepElem(expfns(realnm),false, false)};
          if AUX`Pre(realnm) in set dom expfns
          then FunctionEnv:= FunctionEnv munion {AUX`Pre(nm) |-> mk_TypeRepElem(expfns(AUX`Pre(realnm)), true, false)};
          if AUX`Post(realnm) in set dom expfns
          then FunctionEnv:= FunctionEnv munion {AUX`Post(nm) |-> mk_TypeRepElem(expfns(AUX`Post(realnm)), true, false)})
        elseif exportedpoly
        then
          (PolyEnv:= PolyEnv munion {nm |-> mk_PolyTypeRepElem(polyfns(realnm).vars, polyfns(realnm).tp,false)};
           if AUX`Pre(realnm) in set dom polyfns
           then PolyEnv:= PolyEnv munion
                                 {AUX`Pre(nm) |-> mk_PolyTypeRepElem(
                                               polyfns(AUX`Pre(realnm)).vars,
                                               polyfns(AUX`Pre(realnm)).tp,
                                               true)};
           if AUX`Post(realnm) in set dom polyfns
           then PolyEnv:= PolyEnv munion
                                 {AUX`Post(nm) |-> mk_PolyTypeRepElem(
                                                   polyfns(AUX`Post(realnm)).vars,
                                                   polyfns(AUX`Post(realnm)).tp,
                                                   true)})
        else FunctionEnv:= FunctionEnv munion {nm |-> mk_TypeRepElem(mk_REP`AllTypeRep(),false, false)}
      elseif exportedpoly
      then
        let bind = {nm |-> mk_AS`TypeName(ren(nm),CI`NilContextId) | nm in set dom ren}
                       -- NOTICE that an empty contextid is inserted
        in
         (if TransType(curmod,AUX`InstFnAS(let mk_(-,fntp) = impfns(nm) in fntp,bind)) <> polyfns(realnm).tp
            ------------------------------------------------------------
            -- Error message #70
            -- Importing function signature different from exported type
            ------------------------------------------------------------
          then (ERR`GenErr(nm,<ERROR>,70,[]);
                reswf := false);
          let mk_(tp_l,-) = impfns(nm),
              poly_l =  polyfns(realnm).vars
          in
            if len tp_l <> len poly_l or
               exists i in set inds tp_l & TransType(curmod,AUX`InstFnAS(tp_l(i),bind)) <> poly_l(i)
              ------------------------------------------------------------
              -- Error message #94
              -- Imported type variable list different from exported
              ------------------------------------------------------------
            then (ERR`GenErr(nm,<ERROR>,94,[]);
                  reswf := false);

            let polyrep = mk_PolyTypeRepElem(polyfns(realnm).vars, CurMod(<REM>,curmod,polyfns(realnm).tp), false)
            in
             (PushTypeVarContext(polyfns(realnm).vars);
              reswf := DEF`wf_Type(i,let mk_(-,fntp) = impfns(nm) in fntp) and reswf;
              PopTypeVarContext();
              PolyEnv := PolyEnv munion {nm |-> polyrep};
              if AUX`Pre(realnm) in set dom polyfns
              then PolyEnv:= PolyEnv munion
                               {AUX`Pre(nm) |-> mk_PolyTypeRepElem(
                                                polyfns(realnm).vars,
                                                CurMod(<REM>,curmod, polyfns(AUX`Pre(realnm)).tp),
                                                true)};
              if AUX`Post(realnm) in set dom polyfns
              then PolyEnv:= PolyEnv munion
                               {AUX`Post(nm) |-> mk_PolyTypeRepElem(
                                                 polyfns(realnm).vars,
                                                 CurMod(<REM>,curmod, polyfns(AUX`Post(realnm)).tp),
                                                 true)}))
      else
        let bind = {nm |-> mk_AS`TypeName(ren(nm),CI`NilContextId) | nm in set dom ren}
                       -- NOTICE that an empty contextid is inserted
        in
         (dcl trep : TypeRepElem;
          if exportedfn and (TransType(curmod,AUX`InstFnAS(let mk_(-,fntp) = impfns(nm) in fntp,bind))
                                <> expfns(realnm))
            ------------------------------------------------------------
            -- Error message #70
            -- Importing function signature different from exported type
            ------------------------------------------------------------
          then (ERR`GenErr(nm,<ERROR>,70,[]);
                reswf := false);
          if exportedfn
          then trep := mk_TypeRepElem(CurMod(<REM>,curmod,expfns(realnm)), false, false)
          else trep := mk_TypeRepElem(TransType(nil,let mk_(-,fntp) = impfns(nm) in fntp), false, false);
          reswf := DEF`wf_Type(i,let mk_(-,fntp) = impfns(nm) in fntp) and reswf;
          FunctionEnv := FunctionEnv munion {nm |-> trep};
          if AUX`Pre(realnm) in set dom expfns
          then FunctionEnv:= FunctionEnv munion
                                 {AUX`Pre(nm) |-> mk_TypeRepElem(
                                              CurMod(<REM>,curmod, expfns(AUX`Pre(realnm))),
                                              true,
                                              false)};
          if AUX`Post(realnm) in set dom expfns
          then FunctionEnv:= FunctionEnv munion
                                 {AUX`Post(nm) |-> mk_TypeRepElem(
                                               CurMod(<REM>,curmod, expfns(AUX`Post(realnm))),
                                               true,
                                               false)}));
     return reswf);

  ImportOperations: TYPE`Ind * (map AS`Name to AS`Name) *
                    (map AS`Name to [AS`OpType]) *
                    (map AS`Name to REP`OpTypeRep) *
                    (map AS`Name to REP`FnTypeRep) * bool * AS`Name *
                    AS`Name ==> bool
  ImportOperations(i,ren,impops,expops,expfns,parsed,modid,curmod) ==
   (dcl reswf : bool := true;
    dcl exported : bool;
    dcl realnm : AS`Name;

    for all nm in set dom impops do
      (UsedName := UsedName union {nm};
       realnm := if nm in set dom ren
                 then ren(nm)
                 else nm;
       exported := realnm in set dom expops;
       if parsed and not exported
             ------------------------------------------------------
             -- Error message #71
             -- The operation "%1" is not exported from module "%2"
             ------------------------------------------------------
       then (ERR`GenErr(realnm,<ERROR>,71,[PrintName(realnm),PrintName(modid)]);
             reswf := false);
       if impops(nm) = nil
       then if exported
            then (OperationEnv:= OperationEnv munion
                                 {nm |-> mk_OpTypeRepElem(CurMod(<REM>,curmod,expops(realnm)),false, false, false)};
                  if AUX`Pre(realnm) in set dom expfns
                  then FunctionEnv:= FunctionEnv munion
                                     {AUX`Pre(nm) |-> mk_TypeRepElem(CurMod(<REM>,curmod, expfns(AUX`Pre(realnm))),
                                                  true, false)};
                  if AUX`Post(realnm) in set dom expfns
                  then FunctionEnv:= FunctionEnv munion
                                     {AUX`Post(nm) |-> mk_TypeRepElem(CurMod(<REM>,curmod, expfns(AUX`Post(realnm))),
                                                   true, false)})
            else OperationEnv:= OperationEnv munion
                 {nm |-> mk_OpTypeRepElem(mk_REP`AllTypeRep(),false, false, false)}
       else let bind = {nm |-> mk_AS`TypeName(ren(nm),CI`NilContextId) | nm in set dom ren}
                       -- NOTICE that an empty contextid is inserted
            in
            (dcl trep : OpTypeRepElem;
             if exported and (TransType(curmod,AUX`InstFnAS(impops(nm),bind)) <> expops(realnm))
                   ------------------------------------------------------------
                   -- Error message #72
                   -- Imported operation signature different from exported type
                   ------------------------------------------------------------
             then (ERR`GenErr(nm,<ERROR>,72,[]);
                   reswf := false);
             if exported
             then trep := mk_OpTypeRepElem(CurMod(<REM>,curmod,expops(realnm)),false,false,false)
             else trep := mk_OpTypeRepElem(TransType(curmod,impops(nm)),false,false,false);
             reswf := DEF`wf_Type(i,impops(nm)) and reswf;
             OperationEnv := OperationEnv munion {nm |-> trep};
             if AUX`Pre(realnm) in set dom expfns
             then FunctionEnv:= FunctionEnv munion
                                {AUX`Pre(nm) |->
                                 mk_TypeRepElem(CurMod(<REM>,curmod, expfns(AUX`Pre(realnm))), true, false)};
             if AUX`Post(realnm) in set dom expfns
             then FunctionEnv:= FunctionEnv munion
                                {AUX`Post(nm) |->
                                 mk_TypeRepElem(CurMod(<REM>,curmod, expfns(AUX`Post(realnm))), true, false)}));
    return reswf);

  ImportTags: (map AS`Name to seq of REP`FieldRep) * (map AS`Name to AS`Name) ==> bool
  ImportTags(exptag,ren) ==
   (dcl reswf: bool := true;
    dcl realnm : AS`Name;

    for all nm in set dom exptag do
     (realnm := if nm in set rng ren
                then (inverse ren)(nm)
                else nm;
      if realnm in set dom TagEnv
            ---------------------------
            -- Error message #73
            -- "%1" is multiple defined
            ---------------------------
      then (ERR`GenErr(realnm,<ERROR>,73,[PrintName(realnm)]);
            reswf := false)
      else TagEnv := TagEnv ++ {realnm |-> exptag(nm)});
    return reswf);


  ExpandExport : AS`ExportSig ==> bool
  ExpandExport (mk_AS`ExportSig(tps,val,fns,ops,-)) ==
   (dcl reswf : bool := true;

    for all tp_id in set dom tps do
      if tp_id not in set dom TypeEnv or tp_id in set Renamed
        --------------------------------
        -- Error message #89
        -- "%1" is not defined in module
        --------------------------------
      then (ERR`GenErr(tp_id,<ERROR>,89,[PrintName(tp_id)]);
            reswf := false);
    for all val_id in set dom val do
      if val_id not in set ValueIds or val_id in set Renamed
        --------------------------------
        -- Error message #89
        -- "%1" is not defined in module
        --------------------------------
      then (ERR`GenErr(val_id, <ERROR>,89,[PrintName(val_id)]);
            reswf := false);
    for all fn_id in set dom fns do
      if not (fn_id in set dom FunctionEnv or fn_id in set dom PolyEnv) or fn_id in set Renamed
        --------------------------------
        -- Error message #89
        -- "%1" is not defined in module
        --------------------------------
      then (ERR`GenErr(fn_id,<ERROR>,89,[PrintName(fn_id)]);
            reswf := false)
      else
       (if TransType(nil,let mk_(-,fntp) = fns(fn_id) in fntp) <>
         (if fn_id in set dom FunctionEnv
          --then AUX`InstFn(<PAR>,FunctionEnv(fn_id).tp,TypeParEnv)
          then FunctionEnv(fn_id).tp
          --else AUX`InstFn(<PAR>,PolyEnv(fn_id).tp,TypeParEnv))
          else PolyEnv(fn_id).tp)
          ----------------------------------------
          -- Error message #92
          -- "%1" is exported with wrong signature
          ----------------------------------------
        then (ERR`GenErr(fn_id,<ERROR>,92,[PrintName(fn_id)]);
             reswf := false);

        if fn_id in set dom PolyEnv and
         (let mk_(tp_l,-) = fns (fn_id)
          in
            len tp_l <> len PolyEnv(fn_id).poly or exists i in set inds tp_l &
                  --TransType(nil,tp_l(i)) <> AUX`InstFn(<PAR>,PolyEnv(fn_id).poly(i),TypeParEnv))
                  TransType(nil,tp_l(i)) <> PolyEnv(fn_id).poly(i))
          ----------------------------------------
          -- Error message #93
          -- Type variable list for "%1" exported with wrong types
          ----------------------------------------
        then (ERR`GenErr(fn_id,<ERROR>,93,[PrintName(fn_id)]);
             reswf := false));
    for all op_id in set dom ops do
      if op_id not in set dom OperationEnv or op_id in set Renamed
        --------------------------------
        -- Error message #89
        -- "%1" is not defined in module
        --------------------------------
      then (ERR`GenErr(op_id,<ERROR>,89,[PrintName(op_id)]);
            reswf := false)
      --elseif TransType(nil,ops(op_id)) <> AUX`InstFn(<PAR>,OperationEnv(op_id).tp,TypeParEnv)
      elseif TransType(nil,ops(op_id)) <> OperationEnv(op_id).tp
        ----------------------------------------
        -- Error message #92
        -- "%1" is exported with wrong signature
        ----------------------------------------
      then (ERR`GenErr(op_id,<ERROR>,92,[PrintName(op_id)]);
            reswf := false);
    return reswf);
\end{vdm_al}
#endif VDMSL

\subsection{Expansion of Definition Constructs}

\begin{vdm_al}
  ExpandDefinitions: TYPE`Ind * AS`Name *  AS`Definitions ==> bool
#ifdef VDMSL
  ExpandDefinitions(i,modid, mk_AS`Definitions(tm,vm,fnm,opm,State,-,-)) ==
#endif VDMSL
#ifdef VDMPP
  ExpandDefinitions(i,modid, mk_AS`Definitions(tm,vm,fnm,opm,instvars,-,-,-,-)) ==
#endif VDMPP
    (dcl reswf : bool := true;
   -- put types in environment
   -- do not check invariants yet
   reswf := ExpandTypes(modid,tm);

#ifdef VDMSL
   reswf := ExpandStateIdentifiers(modid,State) and reswf;
   reswf := ExtractOperationSignatures (opm,State) and reswf;
#endif VDMSL
#ifdef VDMPP
   reswf := ExpandInstanceVars(instvars) and reswf;
   reswf := ExtractOperationSignatures (opm) and reswf;
#endif VDMPP
   -- put function and method signatures in environment
   reswf := ExtractFunctionSignatures (fnm) and reswf;
   reswf := ExtractValueDefsFirst(i,vm) and reswf;
#ifdef VDMPP
   reswf := ExtractOverloadedSignatures(opm, fnm);
   reswf := ExtractValueDefs(i,vm) and reswf;
#endif VDMPP
   return reswf);

#ifdef VDMSL
ExpandStateIdentifiers : AS`Name * [AS`StateDef] ==> bool  --OK
ExpandStateIdentifiers(-,StDef) ==
  if StDef = nil then
    return true
  else
     let mk_AS`StateDef(mk_AS`CompositeType(tag, flds,-),Invar,Initvar,-) = StDef
     in
      (dcl reswf : bool := true;
       if not CheckName(tag)
       then
         ---------------------------------
         -- Error message #95
         -- State name "%1" is disregarded
         ---------------------------------
        (ERR`GenErr (tag,<ERROR>,95,[PrintName(tag)]);
         reswf := false)
       else
         --def sttprep = TransStateType(GetCurMod(),StDef);
         --def sttprep = TransStateType(modid,StDef);
         def sttprep = TransStateType(nil,StDef);
             tre = mk_TypeRepElem(sttprep,true,false);
         in
          (TypeEnv := TypeEnv munion {tag |-> tre};
           TagEnv := TagEnv munion {tag |-> TransFields(nil,flds)};
           StateEnv := StateEnv munion {tag |-> tre};
           if Invar <> nil
           then
            (let invfn = mk_REP`TotalFnTypeRep([sttprep], mk_REP`BooleanTypeRep())
             in FunctionEnv := FunctionEnv munion {AUX`Inv(tag) |-> mk_TypeRepElem(invfn,true,true)});
           if Initvar <> nil
           then
            (let initfn = mk_REP`TotalFnTypeRep([sttprep], mk_REP`BooleanTypeRep())
             in FunctionEnv := FunctionEnv munion {AUX`Init(tag) |-> mk_TypeRepElem(initfn,true,true)});
          );
           for mk_AS`Field(nm,tp,-,-) in flds do
             if nm <> nil
             then
              (if not CheckName(nm)
               then
                 ---------------------------------
                 -- Error message #95
                 -- State name "%1" is disregarded
                 ---------------------------------
                (ERR`GenErr (nm,<MESSAGE>,95,[PrintName(nm)]);
                 reswf := false)
               else
                (StateEnv := StateEnv munion {nm |-> mk_TypeRepElem(TransType(nil,tp),false, false)};
                 CI`SetTypeInfo(nm.cid, TransType(GetCurMod(),tp)););
              );
       return reswf);
#endif VDMSL

  -- VDM++: This operation is not general enough at the moment as it takes
  -- only the instance variables in the current class into account.

  UsedStateIds: set of AS`Name ==> set of AS`Name
  UsedStateIds(ids) ==
    return ids inter dom StateEnv;

  ExpandTypes : AS`Name * map AS`Name to AS`TypeDef ==> bool
  ExpandTypes (modid, tp_m) ==
      (dcl reswf : bool := true;
        for all mk_AS`TypeDef(nm, Tp, Invar, Eq, Ord,-,-) in set rng tp_m do
          if not CheckName(nm) then
              --------------------------------------
              -- Error message #97
              -- Type definition "%1" is disregarded
              --------------------------------------
            ( ERR`GenErr (nm,<MESSAGE>,97,[PrintName(nm)]);
              reswf := false)
          else
           (reswf := ColRecs (Tp) and reswf;
            def localinv = Invar;
                stp = TransTypeDef(nil,nm,Tp, localinv)
            in
              TypeEnv := TypeEnv ++ {nm |-> mk_TypeRepElem(stp, false, false)}
                                 ++ {AUX`ExtName(modid,nm) |-> mk_TypeRepElem(stp, true, false)};
              if Invar <> nil
              then (def invfn = mk_REP`TotalFnTypeRep([TransType(nil,Tp)], mk_REP`BooleanTypeRep())
                    in FunctionEnv := FunctionEnv munion {AUX`Inv(nm) |-> mk_TypeRepElem(invfn,true, true)}));
        return reswf);

  ColRecs: AS`Type ==> bool
  ColRecs(tp) ==
    cases tp:
      mk_AS`BooleanType(-),
      mk_AS`NumericType(-,-),
      mk_AS`TokenType(-),
      mk_AS`CharType(-),
      mk_AS`VoidType(-),
      mk_AS`QuoteType(-,-),
      mk_AS`TypeName(-,-),
      mk_AS`TypeVar(-,-) -> return true,
      mk_AS`CompositeType(-, fields, -) -> def nested = {ColRecs(f.type) | f in set elems fields};
                                               tag_ok = ExpandCompositeType(tp)
                                           in
                                             return (false not in set nested) and tag_ok,
       mk_AS`UnionType(tp_l,-),
       mk_AS`ProductType(tp_l,-) -> def nested = {ColRecs(tp) | tp in set elems tp_l}
                                    in
                                      return false not in set nested,
       mk_AS`BracketedType(type,-),
       mk_AS`OptionalType(type,-),
       mk_AS`Set0Type(type,-),
       mk_AS`Set1Type(type,-),
       mk_AS`Seq0Type(type,-),
       mk_AS`Seq1Type(type,-) -> return ColRecs(type),
       mk_AS`GeneralMap0Type(d,r,-),
       mk_AS`GeneralMap1Type(d,r,-),
       mk_AS`InjectiveMap0Type(d,r,-),
       mk_AS`InjectiveMap1Type(d,r,-) -> def d_ok = ColRecs(d);
                                            r_ok = ColRecs(r)
                                        in
                                          return d_ok and r_ok,
       mk_AS`PartialFnType(tp_l, tp, -),
       mk_AS`TotalFnType(tp_l, tp, -) -> def nested = {ColRecs(tp) | tp in set elems tp_l};
                                             tp_ok  = ColRecs(tp)
                                         in
                                           return (false not in set nested) and tp_ok,
       others -> error
    end;

  ExpandCompositeType : AS`CompositeType ==> bool --OK
  ExpandCompositeType (mk_AS`CompositeType(tag, flds, -)) ==
    (dcl reswf : bool := true;
     def tflds = TransFields(nil,flds)
     in
      if CheckLocalTag(tag)
      then -- tag already used
        if TagEnv(tag) <> tflds
        then
          -- new definition of tag is illegal
          ---------------------------
          -- Error message #73
          -- "%1" is multiple defined
          ---------------------------
         (ERR`GenErr (tag, <ERROR>,73,[PrintName(tag)]);
          reswf := false)
        else skip
      else
       (TagEnv := TagEnv munion {tag |-> tflds};
--#ifdef VDMSL
        --TagEnv := TagEnv munion {AUX`ExtName(GetCurMod(), tag) |-> tflds};
--#endif VDMSL
       );
      return reswf);
\end{vdm_al}

\begin{vdm_al}

  ExtractFunctionSignatures : map AS`Name to AS`FnDef ==> bool
  ExtractFunctionSignatures (fn_m) ==
    (dcl reswf : bool := true;

      for all fnnm in set dom fn_m do
      let fn = fn_m(fnnm) in
#ifdef VDMPP
      if not MANGLE`IsMangled(fnnm)
      then
#endif VDMPP
        if is_AS`ExplFnDef(fn) then
          reswf := ExtractExplicitFunctionSignature(fn) and reswf
        elseif is_AS`ExtExplFnDef(fn) then
          reswf := ExtractExtExplicitFunctionSignature(fn) and reswf
        else
          reswf := ExtractImplicitFunctionSignature(fn) and reswf;
      return reswf);

  ExtractExplicitFunctionSignature : AS`ExplFnDef ==> bool
  ExtractExplicitFunctionSignature(mk_AS`ExplFnDef(nm,tv_l,tp,-,-,fnpre,fnpost,-,stat,-,-)) ==
      (MarkUsedType(tp);
       if not CheckName(nm) then
           ---------------------------------------
           -- Error message #98
           -- Ignoring function signature for "%1"
           ---------------------------------------
         ( ERR`GenErr (nm,<ERROR>,98,[PrintName(nm)]);
           return false)
       else
         (def fntp = TransType(nil,tp)
          in
          if tv_l <> []
          then def r_l = TransTypeList(nil,tv_l)
               in
                let polyelem = mk_PolyTypeRepElem(r_l,fntp,false)
                in
                  (PolyEnv := PolyEnv munion {nm |-> polyelem};
                   if fnpre <> nil
                   then let mk_(tv_l,pfn) = AUX`MakePolyPreType(r_l,fntp)
                        in PolyEnv := PolyEnv munion {AUX`Pre(nm) |-> mk_PolyTypeRepElem(tv_l,pfn,true)};
                   if fnpost <> nil
                   then let mk_(tv_l,pfn) = AUX`MakePolyPostType(r_l,fntp)
                        in PolyEnv := PolyEnv munion {AUX`Post(nm) |-> mk_PolyTypeRepElem(tv_l,pfn,true)})
          else
          let tpelem = mk_TypeRepElem(fntp,false, stat)
          in
           (FunctionEnv := FunctionEnv munion {nm |-> tpelem};
            if fnpre <> nil
            then FunctionEnv := FunctionEnv munion {AUX`Pre(nm) |-> mk_TypeRepElem(AUX`MakePreType(fntp), true, stat)};
            if fnpost <> nil
            then FunctionEnv := FunctionEnv munion {AUX`Post(nm) |-> mk_TypeRepElem(AUX`MakePostType(fntp), true, stat)}
            );
          return true));

  ExtractImplicitFunctionSignature : AS`ImplFnDef ==> bool
  ExtractImplicitFunctionSignature(mk_AS`ImplFnDef(nm,tv_l,partps,resnmtps,fnpre,-,-,stat,-)) ==
      let fnrng = ConstructImplRngType(resnmtps) in
      (MarkUsedType(fnrng);
       if not CheckName(nm) then
           ---------------------------------------
           -- Error message #98
           -- Ignoring function signature for "%1"
           ---------------------------------------
         ( ERR`GenErr (nm,<ERROR>,98,[PrintName(nm)]);
           return false)
       else
         def domtps = ConstructImplDomType(partps);
             restp = TransType(nil,fnrng) in
        (for t in domtps do
           MarkUsedType(t);
         def domtp = TransTypeList(nil,domtps) in
         let fnsig = mk_REP`TotalFnTypeRep(domtp, restp),
             fnpresig = mk_REP`TotalFnTypeRep(domtp, mk_REP`BooleanTypeRep()),
             fnpostsig = mk_REP`TotalFnTypeRep(domtp^[restp], mk_REP`BooleanTypeRep())
         in
           if tv_l <> []
           then def r_l = TransTypeList(nil,tv_l)
                in
                let elem     = mk_PolyTypeRepElem(r_l,fnsig,false),
                    preelem  = mk_PolyTypeRepElem(r_l,fnpresig,true),
                    postelem = mk_PolyTypeRepElem(r_l,fnpostsig,true)
           in
             (PolyEnv := PolyEnv munion {nm |-> elem};
               if fnpre <> nil
               then PolyEnv := PolyEnv munion {AUX`Pre(nm) |-> preelem};
               PolyEnv := PolyEnv munion {AUX`Post(nm) |-> postelem})
           else
           let tpelem = mk_TypeRepElem(fnsig,false,stat),
               tppreelem = mk_TypeRepElem(fnpresig,true,stat),
               tppostelem = mk_TypeRepElem(fnpostsig,true,stat)
           in
             ( FunctionEnv := FunctionEnv munion {nm |-> tpelem};
               if fnpre <> nil
               then FunctionEnv := FunctionEnv munion {AUX`Pre(nm) |-> tppreelem};
               FunctionEnv := FunctionEnv munion {AUX`Post(nm) |-> tppostelem});
            return true));

  ExtractExtExplicitFunctionSignature : AS`ExtExplFnDef ==> bool
  ExtractExtExplicitFunctionSignature (mk_AS`ExtExplFnDef(nm,tv_l,partps,resnmtps,-,fnpre,fnpost,-, stat,-,-)) ==
      let fnrng = ConstructImplRngType(resnmtps) in
      (MarkUsedType(fnrng);
       if not CheckName(nm) then
           ---------------------------------------
           -- Error message #98
           -- Ignoring function signature for "%1"
           ---------------------------------------
         ( ERR`GenErr (nm,<ERROR>,98,[PrintName(nm)]);
           return false)
       else
         def domtps = ConstructImplDomType(partps);
             restp = TransType(nil,fnrng) in
        (for t in domtps do
           MarkUsedType(t);
         def domtp = TransTypeList(nil,domtps) in
         let fnsig = mk_REP`TotalFnTypeRep(domtp, restp),
             fnpresig = mk_REP`TotalFnTypeRep(domtp, mk_REP`BooleanTypeRep()),
             fnpostsig = mk_REP`TotalFnTypeRep(domtp^[restp], mk_REP`BooleanTypeRep()) in
           if tv_l <> []
           then def r_l = TransTypeList(nil,tv_l)
                in
                let elem     = mk_PolyTypeRepElem(r_l,fnsig,false),
                    preelem  = mk_PolyTypeRepElem(r_l,fnpresig,true),
                    postelem = mk_PolyTypeRepElem(r_l,fnpostsig,true)
           in
             (PolyEnv := PolyEnv munion {nm |-> elem};
               if fnpre <> nil
               then PolyEnv := PolyEnv munion {AUX`Pre(nm) |-> preelem};
               if fnpost <> nil
               then PolyEnv := PolyEnv munion {AUX`Post(nm) |-> postelem})
           else
           let tpelem = mk_TypeRepElem(fnsig,false,stat),
               tppreelem = mk_TypeRepElem(fnpresig,true,stat),
               tppostelem = mk_TypeRepElem(fnpostsig,true,stat)
           in
             ( FunctionEnv := FunctionEnv munion {nm |-> tpelem};
               if fnpre <> nil
               then FunctionEnv := FunctionEnv munion {AUX`Pre(nm) |-> tppreelem};
               if fnpost <> nil
               then FunctionEnv := FunctionEnv munion {AUX`Post(nm) |-> tppostelem});
            return true));

#ifdef VDMSL
  ExtractOperationSignatures : (map AS`Name to AS`OpDef) * [AS`StateDef] ==>
                               bool
  ExtractOperationSignatures (opdefmap,StDef) ==
#endif VDMSL
#ifdef VDMPP
  ExtractOperationSignatures : (map AS`Name to AS`OpDef) ==> bool
  ExtractOperationSignatures (opdefmap) ==
#endif VDMPP
      (dcl reswf : bool := true;
        for all opnm in set dom opdefmap do
        let op = opdefmap(opnm) in
#ifdef VDMSL
          if is_AS`ExplOpDef(op) then
            reswf := ExtractExplicitOperationSignature(op,StDef) and reswf
          elseif is_AS`ImplOpDef(op) then
            reswf := ExtractImplicitOperationSignature(op,StDef) and reswf
          else
            reswf := ExtractExtExplicitOperationSignature(op,StDef) and reswf;
#endif VDMSL
#ifdef VDMPP
          if not MANGLE`IsMangled(opnm)
          then
            if is_AS`ExplOpDef(op) then
              reswf := ExtractExplicitOperationSignature(op) and reswf
            elseif is_AS`ImplOpDef(op) then
              reswf := ExtractImplicitOperationSignature(op) and reswf
            else
              reswf := ExtractExtExplicitOperationSignature(op) and reswf;
#endif VDMPP
        return reswf);

#ifdef VDMSL
  ExtractExplicitOperationSignature : AS`ExplOpDef * [AS`StateDef] ==> bool
  ExtractExplicitOperationSignature(mk_AS`ExplOpDef(nm,oppure,-,tp,-,-,oppre,oppost,-,stat,-,-), StDef) ==
#endif VDMSL
#ifdef VDMPP
  ExtractExplicitOperationSignature : AS`ExplOpDef ==> bool
  ExtractExplicitOperationSignature(mk_AS`ExplOpDef(nm,oppure,-,tp,-,-,oppre,oppost,-,stat,-,-)) ==
#endif VDMPP
   (dcl reswf : bool := true;

    MarkUsedType(tp);
    if not CheckName(nm)
    then
     (------------------------------------
      -- Error message #99
      -- Ignoring operation signature "%1"
      ------------------------------------
      ERR`GenErr (nm,<ERROR>,99,[PrintName(nm)]);
      return false)
    else
      def opsig = TransType(nil,tp)
      in
       (OperationEnv := OperationEnv munion
                   {nm |-> mk_OpTypeRepElem(opsig,false,stat,oppure)};
#ifdef VDMSL
        if oppre <> nil
        then
          let pretp = AUX`MakeOpPreType(nil,opsig,StDef)
          in FunctionEnv := FunctionEnv munion
                     {AUX`Pre(nm) |-> mk_TypeRepElem(pretp,true,true)};
        if oppost <> nil
        then
          let posttp = AUX`MakeOpPostType(nil,opsig,StDef)
          in FunctionEnv := FunctionEnv munion
                     {AUX`Post(nm) |-> mk_TypeRepElem(posttp,true,true)}
#endif VDMSL
#ifdef VDMPP
        if oppre <> nil
        then
          let pretp = AUX`MakeOpPreType(nil,opsig,nil)
          in FunctionEnv := FunctionEnv munion
                     {AUX`Pre(nm) |-> mk_TypeRepElem(pretp,true,true)};
        if oppost <> nil
        then
          let posttp = AUX`MakeOpPostType(nil,opsig,nil)
          in FunctionEnv := FunctionEnv munion
                     {AUX`Post(nm) |-> mk_TypeRepElem(posttp,true,true)}
#endif VDMPP
       );
    return reswf;
   );

#ifdef VDMSL
  ExtractImplicitOperationSignature : AS`ImplOpDef * [AS`StateDef] ==> bool
  ExtractImplicitOperationSignature
   (mk_AS`ImplOpDef(nm,oppure,-,partps,resnmtps,-,oppre,-,-,-,stat,-,-),StDef) ==
#endif VDMSL
#ifdef VDMPP
  ExtractImplicitOperationSignature : AS`ImplOpDef ==> bool
  ExtractImplicitOperationSignature
   (mk_AS`ImplOpDef(nm,oppure,-,partps,resnmtps,-,oppre,-,-,-,stat,-,-)) ==
#endif VDMPP
   (dcl reswf : bool := true;

    let oprng = ConstructImplRngType(resnmtps)
    in MarkUsedType(oprng);
    if not CheckName(nm)
    then
     (------------------------------------
      -- Error message #99
      -- Ignoring operation signature "%1"
      ------------------------------------
      ERR`GenErr (nm,<MESSAGE>,99,[PrintName(nm)]);
      return false)
    else
      def domtps = ConstructImplDomType(partps);
      in
       (dcl rngtp : REP`TypeRep := mk_REP`UnitTypeRep();
        if resnmtps <> []
        then
          let oprng = ConstructImplRngType(resnmtps)
          in rngtp := TransType(nil,oprng);
        for t in domtps do
          MarkUsedType(t);
        def opsig = mk_REP`OpTypeRep(TransTypeList(nil,domtps), rngtp)
        in
          let tpelem = mk_OpTypeRepElem(opsig,false,stat,oppure)
          in
           (OperationEnv := OperationEnv munion {nm |-> tpelem};
#ifdef VDMSL
            if oppre <> nil
            then
              let pretp = AUX`MakeOpPreType(nil,opsig,StDef)
              in FunctionEnv := FunctionEnv munion
                         {AUX`Pre(nm) |-> mk_TypeRepElem(pretp,true, true)};
            let posttp = AUX`MakeOpPostType(nil,opsig,StDef)
            in FunctionEnv := FunctionEnv munion
                       {AUX`Post(nm) |-> mk_TypeRepElem(posttp,true, true)}
#endif VDMSL
#ifdef VDMPP
            if oppre <> nil
            then
              let pretp = AUX`MakeOpPreType(nil,opsig,nil)
              in FunctionEnv := FunctionEnv munion
                         {AUX`Pre(nm) |-> mk_TypeRepElem(pretp,true, true)};
            let posttp = AUX`MakeOpPostType(nil,opsig,nil)
            in FunctionEnv := FunctionEnv munion
                       {AUX`Post(nm) |-> mk_TypeRepElem(posttp,true, true)}
#endif VDMPP
            );
        return reswf;
       );
   );

#ifdef VDMSL
  ExtractExtExplicitOperationSignature : AS`ExtExplOpDef * [AS`StateDef] ==> bool
  ExtractExtExplicitOperationSignature
    (mk_AS`ExtExplOpDef(nm,oppure,-,partps,resnmtps,-,-,oppre,oppost,-,-,stat,-,-), StDef) ==
#endif VDMSL
#ifdef VDMPP
  ExtractExtExplicitOperationSignature : AS`ExtExplOpDef ==> bool
  ExtractExtExplicitOperationSignature
    (mk_AS`ExtExplOpDef(nm,oppure,-,partps,resnmtps,-,-,oppre,oppost,-,-,stat,-,-)) ==
#endif VDMPP
   (dcl reswf : bool := true;

    let oprng = ConstructImplRngType(resnmtps)
    in MarkUsedType(oprng);
    if not CheckName(nm)
    then
     (------------------------------------
      -- Error message #99
      -- Ignoring operation signature "%1"
          ------------------------------------
      ERR`GenErr (nm,<MESSAGE>,99,[PrintName(nm)]);
      return false)
    else
      def domtps = ConstructImplDomType(partps);
        in
         (dcl rngtp : REP`TypeRep := mk_REP`UnitTypeRep();
          if resnmtps <> []
          then
            def oprng = ConstructImplRngType(resnmtps)
            in rngtp := TransType(nil,oprng);
          for t in domtps do
            MarkUsedType(t);
          def opsig = mk_REP`OpTypeRep(TransTypeList(nil,domtps),rngtp)
          in
            let tpelem = mk_OpTypeRepElem(opsig,false,stat,oppure)
            in
             (OperationEnv := OperationEnv munion {nm |-> tpelem};
#ifdef VDMSL
              if oppre <> nil
              then
                let pretp = AUX`MakeOpPreType(nil,opsig,StDef)
                in FunctionEnv := FunctionEnv munion
                           {AUX`Pre(nm) |-> mk_TypeRepElem(pretp,true,true)};
              if oppost <> nil
              then
                let posttp = AUX`MakeOpPostType(nil,opsig,StDef)
                in FunctionEnv := FunctionEnv munion
                           {AUX`Post(nm) |-> mk_TypeRepElem(posttp,true,true)}
#endif VDMSL
#ifdef VDMPP
              if oppre <> nil
              then
                let pretp = AUX`MakeOpPreType(nil,opsig,nil)
                in FunctionEnv := FunctionEnv munion
                           {AUX`Pre(nm) |-> mk_TypeRepElem(pretp,true,true)};
              if oppost <> nil
              then
                let posttp = AUX`MakeOpPostType(nil,opsig,nil)
                in FunctionEnv := FunctionEnv munion
                           {AUX`Post(nm) |-> mk_TypeRepElem(posttp,true,true)}
#endif VDMPP
             );
          return reswf;
         );
   );

#ifdef VDMPP
\end{vdm_al}
The operation \texttt{ExtractOverloadedSignatures} is used to take all
of those functions and operations in the current class that are
overloaded (within this class) and add them to the current environment.
\begin{vdm_al}
  ExtractOverloadedSignatures : map AS`Name to AS`OpDef * map AS`Name to AS`FnDef ==> bool
  ExtractOverloadedSignatures(p_opm, p_fnm) ==
   (dcl l_reswf : bool := true;
    for all b_opnm in set dom p_opm do
      if MANGLE`IsMangled(b_opnm)
      then
        def l_nm     = MANGLE`GetUnmangledName(b_opnm);
            l_def    = p_opm(b_opnm);
            mk_(l_opdom, l_oprng) = GetOperationSignature(l_def);
            l_static = GetOperationStaticStatus(l_def)
        in
          if l_nm in set dom OverloadedEnv
          then
            if OverloadedTypeConsistent(l_nm,l_opdom,true)
            then InsertOverloadedName(l_nm, l_opdom, l_oprng, true, l_static)
            else l_reswf := false
          else InsertOverloadedName(l_nm, l_opdom, l_oprng, true, l_static);

    for all b_fnm in set dom p_fnm do
      if MANGLE`IsMangled(b_fnm)
      then
        def l_nm     = MANGLE`GetUnmangledName(b_fnm);
            l_def    = p_fnm(b_fnm);
            mk_(l_fndom, l_fnrng) = GetFunctionSignature(l_def);
            l_static = GetFunctionStaticStatus(l_def)
        in
          if l_nm in set dom OverloadedEnv
          then
            if OverloadedTypeConsistent(l_nm,l_fndom,false)
            then InsertOverloadedName(l_nm, l_fndom, l_fnrng, false, l_static)
            else l_reswf := false
          else InsertOverloadedName(l_nm, l_fndom, l_fnrng, false, l_static);
    return l_reswf;
  );
\end{vdm_al}
The operation \texttt{OverloadedTypeConsistent} checks that a given
overloaded function or operation's type is consistent with those
functions and operations of the same name that have already been
processed.
\begin{description}
\item[\texttt{p\_nm}] The name of the function or operation being checked.
\item[\texttt{p\_domtp}] The types of the parameters.
\item[\texttt{p\_isop}] A flag indicating if a function or operation
is being checked
\end{description}

\begin{vdm_al}
OverloadedTypeConsistent : AS`Name * seq of REP`TypeRep * bool ==> bool
OverloadedTypeConsistent(p_nm, p_domtp, p_isop) ==
  let l_typereps = OverloadedEnv(p_nm)
  in
  let l_domtps = if p_isop
                 then { b_tp | mk_TypeRepElem(mk_REP`OpTypeRep(b_tp,-),-,-) in set l_typereps }
                 else { b_tp.fndom | mk_TypeRepElem(b_tp,-,-) in set l_typereps }
  in
  ( dcl l_reswf : bool := true;
    if exists b_tpseq in set l_domtps &
         len b_tpseq = len p_domtp and
         forall i in set inds b_tpseq &
           TYPE`IsOverlapping(b_tpseq(i), p_domtp(i), {})
       ---------------------------------
       -- Error message #382/#384
       -- Parameter types of overloaded operations/functions overlap
       ---------------------------------
    then
    ( ERR`GenErr (p_nm,<ERROR>, if p_isop then 382 else 384, []);
      l_reswf := false
    );
    return l_reswf
  );
\end{vdm_al}

\texttt{InsertOverloadedName} is an auxiliary operation used to insert
overloaded names into the current environment.
\begin{description}
\item[\texttt{p\_nm}] The name of the function or operation being inserted.
\item[\texttt{p\_domtp}] The types of the parameters.
\item[\texttt{p\_rngtp}] The type of the result.
\item[\texttt{p\_isop}] A flag indicating if a function or operation
is being inserted.
\end{description}
\begin{vdm_al}
InsertOverloadedName : AS`Name * seq of REP`TypeRep * REP`TypeRep * bool * bool ==> ()
InsertOverloadedName(p_nm, p_domtps, p_rngtp, p_isop, p_static) ==
  def l_domtps = NormaliseTypeNameList(p_domtps);
      l_rngtp  = NormaliseTypeName(p_rngtp);
      l_methtp = if p_isop
                 then mk_REP`OpTypeRep(l_domtps, l_rngtp)
                 else mk_REP`TotalFnTypeRep(l_domtps, l_rngtp)
  in
  let l_tre = mk_TypeRepElem(l_methtp, false, p_static)
  in
    if p_nm in set dom OverloadedEnv
    then OverloadedEnv(p_nm) := OverloadedEnv(p_nm) union {l_tre}
    else OverloadedEnv       := OverloadedEnv ++ {p_nm |-> {l_tre}};
\end{vdm_al}

Below a number of operations are used to normalise type
representations with respect to VDM++ references to instances of
classes. Inside VCM (called at parse time) references to type names in
the signatures of functions and operations are prefixed by the name of
the current class. This is wrong if the type name referred to really
is a class and not present as a type in the current class. The
normalisation in these operations are used to fix that.
\begin{vdm_al}
  NormaliseTypeNameList: seq of REP`TypeRep ==> seq of REP`TypeRep
  NormaliseTypeNameList(p_tpL) ==
    return [NormaliseTypeName(p_tpL(b_i)) | b_i in set inds p_tpL];

  NormaliseAccessTypeSet: set of AccessType ==> set of AccessType
  NormaliseAccessTypeSet(p_acctpS) ==
    return {NormaliseAccessType(l_acctp) | l_acctp in set p_acctpS};

  NormaliseAccessType: AccessType ==> AccessType
  NormaliseAccessType(p_acctp) ==
    return mu(p_acctp,tp |-> NormaliseTypeName(p_acctp.tp));

  NormaliseTypeName: REP`TypeRep ==> REP`TypeRep
  NormaliseTypeName(p_tp) ==
    cases p_tp:
      mk_REP`TypeNameRep(nm) -> if len nm.ids > 1 and
                                        let l_clnm  = mk_AS`Name([hd nm.ids],nm.cid),
                                            l_elmnm = mk_AS`Name(tl nm.ids,nm.cid)
                                        in
                                          VCM`IsClassName(l_elmnm) and
                                          def l_pte = VCM`GetClassTypeRep(l_clnm);
                                              l_tps = if l_pte = nil
                                                      then {|->}
                                                      else l_pte.tps
                                          in
                                            l_elmnm not in set dom l_tps
                                then return mk_REP`TypeNameRep(mu(p_tp.nm,ids |-> tl (p_tp.nm.ids)))
                                else return p_tp,
    mk_REP`CompositeTypeRep(tag, fields) ->
      (dcl l_fields : seq of REP`FieldRep := [];
       for mk_REP`FieldRep(sel,type,cid) in fields do
         l_fields := l_fields ^ [mk_REP`FieldRep(sel,NormaliseTypeName(type),cid)];
       return mk_REP`CompositeTypeRep(tag,l_fields)),
    mk_REP`UnionTypeRep(tp_s) ->
       (dcl l_tps: set of REP`TypeRep := {};
        for all type in set tp_s do
           l_tps := l_tps union {NormaliseTypeName(type)};
        return mk_REP`UnionTypeRep(l_tps)),
    mk_REP`ProductTypeRep(tp_l) -> return mk_REP`ProductTypeRep(NormaliseTypeNameList(tp_l)),
    mk_REP`InvTypeRep(name,type,invar) -> return mk_REP`InvTypeRep(name,NormaliseTypeName(type),invar),
#ifdef VICE
    mk_REP`ObjRefTypeRep(nm) ->
       return if nm.ids = []
              then mk_REP`TypeNameRep(nm)
              else p_tp,
#endif VICE
    mk_REP`SetTypeRep(type),
    mk_REP`EmptySetTypeRep(type),
    mk_REP`SeqTypeRep(type),
    mk_REP`EmptySeqTypeRep(type) -> return mu(p_tp,elemtp |-> NormaliseTypeName(type)),
    mk_REP`GeneralMapTypeRep(d,r),
    mk_REP`InjectiveMapTypeRep(d,r),
    mk_REP`EmptyMapTypeRep(d,r) -> def l_dtp = NormaliseTypeName(d);
                                       l_rtp = NormaliseTypeName(r)
                                   in
                                     return mu(p_tp,mapdom |-> l_dtp,maprng |-> l_rtp),
    mk_REP`PartialFnTypeRep(tp_l, tp),
    mk_REP`TotalFnTypeRep(tp_l, tp) -> (dcl l_dtp : seq of REP`TypeRep | REP`AllTypeRep;
                                        if is_REP`AllTypeRep(tp_l)
                                        then l_dtp := tp_l
                                        else l_dtp := NormaliseTypeNameList(tp_l);
                                        def l_rtp = NormaliseTypeName(tp)
                                        in
                                         return mu(p_tp,fndom |-> l_dtp,fnrng |-> l_rtp)),
#ifdef VICE
-- This is needed to take care of isPriority operations on CPUs
   mk_REP`OpTypeRep([mk_REP`AnyOpTypeRep(), mk_REP`NumericTypeRep(<NAT>)], mk_REP`UnitTypeRep()) ->
       let l_dtp = [mk_REP`TypeNameRep(mk_AS`Name(["top"],CI`NilContextId)), mk_REP`NumericTypeRep(<NAT>)]
       in
         return mu(p_tp,Dom |-> l_dtp),
#endif VICE
    mk_REP`OpTypeRep(Dom, Rng) -> def l_dtp = NormaliseTypeNameList(Dom);
                                      l_rtp = NormaliseTypeName(Rng)
                                  in
                                    return mu(p_tp,Dom |-> l_dtp,Rng |-> l_rtp),
    mk_REP`PolyTypeRep(vars,tp) -> return mk_REP`PolyTypeRep(vars,NormaliseTypeName(tp)),
    others -> return p_tp
  end;
\end{vdm_al}

The functions \texttt{GetOperationSignature} and
\texttt{GetFunctionSignature} are utility functions used to extract
the signature from operation and function definitions respectively.
\begin{vdm_al}
operations

GetOperationSignature : AS`OpDef ==> (seq of REP`TypeRep) * REP`TypeRep
GetOperationSignature(op) ==
  if is_AS`ExplOpDef(op)
  then return mk_(TransTypeList(nil, op.tp.opdom), TransType(nil, op.tp.oprng))
  else return mk_(TransTypeList(nil, ConstructImplDomType(op.partps)), TransType(nil, ConstructImplRngType(op.resnmtps)));

GetFunctionSignature : AS`FnDef ==> (seq of REP`TypeRep) * REP`TypeRep
GetFunctionSignature(fn) ==
  if is_AS`ExplFnDef(fn)
  then return mk_(TransTypeList(nil, fn.tp.fndom), TransType(nil, fn.tp.fnrng))
  else return mk_(TransTypeList(nil, ConstructImplDomType(fn.partps)), TransType(nil, ConstructImplRngType(fn.resnmtps)));

\end{vdm_al}
The functions \texttt{GetOperationStaticStatus} and
\texttt{GetFunctionStaticStatus} are utility functions used to
extract whether respectively an operation and a function definitions
is static. The functionality is isolated in functions to ease the
implementation.
\begin{vdm_al}
functions

GetOperationStaticStatus : AS`OpDef -> bool
GetOperationStaticStatus(op) ==
  op.stat;

GetFunctionStaticStatus : AS`FnDef -> bool
GetFunctionStaticStatus(fn) ==
  fn.stat;

operations
  ExpandInstanceVars: seq of AS`InstanceVarDef ==> bool
  ExpandInstanceVars(inst_l) ==
    (dcl reswf : bool := true;
     for inst in inst_l do
       if is_AS`InstAssignDef(inst) then
         let mk_AS`InstAssignDef(mk_AS`AssignDef (nm, tp, -, -),-,stat, -) = inst in
           if not CheckName(nm)
                   ---------------------------------
                   -- Error message #95
                   -- State name "%1" is disregarded
                   ---------------------------------
             then (ERR`GenErr (nm,<MESSAGE>,95,[PrintName(nm)]);
                   reswf := false)
            else StateEnv := StateEnv munion {nm |-> mk_TypeRepElem(TransType(nil,tp),false, stat)};
     return reswf);
#endif VDMPP

  ExtractValueDefsFirst: TYPE`Ind * seq of AS`ValueDef ==> bool
  ExtractValueDefsFirst(i,vals) ==
   (dcl reswf : bool := true;

    ValueIds := dunion {dom PAT`ExtractPatternName(defi.pat) | defi in set elems vals};

    for mk_AS`ValueDef(pat,tp,-,-,-,-) in vals do
     if tp <> nil then
      def mk_(wf,bd) = PAT`wf_Pattern(i,pat,TransType(nil,tp))
      in
        (reswf := (wf = true) and reswf;
         ConstEnv := ConstEnv ++ {nm |->
                                    mk_TypeRepElem(
                                      bd(nm).#1,
                                      if nm in set dom ConstEnv
                                      then ConstEnv(nm).used
                                      else false,
                                      true)
                                 | nm in set dom bd});

    for all nm in set ValueIds do
      reswf := CheckName(nm) and reswf;

    return reswf);

  ExtractValueDefs: TYPE`Ind * seq of AS`ValueDef ==> bool
  ExtractValueDefs(i,vals) ==
   (dcl valbds : map AS`Name to (REP`TypeRep * bool);
    dcl reswf : bool;

    def mk_(wf, bds) = ExtractPatterns(i,vals)
    in
      (valbds := bds;
       reswf := wf);
    ConstEnv := ConstEnv ++ {nm |-> mk_TypeRepElem(valbds(nm).#1,false, valbds(nm).#2)
                            | nm in set dom valbds};

    for val in vals do
      def mk_(wf_def,bd) = wf_ValueDef(i,val)
      in
        (reswf := wf_def and reswf;
#ifdef VDMPP
         for all nm in set dom bd do
           --reswf := CheckDefAccess(val.access,nm) and reswf;
           reswf := CheckDefAccess(VCM`MakeTpRng(bd(nm).#1, val.access, true), nm) and reswf;
#endif VDMPP
         ConstEnv := ConstEnv ++
                     { nm |-> mk_TypeRepElem(
                                bd(nm).#1,
                                if nm in set dom ConstEnv
                                then ConstEnv(nm).used
                                else false,
                                if nm in set dom ConstEnv
                                then ConstEnv(nm).stat
                                else true)
                     | nm in set dom bd}
        );
    return reswf);

  ExtractPatterns: TYPE`Ind * seq of (AS`ValueDef | AS`FnDef) ==> bool * map AS`Name to (REP`TypeRep * bool)
  ExtractPatterns(i,vals) ==
   (dcl valbds : map AS`Name to (REP`TypeRep * bool) := {|->},
        valNames : set of AS`Name := {},
        reswf : bool := true;

    for defi in vals do
      if is_AS`ValueDef(defi)
      then let mk_AS`ValueDef(pat,tp,-,-,stat,-) = defi in
           let newids = dom PAT`ExtractPatternName(pat)
           in
            (for all id in set newids do
              if id in set dom valbds
                   ---------------------------------------------------------
                   -- Error message #100
                   -- "%1" is multiple defined, and must have the same value
                   ---------------------------------------------------------
              then ERR`GenErr(id,<WARNING>,100,[PrintName(id)]);
             if tp <> nil
             then def wftp = DEF`wf_Type(i,tp)
                  in
                   (reswf := reswf and wftp;
                    MarkUsedType(tp);
                   def mk_(wf,bd) = PAT`wf_Pattern(i,pat,TransType(nil,tp))
                   in
                   (if wf <> true
                         ---------------------------------------
                         -- Error message #101
                         -- Rhs of value definition cannot match
                         ---------------------------------------
                   then (ERR`GenErr(pat,<ERROR>,101,[]);
                         reswf := false);
                   for all id in set newids do
                    if id in set dom valbds
                    then if valbds(id).#1 = mk_REP`TmpTypeRep()
                         then (valbds := valbds ++ {id |-> mk_(bd(id).#1, stat)};
                               valNames := valNames union {id})
                         elseif valbds(id).#1 <> bd(id).#1
                               ------------------------------------------
                               -- Error message #102
                               -- "%1" is assigned to two different types
                               ------------------------------------------
                         then (ERR`GenErr(id,<ERROR>,102,[PrintName(id)]);
                               reswf := false)
                         else skip
                    else (valbds := valbds munion {id |-> mk_(bd(id).#1, stat)};
                          valNames := valNames union {id})))
             else for all id in set newids do
                    if id not in set dom valbds then
                       (valbds := valbds munion {id |-> mk_(mk_REP`TmpTypeRep(), stat)};
                        valNames := valNames union {id}))
       elseif is_AS`ExplFnDef(defi)
       then
         def mk_AS`ExplFnDef(nm,tv_l,tp,-,-,fnpre,fnpost,-,stat,-,-) = defi;
             fntp = TransType(nil,tp);
         in
          (dcl rep : REP`TypeRep;
           if tv_l <> []
           then rep := mk_REP`PolyTypeRep(TransTypeList(nil,tv_l), TransType(nil,tp))
           else rep := TransType(nil,tp);
           if nm in set dom valbds
              ----------------------------------------------
              -- Error message #103
              -- "%1" cannot be used in multiple definitions
              ----------------------------------------------
           then
            (ERR`GenErr(nm,<ERROR>,103,[PrintName(nm)]);
             reswf := false)
           else
            (valbds := valbds munion {nm |-> mk_(rep, stat)};
             valNames := valNames union {nm};
             if tv_l <> []
             then
               def mk_(field1, field2) = AUX`MakePolyPreType(TransTypeList(nil,tv_l), fntp)
               in
                (if fnpre <> nil
                 then valbds := valbds munion { AUX`Pre(nm) |-> mk_(mk_REP`PolyTypeRep(field1,field2), stat)};
                 if fnpost <> nil
                 then valbds := valbds munion { AUX`Post(nm) |-> mk_(mk_REP`PolyTypeRep(field1,field2), stat)} )
             else
               (if fnpre <> nil
                then valbds := valbds munion { AUX`Pre(nm) |-> mk_(AUX`MakePreType(fntp), stat)};
                if fnpost <> nil
                then valbds := valbds munion { AUX`Post(nm) |-> mk_(AUX`MakePostType(fntp), stat)}
               )
            )
          )
        elseif is_AS`ImplFnDef(defi)
        then let mk_AS`ImplFnDef(nm,tv_l,partps,resnmtps,fnpre,-,-,stat,-) = defi
             in
             def domtps = ConstructImplDomType(partps);
                 rngtp = ConstructImplRngType(resnmtps);
                 domtp = TransTypeList(nil,domtps);
                 restp = TransType(nil,rngtp);
                 fnsig = mk_REP`TotalFnTypeRep(domtp, restp);
                 fnpresig = mk_REP`TotalFnTypeRep(domtp, mk_REP`BooleanTypeRep());
                 fnpostsig = mk_REP`TotalFnTypeRep(domtp^[restp], mk_REP`BooleanTypeRep());
             in
              (dcl rep : REP`TypeRep;
               if tv_l <> []
               then rep := mk_REP`PolyTypeRep(TransTypeList(nil,tv_l), fnsig)
               else rep := fnsig;
               if nm in set dom valbds
                         ----------------------------------------------
                         -- Error message #103
                         -- "%1" cannot be used in multiple definitions
                         ----------------------------------------------
               then (ERR`GenErr(nm,<ERROR>,103,[PrintName(nm)]);
                     reswf := false)
               else
                (valbds := valbds munion {nm |-> mk_(rep,stat)};
                 valNames := valNames union {nm};
                 if tv_l <> []
                 then
                  (if fnpre <> nil
                   then
                     valbds := valbds munion
                               { AUX`Pre(nm) |-> mk_(mk_REP`PolyTypeRep( TransTypeList(nil,tv_l),fnpresig), stat)};
                   valbds := valbds munion
                             { AUX`Post(nm) |-> mk_(mk_REP`PolyTypeRep( TransTypeList(nil,tv_l),fnpostsig), stat)}
                  )
                 else
                  (if fnpre <> nil
                   then
                     valbds := valbds munion { AUX`Pre(nm) |-> mk_(fnpresig, stat)};
                   valbds := valbds munion { AUX`Post(nm) |-> mk_(fnpostsig, stat)}
                  )
               )
             )
        else
          let mk_AS`ExtExplFnDef(nm,tv_l,partps,resnmtps,-,fnpre,fnpost,-, stat,-,-) = defi
          in
          def domtps = ConstructImplDomType(partps);
              rngtp = ConstructImplRngType(resnmtps);
              domtp = TransTypeList(nil,domtps);
              restp = TransType(nil,rngtp);
              fnsig = mk_REP`TotalFnTypeRep(domtp, restp);
              fnpresig = mk_REP`TotalFnTypeRep(domtp, mk_REP`BooleanTypeRep());
              fnpostsig = mk_REP`TotalFnTypeRep(domtp^[restp], mk_REP`BooleanTypeRep());
          in
           (dcl rep : REP`TypeRep;
            if tv_l <> []
            then rep := mk_REP`PolyTypeRep(TransTypeList(nil,tv_l), fnsig)
            else rep := fnsig;
            if nm in set dom valbds
             ----------------------------------------------
             -- Error message #103
             -- "%1" cannot be used in multiple definitions
             ----------------------------------------------
          then (ERR`GenErr(nm,<ERROR>,103,[PrintName(nm)]);
                reswf := false)
          else
          ( valbds := valbds munion {nm |-> mk_(rep,stat)};
            valNames := valNames union {nm};
            if tv_l <> []
            then
            (
              if fnpre <> nil
              then valbds := valbds munion
                             { AUX`Pre(nm) |-> mk_(mk_REP`PolyTypeRep(TransTypeList(nil,tv_l),fnpresig), stat)};
              if fnpost <> nil
              then valbds := valbds munion
                             { AUX`Post(nm) |-> mk_(mk_REP`PolyTypeRep(TransTypeList(nil,tv_l),fnpostsig), stat)}
            )
            else
            ( if fnpre <> nil
              then valbds := valbds munion {AUX`Pre(nm) |-> mk_(fnpresig,stat)};
              if fnpost <> nil
              then valbds := valbds munion {AUX`Post(nm) |-> mk_(fnpostsig, stat)}
            )
          ));

    for all nm in set valNames do
      if AUX`ReservedPrefix (nm)
             ----------------------------------
             -- Error message #110
             -- "%1" contains a reserved prefix
             ----------------------------------
      then ( ERR`GenErr(nm,<ERROR>,110,[PrintName(nm)]);
            reswf := false);

    return mk_(reswf,valbds));

  wf_ValueDef : TYPE`Ind * AS`ValueDef ==> bool * map AS`Name to (REP`TypeRep * nat1)
#ifdef VDMSL
  wf_ValueDef(i,mk_AS`ValueDef(pat,tp,val,-,-,cid)) ==
#endif VDMSL
#ifdef VDMPP
  wf_ValueDef(i,mk_AS`ValueDef(pat,tp,val,access,-,cid)) ==
#endif VDMPP
   (dcl exptp : REP`TypeRep;
    if tp = nil
    then exptp := PAT`Pattern2TypeRep(pat)
    else exptp := TransType(nil,tp);
    def patbind = if tp = nil
                  then pat
                  else mk_AS`TypeBind(pat,tp,cid);
        mk_(wf_e,tp_e) = EXPR`wf_Expr(i,val,exptp);
        mk_(wf_pb,bd) = PAT`wf_PatternBind(i,patbind,tp_e)
    in
     (if wf_pb <> true
      -----------------------
      -- Error message #104
      -- Pattern cannot match
      -----------------------
      then ERR`GenErr(pat, <ERROR>,104,[]);
#ifdef VDMSL
      return mk_(wf_e and (wf_pb = true),bd));
#endif VDMSL
#ifdef VDMPP
       if access = <NOT_INITIALISED_AS>
       then return mk_(wf_e and (wf_pb = true),bd)
       else
         def wf_acc = CheckPatternBindAccess(access,bd)
         in return mk_(wf_e and (wf_pb = true) and wf_acc ,bd));
#endif VDMPP
   );
\end{vdm_al}


#ifdef VDMPP
\begin{vdm_al}

  IsSubClass: AS`Name * AS`Name ==> bool
  IsSubClass(nm1, nm2) ==
    return nm2 in set TransClos(nm1);

  IsLocalSuperSuper : AS`Name ==> bool
  IsLocalSuperSuper (nm) ==
    return nm in set SuperSuper;

   TransClos: AS`Name ==> set of AS`Name
   TransClos(nm) ==
     TransClosAux(nm, {})
   pre VCM`GetClassTypeRep(nm) <> nil;
\end{vdm_al}
The operation \texttt{TransClosIndex} performs a traversal of the
hierarchy structure of a class, and returns a map from nat (indicating
distance) to the set of super classes which correspond to this
distance from the sub class.
\begin{vdm_al}
   TransClosIndex: AS`Name ==> map nat to set of AS`Name
   TransClosIndex(nm) ==
     return TransClosIndexAux(nm, 1, {nm}) -- nm should not be necessary, as the
                                    -- inheritance tree should not contain
                                    -- cycles
   pre VCM`GetClassTypeRep(nm) <> nil;

   TransClosAux: AS`Name * set of AS`Name ==> set of AS`Name
   TransClosAux(nm, done) ==
     (dcl supers : set of AS`Name := {},
          dones : set of AS`Name := done;
      if CheckClassName(nm)
      then supers := LookUpClass(nm).super;
      while not (supers subset dones) do
        let super in set supers\dones
        in
          (supers := supers union TransClosAux(super, dones union {super});
           dones := dones union {super});
      return supers);

\end{vdm_al}
The function \texttt{TransClosIndexAux} is a recursive helper function
for \texttt{TransClosIndex}.
\begin{vdm_al}
operations

  TransClosIndexAux: AS`Name * nat *set of AS`Name ==> map nat to set of AS`Name
  TransClosIndexAux(nm, base, done) ==
   (dcl l_supers : set of AS`Name := {};
    if CheckClassName(nm)
    then l_supers := LookUpClass(nm).super \ done;
    let l_newDone = l_supers union done
    in
     (dcl resmap : map nat to set of AS`Name := { base |-> l_supers };
      for all b_s in set l_supers do
        def indexentry = TransClosIndexAux(b_s, base + 1, l_newDone)
        in
         if dom indexentry inter dom resmap <> {}
          then for all entry in set dom indexentry inter dom resmap do
                 resmap(entry) := resmap(entry) union indexentry(entry)
          else resmap := resmap munion indexentry;
      return resmap);
   );
\end{vdm_al}
#endif VDMPP



#ifdef VDMPP
XXXX

The operation {\em CheckParmsInHierarchy\/} checks that the
signature of operation/function {\em nm\/} of the current class is compatible
with operations that it overrides in the super classes. {\em ptps\/}
is the parameter types. {\em p\_acc\/} is the access permission of the
operation/function.
The boolean value {\em op\_or\_fn} indicates whether an operation or
function is being analyzed.

{\em LookUpParmsInHierarchy\/} together with {\em
ExtractParmsMap\/} finds operations of name {\em nm\/} in the super
classes of the current class and returns a mapping from class name to
signature.

\begin{vdm_al}
  CheckParmsInHierarchy: AS`Name * seq of REP`TypeRep * AS`Access * bool ==> bool
  CheckParmsInHierarchy(nm, ptps, p_acc, op_or_fn) ==
    ( dcl reswf : bool := true;
      def superparms = LookUpParmsInHierarchy(nm, op_or_fn) in
      let l_supOccs = { b_clnm | b_clnm in set dom superparms & GetMethDom(superparms(b_clnm).tp) = ptps }
      in
        for all b_supOcc in set l_supOccs do
          if not NotNarrowedAccess(superparms(b_supOcc).a, p_acc)
          then
          (
            --------------------------------------
            -- Error 369
            -- Scope narrowed by "%1"
            -------------------------------------
            ERR`GenErr (nm, <ERROR>,369,[PrintName (nm)]);
            reswf := false;
          );
      return reswf
    );

  LookUpParmsInHierarchy: AS`Name * bool ==>
                          map AS`Name to (AccessOpTypeRep | AccessFnTypeRep)
  LookUpParmsInHierarchy(nm, op_or_fn) ==
    ( dcl class_m : map AS`Name to (AccessOpTypeRep | AccessFnTypeRep) := {|->};
      for all classnm in set SuperSuper do
        def pti = VCM`GetClassTypeRep(classnm)
        in
          if pti <> nil then -- class was found
               let meths = if op_or_fn then
                              pti.ops
                            else
                              pti.fcts
               in
                   class_m := class_m ++ ExtractParmsMap(nm, classnm, meths);
      return class_m
    );

  ExtractParmsMap: AS`Name * AS`Name * map AS`Name to (AccessOpTypeRep | AccessFnTypeRep)
                   ==> map AS`Name to (AccessOpTypeRep | AccessFnTypeRep)
  ExtractParmsMap(nm, classnm, meths) ==
    (
      let mk_AS`Name([nm1],-) = nm in
        -- Notice the assumption that nm contains no class name.
      for all meth in set dom meths do
        let mk_AS`Name([-, nm2], -) = meth in
          -- Notice the assumption that  contains a class name.
        if nm1 = nm2
        then let tp = meths(meth) in
             return { classnm |-> tp };
      return { |-> }
    )
  pre len nm.ids = 1 and forall meth in set dom meths & len meth.ids = 2;

\end{vdm_al}

{\em FindSuperClassPath\/} together with {\em FindSuperClassPathAux\/}
finds the inheritance path from class {\em clsnm\/} to class {\em
supernm}.

PGL (December 2006): These do not seem to be used so they are commented out

%%\begin {vdm_al}
%--  FindSuperClassPath: AS`Name * AS`Name ==> seq of char * nat
%--  FindSuperClassPath(clsnm, supernm) ==
%--    let mk_(clspath, res) = FindSuperClassPathAux(clsnm, supernm) in
%--    ( dcl msg : seq of char := [];
%--      for i = 1 to len clspath - 1 do
%--        msg := msg ^ PrintName(clspath(i)) ^ " -> ";
%--      msg := msg ^ PrintName(clspath(len clspath));
%--      return mk_(msg, len clspath) );

%--  FindSuperClassPathAux: AS`Name * AS`Name ==> seq of AS`Name * bool
%--  FindSuperClassPathAux(clsnm, supernm) ==
%--    ( let supercls = LookUpClass(clsnm).super in
%--      if supernm in set supercls
%--      then return mk_([clsnm, supernm], true)
%--      else
%--        for all cls in set supercls do
%--          let mk_(clspath, res) = FindSuperClassPathAux(cls, supernm) in
%--          if res
%--          then return mk_([clsnm]^clspath, res);
%--      return mk_([], false)
%--    );
%%\end {vdm_al}
#endif VDMPP

\begin{vdm_al}
  InitEnv : () ==> ()
  InitEnv() ==
   (
    ValueIds := {};
    WhereAmI := [<PURE>];
    ExtEnv := {|->};
    TypeEnv := {|->};
#ifdef VDMSL
    InsideInter:= false;
    RenamedTypes := {|->};
    TypeParEnv := {|->};
#endif VDMSL
    TypeVars := [];
    TagEnv := {|->};
#ifdef VDMSL
    LocTagEnv := {|->};
#endif VDMSL
    ConstEnv := {|->};
    LocalEnv := [];
    StateEnv := {|->};
    FunctionEnv := {|->};
    PolyEnv := {|->};
    OperationEnv := {|->};
#ifdef VDMPP
    OverloadedEnv := {|->};
    SubrespsEnv := {|->};
#endif VDMPP
#ifdef VDMSL
    Renamed := {};
#endif VDMSL
    UsedName := {};
    SEnv := []
#ifdef VDMPP
    ;
    CheckClass := nil;
    Super := {};
    SuperSuper := {};
    TraceEnv := {};
    CurrentMethod := nil;
    FoundClass := nil;
    DefiningClass := []; --nil
#endif VDMPP
    );

  SetExtAll: set of AS`Name ==> bool
  SetExtAll(nm_s) ==
   (dcl reswf : bool := true;

    ExtEnv := {nm |-> <READWRITE> | nm in set dom StateEnv};
    for all nm in set dom StateEnv do
      if nm in set nm_s
            ------------------------------------------------------------------
            -- Error message #105
            -- "%1" is used in both parameter list and in the state definition
            ------------------------------------------------------------------
      then (--ERR`GenErr(nm,<ERROR>,105,[PrintName(nm)]);
            --let pnm in set nm_s be st pnm = nm  -- get name in nm_s for contextinfo
            let {pnm} = nm_s inter {nm}  -- get name in nm_s for contextinfo
            in ERR`GenErr(pnm,<ERROR>,105,[PrintName(pnm)]);
            reswf := false);
    return reswf);

  SetExt: seq of AS`ExtInf * set of AS`Name ==> bool
  SetExt(ext_l,nm_s) ==
    (dcl reswf : bool := true;

     ExtEnv := {|->};
     for mk_AS`ExtInf(md,vars,tp,-) in ext_l do
     ( if tp <> nil then
         MarkUsedType(tp);
       for var in vars do
         def sttp = LookUpState(var,false,<CUR>) in
         (if sttp = nil
          then reswf := false
          elseif tp <> nil and sttp <>
#ifdef VDMSL
                 AUX`InstFn(<PAR>,TransType(nil,tp),TypeParEnv)
#endif VDMSL
#ifdef VDMPP
                 TransType(nil,tp)
#endif VDMPP
                ----------------------------------------------------------------
                -- Error message #106
                -- The type listed for "%1" in the external clause is not the
                -- correct type from the state definition
                ----------------------------------------------------------------
          then (ERR`GenErr(var,<ERROR>,106,[PrintName(var)]);
                reswf := false);
          if var in set dom ExtEnv
                -------------------------------------------
                -- Error message #107
                -- "%1" is multiple used in this ext clause
                -------------------------------------------
          then (ERR`GenErr(var,<ERROR>,107,[PrintName(var)]);
                reswf := false)
          elseif var in set nm_s
                -------------------------------------------------------------
                -- Error message #108
                -- "%1" is used in both parameter list and in this ext clause
                -------------------------------------------------------------
          then (ERR`GenErr(var,<ERROR>,108,[PrintName(var)]);
                reswf := false)
          else ExtEnv := ExtEnv ++ {var |-> md}));
      return reswf);

  PushTypeVarContext: seq of REP`TypeVarRep ==> ()
  PushTypeVarContext(tv_l) ==
    TypeVars := [elems tv_l] ^ TypeVars;

  PopTypeVarContext: () ==> ()
  PopTypeVarContext() ==
    TypeVars := tl TypeVars;

#ifdef VDMSL
  PushContext: <PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE> ==> ()
#endif VDMSL
#ifdef VDMPP
  PushContext: <PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE>|<PERM>|<PTHREAD> ==> ()
#endif VDMPP
  PushContext(kind) ==
    WhereAmI := [kind] ^ WhereAmI;

  PopContext: () ==> ()
  PopContext() ==
    WhereAmI := tl WhereAmI;

#ifdef VDMSL
  GetContext: () ==> <PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE>
#endif VDMSL
#ifdef VDMPP
  GetContext: () ==> <PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE>|<PERM>|<PTHREAD>
#endif VDMPP
  GetContext() ==
    return hd WhereAmI;

#ifdef VDMPP
  TransBinds: AS`Name * map AS`Name to (REP`TypeRep| AccessType| (AS`Name * AccessFieldRep) | set of AccessOpTypeRep)
              ==> map AS`Name to (REP`TypeRep|AccessType| (AS`Name * AccessFieldRep) | set of AccessOpTypeRep)
  TransBinds(classnm,binds) ==
    (dcl res_binds : map AS`Name to (REP`TypeRep|AccessType| (AS`Name * AccessFieldRep)| set of AccessOpTypeRep)
                   := {|->};

     for all nm in set dom binds do
       cases binds(nm) :
         mk_(tag,f_l) ->
           let fr_l = f_l.tp in
           def nf_l = [mk_REP`FieldRep((fr_l(i)).sel, PrependClassName(classnm,(fr_l(i)).tp), (fr_l(i)).dc)
                      | i in set inds fr_l]
           in
             res_binds := res_binds munion {nm |-> mk_(tag,mk_AccessFieldRep(nf_l,f_l.a))},
         tp -> --res_binds := res_binds munion {nm |->
               if IsAccessType (tp)
               then
                 res_binds := res_binds munion {nm |-> mu (tp,tp |-> PrependClassName(classnm,tp.tp)) }
               elseif is_(tp, set of AccessOpTypeRep)
               then
                 res_binds := res_binds munion {nm |-> { mu (tpe, tp |-> PrependClassName(classnm, tpe.tp)) | tpe in set tp } }
               else
                 res_binds := res_binds munion {nm |-> PrependClassName(classnm,tp)}
      end;
    return res_binds);
#endif VDMPP

  CheckName : AS`Name ==> bool
  CheckName(nm) ==
    if nm in set UsedName then (
      ---------------------------
      -- Error message #73
      -- "%1" is multiple defined
      ---------------------------
      ERR`GenErr (nm,<ERROR>,73,[PrintName(nm)]);
      return false
    )
    else if not AUX`ReservedPrefix(nm) then (
      UsedName := UsedName union {nm};
      return true
    )
    else (
      ----------------------------------
      -- Error message #110
      -- "%1" contains a reserved prefix
      ----------------------------------
      ERR`GenErr(nm,<ERROR>,110,[PrintName(nm)]);
      return false
    );

  MarkUsedType: AS`Type ==> ()
  MarkUsedType(tp) ==
    cases tp:
      mk_AS`TypeName(nm,-)              ->
#ifdef VDMSL
                                           if nm not in set dom TypeParEnv
                                           then
#endif VDMSL
                                             if nm in set dom TypeEnv
                                             then TypeEnv(nm).used := true,
      mk_AS`CompositeType(-, fields, -) -> for mk_AS`Field(-,t,-,-) in fields do
                                             MarkUsedType(t),
      mk_AS`UnionType(tp_l,-),
      mk_AS`ProductType(tp_l,-)         -> for t in tp_l do
                                             MarkUsedType(t),
      mk_AS`BracketedType(type,-),
      mk_AS`OptionalType(type,-),
      mk_AS`Set0Type(type,-),
      mk_AS`Set1Type(type,-),
      mk_AS`Seq0Type(type,-),
      mk_AS`Seq1Type(type,-)            -> MarkUsedType(type),
      mk_AS`GeneralMap0Type(d,r,-),
      mk_AS`GeneralMap1Type(d,r,-),
      mk_AS`InjectiveMap0Type(d,r,-),
      mk_AS`InjectiveMap1Type(d,r,-)     -> (MarkUsedType(d);
                                            MarkUsedType(r)),
      mk_AS`OpType(d,r,-)               -> (for t in d do
                                              MarkUsedType(t);
                                            MarkUsedType(r)),
      mk_AS`PartialFnType(tp_l, tp, -),
      mk_AS`TotalFnType(tp_l, tp, -)    -> (for t in tp_l do
                                              MarkUsedType(t);
                                            MarkUsedType(tp))
    end
\end{vdm_al}

\subsection{Transformation of Types to Internal Representation}

\begin{vdm_al}

operations
  TransTypeList: [AS`Name] * seq of AS`Type ==> seq of REP`TypeRep
  TransTypeList(modnm,tp_l) ==
     return [TransType(modnm,tp_l(index)) | index in set inds tp_l];

  TransTypeDef: [AS`Name] * AS`Name * AS`Type * [AS`Invariant] ==> REP`TypeRep
  TransTypeDef(modnm,name,tp,Invar) ==
    if Invar <> nil
    then let nm = if modnm = nil
                  then name
                  else AUX`ExtName(modnm, name)
         in return mk_REP`InvTypeRep(nm,TransType(modnm,tp),mk_(Invar.pat,Invar.expr))
    else return TransType(modnm,tp);

  TransType: [AS`Name] * AS`Type ==> REP`TypeRep
  TransType(modnm,tp) ==
    cases true:
      (is_AS`BooleanType(tp)) -> return mk_REP`BooleanTypeRep(),
      (is_AS`NumericType(tp)) -> return mk_REP`NumericTypeRep(tp.qtp),
      (is_AS`TokenType(tp))   -> return mk_REP`TokenTypeRep(),
      (is_AS`CharType(tp))    -> return mk_REP`CharTypeRep(),
      (is_AS`VoidType(tp))    -> return mk_REP`UnitTypeRep(),
      (is_AS`QuoteType(tp)) -> let mk_AS`QuoteLit(nm,-) = tp.lit
                               in return mk_REP`QuoteTypeRep(mk_AS`Name([nm],CI`NilContextId)),
           -- Wouldn't it be better to use a new Name definition that is context
           -- independent and use this instead of AS`Name ????
      (is_AS`TypeName(tp)) ->
         let nm = tp.name in
#ifdef VDMSL
         if nm in set dom TypeParEnv
         then return TypeParEnv(nm)
         else
#endif VDMSL
             if modnm = nil
             then return mk_REP`TypeNameRep(nm)
             else if len nm.ids = 1
#ifdef VDMPP
                     and not VCM`IsClassName(nm) and
                     nm in set VCM`GetTypes() -- it is a local definition
#endif VDMPP
                  then return mk_REP`TypeNameRep(AUX`ExtName(modnm,nm))
                  else return mk_REP`TypeNameRep(nm),
      (is_AS`TypeVar(tp)) ->  return mk_REP`TypeVarRep(tp.name),
      (is_AS`CompositeType(tp)) ->
         let nm = tp.name in
         return mk_REP`CompositeTypeRep(if modnm = nil
                                 then nm
                                 elseif len nm.ids = 1
                                 then AUX`ExtName(modnm,nm)
                                 else nm,
                                 TransFields(modnm,tp.fields)),
      (is_AS`UnionType(tp)) -> return mk_REP`UnionTypeRep(FlatternUnion({TransType(modnm,t) | t in set elems tp.tps})),
      (is_AS`ProductType(tp)) -> return mk_REP`ProductTypeRep(TransTypeList(modnm,tp.tps)),
      (is_AS`BracketedType(tp)) -> return TransType(modnm,tp.tp),
      (is_AS`OptionalType(tp)) -> return mk_REP`UnionTypeRep(FlatternUnion({mk_REP`NilTypeRep(), TransType(modnm,tp.tp)})),
      (is_AS`Set0Type(tp)) -> def elemtp = TransType(modnm,tp.elemtp)
                              in
                                return mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(elemtp), mk_REP`SetTypeRep(elemtp)}),
      (is_AS`Set1Type(tp)) -> return mk_REP`SetTypeRep(TransType(modnm,tp.elemtp)),
      (is_AS`Seq0Type(tp)) -> def elemtp = TransType(modnm,tp.elemtp)
                              in
                                return mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(elemtp), mk_REP`SeqTypeRep(elemtp)}),
      (is_AS`Seq1Type(tp)) -> return mk_REP`SeqTypeRep(TransType(modnm,tp.elemtp)),
      (is_AS`GeneralMap0Type(tp)) -> def mapdom = TransType(modnm,tp.mapdom);
                                         maprng = TransType(modnm,tp.maprng)
                                     in
                                       return mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mapdom,maprng),
                                                            mk_REP`GeneralMapTypeRep(mapdom,maprng)}),
      (is_AS`GeneralMap1Type(tp)) -> def mapdom = TransType(modnm,tp.mapdom);
                                         maprng = TransType(modnm,tp.maprng)
                                     in
                                       return mk_REP`GeneralMapTypeRep(mapdom,maprng),
      (is_AS`InjectiveMap0Type(tp)) -> def mapdom = TransType(modnm,tp.mapdom);
                                           maprng = TransType(modnm,tp.maprng)
                                       in
                                         return mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mapdom, maprng),
                                                              mk_REP`InjectiveMapTypeRep(mapdom, maprng)}),
      (is_AS`InjectiveMap1Type(tp)) -> def mapdom = TransType(modnm,tp.mapdom);
                                           maprng = TransType(modnm,tp.maprng)
                                       in
                                         return mk_REP`InjectiveMapTypeRep(mapdom, maprng),
      (is_AS`OpType(tp)) -> return mk_REP`OpTypeRep(TransTypeList(modnm,tp.opdom), TransType(modnm,tp.oprng)),
      (is_AS`PartialFnType(tp)) -> return mk_REP`PartialFnTypeRep(TransTypeList(modnm,tp.fndom), TransType(modnm,tp.fnrng)),
      (is_AS`TotalFnType(tp)) -> return mk_REP`TotalFnTypeRep(TransTypeList(modnm,tp.fndom), TransType(modnm,tp.fnrng))
         end
\end{vdm_al}

#ifdef VDMSL
The $CurMod$ function respectively add or remove the current module to
all named types inside the type representation $tp$.

\begin{vdm_al}
functions

  CurMod: (<ADD>|<REM>) * AS`Name * REP`TypeRep +> REP`TypeRep
  CurMod(kind,curmod,tp) ==
    cases tp:
      mk_REP`TypeNameRep(nm) ->
       if kind = <REM>
       then
        if len nm.ids = 2 and (nm.ids)(1) = (curmod.ids)(1)
        then mk_REP`TypeNameRep(mk_AS`Name(tl nm.ids,nm.cid))
        else tp
       else
        if len nm.ids = 1
        then mk_REP`TypeNameRep(mk_AS`Name(curmod.ids ^ nm.ids,nm.cid))
        else tp,
      mk_REP`CompositeTypeRep(tag, fields) ->
        let f_l = [mk_REP`FieldRep((fields(i)).sel,
                                   CurMod(kind,curmod,(fields(i)).tp),
                                   (fields(i)).dc)
                  | i in set inds fields],
            newtag = if kind = <REM>
                     then
                       if len tag.ids = 2 and (tag.ids)(1) = (curmod.ids)(1)
                       then mk_AS`Name(tl tag.ids,tag.cid)
                          -- NOTICE that the contextid of tag is reused
                       else tag
                     else
                       if len tag.ids = 1
                       then mk_AS`Name(curmod.ids ^ tag.ids,tag.cid)
                          -- NOTICE that the contextid of tag is reused
                       else tag
         in
           mk_REP`CompositeTypeRep(newtag,f_l),
                -- Wouldn't it be better to use a context independent version of Name ????
      mk_REP`UnionTypeRep(tp_s) -> mk_REP`UnionTypeRep({CurMod(kind,curmod,tp) | tp in set tp_s}),
      mk_REP`ProductTypeRep(tp_l) -> mk_REP`ProductTypeRep([CurMod(kind,curmod,tp_l(i)) | i in set inds tp_l]),
      mk_REP`SetTypeRep(type) -> mk_REP`SetTypeRep(CurMod(kind,curmod,type)),
      mk_REP`EmptySetTypeRep(type) -> mk_REP`EmptySetTypeRep(CurMod(kind,curmod,type)),
      mk_REP`SeqTypeRep(type) -> mk_REP`SeqTypeRep(CurMod(kind,curmod,type)),
      mk_REP`EmptySeqTypeRep(type) -> mk_REP`EmptySeqTypeRep(CurMod(kind,curmod,type)),
      mk_REP`GeneralMapTypeRep(d,r) -> mk_REP`GeneralMapTypeRep(CurMod(kind,curmod,d), CurMod(kind,curmod,r)),
      mk_REP`InjectiveMapTypeRep(d,r) -> mk_REP`InjectiveMapTypeRep(CurMod(kind,curmod,d), CurMod(kind,curmod,r)),
      mk_REP`EmptyMapTypeRep(d,r) -> mk_REP`EmptyMapTypeRep(CurMod(kind,curmod,d), CurMod(kind,curmod,r)),
      mk_REP`OpTypeRep(tp_l, tp) -> mk_REP`OpTypeRep([CurMod(kind,curmod,tp_l(i)) | i in set inds tp_l],
                                                     CurMod(kind,curmod,tp)),
      mk_REP`PartialFnTypeRep(tp_l, tp) ->
         cases true:
           (is_REP`AllTypeRep(tp_l)) -> mk_REP`PartialFnTypeRep(tp_l, CurMod(kind,curmod,tp)),
           others -> mk_REP`PartialFnTypeRep([CurMod(kind,curmod,tp_l(i)) | i in set inds tp_l],
                                             CurMod(kind,curmod,tp))
         end,
      mk_REP`TotalFnTypeRep(tp_l, tp) ->
         cases true:
           (is_REP`AllTypeRep(tp_l)) -> mk_REP`TotalFnTypeRep(tp_l, CurMod(kind,curmod,tp)),
           others -> mk_REP`TotalFnTypeRep([CurMod(kind,curmod,tp_l(i)) | i in set inds tp_l],
                                           CurMod(kind,curmod,tp))
         end,
      others -> tp
    end
\end{vdm_al}
#endif VDMSL

#ifdef VDMPP
\begin{vdm_al}
operations

  PrependClassName: AS`Name * REP`TypeRep ==> REP`TypeRep
  PrependClassName(classnm,tp') ==
    let tp = if IsAccessType (tp') then tp'.tp else tp' in
    cases tp:
      mk_REP`TypeNameRep(nm) -> --if len nm.ids = 1
                                if len nm.ids = 1 and not VCM`IsClassName(nm)
                                then return mk_REP`TypeNameRep(AUX`ExtName(classnm,nm))
                                else return tp,
      mk_REP`CompositeTypeRep(tag, fields) ->
        def f_l = [mk_REP`FieldRep((fields(i)).sel, PrependClassName(classnm,(fields(i)).tp), (fields(i)).dc)
                  | i in set inds fields];
            tagext = if len tag.ids = 1
                     then AUX`ExtName(classnm,tag)
                     else tag
        in
         return mk_REP`CompositeTypeRep(tagext,f_l),
      mk_REP`UnionTypeRep(tp_s) -> return mk_REP`UnionTypeRep({PrependClassName(classnm,tp) | tp in set tp_s}),
      mk_REP`ProductTypeRep(tp_l) -> return mk_REP`ProductTypeRep([PrependClassName(classnm,tp_l(i)) | i in set inds tp_l]),
      mk_REP`SetTypeRep(type) -> return mk_REP`SetTypeRep(PrependClassName(classnm,type)),
      mk_REP`EmptySetTypeRep(type) -> return mk_REP`EmptySetTypeRep(PrependClassName(classnm,type)),
      mk_REP`SeqTypeRep(type) -> return mk_REP`SeqTypeRep(PrependClassName(classnm,type)),
      mk_REP`EmptySeqTypeRep(type) -> return mk_REP`EmptySeqTypeRep(PrependClassName(classnm,type)),
      mk_REP`GeneralMapTypeRep(d,r) -> return mk_REP`GeneralMapTypeRep(PrependClassName(classnm,d),
                                                                PrependClassName(classnm,r)),
      mk_REP`InjectiveMapTypeRep(d,r) -> return mk_REP`InjectiveMapTypeRep(PrependClassName(classnm,d),
                                                                    PrependClassName(classnm,r)),
      mk_REP`EmptyMapTypeRep(d,r) -> return mk_REP`EmptyMapTypeRep(PrependClassName(classnm,d),
                                                            PrependClassName(classnm,r)),
      mk_REP`PartialFnTypeRep(tp_l, tp) ->
         return mk_REP`PartialFnTypeRep([PrependClassName(classnm,tp_l(i)) | i in set inds tp_l],
                                 PrependClassName(classnm,tp)),
      mk_REP`TotalFnTypeRep(tp_l, tp) ->
         return mk_REP`TotalFnTypeRep([PrependClassName(classnm,tp_l(i)) | i in set inds tp_l],
                               PrependClassName(classnm,tp)),
      others -> return tp
    end;
\end{vdm_al}
#endif VDMPP

\begin{vdm_al}
functions
  FlatternUnion : set of REP`TypeRep -> set of REP`TypeRep
  FlatternUnion(tps) ==
    dunion {if is_REP`UnionTypeRep(tp)
            then let mk_REP`UnionTypeRep(t_s) = tp
                 in
                   FlatternUnion(t_s)
            else {tp}
           | tp in set tps};

  TransFields : [AS`Name] * seq of AS`Field -> seq of REP`FieldRep
  TransFields(modnm,f_l) ==
    [mk_REP`FieldRep(f_l(i).sel, TransType(modnm,f_l(i).type),f_l(i).dc)
    | i in set inds f_l];

#ifdef VDMSL
  TransStateType : [AS`Name] * AS`StateDef -> REP`TypeRep
  TransStateType(modid,mk_AS`StateDef(tp,Invar,-,-)) ==
    TransTypeDef(modid,tp.name,tp,Invar);
#endif VDMSL

  ConstructImplParms : AS`ParameterTypes -> seq of AS`Pattern
  ConstructImplParms (partps) ==
    conc [ let pats = partps(i).pats
           in
             pats
         | i in set inds partps];

  PrintName : AS`Name -> seq of char --OK
  PrintName (mk_AS`Name(ids,-)) ==
    cases ids:
      [a] -> a,
      [a,b] -> a ^ "`" ^ b,
      others -> undefined
    end
  pre len ids in set {1,2};

operations
  ExtractValueBindings : seq of AS`NameType ==> map AS`Name to (REP`TypeRep * nat1)
  ExtractValueBindings(valtps) ==
    if valtps = []
    then return {|->}
    else return { valtp.nm |-> mk_(TransType(nil,valtp.tp), 1) | valtp in set elems valtps };

functions
#ifdef VDMPP
  MakeEmptyClass : AS`Name -> ParseTypeInfo
  MakeEmptyClass(nm) ==
    mk_ParseTypeInfo(nm,false,{},{|->},{|->},{|->},{|->},{|->},{|->},{|->},
                    {|->}, <NONE>, {},{|->},{|->}, false);
#endif VDMPP

  ConstructImplDomType : AS`ParameterTypes -> seq of AS`Type
  ConstructImplDomType (partps) ==
    conc [ [partps(i).tp | - in set inds partps(i).pats] | i in set inds partps];

  ConstructImplRngType : seq of AS`NameType -> AS`Type
  ConstructImplRngType (nmtps) ==
    cases nmtps:
      []     -> mk_AS`VoidType(CI`NilContextId),
      [nmtp] -> nmtp.tp,
      others -> let tps = [ nmtps(i).tp | i in set inds nmtps]
                in
                  mk_AS`ProductType(tps, CI`NilContextId)
    end;
\end{vdm_al}

#ifdef VDMPP
\subsection{Static Members}
The following functions are the public interface to the
\texttt{isStatic} state variable. This variable is used to indicate
whether the current context is static or not.
\begin{vdm_al}
operations
SetStatic : bool ==> ()
SetStatic(p_b) ==
  isStatic := p_b;

UnsetStatic : () ==> ()
UnsetStatic() ==
  isStatic := false;

GetStatic : () ==> bool
GetStatic() ==
  return isStatic;
\end{vdm_al}
#endif VDMPP

\begin{vdm_al}
#ifdef VDMSL
operations
PublicLookUpTypeName : AS`Name * AS`Name ==> [REP`TypeRep]
PublicLookUpTypeName(nm,-) ==
  return LookUpTypeName(nm);
#endif VDMSL
#ifdef VDMPP
PublicLookUpTypeName : AS`Name * AS`Name ==> [REP`TypeRep|AccessType] * [AS`Name]
PublicLookUpTypeName(nm, clnm) ==
 (SetCurClass(clnm);
  SetDefClass(clnm);
  def tp = LookUpTypeName (nm, true);
      foundCls = FoundClass; -- FoundClass is destroyed by calling CheckAccessCurClass
      res = mk_(CheckAccessCurClass (tp), foundCls)
  in
   (UnSetDefClass();
    return res;)
 );
#endif VDMPP

#ifdef VDMSL
LookUpStateEnv: AS`Name ==> [REP`TypeRep]
LookUpStateEnv(nm) ==
  if nm in set dom StateEnv
  then let rsttp = StateEnv(nm).tp
       in
         if is_REP`InvTypeRep(rsttp)
         then return rsttp.shape
         else return rsttp
  else return nil;
#endif VDMSL

#ifdef VDMPP
LookUpOpOrFnName: [AS`Name] * AS`Name ==> [REP`TypeRep | set of REP`TypeRep]
LookUpOpOrFnName(classnm, metnm) ==
 (dcl tp : [REP`TypeRep | set of REP`TypeRep];
  if classnm = nil
  then tp := StripAccessType(LookUp(metnm, true))
  else
    def luio = LookUpInObject(classnm, metnm, false,true)
    in
      cases true:
        (IsAccessType(luio))    -> tp := StripAccessType(luio),
        (IsAccessTypeSet(luio)) -> tp := { StripAccessType(t) | t in set luio },
        others                  -> tp := nil
      end;
  cases true:
    (is_REP`OpTypeRep(tp)),
    (is_REP`TotalFnTypeRep(tp)),
    (is_REP`PartialFnTypeRep(tp)) -> return tp,
    (is_REP`PolyTypeRep(tp))      -> return tp.tp,
    (is_(tp, set of (REP`OpTypeRep | REP`TotalFnTypeRep | REP`PartialFnTypeRep))) 
                                  -> return tp,
    others                        -> return nil
  end;
 );

ExpandClassName: AS`Name * set of AS`Name ==> bool * AS`Name
ExpandClassName(name,nm_s) ==
  if name in set nm_s
  then return mk_(false, name)
  else
    if VCM`IsClassName(name)
    then return mk_(true, name)
    else
     def newtp = StripAccessType(LookUpTypeName(name, false))
     in
       if is_REP`TypeNameRep(newtp)
       then return ExpandClassName(newtp.nm, nm_s union {name})
       else return mk_(false, name);

IsInstanceVar: AS`Name ==> bool
IsInstanceVar(nm) ==
  return IsInstanceVar'(nm, false);

IsStaticInstanceVar: AS`Name ==> bool
IsStaticInstanceVar(nm) ==
  return IsInstanceVar'(nm, true);

IsInstanceVar': AS`Name * bool ==> bool
IsInstanceVar'(nm, checkStatic) ==
  if len nm.ids = 2
  then
    def ncls = mk_AS`Name([(nm.ids)(1)],CI`NilContextId);
        cls = VCM`GetClassTypeRep(ncls)
    in
      if cls = nil
      then return false
      else
        let insts = cls.insts
        in
          return if nm in set dom insts
                 then checkStatic => insts(nm).stat
                 else nm in set dom cls.vals
  else
    return if nm in set dom StateEnv
           then checkStatic => StateEnv(nm).stat
           else false;

LookUpInstanceVar: AS`Name ==> [REP`TypeRep]
LookUpInstanceVar(nm) ==
  if len nm.ids = 2
  then
    def ncls = mk_AS`Name([(nm.ids)(1)],CI`NilContextId);
        cls = VCM`GetClassTypeRep(ncls)
    in
      if cls = nil
      then return nil
      else
        let insts = cls.insts,
            vals = cls.vals
        in
          return if nm in set dom insts
                 then StripAccessType(insts(nm))
                 elseif nm in set dom vals
                 then StripAccessType(vals(nm))
                 else nil
  else
    return if nm in set dom StateEnv
           then StateEnv(nm).tp
           else nil;

HasInstInv: AS`Name ==> bool
HasInstInv(nm) ==
  def pti = VCM`GetClassTypeRep(nm)
  in
    if pti = nil
    then return false
    else return pti.instinv;

#endif VDMPP
end ENV
\end{vdm_al}


\subsection{Test Coverage}

\begin{rtinfo}[MostGeneralNumericType]
{rtinfo.ast}[ENV]
\end{rtinfo}
