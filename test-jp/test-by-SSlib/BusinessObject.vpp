--$Header: /home/vdmtools/cvsroot/toolbox/test-jp/test-by-SSlib/BusinessObject.vpp,v 1.1 2005/11/25 07:05:38 vdmtools Exp $
/*
ビジネスシナリオが参照するビジネス上の情報（オブジェクト）を記述する。
これは、ビジネスシナリオの実現可能性と正しさを裏打ちする
*/
--------------------------------------------------------
class 『帳簿』  is subclass of GofoBook
/*
目的
　『記録』全体を管理する
注意点
　属性・操作ともstaticとする
*/


end 『帳簿』
--------------------------------------------------------
class  『入出金記録帳簿』 is subclass of 『帳簿』

types
public 「キー」 = 「識別子」;
	
public 「記録」 ::
	キー : 「キー」
	記録時刻 : Time
	金額 : 「金額非負」
	振込元 : GofoBook
	振込先 : GofoBook;

operations
--指定された値を持つ入出金記録が設定されている
public 入出金記録設定済 : 
	「識別子」 * Time * 「金額非負」 * GofoBook * GofoBook ==> bool
入出金記録設定済(ある伝票ID, ある時刻, ある金額, ある振込元, ある振込先) == 
	let	ある記録 = findByKeyValues(ある伝票ID)
	in
	return 
		 ある記録 <> nil and
		 ある時刻 = ある記録.明細記録を得る().記録時刻 and
		 ある金額 = ある記録.明細記録を得る().金額 and
		 ある振込元 = ある記録.明細記録を得る().振込元 and
		 ある振込先 = ある記録.明細記録を得る().振込先;

public 『入出金記録帳簿』 : Gofo_DB ==>  『入出金記録帳簿』
『入出金記録帳簿』(aDB) == 
	(
	DBを設定する(aDB);
	return self
	);
	
public create : 「キー」 * Time * 「金額非負」 * GofoBook * GofoBook ==>  GofoBook 
create(あるキー, ある記録時刻, ある金額, ある振込元, ある振込先) ==
	let	新記録 =
			mk_『入出金記録帳簿』`「記録」(
				あるキー,
				ある記録時刻,
				ある金額,
				ある振込元,
				ある振込先
			)
	in
	(
	挿入する(新記録);
	return findByKeyValues(あるキー)
	);
	
public 口座残高 : 「識別子」 * Time ==>  「金額非負」 --振込手数料はまだ勘定に入れていないので、修正要
口座残高(ある口座番号, ある時刻) ==
	let	出金記録選択基準 = 
			lambda x : 「記録」 & 
				x.記録時刻.≦(ある時刻) and
				ある口座番号 = x.振込元.明細記録を得る().キー,
		出金記録列 = Set`asSequence[「記録」](選択する(出金記録選択基準)),
		出金合計 = 
			if 出金記録列 = [] then
				0
			else
				Sequence`Σ[nat](
					[出金記録列(i).金額 | i in set inds 出金記録列]
				),
		入金記録選択基準 = 
			lambda x : 「記録」 & 
				x.記録時刻.≦(ある時刻) and
				ある口座番号 = x.振込先.明細記録を得る().キー,
		入金記録列 = Set`asSequence[「記録」](選択する(入金記録選択基準)),
		入金合計 = 
			if 入金記録列 = [] then
				0
			else
				Sequence`Σ[nat](
					[入金記録列(i).金額 | i in set inds 入金記録列]
				)
	in
	(
	dcl 合計残高 : 「金額非負」 := 0;
	合計残高 := 入金合計 - 出金合計; 
	return 合計残高
	);

end 『入出金記録帳簿』
--------------------------------------------------------
class 『銀行口座帳簿』 is subclass of 『帳簿』

values
protected 発番桁数 = 8;
	
end 『銀行口座帳簿』
--------------------------------------------------------
class 『他行口座帳簿』 is subclass of 『銀行口座帳簿』

types
public 「キー」 = 「識別子」;

public 「記録」 ::
	キー : 「キー」	--口座番号
	記録時刻 : Time
	登録パスワード : 「文字列」
	;
	
operations
public 『他行口座帳簿』 : Gofo_DB ==>  『他行口座帳簿』
『他行口座帳簿』(aDB) == 
	(
	DBを設定する(aDB);
	return self
	);

public create : 「キー」 * Time * 「文字列」 ==>  GofoBook 
create(ある他行口座ID, ある記録時刻, ある登録パスワード) ==
	let	新記録 =
			mk_『他行口座帳簿』`「記録」(
				ある他行口座ID,
				ある記録時刻,
				ある登録パスワード
			)
	in
	(
	挿入する(新記録);
	return findByKeyValues(ある他行口座ID)
	);
	
end 『他行口座帳簿』
--------------------------------------------------------
class 『自行口座帳簿』 is subclass of 『銀行口座帳簿』
--顧客の持つ自行の口座を表す抽象クラス。

types
public 「キー」 = 「識別子」;

public 「記録」 ::
	キー : 「キー」	--口座番号
	記録時刻 : Time
	担当営業店ID : 「識別子」
	登録パスワード : 「文字列」
	;

end 『自行口座帳簿』 
--------------------------------------------------------
class 『普通預金口座帳簿』 is subclass of 『銀行口座帳簿』
--普通預金口座を管理するための帳簿。
--顧客毎に、高々１つの普通預金口座（GofoBookが１つの口座を表す）しか存在しない。
--利子は無いことにした。

types
public 「キー」 = 「識別子」;

public 「記録」 ::
	キー : 「キー」		--普通預金口座番号
	顧客ID : 「識別子」		--顧客ID
	記録時刻 : Time
	担当営業店ID : 「識別子」
	登録パスワード : 「文字列」
	;

operations
--指定された値を持つ定期預金が設定されている
public 普通預金設定済 : 「キー」 * 「識別子」 * 「識別子」 * 「文字列」 ==> bool
普通預金設定済(ある普通預金ID, ある顧客ID, ある担当営業店ID, ある登録パスワード) ==
	let	ある普通預金 = findByKeyValues(ある普通預金ID) in
	return
		 ある普通預金 <> nil and
		 ある普通預金.明細記録を得る().キー = ある普通預金ID and
		 ある普通預金.明細記録を得る().顧客ID = ある顧客ID and
		 ある普通預金.明細記録を得る().担当営業店ID = ある担当営業店ID and
		 ある普通預金.明細記録を得る().登録パスワード = ある登録パスワード;
	
public 『普通預金口座帳簿』 : Gofo_DB ==>  『普通預金口座帳簿』
『普通預金口座帳簿』(aDB) == 
	(
	DBを設定する(aDB);
	return self
	);
	
public create : 「キー」 * 「識別子」 * Time * 「識別子」 * 「文字列」 ==>  GofoBook 
create(ある普通預金ID, ある顧客ID, ある記録時刻, ある担当営業店ID, ある登録パスワード) ==
	let	新記録 =
			mk_『普通預金口座帳簿』`「記録」(
				ある普通預金ID,
				ある顧客ID, 
				ある記録時刻,
				ある担当営業店ID,
				ある登録パスワード
			)
	in
	(
	挿入する(新記録);
	return findByKeyValues(ある普通預金ID)
	);
	
public 普通預金残高 : 『入出金記録帳簿』 * 「識別子」 * Time ==>  「金額非負」
普通預金残高(ある入出金記録帳簿, ある口座番号, ある時刻) == ある入出金記録帳簿.口座残高(ある口座番号, ある時刻) ;

end  『普通預金口座帳簿』 
--------------------------------------------------------
class 『定期預金帳簿』 is subclass of 『銀行口座帳簿』	

values
static private 利率 = 0.01;

types
public 「自動継続区分」 = <自動継続> | <非継続> | <変な自動継続区分>;	--<変な自動継続区分>はエラーチェックのテストのために設定。

public 「キー」 = 「識別子」;

public 「記録」 ::
	キー : 「キー」		--定期預金口座番号
	普通預金ID : 「識別子」	--普通預金口座番号
	顧客ID : 「識別子」		--顧客ID
	記録時刻 : Time
	担当営業店ID : 「識別子」
	登録パスワード : 「文字列」
	設定額 : 「金額正」
	設定日 : 「日付」
	申込時刻 : Time
	日数 : nat1
	自動継続区分 : 「自動継続区分」
	;

functions
static public 利率を得る : () -> real
利率を得る() == 利率;

operations
--指定された値を持つ定期預金が設定されている
public 定期預金設定済 : 
	「キー」 * 「識別子」 * 「識別子」 * Time * 「識別子」 * 「文字列」 * 
	「金額正」 * 「日付」 * Time * nat1 * 『定期預金帳簿』`「自動継続区分」
	==> bool
定期預金設定済(
	ある定期預金ID, ある普通預金ID, ある顧客ID, ある記録時刻, ある担当営業店ID, ある登録パスワード, 
	ある設定額, ある設定日, ある申込時刻, ある日数, ある自動継続区分) ==
	let	ある定期預金 = findByKeyValues(ある定期預金ID) in
	return
		 ある定期預金 <> nil and
		 ある定期預金.明細記録を得る().キー = ある定期預金ID and
		 ある定期預金.明細記録を得る().普通預金ID = ある普通預金ID and
		 ある定期預金.明細記録を得る().顧客ID = ある顧客ID and
		 ある定期預金.明細記録を得る().担当営業店ID = ある担当営業店ID and
		 ある定期預金.明細記録を得る().登録パスワード = ある登録パスワード and
		 ある定期預金.明細記録を得る().設定額  = ある設定額 and 
		 ある定期預金.明細記録を得る().設定日.＝(ある設定日) and
		 ある定期預金.明細記録を得る().申込時刻.＝(ある申込時刻) and
		 ある定期預金.明細記録を得る().申込時刻.日付を得る().≦(ある設定日) and
		 ある定期預金.明細記録を得る().日数 = ある日数 and
		 ある定期預金.明細記録を得る().自動継続区分 = ある自動継続区分
pre
	『業務ルール』`定期預金が変更可能である(ある申込時刻, ある申込時刻, ある設定日) and
	最低設定額() <= ある設定額;

functions
static public 最低設定額 : ()-> 「金額正」
最低設定額() == 『業務ルール』`最低設定額();

operations
public 『定期預金帳簿』 : Gofo_DB ==>  『定期預金帳簿』
『定期預金帳簿』(aDB) == 
	(
	DBを設定する(aDB);
	return self
	);
	
public create : 
	「キー」 * 「識別子」 * 「識別子」 * Time * 「識別子」 * 「文字列」 * 
	「金額正」 * 「日付」 * Time * nat1 * 「自動継続区分」 
	==>  GofoBook
create(
	ある定期預金ID, ある普通預金ID, ある顧客ID, ある記録時刻, ある担当営業店ID, ある登録パスワード, 
	ある設定額, ある設定日, ある申込時刻, ある日数, ある自動継続区分) ==
	let	新記録 =
			mk_『定期預金帳簿』`「記録」(
				ある定期預金ID,
				ある普通預金ID, 
				ある顧客ID, 
				ある記録時刻, 
				ある担当営業店ID, 
				ある登録パスワード, 
				ある設定額, 
				ある設定日, 
				ある申込時刻,
				ある日数, 
				ある自動継続区分
			)
	in
	(
	挿入する(新記録);
	return findByKeyValues(ある定期預金ID)
	);
	
--顧客の直近の定期預金残高を返す
public 定期預金残高 : 『入出金記録帳簿』 * 「識別子」 * Time ==> 「金額非負」
定期預金残高(ある入出金記録帳簿, ある顧客ID, ある時刻) ==  ある入出金記録帳簿.口座残高(ある顧客ID, ある時刻);

end 『定期預金帳簿』
--------------------------------------------------------
class  『税金』 is subclass of 『共通定義』

operations
static public 税金 : 「金額正」 ==> 「金額正」 
税金(金額) == is not yet specified;

end 『税金』
--------------------------------------------------------
class  『営業店帳簿』 is subclass of 『帳簿』

types
public 「キー」 = 「識別子」;

public 「記録」 ::
	ID : 「キー」	--営業店ID
	;

end 『営業店帳簿』
---------------------------------
class 『顧客帳簿』 is subclass of 『帳簿』

types
public 「キー」 = 「識別子」;

public 「記録」 ::
	キー : 「キー」	--顧客ID
	普通預金口座ID : [「識別子」]
	定期預金口座ID集合 : set of 「識別子」
	;
	
operations
public 『顧客帳簿』 : Gofo_DB ==>  『顧客帳簿』
『顧客帳簿』(aDB) == 
	(
	DBを設定する(aDB);
	return self
	);

public create : 
	「キー」 * [「識別子」] * set of 「識別子」  ==>  GofoBook
create(あるキー, ある普通預金口座ID, ある定期預金口座ID集合) ==
	let	新記録 =
			mk_『顧客帳簿』`「記録」(
				あるキー,
				ある普通預金口座ID, 
				ある定期預金口座ID集合 
			)
	in
	(
	挿入する(新記録);
	return findByKeyValues(あるキー)
	);
	
--指定された年月の顧客別残高の平均を返す。
public 月平均残高 : 『普通預金口座帳簿』 * 『定期預金帳簿』 * 『入出金記録帳簿』 * 「識別子」 * int * int ==>  「金額非負」
月平均残高(ある普通預金口座帳簿, ある定期預金帳簿, ある入出金記録帳簿, ある顧客ID, 年, 月) == 
	let	暦 = new JapaneseCalendar(),
		月初日 = 暦.月初日を求める(年,月),
		月末日 = 暦.月末日を求める(年,月)
	in
	(
	dcl 日 : 「日付」 := 月初日;
	dcl 日数 : nat := 0;
	dcl 合計残高 :  「金額非負」 := 0;
	while 日.≦(月末日) do
		(
		合計残高 := 合計残高 + self.残高(ある普通預金口座帳簿, ある定期預金帳簿, ある入出金記録帳簿, ある顧客ID, new Time(日));
		日数 :=  日数 + 1;
		日 := 日.＋(1)
		);
	return 合計残高 / 日数
	);

--顧客の直近の残高を返す。
public 残高 : 『普通預金口座帳簿』 * 『定期預金帳簿』 * 『入出金記録帳簿』 * 「識別子」 * Time ==> 「金額非負」
残高(ある普通預金口座帳簿, ある定期預金帳簿, ある入出金記録帳簿, ある顧客ID, ある時刻) == 
	let	ある顧客 = findByKeyValues(ある顧客ID),
		ある普通預金ID = ある顧客.明細記録を得る().普通預金口座ID,
		ある定期預金ID集合 = ある顧客.明細記録を得る().定期預金口座ID集合,
		普通預金口座 = ある普通預金口座帳簿.findByKeyValues(ある普通預金ID)
	in
	if 普通預金口座 = nil then
		return 0
	else
		(
		dcl 合計残高 : 「金額非負」 := 0;
		for all 定期預金ID in set ある定期預金ID集合 do (
			合計残高 := 合計残高 + ある定期預金帳簿.定期預金残高(ある入出金記録帳簿, 定期預金ID, ある時刻)
		);
		合計残高 := 合計残高 + ある普通預金口座帳簿.普通預金残高(ある入出金記録帳簿, ある普通預金ID, ある時刻);
		return 合計残高
		);

end 『顧客帳簿』 