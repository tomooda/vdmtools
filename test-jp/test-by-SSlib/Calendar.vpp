class CalendarDefinition
values--値
	public homedir = ".";
types
	public 曜日名 = <月> | <火> | <水> | <木> | <金> | <土> | <日>;
	public 曜日数 = nat
	inv 曜日 == 曜日 <= 6;	--曜日を表す数値(日曜日=0, 土曜日=6);
	
end CalendarDefinition
--------------------------------------------------------------
class Calendar is subclass of CalendarDefinition	-- グレゴリオ暦
/*
責任
	グレゴリオ歴を表すクラス。
概要
	グレゴリオ歴の処理を行い、2099年までの春分・秋分を自動計算する。
	日付を表すDateクラスと協調して、暦の処理を行う。
	同一日付のオブジェクトは複数個あり得る。
	休日の集合はサブクラスで提供されることを期待している。
	時刻に関わる計算はグリニッジ標準時を使用しているので、本クラスのサブクラスとして各国別・標準時別の暦クラスを作成し、インスタンス変数「グリニッジ標準時との差」を設定しなければならない。
*/

values--値
	--ユリウス日と修正ユリウス日の日数差。
	private 修正ユリウス日日数差 = 2400000.5;

	private 曜日名列 = [<日>,<月>,<火>,<水>,<木>,<金>,<土>];

	private 年の実日数 = 365.25;
	protected 年の月数 = 12;
	private 補正月数 = 14;
	private 週の日数 = 7;
	private 月平均日数 = 30.6001;
	private 一世紀の年数 = 100;
	private 日付計算係数 = 122.1;
	private 年計算係数 = 4800;
	private 世紀計算係数 = 32044.9;
	private グレゴリオ暦切替前日  = 2299160.0;
	private グレゴリオ暦初日  = 1582.78;
	
	io = new IO();

instance variables

	protected グリニッジ標準時との差 : real := 0;
	protected 今日という日 : [Date] := nil;
	protected 休日集合写像 : map int to set of Date := { |-> };	-- { 年 |-> 休日集合 }

operations

public 暦を得る :  () ==> Calendar
暦を得る() == return self;

functions--関数定義

----比較
/*
関数名
大小比較を行う関数群。

返値
	真ならtrueを返し、そうでなければfalseを返す。

内容
	与えられた２つの日付の大小比較を行う。
*/
public 小さい: Date * Date -> bool
小さい(日付1, 日付2) == 日付1.修正ユリウス日獲得() < 日付2.修正ユリウス日獲得();

public 大きい: Date * Date -> bool
大きい(日付1,日付2) == 日付1.修正ユリウス日獲得() > 日付2.修正ユリウス日獲得();

public 以下: Date * Date -> bool
以下(日付1,日付2) == not 大きい(日付1,日付2);

public 以上: Date * Date -> bool
以上(日付1,日付2) == not 小さい(日付1,日付2);

--与えられた２つの日付が等しいか判定する。
public 等しい: Date * Date -> bool	--等しければtrueを返し、そうでなければfalseを返す。
等しい(日付1,日付2) == 日付1.修正ユリウス日獲得() = 日付2.修正ユリウス日獲得();

public min : Date -> Date -> Date
min(日付1)(日付2) == if 日付1.＜(日付2) then 日付1 else 日付2;

public max : Date -> Date -> Date
max(日付1)(日付2) == if 日付1.＞(日付2) then 日付1 else 日付2;

----照会
operations
public 日付文字列か？ : 
	seq of char	--年月日（西暦４桁）のはずの文字列
	==>
	bool		--年月日として正当ならtrue、そうでなければfalse
日付文字列か？(年月日) == 
	if 文字列から日付を得る(年月日) = false then 
		 return false 
	else 
		 return true;

functions
--閏年であればtrue、平年であればfalseを返す。
public 閏年か？: 
	int	--閏年かどうか判定したい年。
	-> 
	bool	--閏年であるか否か
閏年か？(年) == 年 mod 400 = 0 or (年 mod 一世紀の年数 <> 0 and 年 mod 4 = 0);

public 曜日数を得る: Date -> 曜日数
曜日数を得る(日付) == 
	let	修正ユリウス日 = floor(日付.修正ユリウス日獲得())
	in	(修正ユリウス日 - 4) mod 週の日数;

public 年月日の整数組を得る: Date -> int * int * int
年月日の整数組を得る(日付) == mk_(年(日付),月(日付),日(日付));

public 曜日名を得る : Date -> 曜日名
曜日名を得る(日付) == 曜日名列(曜日数を得る(日付) + 1);

public 曜日名から曜日数を求める : 曜日名 -> 曜日数
曜日名から曜日数を求める(a曜日名) == Sequence`Index[曜日名](a曜日名)(曜日名列) - 1;

operations
--new Calendar().月初指定曜日を得る(2001,7,<日>).年月日の整数三つ組を得る() = mk_( 2001,7,1 )
public 月初指定曜日を得る : int * int * 曜日名 ==> Date
月初指定曜日を得る(年,月,a曜日名) ==
	let	w曜日数 = 曜日名から曜日数を求める(a曜日名),
		月初日 = 月初日を求める(年,月),
		差 = w曜日数 - 曜日数を得る(月初日) in
	cases true:
		(差 = 0)	-> return 月初日,
		(差 > 0)	-> return 月初日.＋(差),
		(差 < 0)	-> return 月初日.＋((週の日数 + 差) mod 週の日数)
	end;

operations
--new Calendar().月末指定曜日を得る(2001,7,<日>).年月日の整数三つ組を得る() = mk_( 2001,7,29 )
public 月末指定曜日を得る : int * int *	曜日名 ==> Date
月末指定曜日を得る(年,月,a曜日名) == 
	 return 月初指定曜日を得る(年,(月+1),a曜日名).−(週の日数);
--指定された月の翌月の最初の指定曜日から７日前を求める。
--月が１２月の場合でも本クラスの関数はy年１３月をy+1年１月と解釈するので、問題ない。

--指定された月・曜日のの、第n曜日を求める。
--new Date().第n指定曜日を得る(2001,7,5,<日>).年月日の整数三つ組を得る() = mk_( 2001,7,29 )
--new Date().第n指定曜日を得る(2001,7,6,<日>).年月日の整数三つ組を得る() = false
public 第n指定曜日を得る : int * int * int * 曜日名
	==>
	Date | bool 	--第n曜日,存在しなければfalse
第n指定曜日を得る(指定年,指定月,第n曜日,a曜日名) ==
	let	月初日 = 月初指定曜日を得る(指定年,指定月,a曜日名),
		結果 = 月初日.＋(週の日数 * (第n曜日 - 1)) in
	cases 月(結果):
		(指定月)	-> return 結果,
		others	->  return false
	end;

--new Calendar().月初日を求める(2001,7).年月日の整数三つ組を得る() = mk_( 2001,7,1 )
public 月初日を求める : int * int ==> Date
月初日を求める(年,月) == return 正則日付を得る(年, 月, 1);

--new Calendar().月末日を求める(2001,7).年月日の整数三つ組を得る() = mk_( 2001,7,31 )
public 月末日を求める : int * int  ==> Date
月末日を求める(年,月) == return 正則日付を得る(年, 月+1, 1).−(1);

functions
public 日曜日か？ : Date -> bool
日曜日か？(日付) == 曜日数を得る(日付) = 0;

public 土曜日か？ : Date -> bool
土曜日か？(日付) == 曜日数を得る(日付) = 6;

public ウィークデイか？ : Date -> bool
ウィークデイか？(日付) == 曜日数を得る(日付) in set {1,...,5};

operations
public 平日か？ : Date ==> bool
平日か？(日付) == return not お休みか？(日付);

functions
public 曜日は平日か？ : 曜日名 -> bool
曜日は平日か？(a曜日名) == a曜日名 not in set {<土>,<日>};

--指定された曜日が、指定された日付間（日付1と日付2の間）に何日あるかを返す。 
--日付１と日付2が指定された曜日であれば勘定に入れる。
public 指定曜日が何日あるか得る: Date * Date * 曜日名 -> int
指定曜日が何日あるか得る(日付1,日付2,a曜日名) ==
	let	w曜日数 = 曜日名から曜日数を求める(a曜日名),
		開始日 = min(日付1)(日付2),
		終了日 = max(日付1)(日付2),
		日数 = 日付の差を求める(終了日,開始日) + 1,
		商 = 日数 div 週の日数,
		剰余 = 日数 mod 週の日数,
		delta = if 曜日数の減算(w曜日数,曜日数を得る(開始日)) + 1 <= 剰余 then 1 else 0	in
	商 + delta
/*
post
	let	開始日 = min(日付1)(日付2),
		終了日 = max(日付1)(日付2)	in
	let 指定曜日の集合 = {日 | 日 : Date & a曜日名 = 曜日名を得る(日) and 開始日.≦(日) and 日.≦(終了日)}  in
	RESULT = card 指定曜日の集合 and
	forall 日f, 日t  in set 指定曜日の集合 &
		日f.≦(日t) => 日付の差を求める(日t, 日f) mod 7 = 0 and 
	exists1 日i  in set 指定曜日の集合 &
		日付の差を求める(日i, 開始日) < 6 and
		exists1 日j  in set 指定曜日の集合 &
			日付の差を求める(終了日, 日j) < 6 and
			日付の差を求める(日j, 日i) = 7 * (RESULT - 1)
*/
		;
/*
以下は、上記関数の山崎利治さんによる段階的洗練を佐原が「翻訳」した記述

pre
type R = {|rng [n → n / 7 | n∈Int]|} 	-- 7で割った商の集合
f, t∈Int, w∈R, 0≦f≦t,
h: Int → R 		--環準同型（ring homomorphism）

post
S = dom h(w) ∩ {f..t}・RESULT ≡ card(S) 	-- RESULTが答え （dom h(w)≡h-1(w)）

--整数系を環（ring）と見て、その商環（quotient ring）への準同型写像があり、その代数系上で事後条件を満たすプログラムを作る
I =｛f..t}
d = t - f + 1 	-- = card(I)
q = d / 7
r = d \ 7 		--7で割った余り

とすると、

q ≦ A ≦ q+1

が成り立つ。なぜなら、

  任意の連続する７日間には、必ずw曜日がちょうど１日存在する。
  card(I) = 7×q + r (0≦r＜7)であるから、Iには少なくともq個の連続する７日間が存在するが、q+1個は存在しない。
  余りのr日間にw曜日が存在するかも知れない。

次に、

x ++ y = (x + y) \ 7
x ┴ y = max(x - y, 0)
として、

T = {h(f)..h(f) ++ (r ┴ 1)}
を考える。Tは余りr日間の曜日に対応する（card(T) = r）。
すると、

A ≡ if w∈T then q + 1 els q end

ここで、

x minus y = if x ≧ y then x - y els x - y + 7 end
とすれば、

w∈T ⇔ (w minus h(f)) + 1 ≦ r
である。なぜならば

w∈T	⇔ {0..(r ┴ 1)}∋wﾕ = w minus h(f)
	⇔ r ┴ 1 ≧ wﾕ
	⇔ r ≧ (w minus h(f)) + 1

従って、プログラムは以下のようになる。

A(f, t w)≡
	let
		d ≡ t - f + 1
		q ≡ d / 7
		r ≡ d \ 7
		delta ≡ if (w minus h(f)) + 1 ≦ r then 1 els 0 end
		x minus y ≡ if x ≧ y then x - y els x - y + 7 end
	in
		q + delta
	end
*/

private 曜日数の減算: int * int -> int
曜日数の減算(x,y) == if x >= y then x - y else x - y + 週の日数;

--日付から、その日付の属する年を求める。
public 年: Date -> int
年(日付) ==
if 月補助関数(日付) < 補正月数 then
		年補助関数(日付) - 年計算係数
	else
		年補助関数(日付) - 年計算係数 + 1;
		
--日付から、その日付の属する月を求める。
public 月: Date -> int
月(日付) == if 月補助関数(日付) < 補正月数 then
		月補助関数(日付) - 1
	else
		月補助関数(日付) - 13;
		
--日付から、日を求める。
public 日: Date -> int
日(日付) == 月始からの日数(日付);

operations
--new Date().年始からの日数(整数三つ組から日付を得る(2001,12,31)) = 365
public 年始からの日数: Date ==> int
年始からの日数(日付) == 
	let	年初日 = 整数三つ組から日付を得る(年(日付), 1, 0) in
	return 日付の差を求める(日付,年初日);

functions
月始からの日数: Date -> int
月始からの日数(日付) == floor(月始からの日数を実数で求める(日付));

月始からの日数を実数で求める: Date -> real
月始からの日数を実数で求める(日付) == 年月日変更の補助関数(日付) + 日付計算係数
- floor(年の実日数 * 年補助関数(日付)) - floor(月平均日数 * 月補助関数(日付)); 

--月を求める補助関数。
月補助関数: 
	Date 
	-> 
	int	--日付計算上都合の良い月(4..15)を返す
月補助関数(日付) ==
	floor((年月日変更の補助関数(日付) + 日付計算係数 - floor(年の実日数 * 年補助関数(日付))) / 月平均日数);

--日付を年月日に変更するための補助関数。
年月日変更の補助関数: Date -> real
年月日変更の補助関数(日付) == 
	let	ユリウス日 = ユリウス日に変換する(日付.修正ユリウス日獲得()),
		世紀 =  floor((ユリウス日 + 世紀計算係数) / 36524.25)
	in	
		if ユリウス日 > グレゴリオ暦切替前日 then
			ユリウス日 + 世紀計算係数 + 世紀 - 世紀 div 4 + 0.5
		else
			ユリウス日 + 32082.9 + 0.5;

--日付から年を求めるための補助関数。
年補助関数: 
	Date 
	-> 
	int	--日付計算に都合の良い補正した年数。
年補助関数(日付) == floor (年月日変更の補助関数(日付) / 年の実日数);

operations
public グリニッジ標準時の春分を得る: int ==> Date
グリニッジ標準時の春分を得る(年) ==
	let	y = 年 / 1000.0	in
	return
		修正ユリウス日から日付を得る(
			 修正ユリウス日に変換する(1721139.2855 + 365.2421376 * 年 + y * y *  (0.067919 - 0.0027879 * y)));
	
public グリニッジ標準時の夏至を得る: int ==> Date
グリニッジ標準時の夏至を得る(年) ==
	let	y = 年 / 1000.0	in
	return
		 修正ユリウス日から日付を得る(
			 修正ユリウス日に変換する(1721233.2486 + 365.2417284 * 年 - y * y * (0.053018 - 0.009332 * y)));	
	 
public グリニッジ標準時の秋分を得る: int ==> Date
グリニッジ標準時の秋分を得る(年) ==
	let	y = 年 / 1000.0	in
	return
		修正ユリウス日から日付を得る(
			修正ユリウス日に変換する (1721325.6978 + 365.2425055 * 年 - y * y * (0.126689 - 0.0019401 * y)));

public グリニッジ標準時の冬至を得る: int ==> Date
グリニッジ標準時の冬至を得る(年) ==
	let	y = 年 / 1000.0	in
	return
		 修正ユリウス日から日付を得る(
			 修正ユリウス日に変換する(1721414.392 + 365.2428898 * 年 - y * y * (0.010965 - 0.0084855 * y)));

  public 春分を得る : int ==> Date
 春分を得る(年) == return 標準時基準の日付を得る(グリニッジ標準時の春分を得る(年));
 
 public 夏至を得る : int ==> Date
 夏至を得る(年) == return 標準時基準の日付を得る(グリニッジ標準時の夏至を得る(年));
 
 public 秋分を得る : int ==> Date
 秋分を得る(年) == return 標準時基準の日付を得る(グリニッジ標準時の秋分を得る(年));
 
 /* 現在、うるう年の冬至は正しく得られない。原因は調査中。 */
 public 冬至を得る : int ==> Date
 冬至を得る(年) == return 標準時基準の日付を得る(グリニッジ標準時の冬至を得る(年));


----計算
functions
public 日付を加算する: Date * int -> Date
日付を加算する(日付,加算日数) == 日付.＋(加算日数);

public 日付の差を求める: Date * Date -> int
日付の差を求める(日付1,日付2) == floor(日付1.修正ユリウス日獲得() - 日付2.修正ユリウス日獲得());

--日付から日数を減算した日付を返す
public 日付を減算する: Date * int -> Date
日付を減算する(日付,減算日数) == 日付.−(減算日数);

----変換

public ユリウス日に変換する: real -> real
ユリウス日に変換する(修正ユリウス日) == 修正ユリウス日 + 修正ユリウス日日数差;

public 修正ユリウス日に変換する: real -> real
修正ユリウス日に変換する(ユリウス日) == ユリウス日 - 修正ユリウス日日数差;

operations
--年月日を通常の値の範囲内に変換する。
--new Calendar().正則日付を得る(2003, 14, 29) = 整数三つ組から日付を得る(2004, 2, 29)
public 正則日付を得る : int * int * int ==> Date
正則日付を得る(年候補, 月候補, 日候補) ==
	let	mk_(年, 月) = 正則月を得る(年候補, 月候補) in
	return 整数三つ組から日付を得る(年, 月, 日候補);

functions
--年月を通常の値の範囲内に変換する。
public 正則月を得る : int * int -> int * int
正則月を得る(年候補, 月候補) ==
	let	年 = 
			if 月候補 <= 0 then
				年候補 + (月候補 - 12) div 年の月数
			else
				年候補 + (月候補 - 1) div 年の月数,
		月候補2 = 月候補 mod 年の月数,
		月 = 
			if 月候補2 = 0 then
				12
			else
				月候補2
	in
	mk_(年, 月);
	
	
--（整数三つ組の）日付を年に変換する(2001,7,1) = 2001.5
public 日付を年に変換する:  int * int * int
	-> 
	real	--日付を年(実数)に変換した値
日付を年に変換する(年, 月, 日) == 年 + (月 - 1) / 年の月数 + (日 - 1.0) / 年の実日数;

public 日付を文字列に変換する : Date +> seq of char
日付を文字列に変換する(日付) == 日付.日付文字列を得る();

operations
public 日付文字列から日付を得る : seq of char ==> [Date]
日付文字列から日付を得る(日付文字列) == 
	let	日付 = 文字列から日付を得る(日付文字列) in
	if 日付 = false then 
		 return nil
   else 
		 return 日付;

--以下は、休日の考慮をした機能で、サブクラスで休日の集合を定義する必要がある。

/* 照会 */
--２つの日付の間の休日の集合を返す。日曜日である休日も含むが、休日でない日曜日は含まない。
public 日付間の休日集合を得る : Date * Date ==> set of Date
日付間の休日集合を得る(日付1,日付2) ==
	let	日1 = min(日付1)(日付2),
		日2 = max(日付1)(日付2),
		年集合 = {年(日1),...,年(日2)},
		休日集合 = dunion {休日集合を得る(年) | 年 in set 年集合}
	in
	return {休日 | 休日 in set 休日集合 & 日付1.≦(休日) and 休日.≦(日付2)};

operations
--２つの日付の間の休日の数を返す。日曜日である休日も含むが、休日でない日曜日は含まない。
public 日曜日を除く休日数を得る: Date * Date ==> int
日曜日を除く休日数を得る(日付1,日付2) == 
	 return card (日付間の休日集合を得る(日付1,日付2));

--２つの日付の間の休日あるいは日曜日の数を返す（開始日を含む）
public 休日数を得る: Date * Date ==> int
休日数を得る(日付1,日付2) ==
	let	日1 = min(日付1)(日付2),
		日2 = max(日付1)(日付2),
		日曜日数 = 指定曜日が何日あるか得る(日1,日2,<日>)	in
	return
		 日曜日数 + card 日曜日を除く休日集合を得る(日1,日2);

operations
--２つの日付の間の休日あるいは日曜日の数を返す（開始日を含まない）
public 開始日を含まない休日数を得る: Date * Date ==> int
開始日を含まない休日数を得る(日付1,日付2) ==
	let	日1 = min(日付1)(日付2),
		日2 = max(日付1)(日付2)	in
	return 休日数を得る(日1.＋( 1), 日2);

private 日曜日を除く休日集合を得る : Date * Date ==> set of Date
日曜日を除く休日集合を得る(日付1,日付2) ==
	let	休日集合 = 日付間の休日集合を得る(日付1,日付2)	in
	return {休日 | 休日 in set 休日集合 & not 日曜日か？(休日)};

--日曜日である休日の集合を返す
public 日曜日である休日の集合を得る : Date * Date ==> set of Date
日曜日である休日の集合を得る(日付1,日付2) == 
	let	休日集合 = 日付間の休日集合を得る(日付1,日付2)	in
	return {休日 | 休日 in set 休日集合 & 日曜日か？(休日)};

/* 変換 */

--休日でない日付を返す（未来へ向かって探索する）
public 未来の平日を得る : Date ==> Date
未来の平日を得る(日付) ==
	cases  お休みか？(日付) or 土曜日か？(日付):
		(true)	-> return 未来の平日を得る(日付.＋( 1)),
		others	-> return 日付
	end;

--休日でない日付を返す（過去へ向かって探索する）
public 過去の平日を得る : Date ==> Date
過去の平日を得る(日付) ==
	cases   お休みか？(日付) or 土曜日か？(日付):
		(true)	-> return 過去の平日を得る (日付.−(1)),
		others	-> return 日付
	end;

--与えられた平日に、平日n日分を加算する
public 平日を加算する : Date * int ==> Date
平日を加算する(日付,加算日数) == 
	 return 平日を加算する補助関数(未来の平日を得る(日付),加算日数);

public 平日を加算する補助関数 : Date * int ==> Date
平日を加算する補助関数(日付,加算日数) ==
	cases お休みか？(日付) or 土曜日か？(日付):
		(true)	-> return 平日を加算する補助関数(日付.＋(1),加算日数),
		others	->
					if 加算日数 <= 0 then
						return 日付
					else
						return 平日を加算する補助関数(日付.＋(1), 加算日数-1)
	end;

--与えられた平日に、平日n日分を減算する
public 平日を減算する : Date * int ==> Date
平日を減算する(日付,減算日数) == 
	 return 平日を減算する補助関数(過去の平日を得る(日付),減算日数);

public 平日を減算する補助関数 : Date * int ==> Date
平日を減算する補助関数(日付,減算日数) ==
	cases お休みか？(日付) or 土曜日か？(日付):
		(true)	-> return 平日を減算する補助関数(日付.−(1),減算日数),
		others	->
					if 減算日数 <= 0 then
						return 日付
					else
						return 平日を減算する補助関数(日付.−(1), 減算日数-1)
	end;

/* 検査 */

public 休日か？ : Date ==> bool 
休日か？(日付) == 
	let	休日集合 = {日.修正ユリウス日獲得() | 日 in set 休日集合を得る(日付.年())}	in
	return 日付.修正ユリウス日獲得() in set 休日集合;

public お休みか？ : Date ==> bool
お休みか？(日付) ==  return 日曜日か？(日付) or 休日か？(日付);

functions
public 日付集合に含まれる :  Date * set of Date -> bool
日付集合に含まれる(日, a国民の休日) == (
	let 国民の休日の修正ユリウス日集合 = {floor d.修正ユリウス日獲得() | d in set a国民の休日}
	in
	日.修正ユリウス日獲得() in set 国民の休日の修正ユリウス日集合
  );

operations--操作定義

----構成子
public 修正ユリウス日から日付を得る: real ==> Date
修正ユリウス日から日付を得る(修正ユリウス日) == 
	return new Date(self,修正ユリウス日);
	
public 整数三つ組から日付を得る: int * int * int  ==> Date
整数三つ組から日付を得る(年, 月, 日) ==
	let	[year,month] = if (月 > 補正月数 - 年の月数) then
			[年 + 年計算係数 , 月 + 1]
		else
			[年 + 年計算係数 - 1 , 月 + 補正月数 - 1],
		世紀 = year div 一世紀の年数,
	 	世紀係数 =		if (日付を年に変換する(年, 月, 日) > グレゴリオ暦初日) then
						世紀 div 4 - 世紀 - 32167.0
					else
						-32205.0,
		半日 = 0.5	
	in
	return 
		修正ユリウス日から日付を得る(floor(年の実日数 * year) + 
		floor(月平均日数 * month) + 日 + 世紀係数 - 半日 - 修正ユリウス日日数差);

public 文字列から日付を得る :
	seq of char	--年月日文字列（年４桁）
	==>
	Date | bool	--指定した年月日の日付。年月日として正しくなければfalse
文字列から日付を得る(年月日) ==
	(if not String`isDigits(年月日) then
		return false;
	let	整数年月日 = String`asInteger(年月日),
		年 = 整数年月日 div 10000,
		整数月日 = 整数年月日 mod 10000,
		月 =  整数月日 div 100,
		日 =  整数月日 mod 100
	in
		if 整数三つ組から日付を得る(年,月,日).日付文字列を得る() = 年月日 then
			return 整数三つ組から日付を得る(年,月,日)
		else
			return false
	);

public 標準時基準の日付を得る : Date ==> Date	--日本の場合、日本標準時
標準時基準の日付を得る(日付) == 
	return 修正ユリウス日から日付を得る (日付.修正ユリウス日獲得() + 日付.暦().グリニッジ標準時との差を得る());	

public ある年の指定曜日集合を得る : int * 曜日名 ==> set of Date
ある年の指定曜日集合を得る(年,曜日) ==
	(
	dcl	ある曜日の集合 : set of Date := {},
		日 : Date := self.第n指定曜日を得る(年,1,1,曜日);
	while 日.≦(self.月末指定曜日を得る(年,12,曜日)) do (
		 ある曜日の集合 :=  ある曜日の集合 union {日};
		日 := 日.＋(7)
	);
	return ある曜日の集合
	);

public グリニッジ標準時との差を得る : () ==> real
グリニッジ標準時との差を得る() == return グリニッジ標準時との差;

public グリニッジ標準時との差を設定する : (real) ==> ()
グリニッジ標準時との差を設定する(差) == グリニッジ標準時との差 := 差;

--休日

public 休日集合を設定する: int ==> ()
休日集合を設定する(-) == is subclass responsibility;
	
public 休日集合を得る: int ==> set of Date 
休日集合を得る(年) == 
	(
	if not 年 in set dom 休日集合写像 then
		self.休日集合を設定する(年);
	return self.休日集合写像(年)
	);
	
--今日をファイルから読み込む
public 今日を読み込む : seq of char ==> [Date]
今日を読み込む(ファイル名) ==
	let	mk_(結果, mk_(y, m, d)) = io.freadval[int * int * int](ファイル名)
	in
	if 結果 then
		return 整数三つ組から日付を得る(y,m,d)
	else
		let	- = io.echo("Can't read today's data file.")
		in
		return nil;

--今日の日付を求めるスタブ関数。
public 今日: () ==> Date
今日() == 
	if 今日という日 = nil then
		return 今日を読み込む(homedir ^ "/temp/Today.txt")	--単体テスト用
	else
		return 今日という日;

--今日の日付を指定したファイルから読み込む。
public ファイルから読み込む今日: seq of char ==> Date
ファイルから読み込む今日(ファイル名) == 
	if 今日という日 = nil then
		return 今日を読み込む(ファイル名)	--単体テスト用
	else
		return 今日という日;

public 今日を設定する : Date ==> ()
今日を設定する(日付) == 今日という日 := 日付;

/*
--業務上の今日の日付を求めるスタブ関数。
public 基準日: () ==> Date
基準日() == is subclass responsibility;

public 基準日を設定する : Date ==> ()
基準日を設定する(-) == is subclass responsibility;

--業務上の会社毎の「今日の日付」を求めるスタブ関数。
public 会社基準日:  seq of char ==> Date
会社基準日(会社コード) == is subclass responsibility;

public 会社基準日を設定する : seq of char * Date ==> ()
会社基準日を設定する(会社コード,-) == is subclass responsibility;
*/
	
end Calendar
