
\section{ActivePlanManager class}
\begin{vdm_al}

class ActivePlanManager is subclass of Strategy


instance variables

private activeTokens : inmap TokenDevice to TransportPlan := {|->};
inv forall x,y in set dom activeTokens &
 x = y =>  activeTokens(x) = activeTokens(y);
--Ensure only uniqu TokenDevice reside in the map.
--Tests if 2 elements from domain is equal then (implication) they point
--to the same entity. 

private busy : bool := false;

private filler : Types`String;

private CR: TPC; 
--private io : IO := new IO();

private tokenDevices : set of TokenDevice;

operations

public setCR : TPC ==> ()
setCR(cr) == CR := cr;

public ActivePlanManager : ()  ==> ActivePlanManager
  ActivePlanManager() == (
	skip;
  
  );
  
public initAPM : () ==> ()
initAPM() == ( 
  --	def mk_ (-,input) = io.freadval[Types`String]("filler.txt") in
   filler := "";
);

public getFiller :() ==> Types`String
getFiller() == (
initAPM();
return filler;
);

public isFinished : () ==> ()
isFinished () == skip;

private addTransportPlan : TransportPlan * TokenDevice ==> ()
  addTransportPlan(plan,tokenDevice) ==(	
   activeTokens := activeTokens ++ {tokenDevice|-> plan};	
	);	

private removeTransportPlan : TransportPlan * TokenDevice ==> ()
  removeTransportPlan(plan,tokenDevice) ==(
  activeTokens := {tokenDevice} <-: activeTokens;  
  --Restrict map to not contain a mapplet containing tokenDevice
 );

public getPlans : () ==> set of TransportPlan
  getPlans() == return rng activeTokens;
  

async public inactiveSection : nat ==> ()
  inactiveSection(id_route) ==
  (
		RTLog`RTWrite("APM Inactive Section",time);
		for all t in set rng activeTokens do
		(
		cycles(13720000)
		(

			if t.containsSection(id_route) then
			(
				let p = inverse activeTokens in (
				RTLog`RTWrite("APM inactive section requesting plan",time);
				CR.calcTransportPlan(mk_MessageTypes`REQUESTPLAN(t.getPlanAsNaviInput(),p(t)));
				);
			)
		)
 	 	);
 	 	RTLog`RTWrite("APM Inacive Done",time);
	);

public returnTransportPlan :  MessageTypes`RETURNPLAN ==> ()
returnTransportPlan(msg) ==
(	
	RTLog`RTWrite("APM Return Plan",time);
	cycles(43960000)
	(
	let mk_MessageTypes`RETURNPLAN(dto, tok) = msg in
	(		
		let plan = new TransportPlan(dto) in (
			if tok in set dom activeTokens then (
				activeTokens(tok).assignNewPlan(dto);
				CRSystem`sms.send(tok,mk_SMSGateway`SMSMessage(<setInactive>,[plan]),time);
				tok.notifyPassenger(activeTokens(tok),filler);			
			)
			else(
				addTransportPlan(plan, tok);
				CRSystem`sms.send(tok,mk_SMSGateway`SMSMessage(<setInactive>,[plan]),time);
				Station`getStation(plan.getNextSection().departureLocation).addPassenger(plan);
			);
		);
	);
	);
	RTLog`RTWrite("APM Return Plan Done",time);
);

public requestTransportPlan : MessageTypes`REQUESTPLAN ==> ()
requestTransportPlan(msg) ==
(
	RTLog`RTWrite("APM Request Plan",time);
	cycles(2800000)
	(
		CR.calcTransportPlan(msg);
	);
);							



--public requestTransportPlan : TPC`NavigationInput * TokenDevice ==> TransportPlan
--requestTransportPlan(navIn, tok) == (
--	 let dto = q_CR_out.calculateTransportPlan(navIn,tok) in (
--		let plan = new TransportPlan(dto.routeList, dto.choice, dto.id_token) in (
--		addTransportPlan(plan,tok);
--		return plan;
--		);
--	)
--
--);

sync
--mutex(returnTransportPlan);
--mutex(inactiveSection)

end ActivePlanManager

\end{vdm_al}
\section{CRSystem}

\begin{vdm_al}
system CRSystem

instance variables

-- cpu for TPC
cpu1 : CPU := new CPU (<FCFS>,1E12);


-- cpu for APM
cpu2 : CPU := new CPU (<FCFS>,2800E6);

-- cpu for the controller
cpu3 : CPU := new CPU (<FCFS>,1E12);
--cpu for the SMSGateway
cpu4 : CPU := new CPU (<FCFS>,1E20);
-- bus to connect SMSGateway to APM
bus4 : BUS := new BUS (<FCFS>,1E12,{cpu4,cpu2});
--bus5 : BUS := new BUS (<FCFS>,1E3,{cpu4,cpu5});
-- bus to connect TPC and APM
bus1 : BUS := new BUS (<FCFS>,1E3,{cpu1,cpu2});
-- bus to connect Controller and APM
bus2 : BUS := new BUS (<FCFS>,1E3,{cpu2,cpu3});
-- bust to connect Controller and TPC
bus3 : BUS := new BUS (<FCFS>,1E3,{cpu1,cpu3});


cpu7 : CPU := new CPU(<FCFS>,105E6);


bus7 : BUS := new BUS(<FCFS>,1E18,{cpu2,cpu7});


bus8 : BUS := new BUS(<FCFS>,1E18,{cpu4,cpu7});


--Token Device set up generated by repeater
--cpu5 : CPU := new CPU(<FCFS>,105E6);
--bus6 : BUS := new BUS(<FCFS>,5,{cpu5,cpu2});

--public static tok0 : TokenDevice := new TokenDevice(0);
public static tok7 : TokenDevice := new TokenDevice(0);


public static cb : TPC := new TPC();
public static apm : ActivePlanManager := new ActivePlanManager();
public static grid :  RailwayGrid := new RailwayGrid();
public static grid2 :  RailwayGrid := new RailwayGrid();
public static ctrl : Controller := new Controller();
public static sms : SMSGateway := new SMSGateway();

operations

CRSystem : () ==> CRSystem
CRSystem()==
(
	cpu1.deploy(cb);
	cpu1.deploy(grid2);
	cpu3.deploy(grid);
	cpu3.deploy(ctrl);
	cpu2.deploy(apm);
	cpu4.deploy(sms);
	
	cpu7.deploy(tok7);



)

end CRSystem
\end{vdm_al}
\section{World2}

\begin{vdm_al}
class Controller

instance variables

private railwayGrid : RailwayGrid;
private APM : ActivePlanManager;
private trains : set of Train := {};
private stations : set of Station := {};
private tpc : TPC;
--Ensure that 2 different trains does not service the same route. 
inv forall x,y in set trains & 
	not (x = y) => x.currentRoute <> y.currentRoute 
	

operations

public setRailwayGrid : RailwayGrid ==> ()
setRailwayGrid(grid) == (
	railwayGrid := grid;
);

public initTrains : () ==> ()
initTrains() == (
	dcl i : nat := 0;
	for all s in set railwayGrid.getRoutePlan() do
	(
			trains := trains union {new Train(i,s, self)};
			i := i + 1;
	);
	i := 0;
	Logger`write(trains);
);

public startTrains : () ==> ()
startTrains() == (
	for all s in set trains do
	(
		start(s);
	)
);

public initStations : () ==> ()
initStations() == (
	Station`addStation(new Station(0,"A"));
	Station`addStation(new Station(1,"B"));
	Station`addStation(new Station(2,"C"));
	Station`addStation(new Station(3,"D"));
	Station`addStation(new Station(4,"E"));
	Station`addStation(new Station(5,"F"));
	
);

public setAPM : ActivePlanManager ==> ()
setAPM(apm) == (
	APM := apm;
);

public setTPC : TPC ==> ()
setTPC(t) == (
	tpc := t;
);

async public inactiveSection : nat ==> ()
inactiveSection(routeid) ==
(	
		RTLog`RTWrite("Controller Inactive Section",time);
		tpc.inactiveSection(routeid);
		railwayGrid.setInactiveSection(routeid);
		APM.inactiveSection(routeid);
	
);

public isSectionActive : nat ==> bool
isSectionActive(id) == return railwayGrid.isSectionActive(id); 

public isFinished : () ==> ()
isFinished() == (
	for all s in set trains do(
		s.isFinished();
	);
);

sync
mutex(isSectionActive);
mutex(inactiveSection);
mutex(isSectionActive,inactiveSection);

end Controller
\end{vdm_al}
\section{Customer}

\begin{vdm_al}
class Environment

types 

public outline = [TransportPlan] * [nat] * nat;
public inline = [TPC`NavigationInput] * [nat] * [nat] * nat;

instance variables
  public static tokenDevices : map nat to TokenDevice := {|->};
private controller : Controller;
--private io : IO := new IO();
  private outfileName : seq of char := "";
  protected  outlines : seq of outline := [];
  protected  inlines : seq of inline := [];
  protected  busy : bool := true;
  private runtime : nat := 0;

operations

public Environment : () ==> Environment
Environment()==(
	tokenDevices :=  {0|-> new TokenDevice(0)};
);

public Environment : seq of char ==> Environment
  Environment(fname) ==(
   --  def mk_ (-,input) = io.freadval[seq of inline](fname) in
   inlines := [ mk_(mk_TPC`NavigationInput("A","D",<Cheapest>,1,3000),0,nil,3000)];
	outfileName := fname ^ ".result";
);

public addController : Controller ==> ()
addController (cr) == controller := cr;

public addTokenDevice : TokenDevice ==> ()
addTokenDevice(td) ==
	--tokenDevices := td;
	tokenDevices := tokenDevices munion { td.getTokenId() |-> td};

public isFinished : () ==> ()
		isFinished () == skip;

public test : () ==> map nat to TokenDevice
	test () == return tokenDevices;


public stimulate : () ==> ()
  stimulate() ==
  (
  	
		duration(1) (
	
		if len inlines > 0
		then( 
				dcl curtime : nat := time,
				done : bool := false; 
				(
				while not done do(
					def mk_(nav,tid,route_id,t) = hd inlines in
						if (t < time)
						then (
							Logger`write2("ENV Stimulating",threadid,time);
							if ( route_id = nil )
							then (
									tokenDevices(tid).requestTransportPlan(nav);)
							else( controller.inactiveSection(route_id); );
								
							reduceInline();
							done := len inlines = 0;
						)
						else(
							done :=  true;
						)	
					)
				);
			)
			else(
				busy := false;
				)
	);
  );

private isDone : () ==> ()
isDone() == skip;	

private reduceInline : () ==> ()
reduceInline () == 
	(if(len inlines > 0) then
		inlines := tl inlines;
	)
	pre len inlines > 0;

private inputStimuli : () ==> ()
inputStimuli() == 
	(
		duration(1) (
		runtime := runtime + 5000;
		if len inlines > 0
		then (
			stimulate()
			)
		else (
				busy := false;
		);
	);
);

 public respons : [TransportPlan] * [TransportPlan`Route] * nat ==> ()
  respons(plan, route, t) ==
  	(outlines := outlines ^ [mk_(plan,route,t)]);

  public showResults : () ==> seq of outline
  showResults() ==
    return outlines;
  --def - = io.fwriteval[seq of outline](outfileName,outlines,<start>) in skip;

thread
--while busy do
--(
--	inputStimuli()
--);

periodic(10000,1000,9000,0)(inputStimuli);

sync
--mutex(addTokenDevice);
--mutex(stimulate);
--mutex(reduceInline);
--mutex(respons);
--mutex(showResults);
per isFinished => not busy; --Ensure interleaving in World
--per inputStimuli => runtime < time;

end Environment

\end{vdm_al}
\section{CyberRail class}
\begin{vdm_al}

class GridReservation

instance variables	
--List of Reservation records containing all reservations for the specific section
public reservations : SectionPlan := {|->};
public curTime : nat := 0;
private minDelta : nat := 50000;
private noTrain : nat :=1;
private periode : nat :=1000000;
private maxDelay : nat :=minDelta * 2;
private noInstances : nat := 2;
--private io : IO := new IO();
public routeList : set of Route := {}; 

types

public TimeEntry = set of nat;
public SectionPlan = map TransportPlan`Section to TimeEntry;
	
--GridResConfig - DTO record type for reading persisted configuration.
public GridResConfig ::
	minDelta : nat
	maxDelta : nat
	noTrain : nat
	periode : nat
	noInstances : nat;
	

operations

public GridReservation : () ==> GridReservation
GridReservation() == return;

public GridReservation : RailwayGrid`Grid * set of TransportPlan`Section ==> GridReservation
GridReservation(staticgrid, sectionList) ==
(
	initializeReservations(sectionList);
	calculateReservations(staticgrid);
--	def - = io.fwriteval[SectionPlan]("reservation.txt",reservations,<start>) in skip;

	return;
);	

public getRoutePlan : RailwayGrid`Grid * set of TransportPlan`Section ==> RailwayGrid`RoutePlan
getRoutePlan(grid, segment) == (
	--initializeReservations(segment);
	--calculateReservations(grid);
	return routeList;
);


private initializeReservations : set of TransportPlan`Section ==> ()
initializeReservations(sectionList)==
(
	--Initialize all active sections in reservation map. Sec to empty list. 
	for all sec in set sectionList do
	(
		reservations := reservations ++ {sec |-> {}};
	);
);

private calculateReservations : RailwayGrid`Grid ==> ()
calculateReservations(staticgrid)==
(
	dcl accomulateDuration : nat := 0;
	dcl standInSection : TransportPlan`Section;
	dcl iterations : nat := noInstances; -- How many times should a route be executed.
	dcl tempgrid : seq of TransportPlan`Section;

	while iterations > 0 do
	(
		for all gridsegment in set staticgrid do
		(
			curTime := 0;
			accomulateDuration := 300000;
			--def - = io.fwriteval[seq of TransportPlan`Section]("gridsegment.txt",gridsegment,<append>) in skip;
			tempgrid := gridsegment;
			while len tempgrid > 0 do
			(
				standInSection := hd tempgrid; 
				curTime := findFreeTimeSlot(standInSection, standInSection.dur, accomulateDuration);
				accomulateDuration := curTime + standInSection.dur;
				
				if(len tempgrid = len gridsegment) then
					routeList := routeList union {new Route(gridsegment, curTime)};
								
				--Reserve time for current section.
				while curTime < accomulateDuration do
				(
					dcl temp : set of nat := reservations(standInSection) union {curTime};
					reservations(standInSection) :=  temp;		
					curTime := curTime + minDelta; --minDelta = lowest possible time resolution
				);	
				tempgrid := tl tempgrid;
			);
		);
		--def - = io.fwriteval[SectionPlan]("reservations.txt",reservations,<start>) in skip;
		--def - = io.fwriteval[set of Route]("routeList.txt",routeList,<start>) in skip;
		iterations := iterations - 1;
	)
);

public getSectionPlan : () ==> SectionPlan
getSectionPlan() == return reservations;

private findFreeTimeSlot : TransportPlan`Section *  nat * nat==> nat
findFreeTimeSlot(section, sectionDuration, minStartTime)==
(
	dcl tempRes : set of nat := reservations(section);
	dcl freeSlot : nat :=minStartTime;
	dcl next : nat := freeSlot;
	dcl dur : nat := sectionDuration;
	
	while(dur > 0 ) do
	(
		if(next not in set tempRes) then
		(
			dur := dur - minDelta;
			next := next + minDelta;
		)
		else
		(
			dur := sectionDuration;
			freeSlot := next + minDelta;
			next := freeSlot; --new starting point 
		);
	);
	return freeSlot;
);

-- public getRouteList : () ==> set of Route
-- getRouteList() ==
-- (
-- 	return routeList;
-- )





end GridReservation

\end{vdm_al}
\section{Logger class}

\begin{vdm_al}

class Logger

types
	public logType =  (TPC`String | InactiveRoute | TP | RouteStatus | nat | set of Train | bool | set of TransportPlan | set of Station | TransportPlan);
	
	public InactiveRoute::
				name:TPC`String
				routeid : nat
				curtime : nat;
	
	public TP::
				name:TPC`String
				tp: TransportPlan;
				
	public RouteStatus::
				name:TPC`String
				action:TPC`String
				tokenId: nat;
				

instance variables 
	public static log : seq of logType := [];
	private static initLog : bool := true;

operations

	public static write : logType ==> () 
	write(o)== 	( 
		duration(0)(	
		log := log ^ [o] ^ ["\n"];
		Logger`flush();
		);
	);
	
	public static write2 : logType * nat * nat ==> () 
	write2(o, tr, ti)== 	( 
		duration(0)(	
		log := log ^ [o] ^ [tr] ^ [ti] ^ ["\n"];
		Logger`flush();
		);
	);

	public static flush : () ==> ()
	flush()== (
	--dcl io: IO := new IO();
	if(initLog = true) then
		skip -- def - = io.fwriteval[seq of logType]("logger.log",log,<start>) in skip
	else
		skip; -- def - = io.fwriteval[seq of logType]("logger.log",log,<append>) in skip;
	);

	public static printLog : () ==> seq of logType	
	printLog() == return log;

sync
mutex(write);
mutex(write2);
mutex(write, write2);

end Logger

\end{vdm_al}
\section{MessageQueue}

\begin{vdm_al}
class MessageQueue

instance variables

queue : seq of Message := [];
size : nat := 0;


types
public String = seq of char;
public FunctionType = <setInactive> | <setActive>; 
public ParamType = nat | String;

public Message::
	funct : FunctionType
	params : seq of ParamType

operations

--Constructor
public MessageQueue : nat ==> MessageQueue
MessageQueue(psize) ==
	size := psize;


public push: Message ==> ()
push(message) ==
	queue := queue ^ [message];

public pop: () ==> Message
pop() == (
	let rtn_data = hd queue
	in
	(
		queue := tl queue;
		return rtn_data;
	)
);

sync
per push => #fin(push) - #fin(pop) < size; 	--ensure that there's space in the queue
per pop => #fin(push) - #fin(pop) > 0;			--ensure that there's data in the queue
mutex(pop,push);		--Only a single activation of pop at a time.
--Have not testet if this sync is enough.	

end MessageQueue
\end{vdm_al}

\section{Types}

\begin{vdm_al}


class Types

types

public State = <PreJourney>|<Journey>|<PostJourney>;
public String = seq of char;
public SectionId = nat;

end Types

class MessageTypes

types

--Message Types
public REQUESTPLAN :: 
		navi : TPC`NavigationInput 
		tokdev : TokenDevice;
public RETURNPLAN :: 
		plan : TransportPlan`DTO 
		tokdev : TokenDevice;
public CALCPLAN :: 
		navi : TPC`NavigationInput 
		tokdev : TokenDevice;
public INACTIVEROUTE :: 
		routeid : nat;
public ACTIVEROUTE :: 
		routeid : nat;
public ADDROUTE :: 
		route : TransportPlan`Route;	 
public REMOVEROUTE :: 
		route : TransportPlan`Route;	 
public STRATEGYINIT :: ;
public STRATEGYEND :: ;	
public STRATEGYNOTIFY ::
		routeid : nat;

public MessageT = REQUESTPLAN | RETURNPLAN | CALCPLAN | 
			INACTIVEROUTE | ACTIVEROUTE | ADDROUTE | REMOVEROUTE |
			STRATEGYINIT | STRATEGYEND | STRATEGYNOTIFY;




operations

--public test : MessageT ==> seq of char
--test (cmd) ==
--(
--	cases cmd:
--		mk_MessageTypes`INACTIVEROUTE(-) -> return "inactiveroute",
--		mk_MessageTypes`REQUESTPLAN(-) -> return "request"
--	end;
--	return "fail";
--)

	

end MessageTypes


\end{vdm_al}
\section{CyberRail class}
\begin{vdm_al}

class RailwayGrid

instance variables

private sectionList : set of TransportPlan`Section; 
private grid : Grid := {};
private inactiveGrid : Grid := {};
private inactiveSectionID : set of nat := {};
--private io : IO := new IO();
private routePlan : RoutePlan := {};
private gridReservation : GridReservation;

types

public Plan = seq of TransportPlan`Section;
public GridSegment = seq of TransportPlan`Section;
public Grid = set of GridSegment;
public RoutePlan = set of Route;
--public Schedule = set of Plan;

operations

--Constructor	
public RailwayGrid : () ==> RailwayGrid	
RailwayGrid()==
(	

	return self;
);


public getSectionPlan : () ==> GridReservation`SectionPlan
getSectionPlan() == return gridReservation.getSectionPlan();

private recAlgo : Grid * GridSegment * Types`String ==> Grid
recAlgo(grid, gridsegment, station) ==
(
	dcl grid_temp : Grid := grid;
	for all r in set sectionList  do
	(
		if( r.departureLocation = station and 	
				not (exists p in set elems gridsegment & 
				r.arrivalLocation = p.arrivalLocation or
				r.arrivalLocation = p.departureLocation) )
		then (
					dcl temp : GridSegment :=  gridsegment ^ [r];
					grid_temp := grid_temp union {temp};
			 		grid_temp := recAlgo( grid_temp, temp, r.arrivalLocation);
			  );
	);
 	return grid_temp;
);

--------------------------------------------------------------------------
 -- This method creates a railway grid and a timetable and is contructed  
 -- through several layers as follows: All sections -> all segments -> 
 -- all sections mapped to reservations times -> filter = final grid & 
 -- time table
 -------------------------------------------------------------------------
 public initGrid : () ==> ()
 initGrid() == (
 
 	duration(0)
	(
	
		dcl 	R1  : TransportPlan`Section := mk_TransportPlan`Section("A", "B", 42, "P1", 200000, 1), 
				R2  : TransportPlan`Section := mk_TransportPlan`Section("A", "C", 42, "P1", 250000, 2),
				R3  : TransportPlan`Section := mk_TransportPlan`Section("B", "C", 99, "P1", 600000, 3),	
				R4  : TransportPlan`Section := mk_TransportPlan`Section("B", "D", 42, "P1", 300000, 4),
				R5  : TransportPlan`Section := mk_TransportPlan`Section("B", "A", 42, "P1", 200000, 5),	
				R6  : TransportPlan`Section := mk_TransportPlan`Section("C", "D", 42, "P1", 250000, 6),
				R7  : TransportPlan`Section := mk_TransportPlan`Section("C", "A", 42, "P1", 300000, 7),
				R8  : TransportPlan`Section := mk_TransportPlan`Section("D", "B", 42, "P1", 200000, 8),	
				R9  : TransportPlan`Section := mk_TransportPlan`Section("D", "C", 42, "P1", 250000, 9),
				R10 : TransportPlan`Section := mk_TransportPlan`Section("C", "B", 99, "P1", 600000,10),
				R11 : TransportPlan`Section := mk_TransportPlan`Section("B", "E", 99, "P1", 500000,11),
				R12 : TransportPlan`Section := mk_TransportPlan`Section("C", "F", 99, "P1", 500000,12),
				R13 : TransportPlan`Section := mk_TransportPlan`Section("F", "D", 99, "P1", 200000,13),
				R14 : TransportPlan`Section := mk_TransportPlan`Section("E", "D", 99, "P1", 200000,14);
 		
 		--Define active sections to use in grid
		sectionList := {R1,R3,R4,R5,R6,R7,R9,R10,R11,R12,R13,R14}; 
 
 		--Calculate all possible segments (aka grid) based on active sections.
		grid := recAlgo({},[], "A") union 
				recAlgo({},[], "B") union 
				recAlgo({},[], "C") union 
				recAlgo({},[], "D") union
				recAlgo({},[], "E") union
				recAlgo({},[], "F");
		
		--Filter grid to obtain a semi random grid and hence time table. 
		(dcl filteredGrid : Grid := filter(3, grid);
		
		--Calculate time table based on the grid.
		gridReservation :=  new GridReservation(filteredGrid, sectionList););
		
		--def - = io.fwriteval[Grid]("grid.txt",grid,<start>) in skip;
		
 		routePlan := gridReservation.getRoutePlan(grid,sectionList);
 		--def - = io.fwriteval[RoutePlan]("routePlan.txt",routePlan,<start>) in skip;
 		--def - = io.fwriteval[set of TransportPlan`Section]("sectionList.txt",sectionList,<start>) in skip;

 	);
 );

public getRoutePlan: () ==> RoutePlan
getRoutePlan()==
(
	return routePlan;
);

public getGrid : () ==> Grid
getGrid() == return grid;

public isSectionActive : nat ==> bool
isSectionActive(id) == (
		if id in set inactiveSectionID then
			return false
		else
			return true;
);

public setInactiveSection : nat ==> ()
setInactiveSection(id)==
(
	duration(0) (
	Logger`write("RailwayGrid inactive route");
	inactiveSectionID := inactiveSectionID union {id};
	inactiveGrid := inactiveGrid union  {tp | tp in set grid & exists x in set elems tp & x.id_section = id};
	grid := {x | x in set grid & id not in set {section.id_section | section in set elems x}}; 
	);
)
pre exists x in set sectionList & x.id_section = id;

public filter : nat * Grid ==> Grid
filter(id, agrid) ==
(
	return {x | x in set agrid & len x > id};
);



---------------------------------------------------------------------------------------------------------------
public test : () ==> ()
test()== 
(
	writef (recAlgo({},[], "A") union recAlgo({},[], "B") union recAlgo({},[], "C") union recAlgo({},[], "D") );
);

private writef : Grid ==> ()
	writef(grid)==
	(
		--def - = io.fwriteval[Grid]("railway.txt",grid,<append>) in 
            skip;
	);

sync
--mutex (isRouteActive);
	
end RailwayGrid
\end{vdm_al}


\begin{vdm_al}

class Route 

instance variables
public sections : seq of TransportPlan`Section;
public traveledSections : seq of TransportPlan`Section;
public departureTime : nat := 0;
public departureLocation : TPC`String := ""; --REPLACE!!
public arrivalLocation : TPC`String := ""; --REPLACE!
public totalDuration : nat := 0;
public arrivalTime : nat := 0;

inv len sections > 0 => forall i in set inds sections 
  & i < len sections => 
  sections(i).arrivalLocation = sections(i+1).departureLocation;
  
inv arrivalTime >= departureTime;

operations

--Constructor
public Route : seq of TransportPlan`Section * nat ==>  Route
Route(a_sections, a_departureTime)==
(
	sections := []; traveledSections := [];
	totalDuration := 0;
	sections := a_sections;
	(dcl tempSections : seq of TransportPlan`Section := sections;
	
		while len tempSections > 0 do
		(
			totalDuration := totalDuration + (hd tempSections).dur;
			tempSections := tl tempSections;
		);
	);
	atomic(
	departureTime := a_departureTime;
	arrivalTime := a_departureTime + totalDuration;
	);
	departureLocation := (hd sections).departureLocation;
	arrivalLocation := sections(len sections).arrivalLocation;
);

public Route : () ==> Route
Route() == (sections := []; traveledSections := [];);

public getLength : () ==> nat
getLength() == return len sections;

public getRouteLength : () ==> nat
getRouteLength() == return len sections;

public getSection : () ==> [TransportPlan`Section]
getSection() == (
	if len sections > 0 then
		return hd sections
	else
		return nil;
);

public sectionTraveled : () ==> ()
sectionTraveled() == (
	duration(0)(
	traveledSections := traveledSections ^ [hd sections];
	sections := tl sections;
	);
)
pre len sections > 0;
	
public getDuration : () ==> nat
getDuration()==
(
	return totalDuration
);

public getNextArrivalTime : () ==> nat
getNextArrivalTime() ==
(
	duration(0)(
	dcl x : nat :=  departureTime;
	if len sections > 0 then (
		for s in traveledSections do
		(
			x := x + s.dur;
		);
		
		x := x + (hd sections).dur;
		return x;	
	);
	return -1;
	);
);

public getDepartureTime : () ==> nat
getDepartureTime()==
(
	return departureTime;
);

public getDepartureLocation : () ==> TPC`String
getDepartureLocation()==
(
	return departureLocation;
);

public getArrivalTime : () ==> nat
getArrivalTime()==
(
	return departureTime + totalDuration
);

public getArrivalLocation : () ==> TPC`String
getArrivalLocation()==
(
	return arrivalLocation;
);
	

sync 
--mutex (sectionTraveled);



end Route

\end{vdm_al}


\section{Logger class}

\begin{vdm_al}

class RTLog

types
	public LType =  map seq of char to seq of nat; 
	
instance variables 
	public static rtlog : LType := {|->};
	private static initLog : bool := true;
	private static temp : seq of nat := [];

operations

	public static RTWrite : seq of char * nat ==> () 
	RTWrite(id, val)== 	( 
		duration(0)(	
			if {id} subset dom rtlog then (
				rtlog(id) := rtlog(id) ^ [val]; 
			)		
			else (
				rtlog := rtlog munion {id |-> [val]};
			);
			
		);
	);
	
	public static RTflush : () ==> ()	
	RTflush()== (
	--dcl io: IO := new IO();
	if(initLog = true) then
		 --def - = io.fwriteval[LType]("RTLog.log",rtlog,<start>) in 
                 skip
	else
		 --def - = io.fwriteval[LType]("RTLog.log",rtlog,<append>) in 
                 skip;
	);
	
	public test : () ==> ()
	test()==
	(
		RTLog`RTWrite("a", 1);
		RTLog`RTWrite("b", 2);
		RTLog`RTWrite("a", 3);
		RTLog`RTWrite("b", 4);
		RTLog`RTWrite("a", 5);
		RTLog`RTWrite("b", 6);
		RTLog`RTflush();	
	)

sync
mutex(RTWrite);

end RTLog

\end{vdm_al}
\section{SMSGateway class}

\begin{vdm_al}

class SMSGateway

instance variables
delay : nat;
queue : seq of Message := [];
size : nat := 0;

types
public String = seq of char;
public FunctionType = <setInactive> | <setActive>; 
public ParamType = nat | TokenDevice | TransportPlan;
public SMSMessage::
	funct : FunctionType
	params : seq of ParamType;
private Message ::
	rcv  : TokenDevice
	sendTime : nat
	msg : SMSMessage;

	
operations

public SMSGateway : () ==> SMSGateway
SMSGateway()==
(
	skip;
);

public initialize : nat * nat ==> ()
initialize(a_delay, capacity)== (
	delay := a_delay;
	size := capacity;
);


async public send : TokenDevice * SMSMessage * nat ==> ()
send(rcv, msg, a_time) ==
(
	push(mk_Message(rcv, a_time + delay, msg));
);

private pop: () ==> Message
pop() == (
	let rtn_data = hd queue in (
		queue := tl queue;
		return rtn_data;
	)
);

private peek : () ==> Message
peek() == (
	let data = hd queue in (
		return data;
	)
);


private push: Message ==> ()
push(message) ==
	queue := queue ^ [message];
	

private process : () ==> ()
process() ==
(
	if len queue > 0 and peek().sendTime <= time then (
		let entry = pop() in (
			--cases entry.msg.funct:
			--		<setInactive> -> entry.rcv.notify(entry.msg.params(0)), 
			--		<setActive> -> skip
			--	end;	
			entry.rcv.notifyPassenger(entry.msg.params(1),"");	
			Logger`write2("SMSGateway.send ", time, time );	
		);
		
	)
);

thread 

periodic(1000, 100, 900, 0)	(process);		



sync
--per push => #fin(push) - #fin(pop) < size; 		--ensure that there's space in the queue
--per pop => #fin(push) - #fin(pop) > 0;			--ensure that there's data in the queue
--mutex(pop,push);								--Only a single activation of pop at a time.

end SMSGateway


\end{vdm_al}
\section{SNW class}
\begin{vdm_al}


class SNW is subclass of Strategy


instance variables

private state : State := <run>;

types

public State =  <run> | <halt>;

operations




strategyInit : () ==> ()
strategyInit() == 
(
	state := <halt>
);

strategyNotify : () ==> ()
strategyNotify() == is subclass responsibility;


strategyEnd : () ==> ()
strategyEnd() == 
(
	state := <run>;
);

handleEvents : ActivePlanManager ==> ()
handleEvents(apm) == is subclass responsibility;


end SNW

\end{vdm_al}
\section{Station}
\begin{vdm_al}
class Station
instance variables
private passengers : set of TransportPlan := {};
private stationId : nat;
private static stationList : set of Station := {};
private name : TPC`String;
operations

public Station : nat * TPC`String ==> Station
Station(id, sname) == (
stationId := id;
name := sname;
);

public addPassenger : TransportPlan ==> ()
addPassenger(tp) == (

	if tp.sectionsRemaining() > 0 then(
		passengers := passengers union {tp};
	);
)
pre tp.getNextSection().departureLocation = name;

public getName : () ==> TPC`String
getName() == return name;

public getPassengers : Train ==> set of TransportPlan
getPassengers(t) == (
	(
		dcl rtnPassengers : set of TransportPlan := {};
		for all p in set passengers	do (
			if p.getNextSection().arrivalLocation = t.getCurrentSection().arrivalLocation then 
			(
				rtnPassengers := rtnPassengers union {p};
				passengers := passengers \ {p};
				Logger`write2("Station adding passenger",t.getTrainId(),time); 
			);
		);
		return rtnPassengers;
	);
);

public getPas : () ==> set of TransportPlan
getPas() == return passengers;

public static getStation : TPC`String ==> [Station]
getStation(sname) ==( 
for all x in set stationList do(
	if x.getName() = sname then(
		return x;
	);
	
);
return nil;
);

public static getList : () ==> set of Station
getList() == return stationList;

public static addStation : Station ==> ()
addStation(s) == stationList := stationList union {s};

sync
mutex(addPassenger);
mutex(addPassenger, getPassengers);
mutex(getPassengers);
--per  getPassengers => #act(getPassengers) = #fin(getPassengers);
end Station
\end{vdm_al}
\section{Strategy class}
\begin{vdm_al}

class Strategy

types


operations

strategyInit : () ==> ()
strategyInit() == 
is subclass responsibility;

strategyNotify : () ==> ()
strategyNotify() == 
is subclass responsibility;

strategyEnd : () ==> ()
strategyEnd() == 
is subclass responsibility;

handleEvents : () ==> ()
handleEvents() == 
is subclass responsibility;



end Strategy

\end{vdm_al}
\section{TokenDevice class}

\begin{vdm_al}

class TokenDevice

instance variables

  private id_token : nat := 1;
  private transportPlan : [TransportPlan] := nil;
  private q_Env_out : Environment;
  private q_APM_out : ActivePlanManager;
  private test : bool := false;


operations
 
 public TokenDevice : nat ==> TokenDevice
  TokenDevice(id) == (id_token := id;);


async public notifyPassenger : TransportPlan * Types`String ==> ()
notifyPassenger(TransPlan, Filler) ==
(
	transportPlan := TransPlan;
	RTLog`RTWrite("TD Notify Passenger",time);
	Logger`write2(transportPlan,id_token,time);
	q_Env_out.respons( transportPlan, nil,time);
	test := true;
);
    

public requestTransportPlan : TPC`NavigationInput ==> ()
  requestTransportPlan(NavInput) ==
(
	RTLog`RTWrite("TDRequestPlan",time);
  	q_APM_out.requestTransportPlan( mk_MessageTypes`REQUESTPLAN(NavInput, self));
);

public getTokenId : () ==> nat
  getTokenId() == return id_token;

private sectionTraveled : () ==> ()
  sectionTraveled() == (transportPlan.sectionTraveled();
)
pre transportPlan.sectionsRemaining() > 0;


public travel : () ==> ()
travel () == skip;
--(
--		onTheRoad();
--		if( transportPlan <> nil and transportPlan.routesRemaining() > 0 ) then(
		--dcl t : TransportPlan`Route := (transportPlan.getNextRoute());
--	routeTraveled();
--	)
--);

public onTheRoad : () ==> ()
onTheRoad () == skip;

public isFinished : () ==> ()
isFinished() == skip;

public setEnv : Environment ==> ()
setEnv(env) == q_Env_out := env;

public setAPM : ActivePlanManager ==> ()
setAPM(apm) == q_APM_out := apm;

public isFin : () ==> ()
isFin() == skip;


sync

--per isFin => (#fin(notifyPassenger) > 0);

--mutex(notifyPassenger);
--mutex(requestTransportPlan);

end TokenDevice

\end{vdm_al}


\section{TPC class}

\begin{vdm_al}


class TPC

instance variables

private normalState : bool := true;
private curtime : nat := 0;
private railway : RailwayGrid;
private q_APM_out : ActivePlanManager;
private timeout : nat := 0;

types

public NavigationInput :: 
departureLocation : String
arrivalLocation : String
transportChoice : Choice
id_token : nat1
departureTime : nat

inv n == len n.departureLocation > 0 and
	len n.arrivalLocation > 0 ;
	
public String = seq of char;
public Choice = <Cheapest>|<Quickest>


operations

public setAPM : ActivePlanManager ==> ()
setAPM(apm) == q_APM_out := apm;

public setRailwayGrid : RailwayGrid ==> ()
setRailwayGrid(grid)== (
	railway := grid;
);

public isFinished : () ==> ()
isFinished () == skip;


public calculateTransportPlan : NavigationInput ==> seq of TransportPlan`Section 
calculateTransportPlan(navInput) ==
(
RTLog`RTWrite("TPC Calc Plan start",time);
	cycles(154000)(
 dcl tempPlan : TransportPlan;
 dcl tempSections : GridReservation`SectionPlan := railway.getSectionPlan();
 dcl tempGrid : RailwayGrid`Grid := railway.getGrid();

 def l = {r | r in set tempGrid & r(1).departureLocation = navInput.departureLocation 
         and r(len r).arrivalLocation = navInput.arrivalLocation} in (
 if card l > 0 then 
 (
 	(dcl fastst : nat := 0;
 	dcl tempSeclist : seq of TransportPlan`Section := [];
 	dcl tmpList : seq of TransportPlan`Section;
 	dcl tmpSec : TransportPlan`Section;
 	dcl tmpTime : nat := 0;
 	dcl test : bool := false;
 	
 	for all seclist in set l do
 	(
 		test := true;
 		tmpTime := navInput.departureTime;
 		tmpList := seclist;
 		while len tmpList > 0 and test do 
 		(
 			tmpSec := hd tmpList;
 			tmpList := tl tmpList;
 			if not (exists t in set tempSections(tmpSec) & t > tmpTime) then(
 				test := false;
 			);
 			if test then(
 				tmpTime := findSmallest(tempSections(tmpSec), tmpTime) + tmpSec.dur;
 			);
 		);
 		
 		if( tmpTime < fastst or fastst = 0 and test = true) then (
 			fastst := tmpTime;
 			tempSeclist := seclist;
 		);
 	);
 	RTLog`RTWrite("TPC Calc Plan Done",time);
 	return tempSeclist;
 );
 );
);
return [];
);
)
pre exists r in set railway.getGrid() & r(1).departureLocation = navInput.departureLocation and r(len r).arrivalLocation = navInput.arrivalLocation;


public setActiveSection : nat ==> ()
setActiveSection(id_Section) == is not yet specified;


private findCheapest : RailwayGrid`Grid ==> [seq of TransportPlan`Section]
findCheapest(list) ==
(
	dcl sum : real := 0;
	dcl cheap : real := 9999;
	dcl rtn : seq of TransportPlan`Section := [];
	
	for all s in set list do
	(
		sum := 0;
		for r in s do
			sum := sum + r.fee;
		if sum < cheap then
		(
			cheap := sum;
			rtn := s;
		);    
	);
	return rtn;
);

private findQuickest : RailwayGrid`Grid ==> [seq of TransportPlan`Section]
findQuickest (list) == findCheapest(list);

public calcTransportPlan : MessageTypes`REQUESTPLAN ==> ()
calcTransportPlan(msg)==(
	let mk_MessageTypes`REQUESTPLAN(navi, tok) = msg in
	(	
		q_APM_out.returnTransportPlan( mk_MessageTypes`RETURNPLAN(mk_TransportPlan`DTO(navi.id_token,calculateTransportPlan(navi), navi.transportChoice, navi.departureTime),tok));
	)
);

public inactiveSection : nat ==> ()
inactiveSection(routeid) ==
(	
		railway.setInactiveSection(routeid);
);

public setInactiveSection : nat ==> ()
setInactiveSection(id_Section) == (
skip;
);

functions 
public findSmallest : set of nat * nat -> nat
findSmallest(list, v) == (
	let l  = {x | x in set list & x >= v} in(
	hd [x | x in set l & forall y in set l & x <= y]
	)
);

end TPC
\end{vdm_al}


\section{Train}

\begin{vdm_al}
class Train

instance variables
private passengers : set of TransportPlan := {};
private trainId : nat;
public currentRoute : Route;
private arrivalTime : nat := 0;
private done : bool := false;
private test : nat := 0;
private state : Types`State := <PreJourney>;
private controller : Controller;
private curStation : Types`String;
private curSection : TransportPlan`Section;



types

operations

public Train : nat * Route * Controller==> Train
Train(tId, r, ctrl) == (trainId := tId;
	currentRoute := r;
	arrivalTime := r.getDepartureTime();
	controller := ctrl;
);

--public setTPC : TPC ==> ()
--setTPC(t) == tpc := t;

public addPassenger : TokenDevice ==> ()
addPassenger(passenger) ==(
	passengers := passengers union {passenger};
);

public setRoute : Route ==> ()
setRoute(r) == (
	currentRoute := r;
);

public removePassenger : TransportPlan ==> ()
removePassenger(passenger) == (
	passengers := passengers \ {passenger};
	Logger`write2("Train Removing passenger",trainId,time);
);

public getTrainId : () ==> nat
getTrainId() == return trainId;

public getCurrentSection : () ==> TransportPlan`Section
getCurrentSection() == return currentRoute.getSection();

public passengerTravel : () ==> () 
passengerTravel() == (
	for all p in set passengers do
		p.sectionTraveled();
);

private travel : () ==> ()
travel() == (
	duration(0)(
	if not done then (
	if state = <PreJourney> then(
		if currentRoute.getDepartureTime() <= time then (
			passengers := passengers union Station`getStation(currentRoute.departureLocation).getPassengers(self);
			state := <Journey>;
			arrivalTime := currentRoute.getNextArrivalTime();
			passengerTravel();
		);
	)
	else(
	if arrivalTime <> -1 and arrivalTime > time then(
		curStation := currentRoute.getArrivalLocation();
		currentRoute.sectionTraveled();
		arrivalTime := currentRoute.getNextArrivalTime();
		curSection := currentRoute.getSection();
		
		if not (arrivalTime = -1 ) and controller.isSectionActive(curSection.id_section) then(
			passengers := passengers union Station`getStation(curStation).getPassengers(self);
		);
	
		for all p in set passengers do (

			if p.sectionsRemaining() = 0 then (
				removePassenger(p);
			)
			else if ((arrivalTime = -1) or not (p.getNextSection().arrivalLocation = curSection.arrivalLocation) ) then (
				removePassenger(p);
				Station`getStation(curStation).addPassenger(p);
			);
		);
		passengerTravel();
		);
		
	);
		if(arrivalTime = -1 or not (controller.isSectionActive(currentRoute.getSection().id_section))) then(
			done := true;
			--Logger`write2(card passengers,trainId,time);
		);
	);
);
);

public isFinished : () ==> ()
isFinished() == skip;

sync
per isFinished => (done = true);

thread
--	while true do(
--		travel();
--	);

periodic(50000,100000,40000,0)(travel);

end Train
\end{vdm_al}
\section{TransportPlan class}

\begin{vdm_al}


class TransportPlan

instance variables
  private id_token : nat;
  private totalFee : real;
  private totalDuration : nat;
  private choice : TPC`Choice;
  private sectionList : seq of Section := [];
  private sectionTravled : seq of Section := [];
  private departureTime : nat;

inv len sectionList > 0 => forall i in set inds sectionList 
  & i < len sectionList => 
  sectionList(i).arrivalLocation = sectionList(i+1).departureLocation;


types

public Section ::
departureLocation : TPC`String
arrivalLocation : TPC`String
fee : real
platform : TPC`String
dur : nat
id_section : nat
inv r == len r.platform > 0 and
			len r.arrivalLocation > 0 and
			len r.departureLocation > 0 and
			r.fee >= 0 ;

public DTO ::
	id_token : nat
	sectionList : seq of TransportPlan`Section
	choice : TPC`Choice
	depTime : nat;



operations

--Constructor
public TransportPlan : TransportPlan`DTO ==> TransportPlan
TransportPlan(dto) ==
(
	id_token := dto.id_token;
	choice := dto.choice;
	sectionList := dto.sectionList;
	departureTime := dto.depTime;
);

public assignNewPlan : TransportPlan`DTO ==> ()
assignNewPlan(dto) ==
(
	choice := dto.choice;
	sectionList := dto.sectionList;
	departureTime := dto.depTime;
);


public getNextSection : () ==> [TransportPlan`Section]
getNextSection () == (
	if len sectionList > 0 then
		return hd sectionList
	else
		return nil;
)
pre len sectionList > 0;

public containsSection: nat ==> bool
containsSection(id_section) == 
return exists r in set elems sectionList & r.id_section = id_section
pre len sectionList > 0;

public addSection: Section ==> ()
addSection(section) ==(
 sectionList := sectionList^[section];
 totalFee:= totalFee + section.fee
)
pre sectionList(len sectionList).arrivalLocation = section.departureLocation;

public sectionTraveled: () ==> ()
sectionTraveled () == (
	sectionTravled := sectionTravled ^ [hd sectionList];
	sectionList := tl sectionList;
	Logger`write(mk_Logger`RouteStatus("RouteStatus","RouteTraveled", id_token)); Logger`write(time);
)
pre len sectionList > 0;

public sectionsRemaining : () ==> nat
sectionsRemaining() == ( return len sectionList;);

public getByValue : () ==> DTO
getByValue()== return mk_TransportPlan`DTO(id_token, sectionList, choice, departureTime);


public getPlanAsNaviInput: () ==> TPC`NavigationInput
getPlanAsNaviInput() ==(
return mk_TPC`NavigationInput((hd sectionList).departureLocation, (sectionList(len sectionList)).arrivalLocation, choice, id_token, departureTime )
)
pre len sectionList > 0;

public getTokenId: () ==> nat
getTokenId() == return id_token;

--debug
public getSectionList: () ==> seq of Section
getSectionList()==
	return sectionList;

sync
	--mutex(routeTraveled);
	
end TransportPlan
\end{vdm_al}
\section{World2}

\begin{vdm_al}
class World2

instance variables
  protected env : [Environment] := nil;

operations


  public World2 : seq of char ==> World2
  World2(fname) ==
	(
		duration(0)(
		env := new Environment(fname);

		env.addController(CRSystem`ctrl);
		CRSystem`cb.setAPM(CRSystem`apm);
		CRSystem`cb.setRailwayGrid(CRSystem`grid2);
		CRSystem`apm.setCR(CRSystem`cb);
		CRSystem`ctrl.setAPM(CRSystem`apm);
		CRSystem`ctrl.setRailwayGrid(CRSystem`grid);
		CRSystem`ctrl.setTPC(CRSystem`cb);
		CRSystem`sms.initialize(13600,1000);
		
		--Token Device set up generated by repeater
		--env.addTokenDevice(CRSystem`tok0);
		--CRSystem`tok0.setAPM(CRSystem`apm);
		--CRSystem`tok0.setEnv(env);
		env.addTokenDevice(CRSystem`tok7);

		
		
		CRSystem`tok7.setAPM(CRSystem`apm);

		
		
		CRSystem`tok7.setEnv(env);


	);
		
	);

	public run : () ==>  seq of Logger`logType
	run() == 	
	(
		--dcl i : nat := 5;
		duration(0)(
		CRSystem`grid.initGrid();
		CRSystem`grid2.initGrid();
		CRSystem`ctrl.initTrains();
		CRSystem`ctrl.initStations();
		CRSystem`ctrl.startTrains();
		CRSystem`apm.initAPM();
		);
		start(CRSystem`sms);
		start(env);
		Logger`write2("World Setup complete",0,time);
		--env.isFinished();
		CRSystem`ctrl.isFinished();	
		Logger`write("This is the end");	
		def - = env.showResults() in skip;
		--RTLog`RTflush();
		return Logger`printLog();


	)
end World2
class A

operations
public Test: () ==> seq of Logger`logType
Test() ==
  return new World2("test 3/#3A.txt").run()
end A
\end{vdm_al}
